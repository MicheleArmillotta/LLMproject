[
  {
    "function_name": "print_dl_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2753-2756",
    "snippet": "void print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_dl_rq",
          "args": [
            "m",
            "cpu",
            "&cpu_rq(cpu)->dl"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "print_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/debug.c",
          "lines": "604-625",
          "snippet": "void print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid print_dl_rq(struct seq_file *m, int cpu, struct dl_rq *dl_rq)\n{\n\tstruct dl_bw *dl_bw;\n\n\tSEQ_printf(m, \"\\n\");\n\tSEQ_printf(m, \"dl_rq[%d]:\\n\", cpu);\n\n#define PU(x) \\\n\tSEQ_printf(m, \"  .%-30s: %lu\\n\", #x, (unsigned long)(dl_rq->x))\n\n\tPU(dl_nr_running);\n#ifdef CONFIG_SMP\n\tPU(dl_nr_migratory);\n\tdl_bw = &cpu_rq(cpu)->rd->dl_bw;\n#else\n\tdl_bw = &dl_rq->dl_bw;\n#endif\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->bw\", dl_bw->bw);\n\tSEQ_printf(m, \"  .%-30s: %lld\\n\", \"dl_bw->total_bw\", dl_bw->total_bw);\n\n#undef PU\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2755
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid print_dl_stats(struct seq_file *m, int cpu)\n{\n\tprint_dl_rq(m, cpu, &cpu_rq(cpu)->dl);\n}"
  },
  {
    "function_name": "dl_cpu_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2733-2749",
    "snippet": "bool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2745
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cpus",
            "0",
            "0"
          ],
          "line": 2744
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "300-305",
          "snippet": "static inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void dl_change_utilization(struct task_struct *p, u64 new_bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void dl_change_utilization(struct task_struct *p, u64 new_bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "cpu"
          ],
          "line": 2743
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2742
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2741
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2740
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nbool dl_cpu_busy(unsigned int cpu)\n{\n\tunsigned long flags;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus;\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, 0);\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn overflow;\n}"
  },
  {
    "function_name": "dl_cpuset_cpumask_can_shrink",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2712-2731",
    "snippet": "int dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&cur_dl_b->lock",
            "flags"
          ],
          "line": 2727
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&cur_dl_b->lock",
            "flags"
          ],
          "line": 2723
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_weight",
          "args": [
            "trial"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpumask_any(cur)"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "cur"
          ],
          "line": 2720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2719
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint dl_cpuset_cpumask_can_shrink(const struct cpumask *cur,\n\t\t\t\t const struct cpumask *trial)\n{\n\tint ret = 1, trial_cpus;\n\tstruct dl_bw *cur_dl_b;\n\tunsigned long flags;\n\n\trcu_read_lock_sched();\n\tcur_dl_b = dl_bw_of(cpumask_any(cur));\n\ttrial_cpus = cpumask_weight(trial);\n\n\traw_spin_lock_irqsave(&cur_dl_b->lock, flags);\n\tif (cur_dl_b->bw != -1 &&\n\t    cur_dl_b->bw * trial_cpus < cur_dl_b->total_bw)\n\t\tret = 0;\n\traw_spin_unlock_irqrestore(&cur_dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dl_task_can_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2679-2710",
    "snippet": "int dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus, ret;\n\tunsigned long flags;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2706
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpus"
          ],
          "line": 2703
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "293-298",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cpus",
            "0",
            "p->dl.dl_bw"
          ],
          "line": 2693
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "300-305",
          "snippet": "static inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void dl_change_utilization(struct task_struct *p, u64 new_bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void dl_change_utilization(struct task_struct *p, u64 new_bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "dest_cpu"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2691
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "dest_cpu"
          ],
          "line": 2690
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2689
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_active_mask",
            "cs_cpus_allowed"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint dl_task_can_attach(struct task_struct *p, const struct cpumask *cs_cpus_allowed)\n{\n\tunsigned int dest_cpu;\n\tstruct dl_bw *dl_b;\n\tbool overflow;\n\tint cpus, ret;\n\tunsigned long flags;\n\n\tdest_cpu = cpumask_any_and(cpu_active_mask, cs_cpus_allowed);\n\n\trcu_read_lock_sched();\n\tdl_b = dl_bw_of(dest_cpu);\n\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\tcpus = dl_bw_cpus(dest_cpu);\n\toverflow = __dl_overflow(dl_b, cpus, 0, p->dl.dl_bw);\n\tif (overflow) {\n\t\tret = -EBUSY;\n\t} else {\n\t\t/*\n\t\t * We reserve space for this task in the destination\n\t\t * root_domain, as we can't fail after this point.\n\t\t * We will free resources in the source root_domain\n\t\t * later on (see set_cpus_allowed_dl()).\n\t\t */\n\t\t__dl_add(dl_b, p->dl.dl_bw, cpus);\n\t\tret = 0;\n\t}\n\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\trcu_read_unlock_sched();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "dl_param_changed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2665-2676",
    "snippet": "bool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nbool dl_param_changed(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tif (dl_se->dl_runtime != attr->sched_runtime ||\n\t    dl_se->dl_deadline != attr->sched_deadline ||\n\t    dl_se->dl_period != attr->sched_period ||\n\t    dl_se->flags != attr->sched_flags)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "__dl_clear_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2648-2663",
    "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}"
  },
  {
    "function_name": "__checkparam_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2611-2643",
    "snippet": "bool __checkparam_dl(const struct sched_attr *attr)\n{\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif ((attr->sched_period != 0 &&\n\t     attr->sched_period < attr->sched_deadline) ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nbool __checkparam_dl(const struct sched_attr *attr)\n{\n\t/* special dl tasks don't actually use any parameter */\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn true;\n\n\t/* deadline != 0 */\n\tif (attr->sched_deadline == 0)\n\t\treturn false;\n\n\t/*\n\t * Since we truncate DL_SCALE bits, make sure we're at least\n\t * that big.\n\t */\n\tif (attr->sched_runtime < (1ULL << DL_SCALE))\n\t\treturn false;\n\n\t/*\n\t * Since we use the MSB for wrap-around and sign issues, make\n\t * sure it's not set (mind that period can be equal to zero).\n\t */\n\tif (attr->sched_deadline & (1ULL << 63) ||\n\t    attr->sched_period & (1ULL << 63))\n\t\treturn false;\n\n\t/* runtime <= deadline <= period (if period != 0) */\n\tif ((attr->sched_period != 0 &&\n\t     attr->sched_period < attr->sched_deadline) ||\n\t    attr->sched_deadline < attr->sched_runtime)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "__getparam_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2590-2599",
    "snippet": "void __getparam_dl(struct task_struct *p, struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tattr->sched_priority = p->rt_priority;\n\tattr->sched_runtime = dl_se->dl_runtime;\n\tattr->sched_deadline = dl_se->dl_deadline;\n\tattr->sched_period = dl_se->dl_period;\n\tattr->sched_flags = dl_se->flags;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __getparam_dl(struct task_struct *p, struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tattr->sched_priority = p->rt_priority;\n\tattr->sched_runtime = dl_se->dl_runtime;\n\tattr->sched_deadline = dl_se->dl_deadline;\n\tattr->sched_period = dl_se->dl_period;\n\tattr->sched_flags = dl_se->flags;\n}"
  },
  {
    "function_name": "__setparam_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2578-2588",
    "snippet": "void __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "dl_se->dl_deadline",
            "dl_se->dl_runtime"
          ],
          "line": 2587
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __setparam_dl(struct task_struct *p, const struct sched_attr *attr)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime = attr->sched_runtime;\n\tdl_se->dl_deadline = attr->sched_deadline;\n\tdl_se->dl_period = attr->sched_period ?: dl_se->dl_deadline;\n\tdl_se->flags = attr->sched_flags;\n\tdl_se->dl_bw = to_ratio(dl_se->dl_period, dl_se->dl_runtime);\n\tdl_se->dl_density = to_ratio(dl_se->dl_deadline, dl_se->dl_runtime);\n}"
  },
  {
    "function_name": "sched_dl_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2515-2568",
    "snippet": "int sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(task_cpu(p));\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cpus, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2565
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_has_dl_policy",
          "args": [
            "p"
          ],
          "line": 2557
        },
        "resolved": true,
        "details": {
          "function_name": "task_has_dl_policy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "184-187",
          "snippet": "static inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_has_dl_policy(struct task_struct *p)\n{\n\treturn dl_policy(p->policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_change_utilization",
          "args": [
            "p",
            "new_bw"
          ],
          "line": 2555
        },
        "resolved": true,
        "details": {
          "function_name": "dl_change_utilization",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "156-181",
          "snippet": "void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_add",
          "args": [
            "dl_b",
            "new_bw",
            "cpus"
          ],
          "line": 2554
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "293-298",
          "snippet": "static inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_add(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw += tsk_bw;\n\t__dl_update(dl_b, -((s32)tsk_bw / cpus));\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "cpus"
          ],
          "line": 2553
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "286-291",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_overflow",
          "args": [
            "dl_b",
            "cpus",
            "p->dl.dl_bw",
            "new_bw"
          ],
          "line": 2545
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "300-305",
          "snippet": "static inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static inline void __dl_update(struct dl_bw *dl_b, s64 bw);",
            "extern void dl_change_utilization(struct task_struct *p, u64 new_bw);",
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline void __dl_update(struct dl_bw *dl_b, s64 bw);\nextern void dl_change_utilization(struct task_struct *p, u64 new_bw);\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nbool __dl_overflow(struct dl_bw *dl_b, int cpus, u64 old_bw, u64 new_bw)\n{\n\treturn dl_b->bw != -1 &&\n\t       dl_b->bw * cpus < dl_b->total_bw - old_bw + new_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 2540
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2537
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 2536
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "period",
            "runtime"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "task_cpu(p)"
          ],
          "line": 2518
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nint sched_dl_overflow(struct task_struct *p, int policy,\n\t\t      const struct sched_attr *attr)\n{\n\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\tu64 period = attr->sched_period ?: attr->sched_deadline;\n\tu64 runtime = attr->sched_runtime;\n\tu64 new_bw = dl_policy(policy) ? to_ratio(period, runtime) : 0;\n\tint cpus, err = -1;\n\n\tif (attr->sched_flags & SCHED_FLAG_SUGOV)\n\t\treturn 0;\n\n\t/* !deadline task may carry old deadline bandwidth */\n\tif (new_bw == p->dl.dl_bw && task_has_dl_policy(p))\n\t\treturn 0;\n\n\t/*\n\t * Either if a task, enters, leave, or stays -deadline but changes\n\t * its parameters, we may need to update accordingly the total\n\t * allocated bandwidth of the container.\n\t */\n\traw_spin_lock(&dl_b->lock);\n\tcpus = dl_bw_cpus(task_cpu(p));\n\tif (dl_policy(policy) && !task_has_dl_policy(p) &&\n\t    !__dl_overflow(dl_b, cpus, 0, new_bw)) {\n\t\tif (hrtimer_active(&p->dl.inactive_timer))\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\terr = 0;\n\t} else if (dl_policy(policy) && task_has_dl_policy(p) &&\n\t\t   !__dl_overflow(dl_b, cpus, p->dl.dl_bw, new_bw)) {\n\t\t/*\n\t\t * XXX this is slightly incorrect: when the task\n\t\t * utilization decreases, we should delay the total\n\t\t * utilization change until the task's 0-lag point.\n\t\t * But this would require to set the task's \"inactive\n\t\t * timer\" when the task is not inactive.\n\t\t */\n\t\t__dl_sub(dl_b, p->dl.dl_bw, cpus);\n\t\t__dl_add(dl_b, new_bw, cpus);\n\t\tdl_change_utilization(p, new_bw);\n\t\terr = 0;\n\t} else if (!dl_policy(policy) && task_has_dl_policy(p)) {\n\t\t/*\n\t\t * Do not decrease the total deadline utilization here,\n\t\t * switched_from_dl() will take care to do it at the correct\n\t\t * (0-lag) time.\n\t\t */\n\t\terr = 0;\n\t}\n\traw_spin_unlock(&dl_b->lock);\n\n\treturn err;\n}"
  },
  {
    "function_name": "sched_dl_do_global",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2478-2505",
    "snippet": "void sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\n\tdef_dl_bandwidth.dl_period = global_rt_period();\n\tdef_dl_bandwidth.dl_runtime = global_rt_runtime();\n\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\n\t/*\n\t * FIXME: As above...\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\t\tinit_dl_rq_bw_ratio(&cpu_rq(cpu)->dl);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct dl_bandwidth def_dl_bandwidth;",
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_dl_rq_bw_ratio",
          "args": [
            "&cpu_rq(cpu)->dl"
          ],
          "line": 2503
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_rq_bw_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2465-2476",
          "snippet": "void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2495
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1513-1519",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2489
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1508-1511",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid sched_dl_do_global(void)\n{\n\tu64 new_bw = -1;\n\tstruct dl_bw *dl_b;\n\tint cpu;\n\tunsigned long flags;\n\n\tdef_dl_bandwidth.dl_period = global_rt_period();\n\tdef_dl_bandwidth.dl_runtime = global_rt_runtime();\n\n\tif (global_rt_runtime() != RUNTIME_INF)\n\t\tnew_bw = to_ratio(global_rt_period(), global_rt_runtime());\n\n\t/*\n\t * FIXME: As above...\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tdl_b->bw = new_bw;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\t\tinit_dl_rq_bw_ratio(&cpu_rq(cpu)->dl);\n\t}\n}"
  },
  {
    "function_name": "init_dl_rq_bw_ratio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2465-2476",
    "snippet": "void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1513-1519",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1508-1511",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
  },
  {
    "function_name": "sched_dl_global_validate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2429-2463",
    "snippet": "int sched_dl_global_validate(void)\n{\n\tu64 runtime = global_rt_runtime();\n\tu64 period = global_rt_period();\n\tu64 new_bw = to_ratio(period, runtime);\n\tstruct dl_bw *dl_b;\n\tint cpu, ret = 0;\n\tunsigned long flags;\n\n\t/*\n\t * Here we want to check the bandwidth not being set to some\n\t * value smaller than the currently allocated bandwidth in\n\t * any of the root_domains.\n\t *\n\t * FIXME: Cycling on all the CPUs is overdoing, but simpler than\n\t * cycling on root_domains... Discussion on different/better\n\t * solutions is welcome!\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tif (new_bw < dl_b->total_bw)\n\t\t\tret = -EBUSY;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock_sched",
          "args": [],
          "line": 2456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&dl_b->lock",
            "flags"
          ],
          "line": 2451
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched",
          "args": [],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "period",
            "runtime"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 2432
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1508-1511",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 2431
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1513-1519",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nint sched_dl_global_validate(void)\n{\n\tu64 runtime = global_rt_runtime();\n\tu64 period = global_rt_period();\n\tu64 new_bw = to_ratio(period, runtime);\n\tstruct dl_bw *dl_b;\n\tint cpu, ret = 0;\n\tunsigned long flags;\n\n\t/*\n\t * Here we want to check the bandwidth not being set to some\n\t * value smaller than the currently allocated bandwidth in\n\t * any of the root_domains.\n\t *\n\t * FIXME: Cycling on all the CPUs is overdoing, but simpler than\n\t * cycling on root_domains... Discussion on different/better\n\t * solutions is welcome!\n\t */\n\tfor_each_possible_cpu(cpu) {\n\t\trcu_read_lock_sched();\n\t\tdl_b = dl_bw_of(cpu);\n\n\t\traw_spin_lock_irqsave(&dl_b->lock, flags);\n\t\tif (new_bw < dl_b->total_bw)\n\t\t\tret = -EBUSY;\n\t\traw_spin_unlock_irqrestore(&dl_b->lock, flags);\n\n\t\trcu_read_unlock_sched();\n\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "prio_changed_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2366-2396",
    "snippet": "static void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || rq->curr == p) {\n#ifdef CONFIG_SMP\n\t\t/*\n\t\t * This might be too much, but unfortunately\n\t\t * we don't have the old deadline value, and\n\t\t * we can't argue if the task is increasing\n\t\t * or lowering its prio, so...\n\t\t */\n\t\tif (!rq->dl.overloaded)\n\t\t\tdeadline_queue_pull_task(rq);\n\n\t\t/*\n\t\t * If we now have a earlier deadline task than p,\n\t\t * then reschedule, provided p is still on this\n\t\t * runqueue.\n\t\t */\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))\n\t\t\tresched_curr(rq);\n#else\n\t\t/*\n\t\t * Again, we don't know if p has a earlier\n\t\t * or later deadline, so let's blindly set a\n\t\t * (maybe not needed) rescheduling point.\n\t\t */\n\t\tresched_curr(rq);\n#endif /* CONFIG_SMP */\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq->dl.earliest_dl.curr",
            "p->dl.deadline"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "deadline_queue_pull_task",
          "args": [
            "rq"
          ],
          "line": 2378
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_pull_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "602-604",
          "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2369
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void prio_changed_dl(struct rq *rq, struct task_struct *p,\n\t\t\t    int oldprio)\n{\n\tif (task_on_rq_queued(p) || rq->curr == p) {\n#ifdef CONFIG_SMP\n\t\t/*\n\t\t * This might be too much, but unfortunately\n\t\t * we don't have the old deadline value, and\n\t\t * we can't argue if the task is increasing\n\t\t * or lowering its prio, so...\n\t\t */\n\t\tif (!rq->dl.overloaded)\n\t\t\tdeadline_queue_pull_task(rq);\n\n\t\t/*\n\t\t * If we now have a earlier deadline task than p,\n\t\t * then reschedule, provided p is still on this\n\t\t * runqueue.\n\t\t */\n\t\tif (dl_time_before(rq->dl.earliest_dl.curr, p->dl.deadline))\n\t\t\tresched_curr(rq);\n#else\n\t\t/*\n\t\t * Again, we don't know if p has a earlier\n\t\t * or later deadline, so let's blindly set a\n\t\t * (maybe not needed) rescheduling point.\n\t\t */\n\t\tresched_curr(rq);\n#endif /* CONFIG_SMP */\n\t}\n}"
  },
  {
    "function_name": "switched_to_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2338-2360",
    "snippet": "static void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\tput_task_struct(p);\n\n\t/* If p is not queued we will update its parameters at next wakeup. */\n\tif (!task_on_rq_queued(p)) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\n\t\treturn;\n\t}\n\n\tif (rq->curr != p) {\n#ifdef CONFIG_SMP\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)\n\t\t\tdeadline_queue_push_tasks(rq);\n#endif\n\t\tif (dl_task(rq->curr))\n\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\telse\n\t\t\tresched_curr(rq);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 2358
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr_dl",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1668-1685",
          "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2355
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "deadline_queue_push_tasks",
          "args": [
            "rq"
          ],
          "line": 2353
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_push_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "598-600",
          "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2345
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "128-133",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2344
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 2341
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 2340
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void switched_to_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\tput_task_struct(p);\n\n\t/* If p is not queued we will update its parameters at next wakeup. */\n\tif (!task_on_rq_queued(p)) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\n\t\treturn;\n\t}\n\n\tif (rq->curr != p) {\n#ifdef CONFIG_SMP\n\t\tif (p->nr_cpus_allowed > 1 && rq->dl.overloaded)\n\t\t\tdeadline_queue_push_tasks(rq);\n#endif\n\t\tif (dl_task(rq->curr))\n\t\t\tcheck_preempt_curr_dl(rq, p, 0);\n\t\telse\n\t\t\tresched_curr(rq);\n\t}\n}"
  },
  {
    "function_name": "switched_from_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2290-2332",
    "snippet": "static void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * task_non_contending() can start the \"inactive timer\" (if the 0-lag\n\t * time is in the future). If the task switches back to dl before\n\t * the \"inactive timer\" fires, it can continue to consume its current\n\t * runtime using its current deadline. If it stays outside of\n\t * SCHED_DEADLINE until the 0-lag time passes, inactive_task_timer()\n\t * will reset the task parameters.\n\t */\n\tif (task_on_rq_queued(p) && p->dl.dl_runtime)\n\t\ttask_non_contending(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\t/*\n\t\t * Inactive timer is armed. However, p is leaving DEADLINE and\n\t\t * might migrate away from this rq while continuing to run on\n\t\t * some other class. We need to remove its contribution from\n\t\t * this rq running_bw now, or sub_rq_bw (below) will complain.\n\t\t */\n\t\tif (p->dl.dl_non_contending)\n\t\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * We cannot use inactive_task_timer() to invoke sub_running_bw()\n\t * at the 0-lag time, because the task could have been migrated\n\t * while SCHED_OTHER in the meanwhile.\n\t */\n\tif (p->dl.dl_non_contending)\n\t\tp->dl.dl_non_contending = 0;\n\n\t/*\n\t * Since this might be the only -deadline task on the rq,\n\t * this is the right place to try to pull some other one\n\t * from an overloaded CPU, if any.\n\t */\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tdeadline_queue_pull_task(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "deadline_queue_pull_task",
          "args": [
            "rq"
          ],
          "line": 2331
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_pull_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "602-604",
          "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2312
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 2311
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_non_contending",
          "args": [
            "p"
          ],
          "line": 2301
        },
        "resolved": true,
        "details": {
          "function_name": "task_non_contending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "237-292",
          "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void switched_from_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * task_non_contending() can start the \"inactive timer\" (if the 0-lag\n\t * time is in the future). If the task switches back to dl before\n\t * the \"inactive timer\" fires, it can continue to consume its current\n\t * runtime using its current deadline. If it stays outside of\n\t * SCHED_DEADLINE until the 0-lag time passes, inactive_task_timer()\n\t * will reset the task parameters.\n\t */\n\tif (task_on_rq_queued(p) && p->dl.dl_runtime)\n\t\ttask_non_contending(p);\n\n\tif (!task_on_rq_queued(p)) {\n\t\t/*\n\t\t * Inactive timer is armed. However, p is leaving DEADLINE and\n\t\t * might migrate away from this rq while continuing to run on\n\t\t * some other class. We need to remove its contribution from\n\t\t * this rq running_bw now, or sub_rq_bw (below) will complain.\n\t\t */\n\t\tif (p->dl.dl_non_contending)\n\t\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * We cannot use inactive_task_timer() to invoke sub_running_bw()\n\t * at the 0-lag time, because the task could have been migrated\n\t * while SCHED_OTHER in the meanwhile.\n\t */\n\tif (p->dl.dl_non_contending)\n\t\tp->dl.dl_non_contending = 0;\n\n\t/*\n\t * Since this might be the only -deadline task on the rq,\n\t * this is the right place to try to pull some other one\n\t * from an overloaded CPU, if any.\n\t */\n\tif (!task_on_rq_queued(p) || rq->dl.dl_nr_running)\n\t\treturn;\n\n\tdeadline_queue_pull_task(rq);\n}"
  },
  {
    "function_name": "init_sched_dl_class",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2279-2286",
    "snippet": "void __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid __init init_sched_dl_class(void)\n{\n\tunsigned int i;\n\n\tfor_each_possible_cpu(i)\n\t\tzalloc_cpumask_var_node(&per_cpu(local_cpu_mask_dl, i),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(i));\n}"
  },
  {
    "function_name": "rq_offline_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2270-2277",
    "snippet": "static void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_clear_freecpu",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 2276
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_clear_freecpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "235-238",
          "snippet": "void cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_clear_overload",
          "args": [
            "rq"
          ],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_overload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "400-407",
          "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void rq_offline_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_clear_overload(rq);\n\n\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\tcpudl_clear_freecpu(&rq->rd->cpudl, rq->cpu);\n}"
  },
  {
    "function_name": "rq_online_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2259-2267",
    "snippet": "static void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "rq->dl.earliest_dl.curr"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "194-218",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_set_freecpu",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set_freecpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "225-228",
          "snippet": "void cpudl_set_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_set_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_set_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_set_overload",
          "args": [
            "rq"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "dl_set_overload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "384-398",
          "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void rq_online_dl(struct rq *rq)\n{\n\tif (rq->dl.overloaded)\n\t\tdl_set_overload(rq);\n\n\tcpudl_set_freecpu(&rq->rd->cpudl, rq->cpu);\n\tif (rq->dl.dl_nr_running > 0)\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, rq->dl.earliest_dl.curr);\n}"
  },
  {
    "function_name": "set_cpus_allowed_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2225-2256",
    "snippet": "static void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask)\n{\n\tstruct root_domain *src_rd;\n\tstruct rq *rq;\n\n\tBUG_ON(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t/*\n\t * Migrating a SCHED_DEADLINE task between exclusive\n\t * cpusets (different root_domains) entails a bandwidth\n\t * update. We already made space for us in the destination\n\t * domain (see cpuset_can_attach()).\n\t */\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t/*\n\t\t * We now free resources of the root_domain we are migrating\n\t\t * off. In the worst case, sched_setattr() may temporary fail\n\t\t * until we complete the update.\n\t\t */\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_sub(src_dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\tset_cpus_allowed_common(p, new_mask);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_cpus_allowed_common",
          "args": [
            "p",
            "new_mask"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "set_cpus_allowed_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1009-1013",
          "snippet": "void set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_cpus_allowed_common(struct task_struct *p, const struct cpumask *new_mask)\n{\n\tcpumask_copy(&p->cpus_allowed, new_mask);\n\tp->nr_cpus_allowed = cpumask_weight(new_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&src_dl_b->lock"
          ],
          "line": 2252
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "src_dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "286-291",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2251
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&src_dl_b->lock"
          ],
          "line": 2250
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "cpu_of(rq)"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 2244
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_intersects",
          "args": [
            "src_rd->span",
            "new_mask"
          ],
          "line": 2241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 2233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_task(p)"
          ],
          "line": 2231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 2231
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void set_cpus_allowed_dl(struct task_struct *p,\n\t\t\t\tconst struct cpumask *new_mask)\n{\n\tstruct root_domain *src_rd;\n\tstruct rq *rq;\n\n\tBUG_ON(!dl_task(p));\n\n\trq = task_rq(p);\n\tsrc_rd = rq->rd;\n\t/*\n\t * Migrating a SCHED_DEADLINE task between exclusive\n\t * cpusets (different root_domains) entails a bandwidth\n\t * update. We already made space for us in the destination\n\t * domain (see cpuset_can_attach()).\n\t */\n\tif (!cpumask_intersects(src_rd->span, new_mask)) {\n\t\tstruct dl_bw *src_dl_b;\n\n\t\tsrc_dl_b = dl_bw_of(cpu_of(rq));\n\t\t/*\n\t\t * We now free resources of the root_domain we are migrating\n\t\t * off. In the worst case, sched_setattr() may temporary fail\n\t\t * until we complete the update.\n\t\t */\n\t\traw_spin_lock(&src_dl_b->lock);\n\t\t__dl_sub(src_dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&src_dl_b->lock);\n\t}\n\n\tset_cpus_allowed_common(p, new_mask);\n}"
  },
  {
    "function_name": "task_woken_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2213-2223",
    "snippet": "static void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2117-2122",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&rq->curr->dl"
          ],
          "line": 2220
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "217-222",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2218
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "rq->curr"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 2215
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_woken_dl(struct rq *rq, struct task_struct *p)\n{\n\tif (!task_running(rq, p) &&\n\t    !test_tsk_need_resched(rq->curr) &&\n\t    p->nr_cpus_allowed > 1 &&\n\t    dl_task(rq->curr) &&\n\t    (rq->curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &rq->curr->dl))) {\n\t\tpush_dl_tasks(rq);\n\t}\n}"
  },
  {
    "function_name": "pull_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2124-2207",
    "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "this_rq"
          ],
          "line": 2206
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "this_rq",
            "src_rq"
          ],
          "line": 2202
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1949-1954",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "this_rq",
            "p",
            "0"
          ],
          "line": 2196
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "&p->dl",
            "&this_rq->dl"
          ],
          "line": 2195
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "142-147",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&this_rq->dl"
          ],
          "line": 2194
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "128-133",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "this_cpu"
          ],
          "line": 2193
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&src_rq->dl"
          ],
          "line": 2192
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&src_rq->dl"
          ],
          "line": 2191
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "src_rq->curr->dl.deadline"
          ],
          "line": 2184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!task_on_rq_queued(p)"
          ],
          "line": 2178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2178
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "p == src_rq->curr"
          ],
          "line": 2177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "this_rq->dl.earliest_dl.curr"
          ],
          "line": 2175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "dmin"
          ],
          "line": 2173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_earliest_pushable_dl_task",
          "args": [
            "src_rq",
            "this_cpu"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "pick_earliest_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1836-1856",
          "snippet": "static struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "this_rq",
            "src_rq"
          ],
          "line": 2157
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1938-1947",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "this_rq->dl.earliest_dl.curr",
            "src_rq->dl.earliest_dl.next"
          ],
          "line": 2152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 2145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "this_rq->rd->dlo_mask"
          ],
          "line": 2141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_rmb",
          "args": [],
          "line": 2139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!dl_overloaded(this_rq)"
          ],
          "line": 2132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_overloaded",
          "args": [
            "this_rq"
          ],
          "line": 2132
        },
        "resolved": true,
        "details": {
          "function_name": "dl_overloaded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "379-382",
          "snippet": "static inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
  },
  {
    "function_name": "push_dl_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2117-2122",
    "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "push_dl_task",
          "args": [
            "rq"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2117-2122",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
  },
  {
    "function_name": "push_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2030-2115",
    "snippet": "static int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (unlikely(next_task == rq->curr)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If next_task preempts rq->curr, and rq->curr\n\t * can move away, it makes sense to just reschedule\n\t * without going further in pushing next_task.\n\t */\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t/* We might release rq lock */\n\tget_task_struct(next_task);\n\n\t/* Will lock the rq it'll find */\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t/*\n\t\t * We must check all this again, since\n\t\t * find_lock_later_rq releases rq->lock and it is\n\t\t * then possible that next_task has migrated.\n\t\t */\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task == next_task) {\n\t\t\t/*\n\t\t\t * The task is still there. We don't try\n\t\t\t * again, some other CPU will pull it when ready.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t/* No more tasks */\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tsub_running_bw(&next_task->dl, &rq->dl);\n\tsub_rq_bw(&next_task->dl, &rq->dl);\n\tset_task_cpu(next_task, later_rq->cpu);\n\tadd_rq_bw(&next_task->dl, &later_rq->dl);\n\n\t/*\n\t * Update the later_rq clock here, because the clock is used\n\t * by the cpufreq_update_util() inside __add_running_bw().\n\t */\n\tupdate_rq_clock(later_rq);\n\tadd_running_bw(&next_task->dl, &later_rq->dl);\n\tactivate_task(later_rq, next_task, ENQUEUE_NOCLOCK);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "next_task"
          ],
          "line": 2112
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 2109
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1949-1954",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "later_rq"
          ],
          "line": 2107
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "activate_task",
          "args": [
            "later_rq",
            "next_task",
            "ENQUEUE_NOCLOCK"
          ],
          "line": 2104
        },
        "resolved": true,
        "details": {
          "function_name": "deactivate_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "754-760",
          "snippet": "void deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid deactivate_task(struct rq *rq, struct task_struct *p, int flags)\n{\n\tif (task_contributes_to_load(p))\n\t\trq->nr_uninterruptible++;\n\n\tdequeue_task(rq, p, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "&next_task->dl",
            "&later_rq->dl"
          ],
          "line": 2103
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "142-147",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "later_rq"
          ],
          "line": 2102
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&next_task->dl",
            "&later_rq->dl"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "128-133",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "next_task",
            "later_rq->cpu"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&next_task->dl",
            "&rq->dl"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&next_task->dl",
            "&rq->dl"
          ],
          "line": 2093
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pick_next_pushable_dl_task",
          "args": [
            "rq"
          ],
          "line": 2074
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2005-2023",
          "snippet": "static struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_lock_later_rq",
          "args": [
            "next_task",
            "rq"
          ],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_later_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1948-2003",
          "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define DL_MAX_TRIES 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "next_task"
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "next_task->dl.deadline",
            "rq->curr->dl.deadline"
          ],
          "line": 2055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 2045
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "next_task == rq->curr"
          ],
          "line": 2044
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int push_dl_task(struct rq *rq)\n{\n\tstruct task_struct *next_task;\n\tstruct rq *later_rq;\n\tint ret = 0;\n\n\tif (!rq->dl.overloaded)\n\t\treturn 0;\n\n\tnext_task = pick_next_pushable_dl_task(rq);\n\tif (!next_task)\n\t\treturn 0;\n\nretry:\n\tif (unlikely(next_task == rq->curr)) {\n\t\tWARN_ON(1);\n\t\treturn 0;\n\t}\n\n\t/*\n\t * If next_task preempts rq->curr, and rq->curr\n\t * can move away, it makes sense to just reschedule\n\t * without going further in pushing next_task.\n\t */\n\tif (dl_task(rq->curr) &&\n\t    dl_time_before(next_task->dl.deadline, rq->curr->dl.deadline) &&\n\t    rq->curr->nr_cpus_allowed > 1) {\n\t\tresched_curr(rq);\n\t\treturn 0;\n\t}\n\n\t/* We might release rq lock */\n\tget_task_struct(next_task);\n\n\t/* Will lock the rq it'll find */\n\tlater_rq = find_lock_later_rq(next_task, rq);\n\tif (!later_rq) {\n\t\tstruct task_struct *task;\n\n\t\t/*\n\t\t * We must check all this again, since\n\t\t * find_lock_later_rq releases rq->lock and it is\n\t\t * then possible that next_task has migrated.\n\t\t */\n\t\ttask = pick_next_pushable_dl_task(rq);\n\t\tif (task == next_task) {\n\t\t\t/*\n\t\t\t * The task is still there. We don't try\n\t\t\t * again, some other CPU will pull it when ready.\n\t\t\t */\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (!task)\n\t\t\t/* No more tasks */\n\t\t\tgoto out;\n\n\t\tput_task_struct(next_task);\n\t\tnext_task = task;\n\t\tgoto retry;\n\t}\n\n\tdeactivate_task(rq, next_task, 0);\n\tsub_running_bw(&next_task->dl, &rq->dl);\n\tsub_rq_bw(&next_task->dl, &rq->dl);\n\tset_task_cpu(next_task, later_rq->cpu);\n\tadd_rq_bw(&next_task->dl, &later_rq->dl);\n\n\t/*\n\t * Update the later_rq clock here, because the clock is used\n\t * by the cpufreq_update_util() inside __add_running_bw().\n\t */\n\tupdate_rq_clock(later_rq);\n\tadd_running_bw(&next_task->dl, &later_rq->dl);\n\tactivate_task(later_rq, next_task, ENQUEUE_NOCLOCK);\n\tret = 1;\n\n\tresched_curr(later_rq);\n\n\tdouble_unlock_balance(rq, later_rq);\n\nout:\n\tput_task_struct(next_task);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "pick_next_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "2005-2023",
    "snippet": "static struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_task(p)"
          ],
          "line": 2020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 2020
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!task_on_rq_queued(p)"
          ],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 2019
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->nr_cpus_allowed <= 1"
          ],
          "line": 2017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_current(rq, p)"
          ],
          "line": 2016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rq->cpu != task_cpu(p)"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "rq->dl.pushable_dl_tasks_root.rb_leftmost",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 2012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 2009
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "497-500",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct task_struct *pick_next_pushable_dl_task(struct rq *rq)\n{\n\tstruct task_struct *p;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\n\tp = rb_entry(rq->dl.pushable_dl_tasks_root.rb_leftmost,\n\t\t     struct task_struct, pushable_dl_tasks);\n\n\tBUG_ON(rq->cpu != task_cpu(p));\n\tBUG_ON(task_current(rq, p));\n\tBUG_ON(p->nr_cpus_allowed <= 1);\n\n\tBUG_ON(!task_on_rq_queued(p));\n\tBUG_ON(!dl_task(p));\n\n\treturn p;\n}"
  },
  {
    "function_name": "find_lock_later_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1948-2003",
    "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [
      "#define DL_MAX_TRIES 3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 1998
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1949-1954",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "task->dl.deadline",
            "later_rq->dl.earliest_dl.curr"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task)"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "task"
          ],
          "line": 1980
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "task"
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "task"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "later_rq->cpu",
            "&task->cpus_allowed"
          ],
          "line": 1977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "task"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 1975
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1938-1947",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "task->dl.deadline",
            "later_rq->dl.earliest_dl.curr"
          ],
          "line": 1963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_later_rq",
          "args": [
            "task"
          ],
          "line": 1955
        },
        "resolved": true,
        "details": {
          "function_name": "find_later_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1860-1945",
          "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
  },
  {
    "function_name": "find_later_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1860-1945",
    "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "later_mask"
          ],
          "line": 1940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first_and",
          "args": [
            "later_mask",
            "sched_domain_span(sd)"
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "this_cpu",
            "sched_domain_span(sd)"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_domain_span",
          "args": [
            "sd"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_domain",
          "args": [
            "cpu",
            "sd"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1902
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "this_cpu",
            "later_mask"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "later_mask"
          ],
          "line": 1893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_find",
          "args": [
            "&task_rq(task)->rd->cpudl",
            "task",
            "later_mask"
          ],
          "line": 1878
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "121-143",
          "snippet": "int cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_allowed)) {\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_allowed) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_allowed)) {\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_allowed) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "task"
          ],
          "line": 1878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!later_mask"
          ],
          "line": 1868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "task"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_cpumask_var_ptr",
          "args": [
            "local_cpu_mask_dl"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
  },
  {
    "function_name": "pick_earliest_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1836-1856",
    "snippet": "static struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "next_node"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_dl_task",
          "args": [
            "rq",
            "p",
            "cpu"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "pick_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1824-1830",
          "snippet": "static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn 1;\n\treturn 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn 1;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next_node",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 1846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 1841
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "497-500",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct task_struct *pick_earliest_pushable_dl_task(struct rq *rq, int cpu)\n{\n\tstruct rb_node *next_node = rq->dl.pushable_dl_tasks_root.rb_leftmost;\n\tstruct task_struct *p = NULL;\n\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn NULL;\n\nnext_node:\n\tif (next_node) {\n\t\tp = rb_entry(next_node, struct task_struct, pushable_dl_tasks);\n\n\t\tif (pick_dl_task(rq, p, cpu))\n\t\t\treturn p;\n\n\t\tnext_node = rb_next(next_node);\n\t\tgoto next_node;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "pick_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1824-1830",
    "snippet": "static int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn 1;\n\treturn 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_test_cpu",
          "args": [
            "cpu",
            "&p->cpus_allowed"
          ],
          "line": 1827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_running",
          "args": [
            "rq",
            "p"
          ],
          "line": 1826
        },
        "resolved": true,
        "details": {
          "function_name": "task_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1526-1533",
          "snippet": "static inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_running(struct rq *rq, struct task_struct *p)\n{\n#ifdef CONFIG_SMP\n\treturn p->on_cpu;\n#else\n\treturn task_current(rq, p);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int pick_dl_task(struct rq *rq, struct task_struct *p, int cpu)\n{\n\tif (!task_running(rq, p) &&\n\t    cpumask_test_cpu(cpu, &p->cpus_allowed))\n\t\treturn 1;\n\treturn 0;\n}"
  },
  {
    "function_name": "set_curr_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1809-1817",
    "snippet": "static void set_curr_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1816
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "574-577",
          "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void set_curr_task_dl(struct rq *rq)\n{\n\tstruct task_struct *p = rq->curr;\n\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t/* You can't push away the running task */\n\tdequeue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "task_fork_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1801-1807",
    "snippet": "static void task_fork_dl(struct task_struct *p)\n{\n\t/*\n\t * SCHED_DEADLINE tasks cannot fork and this is achieved through\n\t * sched_fork()\n\t */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_fork_dl(struct task_struct *p)\n{\n\t/*\n\t * SCHED_DEADLINE tasks cannot fork and this is achieved through\n\t * sched_fork()\n\t */\n}"
  },
  {
    "function_name": "task_tick_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1786-1799",
    "snippet": "static void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\t/*\n\t * Even when we have runtime, update_curr_dl() might have resulted in us\n\t * not being the leftmost task anymore. In that case NEED_RESCHED will\n\t * be set and schedule() will start a new hrtick for the next task.\n\t */\n\tif (hrtick_enabled(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "start_hrtick_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 1798
        },
        "resolved": true,
        "details": {
          "function_name": "start_hrtick_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1693-1695",
          "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leftmost",
          "args": [
            "p",
            "&rq->dl"
          ],
          "line": 1797
        },
        "resolved": true,
        "details": {
          "function_name": "is_leftmost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "331-336",
          "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtick_enabled",
          "args": [
            "rq"
          ],
          "line": 1796
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1844-1847",
          "snippet": "static inline int hrtick_enabled(struct rq *rq)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int hrtick_enabled(struct rq *rq)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_task(rq)",
            "rq",
            "1"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.h",
          "lines": "59-63",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1790
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1788
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1147-1248",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_tick_dl(struct rq *rq, struct task_struct *p, int queued)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\t/*\n\t * Even when we have runtime, update_curr_dl() might have resulted in us\n\t * not being the leftmost task anymore. In that case NEED_RESCHED will\n\t * be set and schedule() will start a new hrtick for the next task.\n\t */\n\tif (hrtick_enabled(rq) && queued && p->dl.runtime > 0 &&\n\t    is_leftmost(p, &rq->dl))\n\t\tstart_hrtick_dl(rq, p);\n}"
  },
  {
    "function_name": "put_prev_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1769-1776",
    "snippet": "static void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1775
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "569-572",
          "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "&p->dl"
          ],
          "line": 1774
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_task(rq)",
            "rq",
            "1"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.h",
          "lines": "59-63",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1773
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1771
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1147-1248",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "pick_next_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1709-1767",
    "snippet": "static struct task_struct *\npick_next_task_dl(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p;\n\tstruct dl_rq *dl_rq;\n\n\tdl_rq = &rq->dl;\n\n\tif (need_pull_dl_task(rq, prev)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we're\n\t\t * being very careful to re-start the picking loop.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tpull_dl_task(rq);\n\t\trq_repin_lock(rq, rf);\n\t\t/*\n\t\t * pull_dl_task() can drop (and re-acquire) rq->lock; this\n\t\t * means a stop task can slip in, in which case we need to\n\t\t * re-start task selection.\n\t\t */\n\t\tif (rq->stop && task_on_rq_queued(rq->stop))\n\t\t\treturn RETRY_TASK;\n\t}\n\n\t/*\n\t * When prev is DL, we may throttle it in put_prev_task().\n\t * So, we update time before we check for dl_nr_running.\n\t */\n\tif (prev->sched_class == &dl_sched_class)\n\t\tupdate_curr_dl(rq);\n\n\tif (unlikely(!dl_rq->dl_nr_running))\n\t\treturn NULL;\n\n\tput_prev_task(rq, prev);\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\n\tp = dl_task_of(dl_se);\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t/* Running task will never be pushed. */\n       dequeue_pushable_dl_task(rq, p);\n\n\tif (hrtick_enabled(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tdeadline_queue_push_tasks(rq);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 0);\n\n\treturn p;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "const struct sched_class dl_sched_class = {\n\t.next\t\t\t= &rt_sched_class,\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\n#ifdef CONFIG_SMP\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n#endif\n\n\t.set_curr_task\t\t= set_curr_task_dl,\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_rq_load_avg",
          "args": [
            "rq_clock_task(rq)",
            "rq",
            "0"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_rq_load_avg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/pelt.h",
          "lines": "59-63",
          "snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline int\nupdate_dl_rq_load_avg(u64 now, struct rq *rq, int running)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1764
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "deadline_queue_push_tasks",
          "args": [
            "rq"
          ],
          "line": 1761
        },
        "resolved": true,
        "details": {
          "function_name": "deadline_queue_push_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "598-600",
          "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "start_hrtick_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "start_hrtick_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1693-1695",
          "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtick_enabled",
          "args": [
            "rq"
          ],
          "line": 1758
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1844-1847",
          "snippet": "static inline int hrtick_enabled(struct rq *rq)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int hrtick_enabled(struct rq *rq)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "574-577",
          "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1752
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!dl_se"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pick_next_dl_entity",
          "args": [
            "rq",
            "dl_rq"
          ],
          "line": 1749
        },
        "resolved": true,
        "details": {
          "function_name": "pick_next_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1698-1707",
          "snippet": "static struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_prev_task",
          "args": [
            "rq",
            "prev"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "put_prev_task_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1769-1776",
          "snippet": "static void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void put_prev_task_dl(struct rq *rq, struct task_struct *p)\n{\n\tupdate_curr_dl(rq);\n\n\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 1);\n\tif (on_dl_rq(&p->dl) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dl_rq->dl_nr_running"
          ],
          "line": 1744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1742
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1147-1248",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "rq->stop"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1727
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1070-1080",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pull_dl_task",
          "args": [
            "rq"
          ],
          "line": 1726
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "rf"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "need_pull_dl_task",
          "args": [
            "rq",
            "prev"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "need_pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "589-592",
          "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nconst struct sched_class dl_sched_class = {\n\t.next\t\t\t= &rt_sched_class,\n\t.enqueue_task\t\t= enqueue_task_dl,\n\t.dequeue_task\t\t= dequeue_task_dl,\n\t.yield_task\t\t= yield_task_dl,\n\n\t.check_preempt_curr\t= check_preempt_curr_dl,\n\n\t.pick_next_task\t\t= pick_next_task_dl,\n\t.put_prev_task\t\t= put_prev_task_dl,\n\n#ifdef CONFIG_SMP\n\t.select_task_rq\t\t= select_task_rq_dl,\n\t.migrate_task_rq\t= migrate_task_rq_dl,\n\t.set_cpus_allowed       = set_cpus_allowed_dl,\n\t.rq_online              = rq_online_dl,\n\t.rq_offline             = rq_offline_dl,\n\t.task_woken\t\t= task_woken_dl,\n#endif\n\n\t.set_curr_task\t\t= set_curr_task_dl,\n\t.task_tick\t\t= task_tick_dl,\n\t.task_fork              = task_fork_dl,\n\n\t.prio_changed           = prio_changed_dl,\n\t.switched_from\t\t= switched_from_dl,\n\t.switched_to\t\t= switched_to_dl,\n\n\t.update_curr\t\t= update_curr_dl,\n};\n\nstatic struct task_struct *\npick_next_task_dl(struct rq *rq, struct task_struct *prev, struct rq_flags *rf)\n{\n\tstruct sched_dl_entity *dl_se;\n\tstruct task_struct *p;\n\tstruct dl_rq *dl_rq;\n\n\tdl_rq = &rq->dl;\n\n\tif (need_pull_dl_task(rq, prev)) {\n\t\t/*\n\t\t * This is OK, because current is on_cpu, which avoids it being\n\t\t * picked for load-balance and preemption/IRQs are still\n\t\t * disabled avoiding further scheduler activity on it and we're\n\t\t * being very careful to re-start the picking loop.\n\t\t */\n\t\trq_unpin_lock(rq, rf);\n\t\tpull_dl_task(rq);\n\t\trq_repin_lock(rq, rf);\n\t\t/*\n\t\t * pull_dl_task() can drop (and re-acquire) rq->lock; this\n\t\t * means a stop task can slip in, in which case we need to\n\t\t * re-start task selection.\n\t\t */\n\t\tif (rq->stop && task_on_rq_queued(rq->stop))\n\t\t\treturn RETRY_TASK;\n\t}\n\n\t/*\n\t * When prev is DL, we may throttle it in put_prev_task().\n\t * So, we update time before we check for dl_nr_running.\n\t */\n\tif (prev->sched_class == &dl_sched_class)\n\t\tupdate_curr_dl(rq);\n\n\tif (unlikely(!dl_rq->dl_nr_running))\n\t\treturn NULL;\n\n\tput_prev_task(rq, prev);\n\n\tdl_se = pick_next_dl_entity(rq, dl_rq);\n\tBUG_ON(!dl_se);\n\n\tp = dl_task_of(dl_se);\n\tp->se.exec_start = rq_clock_task(rq);\n\n\t/* Running task will never be pushed. */\n       dequeue_pushable_dl_task(rq, p);\n\n\tif (hrtick_enabled(rq))\n\t\tstart_hrtick_dl(rq, p);\n\n\tdeadline_queue_push_tasks(rq);\n\n\tif (rq->curr->sched_class != &dl_sched_class)\n\t\tupdate_dl_rq_load_avg(rq_clock_task(rq), rq, 0);\n\n\treturn p;\n}"
  },
  {
    "function_name": "pick_next_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1698-1707",
    "snippet": "static struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "left",
            "structsched_dl_entity",
            "rb_node"
          ],
          "line": 1706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_first_cached",
          "args": [
            "&dl_rq->root"
          ],
          "line": 1701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct sched_dl_entity *pick_next_dl_entity(struct rq *rq,\n\t\t\t\t\t\t   struct dl_rq *dl_rq)\n{\n\tstruct rb_node *left = rb_first_cached(&dl_rq->root);\n\n\tif (!left)\n\t\treturn NULL;\n\n\treturn rb_entry(left, struct sched_dl_entity, rb_node);\n}"
  },
  {
    "function_name": "start_hrtick_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1693-1695",
    "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "start_hrtick_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1688-1691",
    "snippet": "static void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtick_start",
          "args": [
            "rq",
            "p->dl.runtime"
          ],
          "line": 1690
        },
        "resolved": true,
        "details": {
          "function_name": "hrtick_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "295-304",
          "snippet": "void hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid hrtick_start(struct rq *rq, u64 delay)\n{\n\t/*\n\t * Don't schedule slices shorter than 10000ns, that just\n\t * doesn't make sense. Rely on vruntime for fairness.\n\t */\n\tdelay = max_t(u64, delay, 10000LL);\n\thrtimer_start(&rq->hrtick_timer, ns_to_ktime(delay),\n\t\t      HRTIMER_MODE_REL_PINNED);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void start_hrtick_dl(struct rq *rq, struct task_struct *p)\n{\n\thrtick_start(rq, p->dl.runtime);\n}"
  },
  {
    "function_name": "check_preempt_curr_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1668-1685",
    "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_preempt_equal_dl",
          "args": [
            "rq",
            "p"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_equal_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1641-1660",
          "snippet": "static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_tsk_need_resched",
          "args": [
            "rq->curr"
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1672
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&rq->curr->dl"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "217-222",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
  },
  {
    "function_name": "check_preempt_equal_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1641-1660",
    "snippet": "static void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1659
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpudl_find",
          "args": [
            "&rq->rd->cpudl",
            "p",
            "NULL"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_find",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "121-143",
          "snippet": "int cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_allowed)) {\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_allowed) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nint cpudl_find(struct cpudl *cp, struct task_struct *p,\n\t       struct cpumask *later_mask)\n{\n\tconst struct sched_dl_entity *dl_se = &p->dl;\n\n\tif (later_mask &&\n\t    cpumask_and(later_mask, cp->free_cpus, &p->cpus_allowed)) {\n\t\treturn 1;\n\t} else {\n\t\tint best_cpu = cpudl_maximum(cp);\n\n\t\tWARN_ON(best_cpu != -1 && !cpu_present(best_cpu));\n\n\t\tif (cpumask_test_cpu(best_cpu, &p->cpus_allowed) &&\n\t\t    dl_time_before(dl_se->deadline, cp->elements[0].dl)) {\n\t\t\tif (later_mask)\n\t\t\t\tcpumask_set_cpu(best_cpu, later_mask);\n\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void check_preempt_equal_dl(struct rq *rq, struct task_struct *p)\n{\n\t/*\n\t * Current can't be migrated, useless to reschedule,\n\t * let's hope p can move out.\n\t */\n\tif (rq->curr->nr_cpus_allowed == 1 ||\n\t    !cpudl_find(&rq->rd->cpudl, rq->curr, NULL))\n\t\treturn;\n\n\t/*\n\t * p is migratable, so let's not schedule it and\n\t * see if it is pushed or pulled somewhere else.\n\t */\n\tif (p->nr_cpus_allowed != 1 &&\n\t    cpudl_find(&rq->rd->cpudl, p, NULL))\n\t\treturn;\n\n\tresched_curr(rq);\n}"
  },
  {
    "function_name": "migrate_task_rq_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1610-1639",
    "snippet": "static void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)\n{\n\tstruct rq *rq;\n\n\tif (p->state != TASK_WAKING)\n\t\treturn;\n\n\trq = task_rq(p);\n\t/*\n\t * Since p->state == TASK_WAKING, set_task_cpu() has been called\n\t * from try_to_wake_up(). Hence, p->pi_lock is locked, but\n\t * rq->lock is not... So, lock it\n\t */\n\traw_spin_lock(&rq->lock);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\tsub_rq_bw(&p->dl, &rq->dl);\n\traw_spin_unlock(&rq->lock);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rq->lock"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1637
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rq->lock"
          ],
          "line": 1623
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 1617
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void migrate_task_rq_dl(struct task_struct *p, int new_cpu __maybe_unused)\n{\n\tstruct rq *rq;\n\n\tif (p->state != TASK_WAKING)\n\t\treturn;\n\n\trq = task_rq(p);\n\t/*\n\t * Since p->state == TASK_WAKING, set_task_cpu() has been called\n\t * from try_to_wake_up(). Hence, p->pi_lock is locked, but\n\t * rq->lock is not... So, lock it\n\t */\n\traw_spin_lock(&rq->lock);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\tsub_rq_bw(&p->dl, &rq->dl);\n\traw_spin_unlock(&rq->lock);\n}"
  },
  {
    "function_name": "select_task_rq_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1569-1608",
    "snippet": "static int\nselect_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\tstruct task_struct *curr;\n\tstruct rq *rq;\n\n\tif (sd_flag != SD_BALANCE_WAKE)\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = READ_ONCE(rq->curr); /* unlocked access */\n\n\t/*\n\t * If we are dealing with a -deadline task, we must\n\t * decide where to wake it up.\n\t * If it has a later deadline and the current task\n\t * on this rq can't move (provided the waking task\n\t * can!) we prefer to send it somewhere else. On the\n\t * other hand, if it has a shorter deadline, we\n\t * try to make it stay here, it might be important.\n\t */\n\tif (unlikely(dl_task(curr)) &&\n\t    (curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t    (p->nr_cpus_allowed > 1)) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1 &&\n\t\t\t\t(dl_time_before(p->dl.deadline,\n\t\t\t\t\tcpu_rq(target)->dl.earliest_dl.curr) ||\n\t\t\t\t(cpu_rq(target)->dl.dl_nr_running == 0)))\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1604
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "target"
          ],
          "line": 1601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "p->dl.deadline",
            "cpu_rq(target)->dl.earliest_dl.curr"
          ],
          "line": 1599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "target"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_later_rq",
          "args": [
            "p"
          ],
          "line": 1596
        },
        "resolved": true,
        "details": {
          "function_name": "find_later_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1860-1945",
          "snippet": "static int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int find_later_rq(struct task_struct *task)\n{\n\tstruct sched_domain *sd;\n\tstruct cpumask *later_mask = this_cpu_cpumask_var_ptr(local_cpu_mask_dl);\n\tint this_cpu = smp_processor_id();\n\tint cpu = task_cpu(task);\n\n\t/* Make sure the mask is initialized first */\n\tif (unlikely(!later_mask))\n\t\treturn -1;\n\n\tif (task->nr_cpus_allowed == 1)\n\t\treturn -1;\n\n\t/*\n\t * We have to consider system topology and task affinity\n\t * first, then we can look for a suitable CPU.\n\t */\n\tif (!cpudl_find(&task_rq(task)->rd->cpudl, task, later_mask))\n\t\treturn -1;\n\n\t/*\n\t * If we are here, some targets have been found, including\n\t * the most suitable which is, among the runqueues where the\n\t * current tasks have later deadlines than the task's one, the\n\t * rq with the latest possible one.\n\t *\n\t * Now we check how well this matches with task's\n\t * affinity and system topology.\n\t *\n\t * The last CPU where the task run is our first\n\t * guess, since it is most likely cache-hot there.\n\t */\n\tif (cpumask_test_cpu(cpu, later_mask))\n\t\treturn cpu;\n\t/*\n\t * Check if this_cpu is to be skipped (i.e., it is\n\t * not in the mask) or not.\n\t */\n\tif (!cpumask_test_cpu(this_cpu, later_mask))\n\t\tthis_cpu = -1;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tif (sd->flags & SD_WAKE_AFFINE) {\n\t\t\tint best_cpu;\n\n\t\t\t/*\n\t\t\t * If possible, preempting this_cpu is\n\t\t\t * cheaper than migrating.\n\t\t\t */\n\t\t\tif (this_cpu != -1 &&\n\t\t\t    cpumask_test_cpu(this_cpu, sched_domain_span(sd))) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn this_cpu;\n\t\t\t}\n\n\t\t\tbest_cpu = cpumask_first_and(later_mask,\n\t\t\t\t\t\t\tsched_domain_span(sd));\n\t\t\t/*\n\t\t\t * Last chance: if a CPU being in both later_mask\n\t\t\t * and current sd span is valid, that becomes our\n\t\t\t * choice. Of course, the latest possible CPU is\n\t\t\t * already under consideration through later_mask.\n\t\t\t */\n\t\t\tif (best_cpu < nr_cpu_ids) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\treturn best_cpu;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\t/*\n\t * At this point, all our guesses failed, we just return\n\t * 'something', and let the caller sort the things out.\n\t */\n\tif (this_cpu != -1)\n\t\treturn this_cpu;\n\n\tcpu = cpumask_any(later_mask);\n\tif (cpu < nr_cpu_ids)\n\t\treturn cpu;\n\n\treturn -1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&curr->dl"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "217-222",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_task(curr)"
          ],
          "line": 1592
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "curr"
          ],
          "line": 1592
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "rq->curr"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1580
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 1578
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic int\nselect_task_rq_dl(struct task_struct *p, int cpu, int sd_flag, int flags)\n{\n\tstruct task_struct *curr;\n\tstruct rq *rq;\n\n\tif (sd_flag != SD_BALANCE_WAKE)\n\t\tgoto out;\n\n\trq = cpu_rq(cpu);\n\n\trcu_read_lock();\n\tcurr = READ_ONCE(rq->curr); /* unlocked access */\n\n\t/*\n\t * If we are dealing with a -deadline task, we must\n\t * decide where to wake it up.\n\t * If it has a later deadline and the current task\n\t * on this rq can't move (provided the waking task\n\t * can!) we prefer to send it somewhere else. On the\n\t * other hand, if it has a shorter deadline, we\n\t * try to make it stay here, it might be important.\n\t */\n\tif (unlikely(dl_task(curr)) &&\n\t    (curr->nr_cpus_allowed < 2 ||\n\t     !dl_entity_preempt(&p->dl, &curr->dl)) &&\n\t    (p->nr_cpus_allowed > 1)) {\n\t\tint target = find_later_rq(p);\n\n\t\tif (target != -1 &&\n\t\t\t\t(dl_time_before(p->dl.deadline,\n\t\t\t\t\tcpu_rq(target)->dl.earliest_dl.curr) ||\n\t\t\t\t(cpu_rq(target)->dl.dl_nr_running == 0)))\n\t\t\tcpu = target;\n\t}\n\trcu_read_unlock();\n\nout:\n\treturn cpu;\n}"
  },
  {
    "function_name": "yield_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1545-1563",
    "snippet": "static void yield_task_dl(struct rq *rq)\n{\n\t/*\n\t * We make the task go to sleep until its current deadline by\n\t * forcing its runtime to zero. This way, update_curr_dl() stops\n\t * it and the bandwidth timer will wake it up and will give it\n\t * new scheduling parameters (thanks to dl_yielded=1).\n\t */\n\trq->curr->dl.dl_yielded = 1;\n\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t/*\n\t * Tell update_rq_clock() that we've just updated,\n\t * so we don't do microscopic update in schedule()\n\t * and double the fastpath cost.\n\t */\n\trq_clock_skip_update(rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock_skip_update",
          "args": [
            "rq"
          ],
          "line": 1562
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_skip_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1021-1025",
          "snippet": "static inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_REQ_SKIP\t\t0x01"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_REQ_SKIP\t\t0x01\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_clock_skip_update(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\trq->clock_update_flags |= RQCF_REQ_SKIP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1147-1248",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1555
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void yield_task_dl(struct rq *rq)\n{\n\t/*\n\t * We make the task go to sleep until its current deadline by\n\t * forcing its runtime to zero. This way, update_curr_dl() stops\n\t * it and the bandwidth timer will wake it up and will give it\n\t * new scheduling parameters (thanks to dl_yielded=1).\n\t */\n\trq->curr->dl.dl_yielded = 1;\n\n\tupdate_rq_clock(rq);\n\tupdate_curr_dl(rq);\n\t/*\n\t * Tell update_rq_clock() that we've just updated,\n\t * so we don't do microscopic update in schedule()\n\t * and double the fastpath cost.\n\t */\n\trq_clock_skip_update(rq);\n}"
  },
  {
    "function_name": "dequeue_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1512-1533",
    "snippet": "static void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & DEQUEUE_SAVE) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * This check allows to start the inactive timer (or to immediately\n\t * decrease the active utilization, if needed) in two cases:\n\t * when the task blocks and when it is terminating\n\t * (p->state == TASK_DEAD). We can handle the two cases in the same\n\t * way, because from GRUB's point of view the same thing is happening\n\t * (the task moves from \"active contending\" to \"active non contending\"\n\t * or \"inactive\")\n\t */\n\tif (flags & DEQUEUE_SLEEP)\n\t\ttask_non_contending(p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_non_contending",
          "args": [
            "p"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "task_non_contending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "237-292",
          "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dequeue_task_dl",
          "args": [
            "rq",
            "p",
            "flags"
          ],
          "line": 1515
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_task_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1506-1510",
          "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_curr_dl",
          "args": [
            "rq"
          ],
          "line": 1514
        },
        "resolved": true,
        "details": {
          "function_name": "update_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1147-1248",
          "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
            "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tupdate_curr_dl(rq);\n\t__dequeue_task_dl(rq, p, flags);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & DEQUEUE_SAVE) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * This check allows to start the inactive timer (or to immediately\n\t * decrease the active utilization, if needed) in two cases:\n\t * when the task blocks and when it is terminating\n\t * (p->state == TASK_DEAD). We can handle the two cases in the same\n\t * way, because from GRUB's point of view the same thing is happening\n\t * (the task moves from \"active contending\" to \"active non contending\"\n\t * or \"inactive\")\n\t */\n\tif (flags & DEQUEUE_SLEEP)\n\t\ttask_non_contending(p);\n}"
  },
  {
    "function_name": "__dequeue_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1506-1510",
    "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "dequeue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1509
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "574-577",
          "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_dl_entity",
          "args": [
            "&p->dl"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1435-1438",
          "snippet": "static void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "enqueue_task_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1440-1504",
    "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_pushable_dl_task",
          "args": [
            "rq",
            "p"
          ],
          "line": 1503
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_pushable_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "569-572",
          "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_current",
          "args": [
            "rq",
            "p"
          ],
          "line": 1502
        },
        "resolved": true,
        "details": {
          "function_name": "task_current",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1521-1524",
          "snippet": "static inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int task_current(struct rq *rq, struct task_struct *p)\n{\n\treturn rq->curr == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_dl_entity",
          "args": [
            "&p->dl",
            "pi_se",
            "flags"
          ],
          "line": 1500
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1410-1433",
          "snippet": "static void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se, pi_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se, pi_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se, pi_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se, pi_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contending",
          "args": [
            "&p->dl",
            "flags"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "task_contending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "294-329",
          "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "142-147",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "128-133",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_check_constrained_dl",
          "args": [
            "&p->dl"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "dl_check_constrained_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1079-1092",
          "snippet": "static inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_is_implicit",
          "args": [
            "&p->dl"
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "dl_is_implicit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "817-820",
          "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "p->normal_prio"
          ],
          "line": 1455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "pi_task->normal_prio"
          ],
          "line": 1453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rt_mutex_get_top_task",
          "args": [
            "p"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
  },
  {
    "function_name": "dequeue_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1435-1438",
    "snippet": "static void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__dequeue_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1397-1408",
          "snippet": "static void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\t__dequeue_dl_entity(dl_se);\n}"
  },
  {
    "function_name": "enqueue_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1410-1433",
    "snippet": "static void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se, pi_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se, pi_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__enqueue_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1432
        },
        "resolved": true,
        "details": {
          "function_name": "__enqueue_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1370-1395",
          "snippet": "static void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color_cached(&dl_se->rb_node, &dl_rq->root, leftmost);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color_cached(&dl_se->rb_node, &dl_rq->root, leftmost);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "setup_new_dl_entity",
          "args": [
            "dl_se"
          ],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "setup_new_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "623-646",
          "snippet": "static inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(dl_se->dl_boosted);\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(dl_se->dl_boosted);\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se)))"
          ],
          "line": 1427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq_of_dl_rq(dl_rq_of_se(dl_se))"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq_of_se(dl_se)"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1428
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "replenish_dl_entity",
          "args": [
            "dl_se",
            "pi_se"
          ],
          "line": 1425
        },
        "resolved": true,
        "details": {
          "function_name": "replenish_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "666-716",
          "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_entity",
          "args": [
            "dl_se",
            "pi_se"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "852-871",
          "snippet": "static void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !dl_se->dl_boosted)){\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !dl_se->dl_boosted)){\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_contending",
          "args": [
            "dl_se",
            "flags"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "task_contending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "294-329",
          "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "on_dl_rq(dl_se)"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "dl_se"
          ],
          "line": 1414
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void\nenqueue_dl_entity(struct sched_dl_entity *dl_se,\n\t\t  struct sched_dl_entity *pi_se, int flags)\n{\n\tBUG_ON(on_dl_rq(dl_se));\n\n\t/*\n\t * If this is a wakeup or a new instance, the scheduling\n\t * parameters of the task might need updating. Otherwise,\n\t * we want a replenishment of its runtime.\n\t */\n\tif (flags & ENQUEUE_WAKEUP) {\n\t\ttask_contending(dl_se, flags);\n\t\tupdate_dl_entity(dl_se, pi_se);\n\t} else if (flags & ENQUEUE_REPLENISH) {\n\t\treplenish_dl_entity(dl_se, pi_se);\n\t} else if ((flags & ENQUEUE_RESTORE) &&\n\t\t  dl_time_before(dl_se->deadline,\n\t\t\t\t rq_clock(rq_of_dl_rq(dl_rq_of_se(dl_se))))) {\n\t\tsetup_new_dl_entity(dl_se);\n\t}\n\n\t__enqueue_dl_entity(dl_se);\n}"
  },
  {
    "function_name": "__dequeue_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1397-1408",
    "snippet": "static void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_dl_tasks",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1356-1368",
          "snippet": "static inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&dl_se->rb_node",
            "&dl_rq->root"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1399
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void __dequeue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\tif (RB_EMPTY_NODE(&dl_se->rb_node))\n\t\treturn;\n\n\trb_erase_cached(&dl_se->rb_node, &dl_rq->root);\n\tRB_CLEAR_NODE(&dl_se->rb_node);\n\n\tdec_dl_tasks(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "__enqueue_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1370-1395",
    "snippet": "static void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color_cached(&dl_se->rb_node, &dl_rq->root, leftmost);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_dl_tasks",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1394
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1342-1354",
          "snippet": "static inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_insert_color_cached",
          "args": [
            "&dl_se->rb_node",
            "&dl_rq->root",
            "leftmost"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&dl_se->rb_node",
            "parent",
            "link"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "entry->deadline"
          ],
          "line": 1383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structsched_dl_entity",
            "rb_node"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_NODE(&dl_se->rb_node)"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void __enqueue_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rb_node **link = &dl_rq->root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct sched_dl_entity *entry;\n\tint leftmost = 1;\n\n\tBUG_ON(!RB_EMPTY_NODE(&dl_se->rb_node));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct sched_dl_entity, rb_node);\n\t\tif (dl_time_before(dl_se->deadline, entry->deadline))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = 0;\n\t\t}\n\t}\n\n\trb_link_node(&dl_se->rb_node, parent, link);\n\trb_insert_color_cached(&dl_se->rb_node, &dl_rq->root, leftmost);\n\n\tinc_dl_tasks(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "dec_dl_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1356-1368",
    "snippet": "static inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_dl_migration",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "584-587",
          "snippet": "static inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_dl_deadline",
          "args": [
            "dl_rq",
            "dl_se->deadline"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "dec_dl_deadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1338-1338",
          "snippet": "static inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
        }
      },
      {
        "call_info": {
          "callee": "sub_nr_running",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "1"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "sub_nr_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1809-1814",
          "snippet": "static inline void sub_nr_running(struct rq *rq, unsigned count)\n{\n\trq->nr_running -= count;\n\t/* Check if we still need preemption */\n\tsched_update_tick_dependency(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void sub_nr_running(struct rq *rq, unsigned count)\n{\n\trq->nr_running -= count;\n\t/* Check if we still need preemption */\n\tsched_update_tick_dependency(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_rq->dl_nr_running"
          ],
          "line": 1362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_prio(prio)"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 1361
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dec_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\n\tWARN_ON(!dl_prio(prio));\n\tWARN_ON(!dl_rq->dl_nr_running);\n\tdl_rq->dl_nr_running--;\n\tsub_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tdec_dl_deadline(dl_rq, dl_se->deadline);\n\tdec_dl_migration(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "inc_dl_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1342-1354",
    "snippet": "static inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_dl_migration",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "579-582",
          "snippet": "static inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "inc_dl_deadline",
          "args": [
            "dl_rq",
            "deadline"
          ],
          "line": 1352
        },
        "resolved": true,
        "details": {
          "function_name": "inc_dl_deadline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1337-1337",
          "snippet": "static inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
        }
      },
      {
        "call_info": {
          "callee": "add_nr_running",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "1"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "add_nr_running",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1793-1807",
          "snippet": "static inline void add_nr_running(struct rq *rq, unsigned count)\n{\n\tunsigned prev_nr = rq->nr_running;\n\n\trq->nr_running = prev_nr + count;\n\n\tif (prev_nr < 2 && rq->nr_running >= 2) {\n#ifdef CONFIG_SMP\n\t\tif (!READ_ONCE(rq->rd->overload))\n\t\t\tWRITE_ONCE(rq->rd->overload, 1);\n#endif\n\t}\n\n\tsched_update_tick_dependency(rq);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void add_nr_running(struct rq *rq, unsigned count)\n{\n\tunsigned prev_nr = rq->nr_running;\n\n\trq->nr_running = prev_nr + count;\n\n\tif (prev_nr < 2 && rq->nr_running >= 2) {\n#ifdef CONFIG_SMP\n\t\tif (!READ_ONCE(rq->rd->overload))\n\t\t\tWRITE_ONCE(rq->rd->overload, 1);\n#endif\n\t}\n\n\tsched_update_tick_dependency(rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1350
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!dl_prio(prio)"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_prio",
          "args": [
            "prio"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid inc_dl_tasks(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tint prio = dl_task_of(dl_se)->prio;\n\tu64 deadline = dl_se->deadline;\n\n\tWARN_ON(!dl_prio(prio));\n\tdl_rq->dl_nr_running++;\n\tadd_nr_running(rq_of_dl_rq(dl_rq), 1);\n\n\tinc_dl_deadline(dl_rq, deadline);\n\tinc_dl_migration(dl_se, dl_rq);\n}"
  },
  {
    "function_name": "dec_dl_deadline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1338-1338",
    "snippet": "static inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
  },
  {
    "function_name": "inc_dl_deadline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1337-1337",
    "snippet": "static inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline) {}"
  },
  {
    "function_name": "dec_dl_deadline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1313-1333",
    "snippet": "static void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t/*\n\t * Since we may have removed our earliest (and/or next earliest)\n\t * task we must recompute them.\n\t */\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->root.rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "entry->deadline"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "194-218",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "leftmost",
            "structsched_dl_entity",
            "rb_node"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpudl_clear",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_clear_freecpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "235-238",
          "snippet": "void cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_clear_freecpu(struct cpudl *cp, int cpu)\n{\n\tcpumask_clear_cpu(cpu, cp->free_cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1315
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dec_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\t/*\n\t * Since we may have removed our earliest (and/or next earliest)\n\t * task we must recompute them.\n\t */\n\tif (!dl_rq->dl_nr_running) {\n\t\tdl_rq->earliest_dl.curr = 0;\n\t\tdl_rq->earliest_dl.next = 0;\n\t\tcpudl_clear(&rq->rd->cpudl, rq->cpu);\n\t} else {\n\t\tstruct rb_node *leftmost = dl_rq->root.rb_leftmost;\n\t\tstruct sched_dl_entity *entry;\n\n\t\tentry = rb_entry(leftmost, struct sched_dl_entity, rb_node);\n\t\tdl_rq->earliest_dl.curr = entry->deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, entry->deadline);\n\t}\n}"
  },
  {
    "function_name": "inc_dl_deadline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1302-1311",
    "snippet": "static void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpudl_set",
          "args": [
            "&rq->rd->cpudl",
            "rq->cpu",
            "deadline"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "cpudl_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpudeadline.c",
          "lines": "194-218",
          "snippet": "void cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpudl_set(struct cpudl *cp, int cpu, u64 dl)\n{\n\tint old_idx;\n\tunsigned long flags;\n\n\tWARN_ON(!cpu_present(cpu));\n\n\traw_spin_lock_irqsave(&cp->lock, flags);\n\n\told_idx = cp->elements[cpu].idx;\n\tif (old_idx == IDX_INVALID) {\n\t\tint new_idx = cp->size++;\n\n\t\tcp->elements[new_idx].dl = dl;\n\t\tcp->elements[new_idx].cpu = cpu;\n\t\tcp->elements[cpu].idx = new_idx;\n\t\tcpudl_heapify_up(cp, new_idx);\n\t\tcpumask_clear_cpu(cpu, cp->free_cpus);\n\t} else {\n\t\tcp->elements[old_idx].dl = dl;\n\t\tcpudl_heapify(cp, old_idx);\n\t}\n\n\traw_spin_unlock_irqrestore(&cp->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "deadline",
            "dl_rq->earliest_dl.curr"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 1304
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void inc_dl_deadline(struct dl_rq *dl_rq, u64 deadline)\n{\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_rq->earliest_dl.curr == 0 ||\n\t    dl_time_before(deadline, dl_rq->earliest_dl.curr)) {\n\t\tdl_rq->earliest_dl.curr = deadline;\n\t\tcpudl_set(&rq->rd->cpudl, rq->cpu, deadline);\n\t}\n}"
  },
  {
    "function_name": "init_dl_inactive_task_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1292-1298",
    "snippet": "void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = inactive_task_timer;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 1296
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_inactive_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = inactive_task_timer;\n}"
  },
  {
    "function_name": "inactive_task_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1250-1290",
    "snippet": "static enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     inactive_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\tif (p->state == TASK_DEAD && dl_se->dl_non_contending) {\n\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tdl_se->dl_non_contending = 0;\n\t\t}\n\n\t\traw_spin_lock(&dl_b->lock);\n\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&dl_b->lock);\n\t\t__dl_clear_params(p);\n\n\t\tgoto unlock;\n\t}\n\tif (dl_se->dl_non_contending == 0)\n\t\tgoto unlock;\n\n\tsub_running_bw(dl_se, &rq->dl);\n\tdl_se->dl_non_contending = 0;\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1287
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "dl_se",
            "&rq->dl"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_clear_params",
          "args": [
            "p"
          ],
          "line": 1276
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_clear_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2648-2663",
          "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 1275
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "286-291",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 1274
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 1273
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "dl_rq_of_se(&p->dl)"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "&p->dl"
          ],
          "line": 1269
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "task_cpu(p)"
          ],
          "line": 1265
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 1264
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1262
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 1261
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "405-420",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 1259
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsched_dl_entity",
            "inactive_timer"
          ],
          "line": 1252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic enum hrtimer_restart inactive_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     inactive_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\tif (p->state == TASK_DEAD && dl_se->dl_non_contending) {\n\t\t\tsub_running_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tsub_rq_bw(&p->dl, dl_rq_of_se(&p->dl));\n\t\t\tdl_se->dl_non_contending = 0;\n\t\t}\n\n\t\traw_spin_lock(&dl_b->lock);\n\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\traw_spin_unlock(&dl_b->lock);\n\t\t__dl_clear_params(p);\n\n\t\tgoto unlock;\n\t}\n\tif (dl_se->dl_non_contending == 0)\n\t\tgoto unlock;\n\n\tsub_running_bw(dl_se, &rq->dl);\n\tdl_se->dl_non_contending = 0;\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "update_curr_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1147-1248",
    "snippet": "static void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);",
      "extern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&rt_rq->rt_runtime_lock"
          ],
          "line": 1246
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_rt_bandwidth_account",
          "args": [
            "rt_rq"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "sched_rt_bandwidth_account",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/rt.c",
          "lines": "626-632",
          "snippet": "bool sched_rt_bandwidth_account(struct rt_rq *rt_rq)\n{\n\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);\n\n\treturn (hrtimer_active(&rt_b->rt_period_timer) ||\n\t\trt_rq->rt_time < rt_b->rt_runtime);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_top_rt_rq(struct rt_rq *rt_rq);",
            "static void dequeue_top_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_top_rt_rq(struct rt_rq *rt_rq);\nstatic void dequeue_top_rt_rq(struct rt_rq *rt_rq);\n\nbool sched_rt_bandwidth_account(struct rt_rq *rt_rq)\n{\n\tstruct rt_bandwidth *rt_b = sched_rt_bandwidth(rt_rq);\n\n\treturn (hrtimer_active(&rt_b->rt_period_timer) ||\n\t\trt_rq->rt_time < rt_b->rt_runtime);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&rt_rq->rt_runtime_lock"
          ],
          "line": 1238
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_bandwidth_enabled",
          "args": [],
          "line": 1235
        },
        "resolved": true,
        "details": {
          "function_name": "rt_bandwidth_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "572-575",
          "snippet": "static inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int rt_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_leftmost",
          "args": [
            "curr",
            "&rq->dl"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "is_leftmost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "331-336",
          "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task_dl",
          "args": [
            "rq",
            "curr",
            "ENQUEUE_REPLENISH"
          ],
          "line": 1218
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1440-1504",
          "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->dl_boosted || !start_dl_timer(curr)"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_dl_timer",
          "args": [
            "curr"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "start_dl_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "888-931",
          "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dequeue_task_dl",
          "args": [
            "rq",
            "curr",
            "0"
          ],
          "line": 1216
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_task_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1506-1510",
          "snippet": "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tdequeue_dl_entity(&p->dl);\n\tdequeue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_runtime_exceeded",
          "args": [
            "dl_se"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "dl_runtime_exceeded",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1094-1098",
          "snippet": "static\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cap_scale",
          "args": [
            "scaled_delta_exec",
            "scale_cpu"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_scale",
          "args": [
            "delta_exec",
            "scale_freq"
          ],
          "line": 1201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "NULL",
            "cpu"
          ],
          "line": 1199
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_cpu_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1872-1876",
          "snippet": "static __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_scale_freq_capacity",
          "args": [
            "cpu"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_freq_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1852-1856",
          "snippet": "static __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_freq_capacity(int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "grub_reclaim",
          "args": [
            "delta_exec",
            "rq",
            "&curr->dl"
          ],
          "line": 1194
        },
        "resolved": true,
        "details": {
          "function_name": "grub_reclaim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1121-1141",
          "snippet": "static u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->flags & SCHED_FLAG_RECLAIM"
          ],
          "line": 1193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_account_cputime",
          "args": [
            "curr",
            "delta_exec"
          ],
          "line": 1181
        },
        "resolved": true,
        "details": {
          "function_name": "__cgroup_account_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/rstat.c",
          "lines": "362-369",
          "snippet": "void __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include \"cgroup-internal.h\"\n\nvoid __cgroup_account_cputime(struct cgroup *cgrp, u64 delta_exec)\n{\n\tstruct cgroup_rstat_cpu *rstatc;\n\n\trstatc = cgroup_base_stat_cputime_account_begin(cgrp);\n\trstatc->bstat.cputime.sum_exec_runtime += delta_exec;\n\tcgroup_base_stat_cputime_account_end(cgrp, rstatc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_group_exec_runtime",
          "args": [
            "curr",
            "delta_exec"
          ],
          "line": 1178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedstat_set",
          "args": [
            "curr->se.statistics.exec_max",
            "max(curr->se.statistics.exec_max, delta_exec)"
          ],
          "line": 1174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "curr->se.statistics.exec_max",
            "delta_exec"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "253-256",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->dl_yielded"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "(s64)delta_exec <= 0"
          ],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock_task",
          "args": [
            "rq"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "rq_clock_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1013-1019",
          "snippet": "static inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline u64 rq_clock_task(struct rq *rq)\n{\n\tlockdep_assert_held(&rq->lock);\n\tassert_clock_updated(rq);\n\n\treturn rq->clock_task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "on_dl_rq",
          "args": [
            "dl_se"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "on_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "41-44",
          "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "curr"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_of",
          "args": [
            "rq"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "928-935",
          "snippet": "static inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void resched_cpu(int cpu);\n\nstatic inline int cpu_of(struct rq *rq)\n{\n#ifdef CONFIG_SMP\n\treturn rq->cpu;\n#else\n\treturn 0;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\nextern bool sched_rt_bandwidth_account(struct rt_rq *rt_rq);\n\nstatic void update_curr_dl(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tstruct sched_dl_entity *dl_se = &curr->dl;\n\tu64 delta_exec, scaled_delta_exec;\n\tint cpu = cpu_of(rq);\n\tu64 now;\n\n\tif (!dl_task(curr) || !on_dl_rq(dl_se))\n\t\treturn;\n\n\t/*\n\t * Consumed budget is computed considering the time as\n\t * observed by schedulable tasks (excluding time spent\n\t * in hardirq context, etc.). Deadlines are instead\n\t * computed using hard walltime. This seems to be the more\n\t * natural solution, but the full ramifications of this\n\t * approach need further study.\n\t */\n\tnow = rq_clock_task(rq);\n\tdelta_exec = now - curr->se.exec_start;\n\tif (unlikely((s64)delta_exec <= 0)) {\n\t\tif (unlikely(dl_se->dl_yielded))\n\t\t\tgoto throttle;\n\t\treturn;\n\t}\n\n\tschedstat_set(curr->se.statistics.exec_max,\n\t\t      max(curr->se.statistics.exec_max, delta_exec));\n\n\tcurr->se.sum_exec_runtime += delta_exec;\n\taccount_group_exec_runtime(curr, delta_exec);\n\n\tcurr->se.exec_start = now;\n\tcgroup_account_cputime(curr, delta_exec);\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\t/*\n\t * For tasks that participate in GRUB, we implement GRUB-PA: the\n\t * spare reclaimed bandwidth is used to clock down frequency.\n\t *\n\t * For the others, we still need to scale reservation parameters\n\t * according to current frequency and CPU maximum capacity.\n\t */\n\tif (unlikely(dl_se->flags & SCHED_FLAG_RECLAIM)) {\n\t\tscaled_delta_exec = grub_reclaim(delta_exec,\n\t\t\t\t\t\t rq,\n\t\t\t\t\t\t &curr->dl);\n\t} else {\n\t\tunsigned long scale_freq = arch_scale_freq_capacity(cpu);\n\t\tunsigned long scale_cpu = arch_scale_cpu_capacity(NULL, cpu);\n\n\t\tscaled_delta_exec = cap_scale(delta_exec, scale_freq);\n\t\tscaled_delta_exec = cap_scale(scaled_delta_exec, scale_cpu);\n\t}\n\n\tdl_se->runtime -= scaled_delta_exec;\n\nthrottle:\n\tif (dl_runtime_exceeded(dl_se) || dl_se->dl_yielded) {\n\t\tdl_se->dl_throttled = 1;\n\n\t\t/* If requested, inform the user about runtime overruns. */\n\t\tif (dl_runtime_exceeded(dl_se) &&\n\t\t    (dl_se->flags & SCHED_FLAG_DL_OVERRUN))\n\t\t\tdl_se->dl_overrun = 1;\n\n\t\t__dequeue_task_dl(rq, curr, 0);\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(curr)))\n\t\t\tenqueue_task_dl(rq, curr, ENQUEUE_REPLENISH);\n\n\t\tif (!is_leftmost(curr, &rq->dl))\n\t\t\tresched_curr(rq);\n\t}\n\n\t/*\n\t * Because -- for now -- we share the rt bandwidth, we need to\n\t * account our runtime there too, otherwise actual rt tasks\n\t * would be able to exceed the shared quota.\n\t *\n\t * Account to the root rt group for now.\n\t *\n\t * The solution we're working towards is having the RT groups scheduled\n\t * using deadline servers -- however there's a few nasties to figure\n\t * out before that can happen.\n\t */\n\tif (rt_bandwidth_enabled()) {\n\t\tstruct rt_rq *rt_rq = &rq->rt;\n\n\t\traw_spin_lock(&rt_rq->rt_runtime_lock);\n\t\t/*\n\t\t * We'll let actual RT tasks worry about the overflow here, we\n\t\t * have our own CBS to keep us inline; only account when RT\n\t\t * bandwidth is relevant.\n\t\t */\n\t\tif (sched_rt_bandwidth_account(rt_rq))\n\t\t\trt_rq->rt_time += delta_exec;\n\t\traw_spin_unlock(&rt_rq->rt_runtime_lock);\n\t}\n}"
  },
  {
    "function_name": "grub_reclaim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1121-1141",
    "snippet": "static u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic u64 grub_reclaim(u64 delta, struct rq *rq, struct sched_dl_entity *dl_se)\n{\n\tu64 u_inact = rq->dl.this_bw - rq->dl.running_bw; /* Utot - Uact */\n\tu64 u_act;\n\tu64 u_act_min = (dl_se->dl_bw * rq->dl.bw_ratio) >> RATIO_SHIFT;\n\n\t/*\n\t * Instead of computing max{u * bw_ratio, (1 - u_inact - u_extra)},\n\t * we compare u_inact + rq->dl.extra_bw with\n\t * 1 - (u * rq->dl.bw_ratio >> RATIO_SHIFT), because\n\t * u_inact + rq->dl.extra_bw can be larger than\n\t * 1 * (so, 1 - u_inact - rq->dl.extra_bw would be negative\n\t * leading to wrong results)\n\t */\n\tif (u_inact + rq->dl.extra_bw > BW_UNIT - u_act_min)\n\t\tu_act = u_act_min;\n\telse\n\t\tu_act = BW_UNIT - u_inact - rq->dl.extra_bw;\n\n\treturn (delta * u_act) >> BW_SHIFT;\n}"
  },
  {
    "function_name": "dl_runtime_exceeded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1094-1098",
    "snippet": "static\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic\nint dl_runtime_exceeded(struct sched_dl_entity *dl_se)\n{\n\treturn (dl_se->runtime <= 0);\n}"
  },
  {
    "function_name": "dl_check_constrained_dl",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1079-1092",
    "snippet": "static inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "dl_se->dl_boosted || !start_dl_timer(p)"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "start_dl_timer",
          "args": [
            "p"
          ],
          "line": 1086
        },
        "resolved": true,
        "details": {
          "function_name": "start_dl_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "888-931",
          "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq_clock(rq)",
            "dl_next_period(dl_se)"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_next_period",
          "args": [
            "dl_se"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "dl_next_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "873-876",
          "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 1085
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 1084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq_of_se(dl_se)"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 1082
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_check_constrained_dl(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq_of_se(dl_se));\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t    dl_time_before(rq_clock(rq), dl_next_period(dl_se))) {\n\t\tif (unlikely(dl_se->dl_boosted || !start_dl_timer(p)))\n\t\t\treturn;\n\t\tdl_se->dl_throttled = 1;\n\t\tif (dl_se->runtime > 0)\n\t\t\tdl_se->runtime = 0;\n\t}\n}"
  },
  {
    "function_name": "init_dl_task_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "1053-1059",
    "snippet": "void init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = dl_task_timer;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "timer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_REL"
          ],
          "line": 1057
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_task_timer(struct sched_dl_entity *dl_se)\n{\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\n\thrtimer_init(timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\ttimer->function = dl_task_timer;\n}"
  },
  {
    "function_name": "dl_task_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "946-1051",
    "snippet": "static enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * The task might have changed its scheduling policy to something\n\t * different than SCHED_DEADLINE (through switched_from_dl()).\n\t */\n\tif (!dl_task(p))\n\t\tgoto unlock;\n\n\t/*\n\t * The task might have been boosted by someone else and might be in the\n\t * boosting/deboosting path, its not throttled.\n\t */\n\tif (dl_se->dl_boosted)\n\t\tgoto unlock;\n\n\t/*\n\t * Spurious timer due to start_dl_timer() race; or we already received\n\t * a replenishment from rt_mutex_setprio().\n\t */\n\tif (!dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * If the throttle happened during sched-out; like:\n\t *\n\t *   schedule()\n\t *     deactivate_task()\n\t *       dequeue_task_dl()\n\t *         update_curr_dl()\n\t *           start_dl_timer()\n\t *         __dequeue_task_dl()\n\t *     prev->on_rq = 0;\n\t *\n\t * We can be both throttled and !queued. Replenish the counter\n\t * but do not enqueue -- wait for our wakeup to do that.\n\t */\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se, dl_se);\n\t\tgoto unlock;\n\t}\n\n#ifdef CONFIG_SMP\n\tif (unlikely(!rq->online)) {\n\t\t/*\n\t\t * If the runqueue is no longer available, migrate the\n\t\t * task elsewhere. This necessarily changes rq.\n\t\t */\n\t\tlockdep_unpin_lock(&rq->lock, rf.cookie);\n\t\trq = dl_task_offline_migration(rq, p);\n\t\trf.cookie = lockdep_pin_lock(&rq->lock);\n\t\tupdate_rq_clock(rq);\n\n\t\t/*\n\t\t * Now that the task has been migrated to the new RQ and we\n\t\t * have that locked, proceed as normal and enqueue the task\n\t\t * there.\n\t\t */\n\t}\n#endif\n\n\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Queueing this task back might have overloaded rq, check if we need\n\t * to kick someone away.\n\t */\n\tif (has_pushable_dl_tasks(rq)) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its safe to drop\n\t\t * rq->lock.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tpush_dl_task(rq);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\n\t/*\n\t * This can free the task_struct, including this hrtimer, do not touch\n\t * anything related to that after this.\n\t */\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 1048
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_unlock",
          "args": [
            "rq",
            "p",
            "&rf"
          ],
          "line": 1042
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1096-1104",
          "snippet": "static inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nvoid __dl_clear_params(struct task_struct *p);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void\ntask_rq_unlock(struct rq *rq, struct task_struct *p, struct rq_flags *rf)\n\t__releases(rq->lock)\n\t__releases(p->pi_lock)\n{\n\trq_unpin_lock(rq, rf);\n\traw_spin_unlock(&rq->lock);\n\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_repin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "rq_repin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1070-1080",
          "snippet": "static inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_repin_lock(struct rq *rq, struct rq_flags *rf)\n{\n\tlockdep_repin_lock(&rq->lock, rf->cookie);\n\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * Restore the value we stashed in @rf for this pin context.\n\t */\n\trq->clock_update_flags |= rf->clock_update_flags;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "push_dl_task",
          "args": [
            "rq"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "push_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2117-2122",
          "snippet": "static void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void push_dl_tasks(struct rq *rq)\n{\n\t/* push_dl_task() will return true if it moved a -deadline task */\n\twhile (push_dl_task(rq))\n\t\t;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_unpin_lock",
          "args": [
            "rq",
            "&rf"
          ],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "rq_unpin_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1060-1068",
          "snippet": "static inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RQCF_UPDATED\t\t0x04",
            "#define RQCF_ACT_SKIP\t\t0x02"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RQCF_UPDATED\t\t0x04\n#define RQCF_ACT_SKIP\t\t0x02\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void rq_unpin_lock(struct rq *rq, struct rq_flags *rf)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\tif (rq->clock_update_flags > RQCF_ACT_SKIP)\n\t\trf->clock_update_flags = RQCF_UPDATED;\n#endif\n\n\tlockdep_unpin_lock(&rq->lock, rf->cookie);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 1030
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "497-500",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      },
      {
        "call_info": {
          "callee": "resched_curr",
          "args": [
            "rq"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "resched_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "452-474",
          "snippet": "void resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid resched_curr(struct rq *rq)\n{\n\tstruct task_struct *curr = rq->curr;\n\tint cpu;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (test_tsk_need_resched(curr))\n\t\treturn;\n\n\tcpu = cpu_of(rq);\n\n\tif (cpu == smp_processor_id()) {\n\t\tset_tsk_need_resched(curr);\n\t\tset_preempt_need_resched();\n\t\treturn;\n\t}\n\n\tif (set_nr_and_not_polling(curr))\n\t\tsmp_send_reschedule(cpu);\n\telse\n\t\ttrace_sched_wake_idle_without_ipi(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_preempt_curr_dl",
          "args": [
            "rq",
            "p",
            "0"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "check_preempt_curr_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1668-1685",
          "snippet": "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p,\n\t\t\t\t  int flags)\n{\n\tif (dl_entity_preempt(&p->dl, &rq->curr->dl)) {\n\t\tresched_curr(rq);\n\t\treturn;\n\t}\n\n#ifdef CONFIG_SMP\n\t/*\n\t * In the unlikely case current and p have the same deadline\n\t * let us try to decide what's the best thing to do...\n\t */\n\tif ((p->dl.deadline == rq->curr->dl.deadline) &&\n\t    !test_tsk_need_resched(rq->curr))\n\t\tcheck_preempt_equal_dl(rq, p);\n#endif /* CONFIG_SMP */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "rq->curr"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_task_dl",
          "args": [
            "rq",
            "p",
            "ENQUEUE_REPLENISH"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_task_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1440-1504",
          "snippet": "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags)\n{\n\tstruct task_struct *pi_task = rt_mutex_get_top_task(p);\n\tstruct sched_dl_entity *pi_se = &p->dl;\n\n\t/*\n\t * Use the scheduling parameters of the top pi-waiter task if:\n\t * - we have a top pi-waiter which is a SCHED_DEADLINE task AND\n\t * - our dl_boosted is set (i.e. the pi-waiter's (absolute) deadline is\n\t *   smaller than our deadline OR we are a !SCHED_DEADLINE task getting\n\t *   boosted due to a SCHED_DEADLINE pi-waiter).\n\t * Otherwise we keep our runtime and deadline.\n\t */\n\tif (pi_task && dl_prio(pi_task->normal_prio) && p->dl.dl_boosted) {\n\t\tpi_se = &pi_task->dl;\n\t} else if (!dl_prio(p->normal_prio)) {\n\t\t/*\n\t\t * Special case in which we have a !SCHED_DEADLINE task\n\t\t * that is going to be deboosted, but exceeds its\n\t\t * runtime while doing so. No point in replenishing\n\t\t * it, as it's going to return back to its original\n\t\t * scheduling class after this.\n\t\t */\n\t\tBUG_ON(!p->dl.dl_boosted || flags != ENQUEUE_REPLENISH);\n\t\treturn;\n\t}\n\n\t/*\n\t * Check if a constrained deadline task was activated\n\t * after the deadline but before the next period.\n\t * If that is the case, the task will be throttled and\n\t * the replenishment timer will be set to the next period.\n\t */\n\tif (!p->dl.dl_throttled && !dl_is_implicit(&p->dl))\n\t\tdl_check_constrained_dl(&p->dl);\n\n\tif (p->on_rq == TASK_ON_RQ_MIGRATING || flags & ENQUEUE_RESTORE) {\n\t\tadd_rq_bw(&p->dl, &rq->dl);\n\t\tadd_running_bw(&p->dl, &rq->dl);\n\t}\n\n\t/*\n\t * If p is throttled, we do not enqueue it. In fact, if it exhausted\n\t * its budget it needs a replenishment and, since it now is on\n\t * its rq, the bandwidth timer callback (which clearly has not\n\t * run yet) will take care of this.\n\t * However, the active utilization does not depend on the fact\n\t * that the task is on the runqueue or not (but depends on the\n\t * task's state - in GRUB parlance, \"inactive\" vs \"active contending\").\n\t * In other words, even if a task is throttled its utilization must\n\t * be counted in the active utilization; hence, we need to call\n\t * add_running_bw().\n\t */\n\tif (p->dl.dl_throttled && !(flags & ENQUEUE_REPLENISH)) {\n\t\tif (flags & ENQUEUE_WAKEUP)\n\t\t\ttask_contending(&p->dl, flags);\n\n\t\treturn;\n\t}\n\n\tenqueue_dl_entity(&p->dl, pi_se, flags);\n\n\tif (!task_current(rq, p) && p->nr_cpus_allowed > 1)\n\t\tenqueue_pushable_dl_task(rq, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_rq_clock",
          "args": [
            "rq"
          ],
          "line": 1009
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_pin_lock",
          "args": [
            "&rq->lock"
          ],
          "line": 1008
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_offline_migration",
          "args": [
            "rq",
            "p"
          ],
          "line": 1007
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_offline_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "530-565",
          "snippet": "static struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, &p->cpus_allowed);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, &p->cpus_allowed);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_unpin_lock",
          "args": [
            "&rq->lock",
            "rf.cookie"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!rq->online"
          ],
          "line": 1001
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "replenish_dl_entity",
          "args": [
            "dl_se",
            "dl_se"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "replenish_dl_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "666-716",
          "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 995
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 978
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "405-420",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq_lock",
          "args": [
            "p",
            "&rf"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "task_rq_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "90-126",
          "snippet": "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock)\n{\n\tstruct rq *rq;\n\n\tfor (;;) {\n\t\traw_spin_lock_irqsave(&p->pi_lock, rf->flags);\n\t\trq = task_rq(p);\n\t\traw_spin_lock(&rq->lock);\n\t\t/*\n\t\t *\tmove_queued_task()\t\ttask_rq_lock()\n\t\t *\n\t\t *\tACQUIRE (rq->lock)\n\t\t *\t[S] ->on_rq = MIGRATING\t\t[L] rq = task_rq()\n\t\t *\tWMB (__set_task_cpu())\t\tACQUIRE (rq->lock);\n\t\t *\t[S] ->cpu = new_cpu\t\t[L] task_rq()\n\t\t *\t\t\t\t\t[L] ->on_rq\n\t\t *\tRELEASE (rq->lock)\n\t\t *\n\t\t * If we observe the old CPU in task_rq_lock, the acquire of\n\t\t * the old rq->lock will fully serialize against the stores.\n\t\t *\n\t\t * If we observe the new CPU in task_rq_lock, the acquire will\n\t\t * pair with the WMB to ensure we must then also see migrating.\n\t\t */\n\t\tif (likely(rq == task_rq(p) && !task_on_rq_migrating(p))) {\n\t\t\trq_pin_lock(rq, rf);\n\t\t\treturn rq;\n\t\t}\n\t\traw_spin_unlock(&rq->lock);\n\t\traw_spin_unlock_irqrestore(&p->pi_lock, rf->flags);\n\n\t\twhile (unlikely(task_on_rq_migrating(p)))\n\t\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "timer",
            "structsched_dl_entity",
            "dl_timer"
          ],
          "line": 948
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic enum hrtimer_restart dl_task_timer(struct hrtimer *timer)\n{\n\tstruct sched_dl_entity *dl_se = container_of(timer,\n\t\t\t\t\t\t     struct sched_dl_entity,\n\t\t\t\t\t\t     dl_timer);\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq_flags rf;\n\tstruct rq *rq;\n\n\trq = task_rq_lock(p, &rf);\n\n\t/*\n\t * The task might have changed its scheduling policy to something\n\t * different than SCHED_DEADLINE (through switched_from_dl()).\n\t */\n\tif (!dl_task(p))\n\t\tgoto unlock;\n\n\t/*\n\t * The task might have been boosted by someone else and might be in the\n\t * boosting/deboosting path, its not throttled.\n\t */\n\tif (dl_se->dl_boosted)\n\t\tgoto unlock;\n\n\t/*\n\t * Spurious timer due to start_dl_timer() race; or we already received\n\t * a replenishment from rt_mutex_setprio().\n\t */\n\tif (!dl_se->dl_throttled)\n\t\tgoto unlock;\n\n\tsched_clock_tick();\n\tupdate_rq_clock(rq);\n\n\t/*\n\t * If the throttle happened during sched-out; like:\n\t *\n\t *   schedule()\n\t *     deactivate_task()\n\t *       dequeue_task_dl()\n\t *         update_curr_dl()\n\t *           start_dl_timer()\n\t *         __dequeue_task_dl()\n\t *     prev->on_rq = 0;\n\t *\n\t * We can be both throttled and !queued. Replenish the counter\n\t * but do not enqueue -- wait for our wakeup to do that.\n\t */\n\tif (!task_on_rq_queued(p)) {\n\t\treplenish_dl_entity(dl_se, dl_se);\n\t\tgoto unlock;\n\t}\n\n#ifdef CONFIG_SMP\n\tif (unlikely(!rq->online)) {\n\t\t/*\n\t\t * If the runqueue is no longer available, migrate the\n\t\t * task elsewhere. This necessarily changes rq.\n\t\t */\n\t\tlockdep_unpin_lock(&rq->lock, rf.cookie);\n\t\trq = dl_task_offline_migration(rq, p);\n\t\trf.cookie = lockdep_pin_lock(&rq->lock);\n\t\tupdate_rq_clock(rq);\n\n\t\t/*\n\t\t * Now that the task has been migrated to the new RQ and we\n\t\t * have that locked, proceed as normal and enqueue the task\n\t\t * there.\n\t\t */\n\t}\n#endif\n\n\tenqueue_task_dl(rq, p, ENQUEUE_REPLENISH);\n\tif (dl_task(rq->curr))\n\t\tcheck_preempt_curr_dl(rq, p, 0);\n\telse\n\t\tresched_curr(rq);\n\n#ifdef CONFIG_SMP\n\t/*\n\t * Queueing this task back might have overloaded rq, check if we need\n\t * to kick someone away.\n\t */\n\tif (has_pushable_dl_tasks(rq)) {\n\t\t/*\n\t\t * Nothing relies on rq->lock after this, so its safe to drop\n\t\t * rq->lock.\n\t\t */\n\t\trq_unpin_lock(rq, &rf);\n\t\tpush_dl_task(rq);\n\t\trq_repin_lock(rq, &rf);\n\t}\n#endif\n\nunlock:\n\ttask_rq_unlock(rq, p, &rf);\n\n\t/*\n\t * This can free the task_struct, including this hrtimer, do not touch\n\t * anything related to that after this.\n\t */\n\tput_task_struct(p);\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "start_dl_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "888-931",
    "snippet": "static int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "act",
            "HRTIMER_MODE_ABS"
          ],
          "line": 927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "timer"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_us_delta",
          "args": [
            "act",
            "now"
          ],
          "line": 913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_ns",
          "args": [
            "act",
            "delta"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 905
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_to_ns",
          "args": [
            "now"
          ],
          "line": 905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_cb_get_time",
          "args": [
            "timer"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "dl_next_period(dl_se)"
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_next_period",
          "args": [
            "dl_se"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "dl_next_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "873-876",
          "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&rq->lock"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 892
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic int start_dl_timer(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->dl_timer;\n\tstruct rq *rq = task_rq(p);\n\tktime_t now, act;\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\t/*\n\t * We want the timer to fire at the deadline, but considering\n\t * that it is actually coming from rq->clock and not from\n\t * hrtimer's time base reading.\n\t */\n\tact = ns_to_ktime(dl_next_period(dl_se));\n\tnow = hrtimer_cb_get_time(timer);\n\tdelta = ktime_to_ns(now) - rq_clock(rq);\n\tact = ktime_add_ns(act, delta);\n\n\t/*\n\t * If the expiry time already passed, e.g., because the value\n\t * chosen as the deadline is too small, don't even try to\n\t * start the timer in the past!\n\t */\n\tif (ktime_us_delta(act, now) < 0)\n\t\treturn 0;\n\n\t/*\n\t * !enqueued will guarantee another callback; even if one is already in\n\t * progress. This ensures a balanced {get,put}_task_struct().\n\t *\n\t * The race against __run_timer() clearing the enqueued state is\n\t * harmless because we're holding task_rq()->lock, therefore the timer\n\t * expiring after we've done the check will wait on its task_rq_lock()\n\t * and observe our state.\n\t */\n\tif (!hrtimer_is_queued(timer)) {\n\t\tget_task_struct(p);\n\t\thrtimer_start(timer, act, HRTIMER_MODE_ABS);\n\t}\n\n\treturn 1;\n}"
  },
  {
    "function_name": "dl_next_period",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "873-876",
    "snippet": "static inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline u64 dl_next_period(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->deadline - dl_se->dl_deadline + dl_se->dl_period;\n}"
  },
  {
    "function_name": "update_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "852-871",
    "snippet": "static void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !dl_se->dl_boosted)){\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 868
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_dl_revised_wakeup",
          "args": [
            "dl_se",
            "rq"
          ],
          "line": 864
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_revised_wakeup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "790-804",
          "snippet": "static void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !dl_se->dl_boosted"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_is_implicit",
          "args": [
            "dl_se"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "dl_is_implicit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "817-820",
          "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_overflow",
          "args": [
            "dl_se",
            "pi_se",
            "rq_clock(rq)"
          ],
          "line": 859
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_overflow",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "742-770",
          "snippet": "static bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_se->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_se->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_se->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_se->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void update_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t     struct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq)) ||\n\t    dl_entity_overflow(dl_se, pi_se, rq_clock(rq))) {\n\n\t\tif (unlikely(!dl_is_implicit(dl_se) &&\n\t\t\t     !dl_time_before(dl_se->deadline, rq_clock(rq)) &&\n\t\t\t     !dl_se->dl_boosted)){\n\t\t\tupdate_dl_revised_wakeup(dl_se, rq);\n\t\t\treturn;\n\t\t}\n\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n}"
  },
  {
    "function_name": "dl_is_implicit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "817-820",
    "snippet": "static inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool dl_is_implicit(struct sched_dl_entity *dl_se)\n{\n\treturn dl_se->dl_deadline == dl_se->dl_period;\n}"
  },
  {
    "function_name": "update_dl_revised_wakeup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "790-804",
    "snippet": "static void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_time_before(dl_se->deadline, rq_clock(rq))"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void\nupdate_dl_revised_wakeup(struct sched_dl_entity *dl_se, struct rq *rq)\n{\n\tu64 laxity = dl_se->deadline - rq_clock(rq);\n\n\t/*\n\t * If the task has deadline < period, and the deadline is in the past,\n\t * it should already be throttled before this check.\n\t *\n\t * See update_dl_entity() comments for further details.\n\t */\n\tWARN_ON(dl_time_before(dl_se->deadline, rq_clock(rq)));\n\n\tdl_se->runtime = (dl_se->dl_density * laxity) >> BW_SHIFT;\n}"
  },
  {
    "function_name": "dl_entity_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "742-770",
    "snippet": "static bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_se->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_se->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "right",
            "left"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic bool dl_entity_overflow(struct sched_dl_entity *dl_se,\n\t\t\t       struct sched_dl_entity *pi_se, u64 t)\n{\n\tu64 left, right;\n\n\t/*\n\t * left and right are the two sides of the equation above,\n\t * after a bit of shuffling to use multiplications instead\n\t * of divisions.\n\t *\n\t * Note that none of the time values involved in the two\n\t * multiplications are absolute: dl_deadline and dl_runtime\n\t * are the relative deadline and the maximum runtime of each\n\t * instance, runtime is the runtime left for the last instance\n\t * and (deadline - t), since t is rq->clock, is the time left\n\t * to the (absolute) deadline. Even if overflowing the u64 type\n\t * is very unlikely to occur in both cases, here we scale down\n\t * as we want to avoid that risk at all. Scaling down by 10\n\t * means that we reduce granularity to 1us. We are fine with it,\n\t * since this is only a true/false check and, anyway, thinking\n\t * of anything below microseconds resolution is actually fiction\n\t * (but still we want to give the user that illusion >;).\n\t */\n\tleft = (pi_se->dl_deadline >> DL_SCALE) * (dl_se->runtime >> DL_SCALE);\n\tright = ((dl_se->deadline - t) >> DL_SCALE) *\n\t\t(pi_se->dl_runtime >> DL_SCALE);\n\n\treturn dl_time_before(right, left);\n}"
  },
  {
    "function_name": "replenish_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "666-716",
    "snippet": "static void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 708
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred_once",
          "args": [
            "\"sched: DL replenish lagged too much\\n\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "dl_se->deadline",
            "rq_clock(rq)"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "pi_se->dl_runtime <= 0"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 669
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void replenish_dl_entity(struct sched_dl_entity *dl_se,\n\t\t\t\tstruct sched_dl_entity *pi_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tBUG_ON(pi_se->dl_runtime <= 0);\n\n\t/*\n\t * This could be the case for a !-dl task that is boosted.\n\t * Just go with full inherited parameters.\n\t */\n\tif (dl_se->dl_deadline == 0) {\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded && dl_se->runtime > 0)\n\t\tdl_se->runtime = 0;\n\n\t/*\n\t * We keep moving the deadline away until we get some\n\t * available runtime for the entity. This ensures correct\n\t * handling of situations where the runtime overrun is\n\t * arbitrary large.\n\t */\n\twhile (dl_se->runtime <= 0) {\n\t\tdl_se->deadline += pi_se->dl_period;\n\t\tdl_se->runtime += pi_se->dl_runtime;\n\t}\n\n\t/*\n\t * At this point, the deadline really should be \"in\n\t * the future\" with respect to rq->clock. If it's\n\t * not, we are, for some reason, lagging too much!\n\t * Anyway, after having warn userspace abut that,\n\t * we still try to keep the things running by\n\t * resetting the deadline and the budget of the\n\t * entity.\n\t */\n\tif (dl_time_before(dl_se->deadline, rq_clock(rq))) {\n\t\tprintk_deferred_once(\"sched: DL replenish lagged too much\\n\");\n\t\tdl_se->deadline = rq_clock(rq) + pi_se->dl_deadline;\n\t\tdl_se->runtime = pi_se->dl_runtime;\n\t}\n\n\tif (dl_se->dl_yielded)\n\t\tdl_se->dl_yielded = 0;\n\tif (dl_se->dl_throttled)\n\t\tdl_se->dl_throttled = 0;\n}"
  },
  {
    "function_name": "setup_new_dl_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "623-646",
    "snippet": "static inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(dl_se->dl_boosted);\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_time_before(rq_clock(rq), dl_se->deadline)"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_time_before",
          "args": [
            "rq_clock(rq)",
            "dl_se->deadline"
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_se->dl_boosted"
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 625
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void setup_new_dl_entity(struct sched_dl_entity *dl_se)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\n\tWARN_ON(dl_se->dl_boosted);\n\tWARN_ON(dl_time_before(rq_clock(rq), dl_se->deadline));\n\n\t/*\n\t * We are racing with the deadline timer. So, do nothing because\n\t * the deadline timer handler will take care of properly recharging\n\t * the runtime and postponing the deadline\n\t */\n\tif (dl_se->dl_throttled)\n\t\treturn;\n\n\t/*\n\t * We use the regular wall clock time to set deadlines in the\n\t * future; in fact, we must consider execution overheads (time\n\t * spent on hardirq context, etc.).\n\t */\n\tdl_se->deadline = rq_clock(rq) + dl_se->dl_deadline;\n\tdl_se->runtime = dl_se->dl_runtime;\n}"
  },
  {
    "function_name": "deadline_queue_pull_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "602-604",
    "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "deadline_queue_push_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "598-600",
    "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "pull_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "594-596",
    "snippet": "static inline void pull_dl_task(struct rq *rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void pull_dl_task(struct rq *rq)\n{\n}"
  },
  {
    "function_name": "need_pull_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "589-592",
    "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn false;\n}"
  },
  {
    "function_name": "dec_dl_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "584-587",
    "snippet": "static inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
  },
  {
    "function_name": "inc_dl_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "579-582",
    "snippet": "static inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n}"
  },
  {
    "function_name": "dequeue_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "574-577",
    "snippet": "static inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "enqueue_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "569-572",
    "snippet": "static inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n}"
  },
  {
    "function_name": "dl_task_offline_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "530-565",
    "snippet": "static struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, &p->cpus_allowed);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "double_unlock_balance",
          "args": [
            "later_rq",
            "rq"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "double_unlock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1949-1954",
          "snippet": "static inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void double_unlock_balance(struct rq *this_rq, struct rq *busiest)\n\t__releases(busiest->lock)\n{\n\traw_spin_unlock(&busiest->lock);\n\tlock_set_subclass(&this_rq->lock.dep_map, 0, _RET_IP_);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_task_cpu",
          "args": [
            "p",
            "later_rq->cpu"
          ],
          "line": 561
        },
        "resolved": true,
        "details": {
          "function_name": "set_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1132-1182",
          "snippet": "void set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid set_task_cpu(struct task_struct *p, unsigned int new_cpu)\n{\n#ifdef CONFIG_SCHED_DEBUG\n\t/*\n\t * We should never call set_task_cpu() on a blocked task,\n\t * ttwu() will sort out the placement.\n\t */\n\tWARN_ON_ONCE(p->state != TASK_RUNNING && p->state != TASK_WAKING &&\n\t\t\t!p->on_rq);\n\n\t/*\n\t * Migrating fair class task must have p->on_rq = TASK_ON_RQ_MIGRATING,\n\t * because schedstat_wait_{start,end} rebase migrating task's wait_start\n\t * time relying on p->on_rq.\n\t */\n\tWARN_ON_ONCE(p->state == TASK_RUNNING &&\n\t\t     p->sched_class == &fair_sched_class &&\n\t\t     (p->on_rq && !task_on_rq_migrating(p)));\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * The caller should hold either p->pi_lock or rq->lock, when changing\n\t * a task's CPU. ->pi_lock for waking tasks, rq->lock for runnable tasks.\n\t *\n\t * sched_move_task() holds both and thus holding either pins the cgroup,\n\t * see task_group().\n\t *\n\t * Furthermore, all task_rq users should acquire both locks, see\n\t * task_rq_lock().\n\t */\n\tWARN_ON_ONCE(debug_locks && !(lockdep_is_held(&p->pi_lock) ||\n\t\t\t\t      lockdep_is_held(&task_rq(p)->lock)));\n#endif\n\t/*\n\t * Clearly, migrating tasks to offline CPUs is a fairly daft thing.\n\t */\n\tWARN_ON_ONCE(!cpu_online(new_cpu));\n#endif\n\n\ttrace_sched_migrate_task(p, new_cpu);\n\n\tif (task_cpu(p) != new_cpu) {\n\t\tif (p->sched_class->migrate_task_rq)\n\t\t\tp->sched_class->migrate_task_rq(p, new_cpu);\n\t\tp->se.nr_migrations++;\n\t\trseq_migrate(p);\n\t\tperf_event_task_migrate(p);\n\t}\n\n\t__set_task_cpu(p, new_cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "double_lock_balance",
          "args": [
            "rq",
            "later_rq"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "double_lock_balance",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1938-1947",
          "snippet": "static inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void calc_global_load_tick(struct rq *this_rq);",
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void calc_global_load_tick(struct rq *this_rq);\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline int double_lock_balance(struct rq *this_rq, struct rq *busiest)\n{\n\tif (unlikely(!irqs_disabled())) {\n\t\t/* printk() doesn't work well under rq->lock */\n\t\traw_spin_unlock(&this_rq->lock);\n\t\tBUG_ON(1);\n\t}\n\n\treturn _double_lock_balance(this_rq, busiest);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "cpu"
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_any",
          "args": [
            "cpu_active_mask"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "dl_bandwidth_enabled()"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_bandwidth_enabled",
          "args": [],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bandwidth_enabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "273-276",
          "snippet": "static inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline int dl_bandwidth_enabled(void)\n{\n\treturn sysctl_sched_rt_runtime >= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_any_and",
          "args": [
            "cpu_active_mask",
            "&p->cpus_allowed"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_lock_later_rq",
          "args": [
            "p",
            "rq"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "find_lock_later_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "1948-2003",
          "snippet": "static struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define DL_MAX_TRIES 3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\n#define DL_MAX_TRIES 3\n\nstatic struct rq *find_lock_later_rq(struct task_struct *task, struct rq *rq)\n{\n\tstruct rq *later_rq = NULL;\n\tint tries;\n\tint cpu;\n\n\tfor (tries = 0; tries < DL_MAX_TRIES; tries++) {\n\t\tcpu = find_later_rq(task);\n\n\t\tif ((cpu == -1) || (cpu == rq->cpu))\n\t\t\tbreak;\n\n\t\tlater_rq = cpu_rq(cpu);\n\n\t\tif (later_rq->dl.dl_nr_running &&\n\t\t    !dl_time_before(task->dl.deadline,\n\t\t\t\t\tlater_rq->dl.earliest_dl.curr)) {\n\t\t\t/*\n\t\t\t * Target rq has tasks of equal or earlier deadline,\n\t\t\t * retrying does not release any lock and is unlikely\n\t\t\t * to yield a different result.\n\t\t\t */\n\t\t\tlater_rq = NULL;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Retry if something changed. */\n\t\tif (double_lock_balance(rq, later_rq)) {\n\t\t\tif (unlikely(task_rq(task) != rq ||\n\t\t\t\t     !cpumask_test_cpu(later_rq->cpu, &task->cpus_allowed) ||\n\t\t\t\t     task_running(rq, task) ||\n\t\t\t\t     !dl_task(task) ||\n\t\t\t\t     !task_on_rq_queued(task))) {\n\t\t\t\tdouble_unlock_balance(rq, later_rq);\n\t\t\t\tlater_rq = NULL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the rq we found has no -deadline task, or\n\t\t * its earliest one has a later deadline than our\n\t\t * task, the rq is a good one.\n\t\t */\n\t\tif (!later_rq->dl.dl_nr_running ||\n\t\t    dl_time_before(task->dl.deadline,\n\t\t\t\t   later_rq->dl.earliest_dl.curr))\n\t\t\tbreak;\n\n\t\t/* Otherwise we try again. */\n\t\tdouble_unlock_balance(rq, later_rq);\n\t\tlater_rq = NULL;\n\t}\n\n\treturn later_rq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic struct rq *dl_task_offline_migration(struct rq *rq, struct task_struct *p)\n{\n\tstruct rq *later_rq = NULL;\n\n\tlater_rq = find_lock_later_rq(p, rq);\n\tif (!later_rq) {\n\t\tint cpu;\n\n\t\t/*\n\t\t * If we cannot preempt any rq, fall back to pick any\n\t\t * online CPU:\n\t\t */\n\t\tcpu = cpumask_any_and(cpu_active_mask, &p->cpus_allowed);\n\t\tif (cpu >= nr_cpu_ids) {\n\t\t\t/*\n\t\t\t * Failed to find any suitable CPU.\n\t\t\t * The task will never come back!\n\t\t\t */\n\t\t\tBUG_ON(dl_bandwidth_enabled());\n\n\t\t\t/*\n\t\t\t * If admission control is disabled we\n\t\t\t * try a little harder to let the task\n\t\t\t * run.\n\t\t\t */\n\t\t\tcpu = cpumask_any(cpu_active_mask);\n\t\t}\n\t\tlater_rq = cpu_rq(cpu);\n\t\tdouble_lock_balance(rq, later_rq);\n\t}\n\n\tset_task_cpu(p, later_rq->cpu);\n\tdouble_unlock_balance(later_rq, rq);\n\n\treturn later_rq;\n}"
  },
  {
    "function_name": "deadline_queue_pull_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "523-526",
    "snippet": "static inline void deadline_queue_pull_task(struct rq *rq)\n{\n\tqueue_balance_callback(rq, &per_cpu(dl_pull_head, rq->cpu), pull_dl_task);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_balance_callback",
          "args": [
            "rq",
            "&per_cpu(dl_pull_head, rq->cpu)",
            "pull_dl_task"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "queue_balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1217-1230",
          "snippet": "static inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tif (unlikely(head->next))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tif (unlikely(head->next))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "dl_pull_head",
            "rq->cpu"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_pull_task(struct rq *rq)\n{\n\tqueue_balance_callback(rq, &per_cpu(dl_pull_head, rq->cpu), pull_dl_task);\n}"
  },
  {
    "function_name": "deadline_queue_push_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "515-521",
    "snippet": "static inline void deadline_queue_push_tasks(struct rq *rq)\n{\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(dl_push_head, rq->cpu), push_dl_tasks);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_balance_callback",
          "args": [
            "rq",
            "&per_cpu(dl_push_head, rq->cpu)",
            "push_dl_tasks"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "queue_balance_callback",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1217-1230",
          "snippet": "static inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tif (unlikely(head->next))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "struct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);",
            "struct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nstruct rq *__task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(rq->lock);\nstruct rq *task_rq_lock(struct task_struct *p, struct rq_flags *rf)\n\t__acquires(p->pi_lock)\n\t__acquires(rq->lock);\nextern void resched_curr(struct rq *rq);\n\nstatic inline void\nqueue_balance_callback(struct rq *rq,\n\t\t       struct callback_head *head,\n\t\t       void (*func)(struct rq *rq))\n{\n\tlockdep_assert_held(&rq->lock);\n\n\tif (unlikely(head->next))\n\t\treturn;\n\n\thead->func = (void (*)(struct callback_head *))func;\n\thead->next = rq->balance_callback;\n\trq->balance_callback = head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "dl_push_head",
            "rq->cpu"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_pushable_dl_tasks",
          "args": [
            "rq"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "has_pushable_dl_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "497-500",
          "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void deadline_queue_push_tasks(struct rq *rq)\n{\n\tif (!has_pushable_dl_tasks(rq))\n\t\treturn;\n\n\tqueue_balance_callback(rq, &per_cpu(dl_push_head, rq->cpu), push_dl_tasks);\n}"
  },
  {
    "function_name": "need_pull_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "504-507",
    "snippet": "static inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn dl_task(prev);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "prev"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline bool need_pull_dl_task(struct rq *rq, struct task_struct *prev)\n{\n\treturn dl_task(prev);\n}"
  },
  {
    "function_name": "has_pushable_dl_tasks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "497-500",
    "snippet": "static inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_ROOT",
          "args": [
            "&rq->dl.pushable_dl_tasks_root.rb_root"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int has_pushable_dl_tasks(struct rq *rq)\n{\n\treturn !RB_EMPTY_ROOT(&rq->dl.pushable_dl_tasks_root.rb_root);\n}"
  },
  {
    "function_name": "dequeue_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "476-495",
    "snippet": "static void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tif (dl_rq->pushable_dl_tasks_root.rb_leftmost == &p->pushable_dl_tasks) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&p->pushable_dl_tasks);\n\t\tif (next_node) {\n\t\t\tdl_rq->earliest_dl.next = rb_entry(next_node,\n\t\t\t\tstruct task_struct, pushable_dl_tasks)->dl.deadline;\n\t\t}\n\t}\n\n\trb_erase_cached(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_CLEAR_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_erase_cached",
          "args": [
            "&p->pushable_dl_tasks",
            "&dl_rq->pushable_dl_tasks_root"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "next_node",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_next",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dequeue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\n\tif (RB_EMPTY_NODE(&p->pushable_dl_tasks))\n\t\treturn;\n\n\tif (dl_rq->pushable_dl_tasks_root.rb_leftmost == &p->pushable_dl_tasks) {\n\t\tstruct rb_node *next_node;\n\n\t\tnext_node = rb_next(&p->pushable_dl_tasks);\n\t\tif (next_node) {\n\t\t\tdl_rq->earliest_dl.next = rb_entry(next_node,\n\t\t\t\tstruct task_struct, pushable_dl_tasks)->dl.deadline;\n\t\t}\n\t}\n\n\trb_erase_cached(&p->pushable_dl_tasks, &dl_rq->pushable_dl_tasks_root);\n\tRB_CLEAR_NODE(&p->pushable_dl_tasks);\n}"
  },
  {
    "function_name": "enqueue_pushable_dl_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "446-474",
    "snippet": "static void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_node **link = &dl_rq->pushable_dl_tasks_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct task_struct *entry;\n\tbool leftmost = true;\n\n\tBUG_ON(!RB_EMPTY_NODE(&p->pushable_dl_tasks));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct task_struct,\n\t\t\t\t pushable_dl_tasks);\n\t\tif (dl_entity_preempt(&p->dl, &entry->dl))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->earliest_dl.next = p->dl.deadline;\n\n\trb_link_node(&p->pushable_dl_tasks, parent, link);\n\trb_insert_color_cached(&p->pushable_dl_tasks,\n\t\t\t       &dl_rq->pushable_dl_tasks_root, leftmost);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rb_insert_color_cached",
          "args": [
            "&p->pushable_dl_tasks",
            "&dl_rq->pushable_dl_tasks_root",
            "leftmost"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rb_link_node",
          "args": [
            "&p->pushable_dl_tasks",
            "parent",
            "link"
          ],
          "line": 471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_entity_preempt",
          "args": [
            "&p->dl",
            "&entry->dl"
          ],
          "line": 460
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_preempt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "217-222",
          "snippet": "static inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline bool\ndl_entity_preempt(struct sched_dl_entity *a, struct sched_dl_entity *b)\n{\n\treturn dl_entity_is_special(a) ||\n\t       dl_time_before(a->deadline, b->deadline);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rb_entry",
          "args": [
            "parent",
            "structtask_struct",
            "pushable_dl_tasks"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!RB_EMPTY_NODE(&p->pushable_dl_tasks)"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&p->pushable_dl_tasks"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_pushable_dl_task(struct rq *rq, struct task_struct *p)\n{\n\tstruct dl_rq *dl_rq = &rq->dl;\n\tstruct rb_node **link = &dl_rq->pushable_dl_tasks_root.rb_root.rb_node;\n\tstruct rb_node *parent = NULL;\n\tstruct task_struct *entry;\n\tbool leftmost = true;\n\n\tBUG_ON(!RB_EMPTY_NODE(&p->pushable_dl_tasks));\n\n\twhile (*link) {\n\t\tparent = *link;\n\t\tentry = rb_entry(parent, struct task_struct,\n\t\t\t\t pushable_dl_tasks);\n\t\tif (dl_entity_preempt(&p->dl, &entry->dl))\n\t\t\tlink = &parent->rb_left;\n\t\telse {\n\t\t\tlink = &parent->rb_right;\n\t\t\tleftmost = false;\n\t\t}\n\t}\n\n\tif (leftmost)\n\t\tdl_rq->earliest_dl.next = p->dl.deadline;\n\n\trb_link_node(&p->pushable_dl_tasks, parent, link);\n\trb_insert_color_cached(&p->pushable_dl_tasks,\n\t\t\t       &dl_rq->pushable_dl_tasks_root, leftmost);\n}"
  },
  {
    "function_name": "dec_dl_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "432-440",
    "snippet": "static void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_migration",
          "args": [
            "dl_rq"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "409-420",
          "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void dec_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory--;\n\n\tupdate_dl_migration(dl_rq);\n}"
  },
  {
    "function_name": "inc_dl_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "422-430",
    "snippet": "static void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_dl_migration",
          "args": [
            "dl_rq"
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "update_dl_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "409-420",
          "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 424
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void inc_dl_migration(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\n\tif (p->nr_cpus_allowed > 1)\n\t\tdl_rq->dl_nr_migratory++;\n\n\tupdate_dl_migration(dl_rq);\n}"
  },
  {
    "function_name": "update_dl_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "409-420",
    "snippet": "static void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dl_clear_overload",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "dl_clear_overload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "400-407",
          "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_set_overload",
          "args": [
            "rq_of_dl_rq(dl_rq)"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "dl_set_overload",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "384-398",
          "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void update_dl_migration(struct dl_rq *dl_rq)\n{\n\tif (dl_rq->dl_nr_migratory && dl_rq->dl_nr_running > 1) {\n\t\tif (!dl_rq->overloaded) {\n\t\t\tdl_set_overload(rq_of_dl_rq(dl_rq));\n\t\t\tdl_rq->overloaded = 1;\n\t\t}\n\t} else if (dl_rq->overloaded) {\n\t\tdl_clear_overload(rq_of_dl_rq(dl_rq));\n\t\tdl_rq->overloaded = 0;\n\t}\n}"
  },
  {
    "function_name": "dl_clear_overload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "400-407",
    "snippet": "static inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpumask_clear_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->dlo_mask"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_clear_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tatomic_dec(&rq->rd->dlo_count);\n\tcpumask_clear_cpu(rq->cpu, rq->rd->dlo_mask);\n}"
  },
  {
    "function_name": "dl_set_overload",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "384-398",
    "snippet": "static inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_set_cpu",
          "args": [
            "rq->cpu",
            "rq->rd->dlo_mask"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline void dl_set_overload(struct rq *rq)\n{\n\tif (!rq->online)\n\t\treturn;\n\n\tcpumask_set_cpu(rq->cpu, rq->rd->dlo_mask);\n\t/*\n\t * Must be visible before the overload count is\n\t * set (as in sched_rt.c).\n\t *\n\t * Matched by the barrier in pull_dl_task().\n\t */\n\tsmp_wmb();\n\tatomic_inc(&rq->rd->dlo_count);\n}"
  },
  {
    "function_name": "dl_overloaded",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "379-382",
    "snippet": "static inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&rq->rd->dlo_count"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_overloaded(struct rq *rq)\n{\n\treturn atomic_read(&rq->rd->dlo_count);\n}"
  },
  {
    "function_name": "init_dl_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "357-375",
    "snippet": "void init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->root = RB_ROOT_CACHED;\n\n#ifdef CONFIG_SMP\n\t/* zero means no -deadline tasks */\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n\n\tdl_rq->running_bw = 0;\n\tdl_rq->this_bw = 0;\n\tinit_dl_rq_bw_ratio(dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_dl_rq_bw_ratio",
          "args": [
            "dl_rq"
          ],
          "line": 374
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_rq_bw_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2465-2476",
          "snippet": "void init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_rq_bw_ratio(struct dl_rq *dl_rq)\n{\n\tif (global_rt_runtime() == RUNTIME_INF) {\n\t\tdl_rq->bw_ratio = 1 << RATIO_SHIFT;\n\t\tdl_rq->extra_bw = 1 << BW_SHIFT;\n\t} else {\n\t\tdl_rq->bw_ratio = to_ratio(global_rt_runtime(),\n\t\t\t  global_rt_period()) >> (BW_SHIFT - RATIO_SHIFT);\n\t\tdl_rq->extra_bw = to_ratio(global_rt_period(),\n\t\t\t\t\t\t    global_rt_runtime());\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_dl_bw",
          "args": [
            "&dl_rq->dl_bw"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "init_dl_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "345-355",
          "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "struct dl_bandwidth def_dl_bandwidth;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_rq(struct dl_rq *dl_rq)\n{\n\tdl_rq->root = RB_ROOT_CACHED;\n\n#ifdef CONFIG_SMP\n\t/* zero means no -deadline tasks */\n\tdl_rq->earliest_dl.curr = dl_rq->earliest_dl.next = 0;\n\n\tdl_rq->dl_nr_migratory = 0;\n\tdl_rq->overloaded = 0;\n\tdl_rq->pushable_dl_tasks_root = RB_ROOT_CACHED;\n#else\n\tinit_dl_bw(&dl_rq->dl_bw);\n#endif\n\n\tdl_rq->running_bw = 0;\n\tdl_rq->this_bw = 0;\n\tinit_dl_rq_bw_ratio(dl_rq);\n}"
  },
  {
    "function_name": "init_dl_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "345-355",
    "snippet": "void init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "struct dl_bandwidth def_dl_bandwidth;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&def_dl_bandwidth.dl_runtime_lock"
          ],
          "line": 353
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_ratio",
          "args": [
            "global_rt_period()",
            "global_rt_runtime()"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "to_ratio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2377-2391",
          "snippet": "unsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nunsigned long to_ratio(u64 period, u64 runtime)\n{\n\tif (runtime == RUNTIME_INF)\n\t\treturn BW_UNIT;\n\n\t/*\n\t * Doing this here saves a lot of checks in all\n\t * the calling paths, and returning zero seems\n\t * safe for them anyway.\n\t */\n\tif (period == 0)\n\t\treturn 0;\n\n\treturn div64_u64(runtime << BW_SHIFT, period);\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_runtime",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1513-1519",
          "snippet": "static inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define RUNTIME_INF\t\t((u64)~0ULL)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define RUNTIME_INF\t\t((u64)~0ULL)\n\nstatic inline u64 global_rt_runtime(void)\n{\n\tif (sysctl_sched_rt_runtime < 0)\n\t\treturn RUNTIME_INF;\n\n\treturn (u64)sysctl_sched_rt_runtime * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "global_rt_period",
          "args": [],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "global_rt_period",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1508-1511",
          "snippet": "static inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline u64 global_rt_period(void)\n{\n\treturn (u64)sysctl_sched_rt_period * NSEC_PER_USEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&def_dl_bandwidth.dl_runtime_lock"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&dl_b->lock"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstruct dl_bandwidth def_dl_bandwidth;\n\nvoid init_dl_bw(struct dl_bw *dl_b)\n{\n\traw_spin_lock_init(&dl_b->lock);\n\traw_spin_lock(&def_dl_bandwidth.dl_runtime_lock);\n\tif (global_rt_runtime() == RUNTIME_INF)\n\t\tdl_b->bw = -1;\n\telse\n\t\tdl_b->bw = to_ratio(global_rt_period(), global_rt_runtime());\n\traw_spin_unlock(&def_dl_bandwidth.dl_runtime_lock);\n\tdl_b->total_bw = 0;\n}"
  },
  {
    "function_name": "init_dl_bandwidth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "338-343",
    "snippet": "void init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&dl_b->dl_runtime_lock"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nvoid init_dl_bandwidth(struct dl_bandwidth *dl_b, u64 period, u64 runtime)\n{\n\traw_spin_lock_init(&dl_b->dl_runtime_lock);\n\tdl_b->dl_period = period;\n\tdl_b->dl_runtime = runtime;\n}"
  },
  {
    "function_name": "is_leftmost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "331-336",
    "snippet": "static inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int is_leftmost(struct task_struct *p, struct dl_rq *dl_rq)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\treturn dl_rq->root.rb_leftmost == &dl_se->rb_node;\n}"
  },
  {
    "function_name": "task_contending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "294-329",
    "snippet": "static void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_running_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "add_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "142-147",
          "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "dl_task_of(dl_se)"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&dl_se->inactive_timer"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_rq_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 306
        },
        "resolved": true,
        "details": {
          "function_name": "add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "128-133",
          "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 296
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nstatic void task_contending(struct sched_dl_entity *dl_se, int flags)\n{\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (flags & ENQUEUE_MIGRATED)\n\t\tadd_rq_bw(dl_se, dl_rq);\n\n\tif (dl_se->dl_non_contending) {\n\t\tdl_se->dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&dl_se->inactive_timer) == 1)\n\t\t\tput_task_struct(dl_task_of(dl_se));\n\t} else {\n\t\t/*\n\t\t * Since \"dl_non_contending\" is not set, the\n\t\t * task's utilization has already been removed from\n\t\t * active utilization (either when the task blocked,\n\t\t * when the \"inactive timer\" fired).\n\t\t * So, add it back.\n\t\t */\n\t\tadd_running_bw(dl_se, dl_rq);\n\t}\n}"
  },
  {
    "function_name": "task_non_contending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "237-292",
    "snippet": "static void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "timer",
            "ns_to_ktime(zerolag_time)",
            "HRTIMER_MODE_REL"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_to_ktime",
          "args": [
            "zerolag_time"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_struct",
          "args": [
            "p"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 283
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_clear_params",
          "args": [
            "p"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_clear_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2648-2663",
          "snippet": "void __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
            "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid __dl_clear_params(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\n\tdl_se->dl_runtime\t\t= 0;\n\tdl_se->dl_deadline\t\t= 0;\n\tdl_se->dl_period\t\t= 0;\n\tdl_se->flags\t\t\t= 0;\n\tdl_se->dl_bw\t\t\t= 0;\n\tdl_se->dl_density\t\t= 0;\n\n\tdl_se->dl_throttled\t\t= 0;\n\tdl_se->dl_yielded\t\t= 0;\n\tdl_se->dl_non_contending\t= 0;\n\tdl_se->dl_overrun\t\t= 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__dl_sub",
          "args": [
            "dl_b",
            "p->dl.dl_bw",
            "dl_bw_cpus(task_cpu(p))"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "__dl_sub",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "286-291",
          "snippet": "static inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_dl_bw(struct dl_bw *dl_b);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_dl_bw(struct dl_bw *dl_b);\n\nstatic inline\nvoid __dl_sub(struct dl_bw *dl_b, u64 tsk_bw, int cpus)\n{\n\tdl_b->total_bw -= tsk_bw;\n\t__dl_update(dl_b, (s32)tsk_bw / cpus);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_cpus",
          "args": [
            "task_cpu(p)"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "72-75",
          "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cpu",
          "args": [
            "p"
          ],
          "line": 281
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_task_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6542-6556",
          "snippet": "static void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(ftrace_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic DEFINE_MUTEX(ftrace_lock);\n\nstatic void ignore_task_cpu(void *data)\n{\n\tstruct trace_array *tr = data;\n\tstruct trace_pid_list *pid_list;\n\n\t/*\n\t * This function is called by on_each_cpu() while the\n\t * event_mutex is held.\n\t */\n\tpid_list = rcu_dereference_protected(tr->function_pids,\n\t\t\t\t\t     mutex_is_locked(&ftrace_lock));\n\n\tthis_cpu_write(tr->trace_buffer.data->ftrace_ignore_pid,\n\t\t       trace_ignore_this_task(pid_list, current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&dl_b->lock"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_rq_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "135-140",
          "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_bw_of",
          "args": [
            "task_cpu(p)"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "dl_bw_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "67-70",
          "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_task",
          "args": [
            "p"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "pull_dl_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "2124-2207",
          "snippet": "static void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void pull_dl_task(struct rq *this_rq)\n{\n\tint this_cpu = this_rq->cpu, cpu;\n\tstruct task_struct *p;\n\tbool resched = false;\n\tstruct rq *src_rq;\n\tu64 dmin = LONG_MAX;\n\n\tif (likely(!dl_overloaded(this_rq)))\n\t\treturn;\n\n\t/*\n\t * Match the barrier from dl_set_overloaded; this guarantees that if we\n\t * see overloaded we must also see the dlo_mask bit.\n\t */\n\tsmp_rmb();\n\n\tfor_each_cpu(cpu, this_rq->rd->dlo_mask) {\n\t\tif (this_cpu == cpu)\n\t\t\tcontinue;\n\n\t\tsrc_rq = cpu_rq(cpu);\n\n\t\t/*\n\t\t * It looks racy, abd it is! However, as in sched_rt.c,\n\t\t * we are fine with this.\n\t\t */\n\t\tif (this_rq->dl.dl_nr_running &&\n\t\t    dl_time_before(this_rq->dl.earliest_dl.curr,\n\t\t\t\t   src_rq->dl.earliest_dl.next))\n\t\t\tcontinue;\n\n\t\t/* Might drop this_rq->lock */\n\t\tdouble_lock_balance(this_rq, src_rq);\n\n\t\t/*\n\t\t * If there are no more pullable tasks on the\n\t\t * rq, we're done with it.\n\t\t */\n\t\tif (src_rq->dl.dl_nr_running <= 1)\n\t\t\tgoto skip;\n\n\t\tp = pick_earliest_pushable_dl_task(src_rq, this_cpu);\n\n\t\t/*\n\t\t * We found a task to be pulled if:\n\t\t *  - it preempts our current (if there's one),\n\t\t *  - it will preempt the last one we pulled (if any).\n\t\t */\n\t\tif (p && dl_time_before(p->dl.deadline, dmin) &&\n\t\t    (!this_rq->dl.dl_nr_running ||\n\t\t     dl_time_before(p->dl.deadline,\n\t\t\t\t    this_rq->dl.earliest_dl.curr))) {\n\t\t\tWARN_ON(p == src_rq->curr);\n\t\t\tWARN_ON(!task_on_rq_queued(p));\n\n\t\t\t/*\n\t\t\t * Then we pull iff p has actually an earlier\n\t\t\t * deadline than the current task of its runqueue.\n\t\t\t */\n\t\t\tif (dl_time_before(p->dl.deadline,\n\t\t\t\t\t   src_rq->curr->dl.deadline))\n\t\t\t\tgoto skip;\n\n\t\t\tresched = true;\n\n\t\t\tdeactivate_task(src_rq, p, 0);\n\t\t\tsub_running_bw(&p->dl, &src_rq->dl);\n\t\t\tsub_rq_bw(&p->dl, &src_rq->dl);\n\t\t\tset_task_cpu(p, this_cpu);\n\t\t\tadd_rq_bw(&p->dl, &this_rq->dl);\n\t\t\tadd_running_bw(&p->dl, &this_rq->dl);\n\t\t\tactivate_task(this_rq, p, 0);\n\t\t\tdmin = p->dl.deadline;\n\n\t\t\t/* Is there any other task even earlier? */\n\t\t}\nskip:\n\t\tdouble_unlock_balance(this_rq, src_rq);\n\t}\n\n\tif (resched)\n\t\tresched_curr(this_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "dl_se",
            "dl_rq"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_clock",
          "args": [
            "rq"
          ],
          "line": 266
        },
        "resolved": true,
        "details": {
          "function_name": "update_rq_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "185-205",
          "snippet": "void update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid update_rq_clock(struct rq *rq)\n{\n\ts64 delta;\n\n\tlockdep_assert_held(&rq->lock);\n\n\tif (rq->clock_update_flags & RQCF_ACT_SKIP)\n\t\treturn;\n\n#ifdef CONFIG_SCHED_DEBUG\n\tif (sched_feat(WARN_DOUBLE_CLOCK))\n\t\tSCHED_WARN_ON(rq->clock_update_flags & RQCF_UPDATED);\n\trq->clock_update_flags |= RQCF_UPDATED;\n#endif\n\n\tdelta = sched_clock_cpu(cpu_of(rq)) - rq->clock;\n\tif (delta < 0)\n\t\treturn;\n\trq->clock += delta;\n\tupdate_rq_clock_task(rq, delta);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div64_long",
          "args": [
            "(dl_se->runtime * dl_se->dl_period)",
            "dl_se->dl_runtime"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "dl_se->dl_non_contending"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hrtimer_active(&dl_se->inactive_timer)"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_active",
          "args": [
            "&dl_se->inactive_timer"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1320-1337",
          "snippet": "bool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nbool hrtimer_active(const struct hrtimer *timer)\n{\n\tstruct hrtimer_clock_base *base;\n\tunsigned int seq;\n\n\tdo {\n\t\tbase = READ_ONCE(timer->base);\n\t\tseq = raw_read_seqcount_begin(&base->seq);\n\n\t\tif (timer->state != HRTIMER_STATE_INACTIVE ||\n\t\t    base->running == timer)\n\t\t\treturn true;\n\n\t} while (read_seqcount_retry(&base->seq, seq) ||\n\t\t base != READ_ONCE(timer->base));\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 252
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 242
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_rq_of_se",
          "args": [
            "dl_se"
          ],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "dl_rq_of_se",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "33-39",
          "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void task_non_contending(struct task_struct *p)\n{\n\tstruct sched_dl_entity *dl_se = &p->dl;\n\tstruct hrtimer *timer = &dl_se->inactive_timer;\n\tstruct dl_rq *dl_rq = dl_rq_of_se(dl_se);\n\tstruct rq *rq = rq_of_dl_rq(dl_rq);\n\ts64 zerolag_time;\n\n\t/*\n\t * If this is a non-deadline task that has been boosted,\n\t * do nothing\n\t */\n\tif (dl_se->dl_runtime == 0)\n\t\treturn;\n\n\tif (dl_entity_is_special(dl_se))\n\t\treturn;\n\n\tWARN_ON(hrtimer_active(&dl_se->inactive_timer));\n\tWARN_ON(dl_se->dl_non_contending);\n\n\tzerolag_time = dl_se->deadline -\n\t\t div64_long((dl_se->runtime * dl_se->dl_period),\n\t\t\tdl_se->dl_runtime);\n\n\t/*\n\t * Using relative times instead of the absolute \"0-lag time\"\n\t * allows to simplify the code\n\t */\n\tzerolag_time -= rq_clock(rq);\n\n\t/*\n\t * If the \"0-lag time\" already passed, decrease the active\n\t * utilization now, instead of starting a timer\n\t */\n\tif (zerolag_time < 0) {\n\t\tif (dl_task(p))\n\t\t\tsub_running_bw(dl_se, dl_rq);\n\t\tif (!dl_task(p) || p->state == TASK_DEAD) {\n\t\t\tstruct dl_bw *dl_b = dl_bw_of(task_cpu(p));\n\n\t\t\tif (p->state == TASK_DEAD)\n\t\t\t\tsub_rq_bw(&p->dl, &rq->dl);\n\t\t\traw_spin_lock(&dl_b->lock);\n\t\t\t__dl_sub(dl_b, p->dl.dl_bw, dl_bw_cpus(task_cpu(p)));\n\t\t\t__dl_clear_params(p);\n\t\t\traw_spin_unlock(&dl_b->lock);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tdl_se->dl_non_contending = 1;\n\tget_task_struct(p);\n\thrtimer_start(timer, ns_to_ktime(zerolag_time), HRTIMER_MODE_REL);\n}"
  },
  {
    "function_name": "dl_change_utilization",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "156-181",
    "snippet": "void dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);",
      "static void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_rq_bw",
          "args": [
            "new_bw",
            "&rq->dl"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "__add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "105-113",
          "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
        }
      },
      {
        "call_info": {
          "callee": "__sub_rq_bw",
          "args": [
            "p->dl.dl_bw",
            "&rq->dl"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "115-126",
          "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "p"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&p->dl.inactive_timer"
          ],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sub_running_bw",
          "args": [
            "&p->dl",
            "&rq->dl"
          ],
          "line": 167
        },
        "resolved": true,
        "details": {
          "function_name": "sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "149-154",
          "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_on_rq_queued",
          "args": [
            "p"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "task_on_rq_queued",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1535-1538",
          "snippet": "static inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define TASK_ON_RQ_QUEUED\t1"
          ],
          "globals_used": [
            "void __dl_clear_params(struct task_struct *p);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define TASK_ON_RQ_QUEUED\t1\n\nvoid __dl_clear_params(struct task_struct *p);\n\nstatic inline int task_on_rq_queued(struct task_struct *p)\n{\n\treturn p->on_rq == TASK_ON_RQ_QUEUED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "p->dl.flags & SCHED_FLAG_SUGOV"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic void enqueue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void __dequeue_task_dl(struct rq *rq, struct task_struct *p, int flags);\nstatic void check_preempt_curr_dl(struct rq *rq, struct task_struct *p, int flags);\n\nvoid dl_change_utilization(struct task_struct *p, u64 new_bw)\n{\n\tstruct rq *rq;\n\n\tBUG_ON(p->dl.flags & SCHED_FLAG_SUGOV);\n\n\tif (task_on_rq_queued(p))\n\t\treturn;\n\n\trq = task_rq(p);\n\tif (p->dl.dl_non_contending) {\n\t\tsub_running_bw(&p->dl, &rq->dl);\n\t\tp->dl.dl_non_contending = 0;\n\t\t/*\n\t\t * If the timer handler is currently running and the\n\t\t * timer cannot be cancelled, inactive_task_timer()\n\t\t * will see that dl_not_contending is not set, and\n\t\t * will not touch the rq's active utilization,\n\t\t * so we are still safe.\n\t\t */\n\t\tif (hrtimer_try_to_cancel(&p->dl.inactive_timer) == 1)\n\t\t\tput_task_struct(p);\n\t}\n\t__sub_rq_bw(p->dl.dl_bw, &rq->dl);\n\t__add_rq_bw(new_bw, &rq->dl);\n}"
  },
  {
    "function_name": "sub_running_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "149-154",
    "snippet": "static inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sub_running_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "91-103",
          "snippet": "static inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 152
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_running_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "add_running_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "142-147",
    "snippet": "static inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_running_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "__add_running_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "78-89",
          "snippet": "static inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_running_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_running_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "sub_rq_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "135-140",
    "snippet": "static inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sub_rq_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 139
        },
        "resolved": true,
        "details": {
          "function_name": "__sub_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "115-126",
          "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid sub_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__sub_rq_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "add_rq_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "128-133",
    "snippet": "static inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__add_rq_bw",
          "args": [
            "dl_se->dl_bw",
            "dl_rq"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "__add_rq_bw",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "105-113",
          "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
        }
      },
      {
        "call_info": {
          "callee": "dl_entity_is_special",
          "args": [
            "dl_se"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "dl_entity_is_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "205-212",
          "snippet": "static inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define SCHED_FLAG_SUGOV\t0x10000000"
          ],
          "globals_used": [
            "extern void init_dl_task_timer(struct sched_dl_entity *dl_se);",
            "extern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define SCHED_FLAG_SUGOV\t0x10000000\n\nextern void init_dl_task_timer(struct sched_dl_entity *dl_se);\nextern void init_dl_inactive_task_timer(struct sched_dl_entity *dl_se);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline bool dl_entity_is_special(struct sched_dl_entity *dl_se)\n{\n#ifdef CONFIG_CPU_FREQ_GOV_SCHEDUTIL\n\treturn unlikely(dl_se->flags & SCHED_FLAG_SUGOV);\n#else\n\treturn false;\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid add_rq_bw(struct sched_dl_entity *dl_se, struct dl_rq *dl_rq)\n{\n\tif (!dl_entity_is_special(dl_se))\n\t\t__add_rq_bw(dl_se->dl_bw, dl_rq);\n}"
  },
  {
    "function_name": "__sub_rq_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "115-126",
    "snippet": "static inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > dl_rq->this_bw"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->this_bw > old"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&(rq_of_dl_rq(dl_rq))->lock"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __sub_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw > old); /* underflow */\n\tif (dl_rq->this_bw > old)\n\t\tdl_rq->this_bw = 0;\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n}"
  },
  {
    "function_name": "__add_rq_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "105-113",
    "snippet": "static inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->this_bw < old"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&(rq_of_dl_rq(dl_rq))->lock"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __add_rq_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->this_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->this_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->this_bw < old); /* overflow */\n}"
  },
  {
    "function_name": "__sub_running_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "91-103",
    "snippet": "static inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_update_util",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "0"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_update_util",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2200-2200",
          "snippet": "static inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 102
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > old"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&(rq_of_dl_rq(dl_rq))->lock"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __sub_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw -= dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw > old); /* underflow */\n\tif (dl_rq->running_bw > old)\n\t\tdl_rq->running_bw = 0;\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
  },
  {
    "function_name": "__add_running_bw",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "78-89",
    "snippet": "static inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_update_util",
          "args": [
            "rq_of_dl_rq(dl_rq)",
            "0"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_update_util",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2200-2200",
          "snippet": "static inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);",
            "extern void activate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);",
            "extern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\nextern void activate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void deactivate_task(struct rq *rq, struct task_struct *p, int flags);\nextern void check_preempt_curr(struct rq *rq, struct task_struct *p, int flags);\n\nstatic inline void cpufreq_update_util(struct rq *rq, unsigned int flags) {}"
        }
      },
      {
        "call_info": {
          "callee": "rq_of_dl_rq",
          "args": [
            "dl_rq"
          ],
          "line": 88
        },
        "resolved": true,
        "details": {
          "function_name": "rq_of_dl_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "28-31",
          "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw > dl_rq->this_bw"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SCHED_WARN_ON",
          "args": [
            "dl_rq->running_bw < old"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_held",
          "args": [
            "&(rq_of_dl_rq(dl_rq))->lock"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline\nvoid __add_running_bw(u64 dl_bw, struct dl_rq *dl_rq)\n{\n\tu64 old = dl_rq->running_bw;\n\n\tlockdep_assert_held(&(rq_of_dl_rq(dl_rq))->lock);\n\tdl_rq->running_bw += dl_bw;\n\tSCHED_WARN_ON(dl_rq->running_bw < old); /* overflow */\n\tSCHED_WARN_ON(dl_rq->running_bw > dl_rq->this_bw);\n\t/* kick cpufreq (see the comment in kernel/sched/sched.h). */\n\tcpufreq_update_util(rq_of_dl_rq(dl_rq), 0);\n}"
  },
  {
    "function_name": "dl_bw_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "72-75",
    "snippet": "static inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "dl_bw_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "67-70",
    "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\treturn &cpu_rq(i)->dl.dl_bw;\n}"
  },
  {
    "function_name": "dl_bw_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "54-65",
    "snippet": "static inline int dl_bw_cpus(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tint cpus = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcpus++;\n\n\treturn cpus;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_cpu_and",
          "args": [
            "i",
            "rd->span",
            "cpu_active_mask"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_sched_held()",
            "\"sched RCU must be held\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 59
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int dl_bw_cpus(int i)\n{\n\tstruct root_domain *rd = cpu_rq(i)->rd;\n\tint cpus = 0;\n\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\tfor_each_cpu_and(i, rd->span, cpu_active_mask)\n\t\tcpus++;\n\n\treturn cpus;\n}"
  },
  {
    "function_name": "dl_bw_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "47-52",
    "snippet": "static inline struct dl_bw *dl_bw_of(int i)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\treturn &cpu_rq(i)->rd->dl_bw;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "i"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!rcu_read_lock_sched_held()",
            "\"sched RCU must be held\""
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock_sched_held",
          "args": [],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_sched_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "106-119",
          "snippet": "int rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_sched_held(void)\n{\n\tint lockdep_opinion = 0;\n\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\tif (debug_locks)\n\t\tlockdep_opinion = lock_is_held(&rcu_sched_lock_map);\n\treturn lockdep_opinion || !preemptible();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_bw *dl_bw_of(int i)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_sched_held(),\n\t\t\t \"sched RCU must be held\");\n\treturn &cpu_rq(i)->rd->dl_bw;\n}"
  },
  {
    "function_name": "on_dl_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "41-44",
    "snippet": "static inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RB_EMPTY_NODE",
          "args": [
            "&dl_se->rb_node"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline int on_dl_rq(struct sched_dl_entity *dl_se)\n{\n\treturn !RB_EMPTY_NODE(&dl_se->rb_node);\n}"
  },
  {
    "function_name": "dl_rq_of_se",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "33-39",
    "snippet": "static inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_rq",
          "args": [
            "p"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dl_task_of",
          "args": [
            "dl_se"
          ],
          "line": 35
        },
        "resolved": true,
        "details": {
          "function_name": "dl_task_of",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
          "lines": "23-26",
          "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
          "includes": [
            "#include \"pelt.h\"",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct dl_rq *dl_rq_of_se(struct sched_dl_entity *dl_se)\n{\n\tstruct task_struct *p = dl_task_of(dl_se);\n\tstruct rq *rq = task_rq(p);\n\n\treturn &rq->dl;\n}"
  },
  {
    "function_name": "rq_of_dl_rq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "28-31",
    "snippet": "static inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dl_rq",
            "structrq",
            "dl"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct rq *rq_of_dl_rq(struct dl_rq *dl_rq)\n{\n\treturn container_of(dl_rq, struct rq, dl);\n}"
  },
  {
    "function_name": "dl_task_of",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/deadline.c",
    "lines": "23-26",
    "snippet": "static inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}",
    "includes": [
      "#include \"pelt.h\"",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "dl_se",
            "structtask_struct",
            "dl"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"pelt.h\"\n#include \"sched.h\"\n\nstatic inline struct task_struct *dl_task_of(struct sched_dl_entity *dl_se)\n{\n\treturn container_of(dl_se, struct task_struct, dl);\n}"
  }
]