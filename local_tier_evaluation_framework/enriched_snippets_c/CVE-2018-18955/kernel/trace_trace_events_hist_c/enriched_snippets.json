[
  {
    "function_name": "trace_events_hist_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5809-5833",
    "snippet": "static __init int trace_events_hist_init(void)\n{\n\tstruct dentry *entry = NULL;\n\tstruct dentry *d_tracer;\n\tint err = 0;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer)) {\n\t\terr = PTR_ERR(d_tracer);\n\t\tgoto err;\n\t}\n\n\tentry = tracefs_create_file(\"synthetic_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &synth_events_fops);\n\tif (!entry) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn err;\n err:\n\tpr_warn(\"Could not create tracefs 'synthetic_events' entry\\n\");\n\n\treturn err;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations synth_events_fops = {\n\t.open           = synth_events_open,\n\t.write\t\t= synth_events_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Could not create tracefs 'synthetic_events' entry\\n\""
          ],
          "line": 5830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracefs_create_file",
          "args": [
            "\"synthetic_events\"",
            "0644",
            "d_tracer",
            "NULL",
            "&synth_events_fops"
          ],
          "line": 5821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 5817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "d_tracer"
          ],
          "line": 5816
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_init_dentry",
          "args": [],
          "line": 5815
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_init_dentry",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8023-8050",
          "snippet": "struct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic struct trace_array global_trace = {\n\t.trace_flags = TRACE_DEFAULT_FLAGS,\n};\nstatic __always_inline struct;\n\nstruct dentry *tracing_init_dentry(void)\n{\n\tstruct trace_array *tr = &global_trace;\n\n\t/* The top level trace array uses  NULL as parent */\n\tif (tr->dir)\n\t\treturn NULL;\n\n\tif (WARN_ON(!tracefs_initialized()) ||\n\t\t(IS_ENABLED(CONFIG_DEBUG_FS) &&\n\t\t WARN_ON(!debugfs_initialized())))\n\t\treturn ERR_PTR(-ENODEV);\n\n\t/*\n\t * As there may still be users that expect the tracing\n\t * files to exist in debugfs/tracing, we must automount\n\t * the tracefs file system there, so older tools still\n\t * work with the newer kerenl.\n\t */\n\ttr->dir = debugfs_create_automount(\"tracing\", NULL,\n\t\t\t\t\t   trace_automount, NULL);\n\tif (!tr->dir) {\n\t\tpr_warn_once(\"Could not create debugfs directory 'tracing'\\n\");\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct file_operations synth_events_fops = {\n\t.open           = synth_events_open,\n\t.write\t\t= synth_events_write,\n\t.read           = seq_read,\n\t.llseek         = seq_lseek,\n\t.release        = seq_release,\n};\n\nstatic __init int trace_events_hist_init(void)\n{\n\tstruct dentry *entry = NULL;\n\tstruct dentry *d_tracer;\n\tint err = 0;\n\n\td_tracer = tracing_init_dentry();\n\tif (IS_ERR(d_tracer)) {\n\t\terr = PTR_ERR(d_tracer);\n\t\tgoto err;\n\t}\n\n\tentry = tracefs_create_file(\"synthetic_events\", 0644, d_tracer,\n\t\t\t\t    NULL, &synth_events_fops);\n\tif (!entry) {\n\t\terr = -ENODEV;\n\t\tgoto err;\n\t}\n\n\treturn err;\n err:\n\tpr_warn(\"Could not create tracefs 'synthetic_events' entry\\n\");\n\n\treturn err;\n}"
  },
  {
    "function_name": "register_trigger_hist_enable_disable_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5795-5807",
    "snippet": "__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trigger_hist_enable_disable_cmds",
          "args": [],
          "line": 5804
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trigger_hist_enable_disable_cmds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5789-5793",
          "snippet": "static __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
            "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 5803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_hist_disable_cmd"
          ],
          "line": 5802
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 5800
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_enable_disable_cmds(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_enable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\treturn ret;\n\tret = register_event_command(&trigger_hist_disable_cmd);\n\tif (WARN_ON(ret < 0))\n\t\tunregister_trigger_hist_enable_disable_cmds();\n\n\treturn ret;\n}"
  },
  {
    "function_name": "unregister_trigger_hist_enable_disable_cmds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5789-5793",
    "snippet": "static __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};",
      "static struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_event_command",
          "args": [
            "&trigger_hist_disable_cmd"
          ],
          "line": 5792
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_enable_cmd = {\n\t.name\t\t\t= ENABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\nstatic struct event_command trigger_hist_disable_cmd = {\n\t.name\t\t\t= DISABLE_HIST_STR,\n\t.trigger_type\t\t= ETT_HIST_ENABLE,\n\t.func\t\t\t= event_enable_trigger_func,\n\t.reg\t\t\t= event_enable_register_trigger,\n\t.unreg\t\t\t= event_enable_unregister_trigger,\n\t.unreg_all\t\t= hist_enable_unreg_all,\n\t.get_trigger_ops\t= hist_enable_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic __init void unregister_trigger_hist_enable_disable_cmds(void)\n{\n\tunregister_event_command(&trigger_hist_enable_cmd);\n\tunregister_event_command(&trigger_hist_disable_cmd);\n}"
  },
  {
    "function_name": "hist_enable_unreg_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5752-5765",
    "snippet": "static void hist_enable_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\n\t\t\tlist_del_rcu(&test->list);\n\t\t\tupdate_cond_flag(file);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 5762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 5760
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 5759
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 5758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "test",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 5756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_enable_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_HIST_ENABLE) {\n\t\t\tlist_del_rcu(&test->list);\n\t\t\tupdate_cond_flag(file);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hist_enable_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5734-5750",
    "snippet": "static struct event_trigger_ops *\nhist_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n\tenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\n\n\tif (enable)\n\t\tops = param ? &hist_enable_count_trigger_ops :\n\t\t\t&hist_enable_trigger_ops;\n\telse\n\t\tops = param ? &hist_disable_count_trigger_ops :\n\t\t\t&hist_disable_trigger_ops;\n\n\treturn ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);",
      "static struct event_trigger_ops hist_enable_trigger_ops = {\n\t.func\t\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_enable_count_trigger_ops = {\n\t.func\t\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_disable_trigger_ops = {\n\t.func\t\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};",
      "static struct event_trigger_ops hist_disable_count_trigger_ops = {\n\t.func\t\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "cmd",
            "ENABLE_HIST_STR"
          ],
          "line": 5740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\nstatic struct event_trigger_ops hist_enable_trigger_ops = {\n\t.func\t\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_enable_count_trigger_ops = {\n\t.func\t\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_disable_trigger_ops = {\n\t.func\t\t\t= hist_enable_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\nstatic struct event_trigger_ops hist_disable_count_trigger_ops = {\n\t.func\t\t\t= hist_enable_count_trigger,\n\t.print\t\t\t= event_enable_trigger_print,\n\t.init\t\t\t= event_trigger_init,\n\t.free\t\t\t= event_enable_trigger_free,\n};\n\nstatic struct event_trigger_ops *\nhist_enable_get_trigger_ops(char *cmd, char *param)\n{\n\tstruct event_trigger_ops *ops;\n\tbool enable;\n\n\tenable = (strcmp(cmd, ENABLE_HIST_STR) == 0);\n\n\tif (enable)\n\t\tops = param ? &hist_enable_count_trigger_ops :\n\t\t\t&hist_enable_trigger_ops;\n\telse\n\t\tops = param ? &hist_disable_count_trigger_ops :\n\t\t\t&hist_disable_trigger_ops;\n\n\treturn ops;\n}"
  },
  {
    "function_name": "hist_enable_count_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5693-5704",
    "snippet": "static void\nhist_enable_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\thist_enable_trigger(data, rec, event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_enable_trigger",
          "args": [
            "data",
            "rec",
            "event"
          ],
          "line": 5703
        },
        "resolved": true,
        "details": {
          "function_name": "hist_enable_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5676-5691",
          "snippet": "static void\nhist_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void\nhist_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void\nhist_enable_count_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t  struct ring_buffer_event *event)\n{\n\tif (!data->count)\n\t\treturn;\n\n\tif (data->count != -1)\n\t\t(data->count)--;\n\n\thist_enable_trigger(data, rec, event);\n}"
  },
  {
    "function_name": "hist_enable_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5676-5691",
    "snippet": "static void\nhist_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&enable_data->file->triggers",
            "list"
          ],
          "line": 5683
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void\nhist_enable_trigger(struct event_trigger_data *data, void *rec,\n\t\t    struct ring_buffer_event *event)\n{\n\tstruct enable_trigger_data *enable_data = data->private_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &enable_data->file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (enable_data->enable)\n\t\t\t\ttest->paused = false;\n\t\t\telse\n\t\t\t\ttest->paused = true;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "register_trigger_hist_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5666-5674",
    "snippet": "__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "ret < 0"
          ],
          "line": 5671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_event_command",
          "args": [
            "&trigger_hist_cmd"
          ],
          "line": 5670
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_event_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "339-356",
          "snippet": "__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(trigger_commands);",
            "static DEFINE_MUTEX(trigger_cmd_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(trigger_commands);\nstatic DEFINE_MUTEX(trigger_cmd_mutex);\n\n__init int unregister_event_command(struct event_command *cmd)\n{\n\tstruct event_command *p, *n;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trigger_cmd_mutex);\n\tlist_for_each_entry_safe(p, n, &trigger_commands, list) {\n\t\tif (strcmp(cmd->name, p->name) == 0) {\n\t\t\tret = 0;\n\t\t\tlist_del_init(&p->list);\n\t\t\tgoto out_unlock;\n\t\t}\n\t}\n out_unlock:\n\tmutex_unlock(&trigger_cmd_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\n__init int register_trigger_hist_cmd(void)\n{\n\tint ret;\n\n\tret = register_event_command(&trigger_hist_cmd);\n\tWARN_ON(ret < 0);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "event_hist_trigger_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5478-5652",
    "snippet": "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);",
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 5650
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4452-4467",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "trigger_data"
          ],
          "line": 5648
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 5646
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1452-1469",
          "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "NULL",
            "trigger_data",
            "NULL"
          ],
          "line": 5644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 5641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err_clear",
          "args": [],
          "line": 5637
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "392-395",
          "snippet": "static void hist_err_clear(void)\n{\n\thist_err_str[0] = '\\0';\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err_clear(void)\n{\n\thist_err_str[0] = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 5631
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "se_name"
          ],
          "line": 5628
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "869-879",
          "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 5627
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 5626
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_enable",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 5622
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_enable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5335-5351",
          "snippet": "static int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_init",
          "args": [
            "hist_data->map"
          ],
          "line": 5618
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "821-835",
          "snippet": "int tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_init(struct tracing_map *map)\n{\n\tint err;\n\n\tif (map->n_fields < 2)\n\t\treturn -EINVAL; /* need at least 1 key and 1 val */\n\n\terr = tracing_map_alloc_elts(map);\n\tif (err)\n\t\treturn err;\n\n\ttracing_map_clear(map);\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_actions",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 5614
        },
        "resolved": true,
        "details": {
          "function_name": "create_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4304-4326",
          "snippet": "static int create_actions(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tret = onmatch_create(hist_data, file, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tret = onmax_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_actions(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tret = onmatch_create(hist_data, file, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tret = onmax_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 5612
        },
        "resolved": true,
        "details": {
          "function_name": "save_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1428-1450",
          "snippet": "static int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 5611
        },
        "resolved": true,
        "details": {
          "function_name": "has_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1414-1426",
          "snippet": "static bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_named_trigger_data",
          "args": [
            "trigger_data"
          ],
          "line": 5608
        },
        "resolved": true,
        "details": {
          "function_name": "get_named_trigger_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "905-909",
          "snippet": "struct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstruct event_trigger_data *\nget_named_trigger_data(struct event_trigger_data *data)\n{\n\treturn data->named_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->reg",
          "args": [
            "glob",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 5595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 5585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->unreg",
          "args": [
            "glob+1",
            "trigger_ops",
            "trigger_data",
            "file"
          ],
          "line": 5582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_trigger_check_refs",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 5577
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_check_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5375-5396",
          "snippet": "static bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_hist_trigger_match",
          "args": [
            "trigger_data",
            "file"
          ],
          "line": 5574
        },
        "resolved": true,
        "details": {
          "function_name": "have_hist_trigger_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5353-5373",
          "snippet": "static bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_ops->set_filter",
          "args": [
            "param",
            "trigger_data",
            "file"
          ],
          "line": 5568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_INIT_POINTER",
          "args": [
            "trigger_data->filter",
            "NULL"
          ],
          "line": 5562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&trigger_data->list"
          ],
          "line": 5561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*trigger_data)",
            "GFP_KERNEL"
          ],
          "line": 5551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cmd_ops->get_trigger_ops",
          "args": [
            "cmd",
            "trigger"
          ],
          "line": 5549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_data"
          ],
          "line": 5546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "attrs"
          ],
          "line": 5545
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1783-1802",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_data"
          ],
          "line": 5544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_data",
          "args": [
            "hist_trigger_bits",
            "attrs",
            "file",
            "remove"
          ],
          "line": 5543
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4514-4567",
          "snippet": "static struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};\n\nstatic struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "attrs"
          ],
          "line": 5538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "attrs"
          ],
          "line": 5537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_hist_trigger_attrs",
          "args": [
            "trigger"
          ],
          "line": 5536
        },
        "resolved": true,
        "details": {
          "function_name": "parse_hist_trigger_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1898-1946",
          "snippet": "static struct hist_trigger_attrs *parse_hist_trigger_attrs(char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\n\t\tif (strchr(str, '=')) {\n\t\t\tret = parse_assignment(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_attrs *parse_hist_trigger_attrs(char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\n\t\tif (strchr(str, '=')) {\n\t\t\tret = parse_assignment(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "trigger"
          ],
          "line": 5533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "p"
          ],
          "line": 5532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"if\""
          ],
          "line": 5521
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "p",
            "\"if\""
          ],
          "line": 5510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "last_cmd_set",
          "args": [
            "param"
          ],
          "line": 5494
        },
        "resolved": true,
        "details": {
          "function_name": "last_cmd_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "350-356",
          "snippet": "static void last_cmd_set(char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_hist_cmd, str, MAX_FILTER_STR_VAL - 1);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char last_hist_cmd[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_hist_cmd[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_hist_cmd, str, MAX_FILTER_STR_VAL - 1);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
  },
  {
    "function_name": "hist_unreg_all",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5446-5476",
    "snippet": "static void hist_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\n\tif (hist_file_check_refs(file))\n\t\treturn;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\n\t\t\tmutex_lock(&synth_event_mutex);\n\t\t\tse_name = trace_event_name(file->event_call);\n\t\t\tse = find_synth_event(se_name);\n\t\t\tif (se)\n\t\t\t\tse->ref--;\n\t\t\tmutex_unlock(&synth_event_mutex);\n\n\t\t\tupdate_cond_flag(file);\n\t\t\tif (hist_data->enable_timestamps)\n\t\t\t\ttracing_set_time_stamp_abs(file->tr, false);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 5473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_set_time_stamp_abs",
          "args": [
            "file->tr",
            "false"
          ],
          "line": 5471
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_time_stamp_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "6353-6382",
          "snippet": "int tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 5469
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 5467
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "se_name"
          ],
          "line": 5464
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "869-879",
          "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "file->event_call"
          ],
          "line": 5463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 5462
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 5460
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 5459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "test",
            "n",
            "&file->triggers",
            "list"
          ],
          "line": 5456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_file_check_refs",
          "args": [
            "file"
          ],
          "line": 5453
        },
        "resolved": true,
        "details": {
          "function_name": "hist_file_check_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5430-5444",
          "snippet": "static bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void hist_unreg_all(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test, *n;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\n\tif (hist_file_check_refs(file))\n\t\treturn;\n\n\tlist_for_each_entry_safe(test, n, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\n\t\t\tmutex_lock(&synth_event_mutex);\n\t\t\tse_name = trace_event_name(file->event_call);\n\t\t\tse = find_synth_event(se_name);\n\t\t\tif (se)\n\t\t\t\tse->ref--;\n\t\t\tmutex_unlock(&synth_event_mutex);\n\n\t\t\tupdate_cond_flag(file);\n\t\t\tif (hist_data->enable_timestamps)\n\t\t\t\ttracing_set_time_stamp_abs(file->tr, false);\n\t\t\tif (test->ops->free)\n\t\t\t\ttest->ops->free(test->ops, test);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "hist_file_check_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5430-5444",
    "snippet": "static bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 5438
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1354-1371",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_file_check_refs(struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "hist_unregister_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5398-5428",
    "snippet": "static void hist_unregister_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool unregistered = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && test->ops->free)\n\t\ttest->ops->free(test->ops, test);\n\n\tif (hist_data->enable_timestamps) {\n\t\tif (!hist_data->remove || unregistered)\n\t\t\ttracing_set_time_stamp_abs(file->tr, false);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_set_time_stamp_abs",
          "args": [
            "file->tr",
            "false"
          ],
          "line": 5426
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_time_stamp_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "6353-6382",
          "snippet": "int tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test->ops->free",
          "args": [
            "test->ops",
            "test"
          ],
          "line": 5422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 5416
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "0"
          ],
          "line": 5415
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&test->list"
          ],
          "line": 5414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 5411
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5182-5251",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 5407
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "779-794",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_unregister_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool unregistered = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tunregistered = true;\n\t\t\tlist_del_rcu(&test->list);\n\t\t\ttrace_event_trigger_enable_disable(file, 0);\n\t\t\tupdate_cond_flag(file);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (unregistered && test->ops->free)\n\t\ttest->ops->free(test->ops, test);\n\n\tif (hist_data->enable_timestamps) {\n\t\tif (!hist_data->remove || unregistered)\n\t\t\ttracing_set_time_stamp_abs(file->tr, false);\n\t}\n}"
  },
  {
    "function_name": "hist_trigger_check_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5375-5396",
    "snippet": "static bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 5389
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1354-1371",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 5386
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5182-5251",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 5382
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "779-794",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_check_refs(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\thist_data = test->private_data;\n\t\t\tif (check_var_refs(hist_data))\n\t\t\t\treturn true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "have_hist_trigger_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5353-5373",
    "snippet": "static bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 5365
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5182-5251",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 5361
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "779-794",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool have_hist_trigger_match(struct event_trigger_data *data,\n\t\t\t\t    struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tbool match = false;\n\n\tif (hist_data->attrs->name)\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (hist_trigger_match(data, test, named_data, false)) {\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn match;\n}"
  },
  {
    "function_name": "hist_trigger_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5335-5351",
    "snippet": "static int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_cond_flag",
          "args": [
            "file"
          ],
          "line": 5346
        },
        "resolved": true,
        "details": {
          "function_name": "update_cond_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "493-510",
          "snippet": "void update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid update_cond_flag(struct trace_event_file *file)\n{\n\tstruct event_trigger_data *data;\n\tbool set_cond = false;\n\n\tlist_for_each_entry_rcu(data, &file->triggers, list) {\n\t\tif (data->filter || event_command_post_trigger(data->cmd_ops) ||\n\t\t    event_command_needs_rec(data->cmd_ops)) {\n\t\t\tset_cond = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (set_cond)\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n\telse\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_COND_BIT, &file->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_rcu",
          "args": [
            "&data->list"
          ],
          "line": 5345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_trigger_enable_disable",
          "args": [
            "file",
            "1"
          ],
          "line": 5344
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_trigger_enable_disable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "434-452",
          "snippet": "int trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nint trace_event_trigger_enable_disable(struct trace_event_file *file,\n\t\t\t\t       int trigger_enable)\n{\n\tint ret = 0;\n\n\tif (trigger_enable) {\n\t\tif (atomic_inc_return(&file->tm_ref) > 1)\n\t\t\treturn ret;\n\t\tset_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 1, 1);\n\t} else {\n\t\tif (atomic_dec_return(&file->tm_ref) > 0)\n\t\t\treturn ret;\n\t\tclear_bit(EVENT_FILE_FL_TRIGGER_MODE_BIT, &file->flags);\n\t\tret = trace_event_enable_disable(file, 0, 1);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail_rcu",
          "args": [
            "&data->list",
            "&file->triggers"
          ],
          "line": 5340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int hist_trigger_enable(struct event_trigger_data *data,\n\t\t\t       struct trace_event_file *file)\n{\n\tint ret = 0;\n\n\tlist_add_tail_rcu(&data->list, &file->triggers);\n\n\tupdate_cond_flag(file);\n\n\tif (trace_event_trigger_enable_disable(file, 1) < 0) {\n\t\tlist_del_rcu(&data->list);\n\t\tupdate_cond_flag(file);\n\t\tret--;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_register_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5253-5333",
    "snippet": "static int hist_register_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t\t struct event_trigger_data *data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tint ret = 0;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue)) {\n\t\t\t\thist_err(\"Named hist trigger doesn't match existing named trigger (includes variables): \", hist_data->attrs->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto new;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tif (hist_data->attrs->pause)\n\t\t\t\ttest->paused = true;\n\t\t\telse if (hist_data->attrs->cont)\n\t\t\t\ttest->paused = false;\n\t\t\telse if (hist_data->attrs->clear)\n\t\t\t\thist_clear(test);\n\t\t\telse {\n\t\t\t\thist_err(\"Hist trigger already exists\", NULL);\n\t\t\t\tret = -EEXIST;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n new:\n\tif (hist_data->attrs->cont || hist_data->attrs->clear) {\n\t\thist_err(\"Can't clear or continue a nonexistent hist trigger\", NULL);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (hist_data->attrs->pause)\n\t\tdata->paused = true;\n\n\tif (named_data) {\n\t\tdata->private_data = named_data->private_data;\n\t\tset_named_trigger_data(data, named_data);\n\t\tdata->ops = &event_hist_trigger_named_ops;\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->enable_timestamps) {\n\t\tchar *clock = hist_data->attrs->clock;\n\n\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);\n\t\tif (ret) {\n\t\t\thist_err(\"Couldn't set trace_clock: \", clock);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttracing_set_time_stamp_abs(file->tr, true);\n\t}\n\n\tif (named_data)\n\t\tdestroy_hist_data(hist_data);\n\n\tret++;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_trigger_ops event_hist_trigger_named_ops = {\n\t.func\t\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_named_init,\n\t.free\t\t\t= event_hist_trigger_named_free,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 5328
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4452-4467",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_set_time_stamp_abs",
          "args": [
            "file->tr",
            "true"
          ],
          "line": 5324
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_time_stamp_abs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "6353-6382",
          "snippet": "int tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint tracing_set_time_stamp_abs(struct trace_array *tr, bool abs)\n{\n\tint ret = 0;\n\n\tmutex_lock(&trace_types_lock);\n\n\tif (abs && tr->time_stamp_abs_ref++)\n\t\tgoto out;\n\n\tif (!abs) {\n\t\tif (WARN_ON_ONCE(!tr->time_stamp_abs_ref)) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (--tr->time_stamp_abs_ref)\n\t\t\tgoto out;\n\t}\n\n\tring_buffer_set_time_stamp_abs(tr->trace_buffer.buffer, abs);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_time_stamp_abs(tr->max_buffer.buffer, abs);\n#endif\n out:\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Couldn't set trace_clock: \"",
            "clock"
          ],
          "line": 5320
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_set_clock",
          "args": [
            "file->tr",
            "hist_data->attrs->clock"
          ],
          "line": 5318
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_set_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "6239-6271",
          "snippet": "int tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->trace_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};",
            "static void add_tracer_options(struct trace_array *tr, struct tracer *t);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\nstatic void add_tracer_options(struct trace_array *tr, struct tracer *t);\n\nint tracing_set_clock(struct trace_array *tr, const char *clockstr)\n{\n\tint i;\n\n\tfor (i = 0; i < ARRAY_SIZE(trace_clocks); i++) {\n\t\tif (strcmp(trace_clocks[i].name, clockstr) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == ARRAY_SIZE(trace_clocks))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&trace_types_lock);\n\n\ttr->clock_id = i;\n\n\tring_buffer_set_clock(tr->trace_buffer.buffer, trace_clocks[i].func);\n\n\t/*\n\t * New clock may not be consistent with the previous clock.\n\t * Reset the buffer so that it doesn't have incomparable timestamps.\n\t */\n\ttracing_reset_online_cpus(&tr->trace_buffer);\n\n#ifdef CONFIG_TRACER_MAX_TRACE\n\tif (tr->max_buffer.buffer)\n\t\tring_buffer_set_clock(tr->max_buffer.buffer, trace_clocks[i].func);\n\ttracing_reset_online_cpus(&tr->max_buffer);\n#endif\n\n\tmutex_unlock(&trace_types_lock);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->ops->init",
          "args": [
            "data->ops",
            "data"
          ],
          "line": 5310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_named_trigger_data",
          "args": [
            "data",
            "named_data"
          ],
          "line": 5305
        },
        "resolved": true,
        "details": {
          "function_name": "set_named_trigger_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "899-903",
          "snippet": "void set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid set_named_trigger_data(struct event_trigger_data *data,\n\t\t\t    struct event_trigger_data *named_data)\n{\n\tdata->named_data = named_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_clear",
          "args": [
            "test"
          ],
          "line": 5285
        },
        "resolved": true,
        "details": {
          "function_name": "hist_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5148-5161",
          "snippet": "static void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_match",
          "args": [
            "data",
            "test",
            "named_data",
            "false"
          ],
          "line": 5278
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5182-5251",
          "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 5276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_named_trigger",
          "args": [
            "hist_data->attrs->name"
          ],
          "line": 5262
        },
        "resolved": true,
        "details": {
          "function_name": "find_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "779-794",
          "snippet": "struct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nstruct event_trigger_data *find_named_trigger(const char *name)\n{\n\tstruct event_trigger_data *data;\n\n\tif (!name)\n\t\treturn NULL;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (data->named_data)\n\t\t\tcontinue;\n\t\tif (strcmp(data->name, name) == 0)\n\t\t\treturn data;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_trigger_ops event_hist_trigger_named_ops = {\n\t.func\t\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_named_init,\n\t.free\t\t\t= event_hist_trigger_named_free,\n};\n\nstatic int hist_register_trigger(char *glob, struct event_trigger_ops *ops,\n\t\t\t\t struct event_trigger_data *data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct event_trigger_data *test, *named_data = NULL;\n\tint ret = 0;\n\n\tif (hist_data->attrs->name) {\n\t\tnamed_data = find_named_trigger(hist_data->attrs->name);\n\t\tif (named_data) {\n\t\t\tif (!hist_trigger_match(data, named_data, named_data,\n\t\t\t\t\t\ttrue)) {\n\t\t\t\thist_err(\"Named hist trigger doesn't match existing named trigger (includes variables): \", hist_data->attrs->name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (hist_data->attrs->name && !named_data)\n\t\tgoto new;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (!hist_trigger_match(data, test, named_data, false))\n\t\t\t\tcontinue;\n\t\t\tif (hist_data->attrs->pause)\n\t\t\t\ttest->paused = true;\n\t\t\telse if (hist_data->attrs->cont)\n\t\t\t\ttest->paused = false;\n\t\t\telse if (hist_data->attrs->clear)\n\t\t\t\thist_clear(test);\n\t\t\telse {\n\t\t\t\thist_err(\"Hist trigger already exists\", NULL);\n\t\t\t\tret = -EEXIST;\n\t\t\t}\n\t\t\tgoto out;\n\t\t}\n\t}\n new:\n\tif (hist_data->attrs->cont || hist_data->attrs->clear) {\n\t\thist_err(\"Can't clear or continue a nonexistent hist trigger\", NULL);\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (hist_data->attrs->pause)\n\t\tdata->paused = true;\n\n\tif (named_data) {\n\t\tdata->private_data = named_data->private_data;\n\t\tset_named_trigger_data(data, named_data);\n\t\tdata->ops = &event_hist_trigger_named_ops;\n\t}\n\n\tif (data->ops->init) {\n\t\tret = data->ops->init(data->ops, data);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t}\n\n\tif (hist_data->enable_timestamps) {\n\t\tchar *clock = hist_data->attrs->clock;\n\n\t\tret = tracing_set_clock(file->tr, hist_data->attrs->clock);\n\t\tif (ret) {\n\t\t\thist_err(\"Couldn't set trace_clock: \", clock);\n\t\t\tgoto out;\n\t\t}\n\n\t\ttracing_set_time_stamp_abs(file->tr, true);\n\t}\n\n\tif (named_data)\n\t\tdestroy_hist_data(hist_data);\n\n\tret++;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_trigger_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5182-5251",
    "snippet": "static bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "actions_match",
          "args": [
            "hist_data",
            "hist_data_test"
          ],
          "line": 5247
        },
        "resolved": true,
        "details": {
          "function_name": "actions_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4380-4424",
          "snippet": "static bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\n\t\tif (data->fn != data_test->fn)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->fn == action_trace) {\n\t\t\tif (strcmp(data->onmatch.synth_event_name,\n\t\t\t\t   data_test->onmatch.synth_event_name) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event_system,\n\t\t\t\t   data_test->onmatch.match_event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event,\n\t\t\t\t   data_test->onmatch.match_event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tif (strcmp(data->onmax.var_str,\n\t\t\t\t   data_test->onmax.var_str) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmax.fn_name,\n\t\t\t\t   data_test->onmax.fn_name) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\n\t\tif (data->fn != data_test->fn)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->fn == action_trace) {\n\t\t\tif (strcmp(data->onmatch.synth_event_name,\n\t\t\t\t   data_test->onmatch.synth_event_name) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event_system,\n\t\t\t\t   data_test->onmatch.match_event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event,\n\t\t\t\t   data_test->onmatch.match_event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tif (strcmp(data->onmax.var_str,\n\t\t\t\t   data_test->onmax.var_str) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmax.fn_name,\n\t\t\t\t   data_test->onmax.fn_name) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->filter_str",
            "data_test->filter_str"
          ],
          "line": 5244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "key_field->var.name",
            "key_field_test->var.name"
          ],
          "line": 5230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compatible_field",
          "args": [
            "key_field->field",
            "key_field_test->field"
          ],
          "line": 5219
        },
        "resolved": true,
        "details": {
          "function_name": "compatible_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5163-5180",
          "snippet": "static bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 5213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_named_trigger",
          "args": [
            "data_test"
          ],
          "line": 5196
        },
        "resolved": true,
        "details": {
          "function_name": "is_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "802-812",
          "snippet": "bool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nbool is_named_trigger(struct event_trigger_data *test)\n{\n\tstruct event_trigger_data *data;\n\n\tlist_for_each_entry(data, &named_triggers, named_list) {\n\t\tif (test == data)\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool hist_trigger_match(struct event_trigger_data *data,\n\t\t\t       struct event_trigger_data *data_test,\n\t\t\t       struct event_trigger_data *named_data,\n\t\t\t       bool ignore_filter)\n{\n\tstruct tracing_map_sort_key *sort_key, *sort_key_test;\n\tstruct hist_trigger_data *hist_data, *hist_data_test;\n\tstruct hist_field *key_field, *key_field_test;\n\tunsigned int i;\n\n\tif (named_data && (named_data != data_test) &&\n\t    (named_data != data_test->named_data))\n\t\treturn false;\n\n\tif (!named_data && is_named_trigger(data_test))\n\t\treturn false;\n\n\thist_data = data->private_data;\n\thist_data_test = data_test->private_data;\n\n\tif (hist_data->n_vals != hist_data_test->n_vals ||\n\t    hist_data->n_fields != hist_data_test->n_fields ||\n\t    hist_data->n_sort_keys != hist_data_test->n_sort_keys)\n\t\treturn false;\n\n\tif (!ignore_filter) {\n\t\tif ((data->filter_str && !data_test->filter_str) ||\n\t\t   (!data->filter_str && data_test->filter_str))\n\t\t\treturn false;\n\t}\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tkey_field_test = hist_data_test->fields[i];\n\n\t\tif (key_field->flags != key_field_test->flags)\n\t\t\treturn false;\n\t\tif (!compatible_field(key_field->field, key_field_test->field))\n\t\t\treturn false;\n\t\tif (key_field->offset != key_field_test->offset)\n\t\t\treturn false;\n\t\tif (key_field->size != key_field_test->size)\n\t\t\treturn false;\n\t\tif (key_field->is_signed != key_field_test->is_signed)\n\t\t\treturn false;\n\t\tif (!!key_field->var.name != !!key_field_test->var.name)\n\t\t\treturn false;\n\t\tif (key_field->var.name &&\n\t\t    strcmp(key_field->var.name, key_field_test->var.name) != 0)\n\t\t\treturn false;\n\t}\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tsort_key_test = &hist_data_test->sort_keys[i];\n\n\t\tif (sort_key->field_idx != sort_key_test->field_idx ||\n\t\t    sort_key->descending != sort_key_test->descending)\n\t\t\treturn false;\n\t}\n\n\tif (!ignore_filter && data->filter_str &&\n\t    (strcmp(data->filter_str, data_test->filter_str) != 0))\n\t\treturn false;\n\n\tif (!actions_match(hist_data, hist_data_test))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "compatible_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5163-5180",
    "snippet": "static bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->type",
            "test_field->type"
          ],
          "line": 5172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->name",
            "test_field->name"
          ],
          "line": 5170
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_field(struct ftrace_event_field *field,\n\t\t\t     struct ftrace_event_field *test_field)\n{\n\tif (field == test_field)\n\t\treturn true;\n\tif (field == NULL || test_field == NULL)\n\t\treturn false;\n\tif (strcmp(field->name, test_field->name) != 0)\n\t\treturn false;\n\tif (strcmp(field->type, test_field->type) != 0)\n\t\treturn false;\n\tif (field->size != test_field->size)\n\t\treturn false;\n\tif (field->is_signed != test_field->is_signed)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "hist_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5148-5161",
    "snippet": "static void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unpause_named_trigger",
          "args": [
            "data"
          ],
          "line": 5160
        },
        "resolved": true,
        "details": {
          "function_name": "unpause_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "883-886",
          "snippet": "void unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid unpause_named_trigger(struct event_trigger_data *data)\n{\n\t__pause_named_trigger(data, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_clear",
          "args": [
            "hist_data->map"
          ],
          "line": 5157
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "690-702",
          "snippet": "void tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_clear(struct tracing_map *map)\n{\n\tunsigned int i;\n\n\tatomic_set(&map->next_elt, -1);\n\tatomic64_set(&map->hits, 0);\n\tatomic64_set(&map->drops, 0);\n\n\ttracing_map_array_clear(map->map);\n\n\tfor (i = 0; i < map->max_elts; i++)\n\t\ttracing_map_elt_clear(*(TRACING_MAP_ELT(map->elts, i)));\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 5155
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_clear(struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (data->name)\n\t\tpause_named_trigger(data);\n\n\ttracepoint_synchronize_unregister();\n\n\ttracing_map_clear(hist_data->map);\n\n\tif (data->name)\n\t\tunpause_named_trigger(data);\n}"
  },
  {
    "function_name": "event_hist_get_trigger_ops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5142-5146",
    "snippet": "static struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\n\t\t\t\t\t\t\t    char *param)\n{\n\treturn &event_hist_trigger_ops;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);",
      "static struct event_trigger_ops event_hist_trigger_ops = {\n\t.func\t\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_init,\n\t.free\t\t\t= event_hist_trigger_free,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\nstatic struct event_trigger_ops event_hist_trigger_ops = {\n\t.func\t\t\t= event_hist_trigger,\n\t.print\t\t\t= event_hist_trigger_print,\n\t.init\t\t\t= event_hist_trigger_init,\n\t.free\t\t\t= event_hist_trigger_free,\n};\n\nstatic struct event_trigger_ops *event_hist_get_trigger_ops(char *cmd,\n\t\t\t\t\t\t\t    char *param)\n{\n\treturn &event_hist_trigger_ops;\n}"
  },
  {
    "function_name": "event_hist_trigger_named_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5120-5133",
    "snippet": "static void event_hist_trigger_named_free(struct event_trigger_ops *ops,\n\t\t\t\t\t  struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tevent_hist_trigger_free(ops, data->named_data);\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tdel_named_trigger(data);\n\t\ttrigger_data_free(data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 5131
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "19-28",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_named_trigger",
          "args": [
            "data"
          ],
          "line": 5130
        },
        "resolved": true,
        "details": {
          "function_name": "del_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "836-842",
          "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "event_hist_trigger_free",
          "args": [
            "ops",
            "data->named_data"
          ],
          "line": 5126
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5078-5099",
          "snippet": "static void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 5123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void event_hist_trigger_named_free(struct event_trigger_ops *ops,\n\t\t\t\t\t  struct event_trigger_data *data)\n{\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tevent_hist_trigger_free(ops, data->named_data);\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tdel_named_trigger(data);\n\t\ttrigger_data_free(data);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger_named_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5108-5118",
    "snippet": "static int event_hist_trigger_named_init(struct event_trigger_ops *ops,\n\t\t\t\t\t struct event_trigger_data *data)\n{\n\tdata->ref++;\n\n\tsave_named_trigger(data->named_data->name, data);\n\n\tevent_hist_trigger_init(ops, data->named_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_hist_trigger_init",
          "args": [
            "ops",
            "data->named_data"
          ],
          "line": 5115
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5050-5061",
          "snippet": "static int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_named_trigger",
          "args": [
            "data->named_data->name",
            "data"
          ],
          "line": 5113
        },
        "resolved": true,
        "details": {
          "function_name": "save_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "821-830",
          "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_named_init(struct event_trigger_ops *ops,\n\t\t\t\t\t struct event_trigger_data *data)\n{\n\tdata->ref++;\n\n\tsave_named_trigger(data->named_data->name, data);\n\n\tevent_hist_trigger_init(ops, data->named_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_hist_trigger_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5078-5099",
    "snippet": "static void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 5097
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4452-4467",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_field_var_hists",
          "args": [
            "hist_data"
          ],
          "line": 5095
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_field_var_hists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5063-5076",
          "snippet": "static void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t\t      \"!hist\", \"hist\", cmd);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t\t      \"!hist\", \"hist\", cmd);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "remove_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 5093
        },
        "resolved": true,
        "details": {
          "function_name": "remove_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1452-1469",
          "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_data_free",
          "args": [
            "data"
          ],
          "line": 5091
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "19-28",
          "snippet": "void trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid trigger_data_free(struct event_trigger_data *data)\n{\n\tif (data->cmd_ops->set_filter)\n\t\tdata->cmd_ops->set_filter(NULL, data, NULL);\n\n\t/* make sure current triggers exit before free */\n\ttracepoint_synchronize_unregister();\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_named_trigger",
          "args": [
            "data"
          ],
          "line": 5089
        },
        "resolved": true,
        "details": {
          "function_name": "del_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "836-842",
          "snippet": "void del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nvoid del_named_trigger(struct event_trigger_data *data)\n{\n\tkfree(data->name);\n\tdata->name = NULL;\n\n\tlist_del(&data->named_list);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "data->ref <= 0"
          ],
          "line": 5083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void event_hist_trigger_free(struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (WARN_ON_ONCE(data->ref <= 0))\n\t\treturn;\n\n\tdata->ref--;\n\tif (!data->ref) {\n\t\tif (data->name)\n\t\t\tdel_named_trigger(data);\n\n\t\ttrigger_data_free(data);\n\n\t\tremove_hist_vars(hist_data);\n\n\t\tunregister_field_var_hists(hist_data);\n\n\t\tdestroy_hist_data(hist_data);\n\t}\n}"
  },
  {
    "function_name": "unregister_field_var_hists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5063-5076",
    "snippet": "static void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t\t      \"!hist\", \"hist\", cmd);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "event_hist_trigger_func",
          "args": [
            "&trigger_hist_cmd",
            "file",
            "\"!hist\"",
            "\"hist\"",
            "cmd"
          ],
          "line": 5073
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5478-5652",
          "snippet": "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(synth_event_mutex);",
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic void unregister_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\tchar *cmd;\n\tint ret;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tfile = hist_data->field_var_hists[i]->hist_data->event_file;\n\t\tcmd = hist_data->field_var_hists[i]->cmd;\n\t\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t\t      \"!hist\", \"hist\", cmd);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "5050-5061",
    "snippet": "static int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_named_trigger",
          "args": [
            "hist_data->attrs->name",
            "data"
          ],
          "line": 5056
        },
        "resolved": true,
        "details": {
          "function_name": "save_named_trigger",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_trigger.c",
          "lines": "821-830",
          "snippet": "int save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(named_triggers);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include <linux/rculist.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(named_triggers);\n\nint save_named_trigger(const char *name, struct event_trigger_data *data)\n{\n\tdata->name = kstrdup(name, GFP_KERNEL);\n\tif (!data->name)\n\t\treturn -ENOMEM;\n\n\tlist_add(&data->named_list, &named_triggers);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_init(struct event_trigger_ops *ops,\n\t\t\t\t   struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\n\tif (!data->ref && hist_data->attrs->name)\n\t\tsave_named_trigger(hist_data->attrs->name, data);\n\n\tdata->ref++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "event_hist_trigger_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4941-5048",
    "snippet": "static int event_hist_trigger_print(struct seq_file *m,\n\t\t\t\t    struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct hist_field *field;\n\tbool have_var = false;\n\tunsigned int i;\n\n\tseq_puts(m, \"hist:\");\n\n\tif (data->name)\n\t\tseq_printf(m, \"%s:\", data->name);\n\n\tseq_puts(m, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\tseq_puts(m, \"stacktrace\");\n\t\telse\n\t\t\thist_field_print(m, field);\n\t}\n\n\tseq_puts(m, \":vals=\");\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thave_var = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tseq_puts(m, \",\");\n\t\t\thist_field_print(m, field);\n\t\t}\n\t}\n\n\tif (have_var) {\n\t\tunsigned int n = 0;\n\n\t\tseq_puts(m, \":\");\n\n\t\tfor_each_hist_val_field(i, hist_data) {\n\t\t\tfield = hist_data->fields[i];\n\n\t\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\t\tif (n++)\n\t\t\t\t\tseq_puts(m, \",\");\n\t\t\t\thist_field_print(m, field);\n\t\t\t}\n\t\t}\n\t}\n\n\tseq_puts(m, \":sort=\");\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tstruct tracing_map_sort_key *sort_key;\n\t\tunsigned int idx, first_key_idx;\n\n\t\t/* skip VAR vals */\n\t\tfirst_key_idx = hist_data->n_vals - hist_data->n_vars;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tidx = sort_key->field_idx;\n\n\t\tif (WARN_ON(idx >= HIST_FIELDS_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tif (i > 0)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (idx == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tif (idx >= first_key_idx)\n\t\t\t\tidx += hist_data->n_vars;\n\t\t\thist_field_print(m, hist_data->fields[idx]);\n\t\t}\n\n\t\tif (sort_key->descending)\n\t\t\tseq_puts(m, \".descending\");\n\t}\n\tseq_printf(m, \":size=%u\", (1 << hist_data->map->map_bits));\n\tif (hist_data->enable_timestamps)\n\t\tseq_printf(m, \":clock=%s\", hist_data->attrs->clock);\n\n\tprint_actions_spec(m, hist_data);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\", data->filter_str);\n\n\tif (data->paused)\n\t\tseq_puts(m, \" [paused]\");\n\telse\n\t\tseq_puts(m, \" [active]\");\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0",
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 5045
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\" [active]\""
          ],
          "line": 5043
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\" if %s\"",
            "data->filter_str"
          ],
          "line": 5038
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_actions_spec",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 5035
        },
        "resolved": true,
        "details": {
          "function_name": "print_actions_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4427-4440",
          "snippet": "static void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tprint_onmax_spec(m, hist_data, data);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tprint_onmax_spec(m, hist_data, data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_print",
          "args": [
            "m",
            "hist_data->fields[idx]"
          ],
          "line": 5025
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4913-4939",
          "snippet": "static void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"cpu\");\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"cpu\");\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "idx >= HIST_FIELDS_MAX"
          ],
          "line": 5014
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4991
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4971
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4957
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic int event_hist_trigger_print(struct seq_file *m,\n\t\t\t\t    struct event_trigger_ops *ops,\n\t\t\t\t    struct event_trigger_data *data)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tstruct hist_field *field;\n\tbool have_var = false;\n\tunsigned int i;\n\n\tseq_puts(m, \"hist:\");\n\n\tif (data->name)\n\t\tseq_printf(m, \"%s:\", data->name);\n\n\tseq_puts(m, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\tseq_puts(m, \"stacktrace\");\n\t\telse\n\t\t\thist_field_print(m, field);\n\t}\n\n\tseq_puts(m, \":vals=\");\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thave_var = true;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (i == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tseq_puts(m, \",\");\n\t\t\thist_field_print(m, field);\n\t\t}\n\t}\n\n\tif (have_var) {\n\t\tunsigned int n = 0;\n\n\t\tseq_puts(m, \":\");\n\n\t\tfor_each_hist_val_field(i, hist_data) {\n\t\t\tfield = hist_data->fields[i];\n\n\t\t\tif (field->flags & HIST_FIELD_FL_VAR) {\n\t\t\t\tif (n++)\n\t\t\t\t\tseq_puts(m, \",\");\n\t\t\t\thist_field_print(m, field);\n\t\t\t}\n\t\t}\n\t}\n\n\tseq_puts(m, \":sort=\");\n\n\tfor (i = 0; i < hist_data->n_sort_keys; i++) {\n\t\tstruct tracing_map_sort_key *sort_key;\n\t\tunsigned int idx, first_key_idx;\n\n\t\t/* skip VAR vals */\n\t\tfirst_key_idx = hist_data->n_vals - hist_data->n_vars;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\t\tidx = sort_key->field_idx;\n\n\t\tif (WARN_ON(idx >= HIST_FIELDS_MAX))\n\t\t\treturn -EINVAL;\n\n\t\tif (i > 0)\n\t\t\tseq_puts(m, \",\");\n\n\t\tif (idx == HITCOUNT_IDX)\n\t\t\tseq_puts(m, \"hitcount\");\n\t\telse {\n\t\t\tif (idx >= first_key_idx)\n\t\t\t\tidx += hist_data->n_vars;\n\t\t\thist_field_print(m, hist_data->fields[idx]);\n\t\t}\n\n\t\tif (sort_key->descending)\n\t\t\tseq_puts(m, \".descending\");\n\t}\n\tseq_printf(m, \":size=%u\", (1 << hist_data->map->map_bits));\n\tif (hist_data->enable_timestamps)\n\t\tseq_printf(m, \":clock=%s\", hist_data->attrs->clock);\n\n\tprint_actions_spec(m, hist_data);\n\n\tif (data->filter_str)\n\t\tseq_printf(m, \" if %s\", data->filter_str);\n\n\tif (data->paused)\n\t\tseq_puts(m, \" [paused]\");\n\telse\n\t\tseq_puts(m, \" [active]\");\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hist_field_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4913-4939",
    "snippet": "static void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"cpu\");\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\".%s\"",
            "flags"
          ],
          "line": 4936
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_hist_field_flags",
          "args": [
            "hist_field"
          ],
          "line": 4933
        },
        "resolved": true,
        "details": {
          "function_name": "get_hist_field_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2037-2057",
          "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"common_timestamp\""
          ],
          "line": 4928
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'$'"
          ],
          "line": 4925
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 4915
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1687-1722",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_field_print(struct seq_file *m, struct hist_field *hist_field)\n{\n\tconst char *field_name = hist_field_name(hist_field, 0);\n\n\tif (hist_field->var.name)\n\t\tseq_printf(m, \"%s=\", hist_field->var.name);\n\n\tif (hist_field->flags & HIST_FIELD_FL_CPU)\n\t\tseq_puts(m, \"cpu\");\n\telse if (field_name) {\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF ||\n\t\t    hist_field->flags & HIST_FIELD_FL_ALIAS)\n\t\t\tseq_putc(m, '$');\n\t\tseq_printf(m, \"%s\", field_name);\n\t} else if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tseq_puts(m, \"common_timestamp\");\n\n\tif (hist_field->flags) {\n\t\tif (!(hist_field->flags & HIST_FIELD_FL_VAR_REF) &&\n\t\t    !(hist_field->flags & HIST_FIELD_FL_EXPR)) {\n\t\t\tconst char *flags = get_hist_field_flags(hist_field);\n\n\t\t\tif (flags)\n\t\t\t\tseq_printf(m, \".%s\", flags);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "event_hist_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4901-4904",
    "snippet": "static int event_hist_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, hist_show, file);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "hist_show",
            "file"
          ],
          "line": 4903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, hist_show, file);\n}"
  },
  {
    "function_name": "hist_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4871-4899",
    "snippet": "static int hist_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry_rcu(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_show(m, data, n++);\n\t}\n\n\tif (have_hist_err()) {\n\t\tseq_printf(m, \"\\nERROR: %s\\n\", hist_err_str);\n\t\tseq_printf(m, \"  Last command: %s\\n\", last_hist_cmd);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_hist_cmd[MAX_FILTER_STR_VAL];",
      "static char hist_err_str[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 4896
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  Last command: %s\\n\"",
            "last_hist_cmd"
          ],
          "line": 4892
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_hist_err",
          "args": [],
          "line": 4890
        },
        "resolved": true,
        "details": {
          "function_name": "have_hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "397-403",
          "snippet": "static bool have_hist_err(void)\n{\n\tif (strlen(hist_err_str))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic bool have_hist_err(void)\n{\n\tif (strlen(hist_err_str))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_show",
          "args": [
            "m",
            "data",
            "n++"
          ],
          "line": 4887
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_show",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4848-4869",
          "snippet": "static void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "data",
            "&event_file->triggers",
            "list"
          ],
          "line": 4885
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!event_file"
          ],
          "line": 4880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file_data",
          "args": [
            "m->private"
          ],
          "line": 4879
        },
        "resolved": true,
        "details": {
          "function_name": "event_file_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1463-1466",
          "snippet": "static inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline void *event_file_data(struct file *filp)\n{\n\treturn READ_ONCE(file_inode(filp)->i_private);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 4877
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_hist_cmd[MAX_FILTER_STR_VAL];\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic int hist_show(struct seq_file *m, void *v)\n{\n\tstruct event_trigger_data *data;\n\tstruct trace_event_file *event_file;\n\tint n = 0, ret = 0;\n\n\tmutex_lock(&event_mutex);\n\n\tevent_file = event_file_data(m->private);\n\tif (unlikely(!event_file)) {\n\t\tret = -ENODEV;\n\t\tgoto out_unlock;\n\t}\n\n\tlist_for_each_entry_rcu(data, &event_file->triggers, list) {\n\t\tif (data->cmd_ops->trigger_type == ETT_EVENT_HIST)\n\t\t\thist_trigger_show(m, data, n++);\n\t}\n\n\tif (have_hist_err()) {\n\t\tseq_printf(m, \"\\nERROR: %s\\n\", hist_err_str);\n\t\tseq_printf(m, \"  Last command: %s\\n\", last_hist_cmd);\n\t}\n\n out_unlock:\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "hist_trigger_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4848-4869",
    "snippet": "static void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\"",
            "(u64)atomic64_read(&hist_data->map->hits)",
            "n_entries",
            "(u64)atomic64_read(&hist_data->map->drops)"
          ],
          "line": 4866
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&hist_data->map->drops"
          ],
          "line": 4868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic64_read",
          "args": [
            "&hist_data->map->hits"
          ],
          "line": 4867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_entries",
          "args": [
            "m",
            "hist_data"
          ],
          "line": 4862
        },
        "resolved": true,
        "details": {
          "function_name": "print_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4825-4846",
          "snippet": "static int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"#\\n\\n\""
          ],
          "line": 4859
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "data->ops->print",
          "args": [
            "m",
            "data->ops",
            "data"
          ],
          "line": 4858
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_show(struct seq_file *m,\n\t\t\t      struct event_trigger_data *data, int n)\n{\n\tstruct hist_trigger_data *hist_data;\n\tint n_entries;\n\n\tif (n > 0)\n\t\tseq_puts(m, \"\\n\\n\");\n\n\tseq_puts(m, \"# event histogram\\n#\\n# trigger info: \");\n\tdata->ops->print(m, data->ops, data);\n\tseq_puts(m, \"#\\n\\n\");\n\n\thist_data = data->private_data;\n\tn_entries = print_entries(m, hist_data);\n\tif (n_entries < 0)\n\t\tn_entries = 0;\n\n\tseq_printf(m, \"\\nTotals:\\n    Hits: %llu\\n    Entries: %u\\n    Dropped: %llu\\n\",\n\t\t   (u64)atomic64_read(&hist_data->map->hits),\n\t\t   n_entries, (u64)atomic64_read(&hist_data->map->drops));\n}"
  },
  {
    "function_name": "print_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4825-4846",
    "snippet": "static int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_destroy_sort_entries",
          "args": [
            "sort_entries",
            "n_entries"
          ],
          "line": 4843
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy_sort_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "923-932",
          "snippet": "void tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy_sort_entries(struct tracing_map_sort_entry **entries,\n\t\t\t\t      unsigned int n_entries)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\tdestroy_sort_entry(entries[i]);\n\n\tvfree(entries);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_entry_print",
          "args": [
            "m",
            "hist_data",
            "sort_entries[i]->key",
            "sort_entries[i]->elt"
          ],
          "line": 4839
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_entry_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4721-4823",
          "snippet": "static void\nhist_trigger_entry_print(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data, void *key,\n\t\t\t struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tchar str[KSYM_SYMBOL_LEN];\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol_no_offset(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HITCOUNT_IDX\t\t0",
            "#define HIST_STACKTRACE_DEPTH\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void\nhist_trigger_entry_print(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data, void *key,\n\t\t\t struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tchar str[KSYM_SYMBOL_LEN];\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol_no_offset(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_sort_entries",
          "args": [
            "map",
            "hist_data->sort_keys",
            "hist_data->n_sort_keys",
            "&sort_entries"
          ],
          "line": 4832
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_sort_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "1059-1125",
          "snippet": "int tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const struct tracing_map_sort_entry **,\n\t\t\t      const struct tracing_map_sort_entry **);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_sort_entries(struct tracing_map *map,\n\t\t\t     struct tracing_map_sort_key *sort_keys,\n\t\t\t     unsigned int n_sort_keys,\n\t\t\t     struct tracing_map_sort_entry ***sort_entries)\n{\n\tint (*cmp_entries_fn)(const struct tracing_map_sort_entry **,\n\t\t\t      const struct tracing_map_sort_entry **);\n\tstruct tracing_map_sort_entry *sort_entry, **entries;\n\tint i, n_entries, ret;\n\n\tentries = vmalloc(array_size(sizeof(sort_entry), map->max_elts));\n\tif (!entries)\n\t\treturn -ENOMEM;\n\n\tfor (i = 0, n_entries = 0; i < map->map_size; i++) {\n\t\tstruct tracing_map_entry *entry;\n\n\t\tentry = TRACING_MAP_ENTRY(map->map, i);\n\n\t\tif (!entry->key || !entry->val)\n\t\t\tcontinue;\n\n\t\tentries[n_entries] = create_sort_entry(entry->val->key,\n\t\t\t\t\t\t       entry->val);\n\t\tif (!entries[n_entries++]) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (n_entries == 0) {\n\t\tret = 0;\n\t\tgoto free;\n\t}\n\n\tif (n_entries == 1) {\n\t\t*sort_entries = entries;\n\t\treturn 1;\n\t}\n\n\tdetect_dups(entries, n_entries, map->key_size);\n\n\tif (is_key(map, sort_keys[0].field_idx))\n\t\tcmp_entries_fn = cmp_entries_key;\n\telse\n\t\tcmp_entries_fn = cmp_entries_sum;\n\n\tset_sort_key(map, &sort_keys[0]);\n\n\tsort(entries, n_entries, sizeof(struct tracing_map_sort_entry *),\n\t     (int (*)(const void *, const void *))cmp_entries_fn, NULL);\n\n\tif (n_sort_keys > 1)\n\t\tsort_secondary(map,\n\t\t\t       (const struct tracing_map_sort_entry **)entries,\n\t\t\t       n_entries,\n\t\t\t       &sort_keys[0],\n\t\t\t       &sort_keys[1]);\n\n\t*sort_entries = entries;\n\n\treturn n_entries;\n free:\n\ttracing_map_destroy_sort_entries(entries, n_entries);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int print_entries(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map_sort_entry **sort_entries = NULL;\n\tstruct tracing_map *map = hist_data->map;\n\tint i, n_entries;\n\n\tn_entries = tracing_map_sort_entries(map, hist_data->sort_keys,\n\t\t\t\t\t     hist_data->n_sort_keys,\n\t\t\t\t\t     &sort_entries);\n\tif (n_entries < 0)\n\t\treturn n_entries;\n\n\tfor (i = 0; i < n_entries; i++)\n\t\thist_trigger_entry_print(m, hist_data,\n\t\t\t\t\t sort_entries[i]->key,\n\t\t\t\t\t sort_entries[i]->elt);\n\n\ttracing_map_destroy_sort_entries(sort_entries, n_entries);\n\n\treturn n_entries;\n}"
  },
  {
    "function_name": "hist_trigger_entry_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4721-4823",
    "snippet": "static void\nhist_trigger_entry_print(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data, void *key,\n\t\t\t struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tchar str[KSYM_SYMBOL_LEN];\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol_no_offset(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0",
      "#define HIST_STACKTRACE_DEPTH\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\"\\n\""
          ],
          "line": 4822
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_actions",
          "args": [
            "m",
            "hist_data",
            "elt"
          ],
          "line": 4820
        },
        "resolved": true,
        "details": {
          "function_name": "print_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4328-4340",
          "snippet": "static void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == onmax_save)\n\t\t\tonmax_print(m, hist_data, elt, data);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == onmax_save)\n\t\t\tonmax_print(m, hist_data, elt, data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s: %10llu\"",
            "field_name",
            "tracing_map_read_sum(elt, i)"
          ],
          "line": 4815
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_read_sum",
          "args": [
            "elt",
            "i"
          ],
          "line": 4816
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "55-58",
          "snippet": "u64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_sum(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn (u64)atomic64_read(&elt->fields[i].sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_data->fields[i]",
            "0"
          ],
          "line": 4805
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1687-1722",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_stacktrace_print",
          "args": [
            "m",
            "key + key_field->offset",
            "HIST_STACKTRACE_DEPTH"
          ],
          "line": 4780
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_stacktrace_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4703-4719",
          "snippet": "static void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (stacktrace_entries[i] == ULONG_MAX)\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tsprint_symbol(str, stacktrace_entries[i]);\n\t\tseq_printf(m, \"%s\\n\", str);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (stacktrace_entries[i] == ULONG_MAX)\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tsprint_symbol(str, stacktrace_entries[i]);\n\t\tseq_printf(m, \"%s\\n\", str);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_syscall_name",
          "args": [
            "uval"
          ],
          "line": 4772
        },
        "resolved": true,
        "details": {
          "function_name": "get_syscall_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1805-1808",
          "snippet": "static inline const char *get_syscall_name(int syscall)\n{\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline const char *get_syscall_name(int syscall)\n{\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!elt_data"
          ],
          "line": 4760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprint_symbol",
          "args": [
            "str",
            "uval"
          ],
          "line": 4753
        },
        "resolved": true,
        "details": {
          "function_name": "sprint_symbol_no_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "407-410",
          "snippet": "int sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4735
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void\nhist_trigger_entry_print(struct seq_file *m,\n\t\t\t struct hist_trigger_data *hist_data, void *key,\n\t\t\t struct tracing_map_elt *elt)\n{\n\tstruct hist_field *key_field;\n\tchar str[KSYM_SYMBOL_LEN];\n\tbool multiline = false;\n\tconst char *field_name;\n\tunsigned int i;\n\tu64 uval;\n\n\tseq_puts(m, \"{ \");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (i > hist_data->n_vals)\n\t\t\tseq_puts(m, \", \");\n\n\t\tfield_name = hist_field_name(key_field, 0);\n\n\t\tif (key_field->flags & HIST_FIELD_FL_HEX) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %llx\", field_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol_no_offset(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-45s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYM_OFFSET) {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsprint_symbol(str, uval);\n\t\t\tseq_printf(m, \"%s: [%llx] %-55s\", field_name,\n\t\t\t\t   uval, str);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\tstruct hist_elt_data *elt_data = elt->private_data;\n\t\t\tchar *comm;\n\n\t\t\tif (WARN_ON_ONCE(!elt_data))\n\t\t\t\treturn;\n\n\t\t\tcomm = elt_data->comm;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %-16s[%10llu]\", field_name,\n\t\t\t\t   comm, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_SYSCALL) {\n\t\t\tconst char *syscall_name;\n\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tsyscall_name = get_syscall_name(uval);\n\t\t\tif (!syscall_name)\n\t\t\t\tsyscall_name = \"unknown_syscall\";\n\n\t\t\tseq_printf(m, \"%s: %-30s[%3llu]\", field_name,\n\t\t\t\t   syscall_name, uval);\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tseq_puts(m, \"stacktrace:\\n\");\n\t\t\thist_trigger_stacktrace_print(m,\n\t\t\t\t\t\t      key + key_field->offset,\n\t\t\t\t\t\t      HIST_STACKTRACE_DEPTH);\n\t\t\tmultiline = true;\n\t\t} else if (key_field->flags & HIST_FIELD_FL_LOG2) {\n\t\t\tseq_printf(m, \"%s: ~ 2^%-2llu\", field_name,\n\t\t\t\t   *(u64 *)(key + key_field->offset));\n\t\t} else if (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"%s: %-50s\", field_name,\n\t\t\t\t   (char *)(key + key_field->offset));\n\t\t} else {\n\t\t\tuval = *(u64 *)(key + key_field->offset);\n\t\t\tseq_printf(m, \"%s: %10llu\", field_name, uval);\n\t\t}\n\t}\n\n\tif (!multiline)\n\t\tseq_puts(m, \" \");\n\n\tseq_puts(m, \"}\");\n\n\tseq_printf(m, \" hitcount: %10llu\",\n\t\t   tracing_map_read_sum(elt, HITCOUNT_IDX));\n\n\tfor (i = 1; i < hist_data->n_vals; i++) {\n\t\tfield_name = hist_field_name(hist_data->fields[i], 0);\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_VAR ||\n\t\t    hist_data->fields[i]->flags & HIST_FIELD_FL_EXPR)\n\t\t\tcontinue;\n\n\t\tif (hist_data->fields[i]->flags & HIST_FIELD_FL_HEX) {\n\t\t\tseq_printf(m, \"  %s: %10llx\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t} else {\n\t\t\tseq_printf(m, \"  %s: %10llu\", field_name,\n\t\t\t\t   tracing_map_read_sum(elt, i));\n\t\t}\n\t}\n\n\tprint_actions(m, hist_data, elt);\n\n\tseq_puts(m, \"\\n\");\n}"
  },
  {
    "function_name": "hist_trigger_stacktrace_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4703-4719",
    "snippet": "static void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (stacktrace_entries[i] == ULONG_MAX)\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tsprint_symbol(str, stacktrace_entries[i]);\n\t\tseq_printf(m, \"%s\\n\", str);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\\n\"",
            "str"
          ],
          "line": 4717
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprint_symbol",
          "args": [
            "str",
            "stacktrace_entries[i]"
          ],
          "line": 4716
        },
        "resolved": true,
        "details": {
          "function_name": "sprint_symbol_no_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kallsyms.c",
          "lines": "407-410",
          "snippet": "int sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/filter.h>",
            "#include <linux/slab.h>",
            "#include <linux/ctype.h>",
            "#include <linux/sched.h>\t/* for cond_resched */",
            "#include <linux/proc_fs.h>",
            "#include <linux/err.h>",
            "#include <linux/kdb.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/init.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/ftrace.h>\n#include <linux/filter.h>\n#include <linux/slab.h>\n#include <linux/ctype.h>\n#include <linux/sched.h>\t/* for cond_resched */\n#include <linux/proc_fs.h>\n#include <linux/err.h>\n#include <linux/kdb.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <linux/init.h>\n#include <linux/kallsyms.h>\n\nint sprint_symbol_no_offset(char *buffer, unsigned long address)\n{\n\treturn __sprint_symbol(buffer, address, 0, 0);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_stacktrace_print(struct seq_file *m,\n\t\t\t\t\t  unsigned long *stacktrace_entries,\n\t\t\t\t\t  unsigned int max_entries)\n{\n\tchar str[KSYM_SYMBOL_LEN];\n\tunsigned int spaces = 8;\n\tunsigned int i;\n\n\tfor (i = 0; i < max_entries; i++) {\n\t\tif (stacktrace_entries[i] == ULONG_MAX)\n\t\t\treturn;\n\n\t\tseq_printf(m, \"%*c\", 1 + spaces, ' ');\n\t\tsprint_symbol(str, stacktrace_entries[i]);\n\t\tseq_printf(m, \"%s\\n\", str);\n\t}\n}"
  },
  {
    "function_name": "event_hist_trigger",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4643-4701",
    "snippet": "static void event_hist_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t       struct ring_buffer_event *rbe)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tbool use_compound_key = (hist_data->n_keys > 1);\n\tunsigned long entries[HIST_STACKTRACE_DEPTH];\n\tu64 var_ref_vals[TRACING_MAP_VARS_MAX];\n\tchar compound_key[HIST_KEY_SIZE_MAX];\n\tstruct tracing_map_elt *elt = NULL;\n\tstruct stack_trace stacktrace;\n\tstruct hist_field *key_field;\n\tu64 field_contents;\n\tvoid *key = NULL;\n\tunsigned int i;\n\n\tmemset(compound_key, 0, hist_data->key_size);\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tstacktrace.max_entries = HIST_STACKTRACE_DEPTH;\n\t\t\tstacktrace.entries = entries;\n\t\t\tstacktrace.nr_entries = 0;\n\t\t\tstacktrace.skip = HIST_STACKTRACE_SKIP;\n\n\t\t\tmemset(stacktrace.entries, 0, HIST_STACKTRACE_SIZE);\n\t\t\tsave_stack_trace(&stacktrace);\n\n\t\t\tkey = entries;\n\t\t} else {\n\t\t\tfield_contents = key_field->fn(key_field, elt, rbe, rec);\n\t\t\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tkey = (void *)(unsigned long)field_contents;\n\t\t\t\tuse_compound_key = true;\n\t\t\t} else\n\t\t\t\tkey = (void *)&field_contents;\n\t\t}\n\n\t\tif (use_compound_key)\n\t\t\tadd_to_key(compound_key, key, key_field, rec);\n\t}\n\n\tif (use_compound_key)\n\t\tkey = compound_key;\n\n\tif (hist_data->n_var_refs &&\n\t    !resolve_var_refs(hist_data, key, var_ref_vals, false))\n\t\treturn;\n\n\telt = tracing_map_insert(hist_data->map, key);\n\tif (!elt)\n\t\treturn;\n\n\thist_trigger_elt_update(hist_data, elt, rec, rbe, var_ref_vals);\n\n\tif (resolve_var_refs(hist_data, key, var_ref_vals, true))\n\t\thist_trigger_actions(hist_data, elt, rec, rbe, var_ref_vals);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
      "#define HIST_STACKTRACE_SKIP\t5",
      "#define HIST_STACKTRACE_SIZE\t(HIST_STACKTRACE_DEPTH * sizeof(unsigned long))",
      "#define HIST_STACKTRACE_DEPTH\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_trigger_actions",
          "args": [
            "hist_data",
            "elt",
            "rec",
            "rbe",
            "var_ref_vals"
          ],
          "line": 4700
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4629-4641",
          "snippet": "static void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt, void *rec,\n\t\t     struct ring_buffer_event *rbe, u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, rec, rbe, data, var_ref_vals);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt, void *rec,\n\t\t     struct ring_buffer_event *rbe, u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, rec, rbe, data, var_ref_vals);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "resolve_var_refs",
          "args": [
            "hist_data",
            "key",
            "var_ref_vals",
            "true"
          ],
          "line": 4699
        },
        "resolved": true,
        "details": {
          "function_name": "resolve_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1641-1685",
          "snippet": "static bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_trigger_elt_update",
          "args": [
            "hist_data",
            "elt",
            "rec",
            "rbe",
            "var_ref_vals"
          ],
          "line": 4697
        },
        "resolved": true,
        "details": {
          "function_name": "hist_trigger_elt_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4569-4603",
          "snippet": "static void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, rbe, rec);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, rbe, rec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_insert",
          "args": [
            "hist_data->map",
            "key"
          ],
          "line": 4693
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_insert",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "631-634",
          "snippet": "struct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_insert(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_to_key",
          "args": [
            "compound_key",
            "key",
            "key_field",
            "rec"
          ],
          "line": 4683
        },
        "resolved": true,
        "details": {
          "function_name": "add_to_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4605-4627",
          "snippet": "static inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_PTR_STRING)\n\t\t\tsize = strlen(key);\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\t}\n\n\tmemcpy(compound_key + key_field->offset, key, size);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_PTR_STRING)\n\t\t\tsize = strlen(key);\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\t}\n\n\tmemcpy(compound_key + key_field->offset, key, size);\n}"
        }
      },
      {
        "call_info": {
          "callee": "key_field->fn",
          "args": [
            "key_field",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 4674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "save_stack_trace",
          "args": [
            "&stacktrace"
          ],
          "line": 4670
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stacktrace.entries",
            "0",
            "HIST_STACKTRACE_SIZE"
          ],
          "line": 4669
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "compound_key",
            "0",
            "hist_data->key_size"
          ],
          "line": 4658
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_SKIP\t5\n#define HIST_STACKTRACE_SIZE\t(HIST_STACKTRACE_DEPTH * sizeof(unsigned long))\n#define HIST_STACKTRACE_DEPTH\t16\n\nstatic void event_hist_trigger(struct event_trigger_data *data, void *rec,\n\t\t\t       struct ring_buffer_event *rbe)\n{\n\tstruct hist_trigger_data *hist_data = data->private_data;\n\tbool use_compound_key = (hist_data->n_keys > 1);\n\tunsigned long entries[HIST_STACKTRACE_DEPTH];\n\tu64 var_ref_vals[TRACING_MAP_VARS_MAX];\n\tchar compound_key[HIST_KEY_SIZE_MAX];\n\tstruct tracing_map_elt *elt = NULL;\n\tstruct stack_trace stacktrace;\n\tstruct hist_field *key_field;\n\tu64 field_contents;\n\tvoid *key = NULL;\n\tunsigned int i;\n\n\tmemset(compound_key, 0, hist_data->key_size);\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_STACKTRACE) {\n\t\t\tstacktrace.max_entries = HIST_STACKTRACE_DEPTH;\n\t\t\tstacktrace.entries = entries;\n\t\t\tstacktrace.nr_entries = 0;\n\t\t\tstacktrace.skip = HIST_STACKTRACE_SKIP;\n\n\t\t\tmemset(stacktrace.entries, 0, HIST_STACKTRACE_SIZE);\n\t\t\tsave_stack_trace(&stacktrace);\n\n\t\t\tkey = entries;\n\t\t} else {\n\t\t\tfield_contents = key_field->fn(key_field, elt, rbe, rec);\n\t\t\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\t\t\tkey = (void *)(unsigned long)field_contents;\n\t\t\t\tuse_compound_key = true;\n\t\t\t} else\n\t\t\t\tkey = (void *)&field_contents;\n\t\t}\n\n\t\tif (use_compound_key)\n\t\t\tadd_to_key(compound_key, key, key_field, rec);\n\t}\n\n\tif (use_compound_key)\n\t\tkey = compound_key;\n\n\tif (hist_data->n_var_refs &&\n\t    !resolve_var_refs(hist_data, key, var_ref_vals, false))\n\t\treturn;\n\n\telt = tracing_map_insert(hist_data->map, key);\n\tif (!elt)\n\t\treturn;\n\n\thist_trigger_elt_update(hist_data, elt, rec, rbe, var_ref_vals);\n\n\tif (resolve_var_refs(hist_data, key, var_ref_vals, true))\n\t\thist_trigger_actions(hist_data, elt, rec, rbe, var_ref_vals);\n}"
  },
  {
    "function_name": "hist_trigger_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4629-4641",
    "snippet": "static void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt, void *rec,\n\t\t     struct ring_buffer_event *rbe, u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, rec, rbe, data, var_ref_vals);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "data->fn",
          "args": [
            "hist_data",
            "elt",
            "rec",
            "rbe",
            "data",
            "var_ref_vals"
          ],
          "line": 4639
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void\nhist_trigger_actions(struct hist_trigger_data *hist_data,\n\t\t     struct tracing_map_elt *elt, void *rec,\n\t\t     struct ring_buffer_event *rbe, u64 *var_ref_vals)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\t\tdata->fn(hist_data, elt, rec, rbe, data, var_ref_vals);\n\t}\n}"
  },
  {
    "function_name": "add_to_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4605-4627",
    "snippet": "static inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_PTR_STRING)\n\t\t\tsize = strlen(key);\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\t}\n\n\tmemcpy(compound_key + key_field->offset, key, size);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "compound_key + key_field->offset",
            "key",
            "size"
          ],
          "line": 4626
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "key"
          ],
          "line": 4617
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void add_to_key(char *compound_key, void *key,\n\t\t\t      struct hist_field *key_field, void *rec)\n{\n\tsize_t size = key_field->size;\n\n\tif (key_field->flags & HIST_FIELD_FL_STRING) {\n\t\tstruct ftrace_event_field *field;\n\n\t\tfield = key_field->field;\n\t\tif (field->filter_type == FILTER_DYN_STRING)\n\t\t\tsize = *(u32 *)(rec + field->offset) >> 16;\n\t\telse if (field->filter_type == FILTER_PTR_STRING)\n\t\t\tsize = strlen(key);\n\t\telse if (field->filter_type == FILTER_STATIC_STRING)\n\t\t\tsize = field->size;\n\n\t\t/* ensure NULL-termination */\n\t\tif (size > key_field->size - 1)\n\t\t\tsize = key_field->size - 1;\n\t}\n\n\tmemcpy(compound_key + key_field->offset, key, size);\n}"
  },
  {
    "function_name": "hist_trigger_elt_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4569-4603",
    "snippet": "static void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, rbe, rec);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_field_vars",
          "args": [
            "hist_data",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 4602
        },
        "resolved": true,
        "details": {
          "function_name": "update_field_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3114-3121",
          "snippet": "static void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "var_idx",
            "hist_val"
          ],
          "line": 4598
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "70-74",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field->fn",
          "args": [
            "hist_field",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 4596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_update_sum",
          "args": [
            "elt",
            "i",
            "hist_val"
          ],
          "line": 4590
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_update_sum",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "38-41",
          "snippet": "void tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_update_sum(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_add(n, &elt->fields[i].sum);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_field->fn",
          "args": [
            "hist_field",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 4584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_val_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4582
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_update(struct hist_trigger_data *hist_data,\n\t\t\t\t    struct tracing_map_elt *elt, void *rec,\n\t\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t\t    u64 *var_ref_vals)\n{\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tu64 hist_val;\n\n\telt_data = elt->private_data;\n\telt_data->var_ref_vals = var_ref_vals;\n\n\tfor_each_hist_val_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t\tcontinue;\n\t\t}\n\t\ttracing_map_update_sum(elt, i, hist_val);\n\t}\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\thist_val = hist_field->fn(hist_field, elt, rbe, rec);\n\t\t\tvar_idx = hist_field->var.idx;\n\t\t\ttracing_map_set_var(elt, var_idx, hist_val);\n\t\t}\n\t}\n\n\tupdate_field_vars(hist_data, elt, rbe, rec);\n}"
  },
  {
    "function_name": "create_hist_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4514-4567",
    "snippet": "static struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 4564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_data",
          "args": [
            "hist_data"
          ],
          "line": 4562
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4452-4467",
          "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_tracing_map_fields",
          "args": [
            "hist_data"
          ],
          "line": 4554
        },
        "resolved": true,
        "details": {
          "function_name": "create_tracing_map_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4469-4512",
          "snippet": "static int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_data->map"
          ],
          "line": 4549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_data->map"
          ],
          "line": 4548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_create",
          "args": [
            "map_bits",
            "hist_data->key_size",
            "map_ops",
            "hist_data"
          ],
          "line": 4546
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "760-800",
          "snippet": "struct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map *tracing_map_create(unsigned int map_bits,\n\t\t\t\t       unsigned int key_size,\n\t\t\t\t       const struct tracing_map_ops *ops,\n\t\t\t\t       void *private_data)\n{\n\tstruct tracing_map *map;\n\tunsigned int i;\n\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tmap = kzalloc(sizeof(*map), GFP_KERNEL);\n\tif (!map)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmap->map_bits = map_bits;\n\tmap->max_elts = (1 << map_bits);\n\tatomic_set(&map->next_elt, -1);\n\n\tmap->map_size = (1 << (map_bits + 1));\n\tmap->ops = ops;\n\n\tmap->private_data = private_data;\n\n\tmap->map = tracing_map_array_alloc(map->map_size,\n\t\t\t\t\t   sizeof(struct tracing_map_entry));\n\tif (!map->map)\n\t\tgoto free;\n\n\tmap->key_size = key_size;\n\tfor (i = 0; i < TRACING_MAP_KEYS_MAX; i++)\n\t\tmap->key_idx[i] = -1;\n out:\n\treturn map;\n free:\n\ttracing_map_destroy(map);\n\tmap = ERR_PTR(-ENOMEM);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_sort_keys",
          "args": [
            "hist_data"
          ],
          "line": 4540
        },
        "resolved": true,
        "details": {
          "function_name": "create_sort_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4162-4246",
          "snippet": "static int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str) {\n\t\t\tif (i == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str) {\n\t\t\tif (i == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4536
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4122-4146",
          "snippet": "static int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_actions",
          "args": [
            "hist_data"
          ],
          "line": 4532
        },
        "resolved": true,
        "details": {
          "function_name": "parse_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4264-4302",
          "snippet": "static int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif (strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmatch(\");\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = action_trace;\n\t\t} else if (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmax(\");\n\n\t\t\tdata = onmax_parse(action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = onmax_save;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif (strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmatch(\");\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = action_trace;\n\t\t} else if (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmax(\");\n\n\t\t\tdata = onmax_parse(action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = onmax_save;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 4526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*hist_data)",
            "GFP_KERNEL"
          ],
          "line": 4524
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct tracing_map_ops hist_trigger_elt_data_ops = {\n\t.elt_alloc\t= hist_trigger_elt_data_alloc,\n\t.elt_free\t= hist_trigger_elt_data_free,\n\t.elt_init\t= hist_trigger_elt_data_init,\n};\n\nstatic struct hist_trigger_data *\ncreate_hist_data(unsigned int map_bits,\n\t\t struct hist_trigger_attrs *attrs,\n\t\t struct trace_event_file *file,\n\t\t bool remove)\n{\n\tconst struct tracing_map_ops *map_ops = NULL;\n\tstruct hist_trigger_data *hist_data;\n\tint ret = 0;\n\n\thist_data = kzalloc(sizeof(*hist_data), GFP_KERNEL);\n\tif (!hist_data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\thist_data->attrs = attrs;\n\thist_data->remove = remove;\n\thist_data->event_file = file;\n\n\tret = parse_actions(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_hist_fields(hist_data, file);\n\tif (ret)\n\t\tgoto free;\n\n\tret = create_sort_keys(hist_data);\n\tif (ret)\n\t\tgoto free;\n\n\tmap_ops = &hist_trigger_elt_data_ops;\n\n\thist_data->map = tracing_map_create(map_bits, hist_data->key_size,\n\t\t\t\t\t    map_ops, hist_data);\n\tif (IS_ERR(hist_data->map)) {\n\t\tret = PTR_ERR(hist_data->map);\n\t\thist_data->map = NULL;\n\t\tgoto free;\n\t}\n\n\tret = create_tracing_map_fields(hist_data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn hist_data;\n free:\n\thist_data->attrs = NULL;\n\n\tdestroy_hist_data(hist_data);\n\n\thist_data = ERR_PTR(ret);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "create_tracing_map_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4469-4512",
    "snippet": "static int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_add_var",
          "args": [
            "map"
          ],
          "line": 4503
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "243-251",
          "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_add_sum_field",
          "args": [
            "map"
          ],
          "line": 4497
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_sum_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "226-229",
          "snippet": "int tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_sum_field(struct tracing_map *map)\n{\n\treturn tracing_map_add_field(map, tracing_map_cmp_atomic64);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_add_key_field",
          "args": [
            "map",
            "hist_field->offset",
            "cmp_fn"
          ],
          "line": 4493
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_key_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "269-284",
          "snippet": "int tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_key_field(struct tracing_map *map,\n\t\t\t      unsigned int offset,\n\t\t\t      tracing_map_cmp_fn_t cmp_fn)\n\n{\n\tint idx = tracing_map_add_field(map, cmp_fn);\n\n\tif (idx < 0)\n\t\treturn idx;\n\n\tmap->fields[idx].offset = offset;\n\n\tmap->key_idx[map->n_keys++] = idx;\n\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_cmp_num",
          "args": [
            "field->size",
            "field->is_signed"
          ],
          "line": 4491
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_cmp_num",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "166-199",
          "snippet": "tracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\ntracing_map_cmp_fn_t tracing_map_cmp_num(int field_size,\n\t\t\t\t\t int field_is_signed)\n{\n\ttracing_map_cmp_fn_t fn = tracing_map_cmp_none;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s64;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s32;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s16;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = tracing_map_cmp_s8;\n\t\telse\n\t\t\tfn = tracing_map_cmp_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 4488
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1417-1423",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 4476
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_tracing_map_fields(struct hist_trigger_data *hist_data)\n{\n\tstruct tracing_map *map = hist_data->map;\n\tstruct ftrace_event_field *field;\n\tstruct hist_field *hist_field;\n\tint i, idx = 0;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field->flags & HIST_FIELD_FL_KEY) {\n\t\t\ttracing_map_cmp_fn_t cmp_fn;\n\n\t\t\tfield = hist_field->field;\n\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_STACKTRACE)\n\t\t\t\tcmp_fn = tracing_map_cmp_none;\n\t\t\telse if (!field)\n\t\t\t\tcmp_fn = tracing_map_cmp_num(hist_field->size,\n\t\t\t\t\t\t\t     hist_field->is_signed);\n\t\t\telse if (is_string_field(field))\n\t\t\t\tcmp_fn = tracing_map_cmp_string;\n\t\t\telse\n\t\t\t\tcmp_fn = tracing_map_cmp_num(field->size,\n\t\t\t\t\t\t\t     field->is_signed);\n\t\t\tidx = tracing_map_add_key_field(map,\n\t\t\t\t\t\t\thist_field->offset,\n\t\t\t\t\t\t\tcmp_fn);\n\t\t} else if (!(hist_field->flags & HIST_FIELD_FL_VAR))\n\t\t\tidx = tracing_map_add_sum_field(map);\n\n\t\tif (idx < 0)\n\t\t\treturn idx;\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tidx = tracing_map_add_var(map);\n\t\t\tif (idx < 0)\n\t\t\t\treturn idx;\n\t\t\thist_field->var.idx = idx;\n\t\t\thist_field->var.hist_data = hist_data;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "destroy_hist_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4452-4467",
    "snippet": "static void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data"
          ],
          "line": 4466
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_synth_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 4464
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_synth_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3542-3548",
          "snippet": "static void destroy_synth_var_refs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++)\n\t\tdestroy_hist_field(hist_data->synth_var_refs[i], 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_synth_var_refs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++)\n\t\tdestroy_hist_field(hist_data->synth_var_refs[i], 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_field_var_hists",
          "args": [
            "hist_data"
          ],
          "line": 4463
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4442-4450",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_field_vars",
          "args": [
            "hist_data"
          ],
          "line": 4462
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3524-3530",
          "snippet": "static void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_actions",
          "args": [
            "hist_data"
          ],
          "line": 4461
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_actions",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4248-4262",
          "snippet": "static void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tonmax_destroy(data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tonmax_destroy(data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_destroy",
          "args": [
            "hist_data->map"
          ],
          "line": 4459
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "668-677",
          "snippet": "void tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_destroy(struct tracing_map *map)\n{\n\tif (!map)\n\t\treturn;\n\n\ttracing_map_free_elts(map);\n\n\ttracing_map_array_free(map->map);\n\tkfree(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_fields",
          "args": [
            "hist_data"
          ],
          "line": 4458
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2289-2299",
          "snippet": "static void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "hist_data->attrs"
          ],
          "line": 4457
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1783-1802",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_data(struct hist_trigger_data *hist_data)\n{\n\tif (!hist_data)\n\t\treturn;\n\n\tdestroy_hist_trigger_attrs(hist_data->attrs);\n\tdestroy_hist_fields(hist_data);\n\ttracing_map_destroy(hist_data->map);\n\n\tdestroy_actions(hist_data);\n\tdestroy_field_vars(hist_data);\n\tdestroy_field_var_hists(hist_data);\n\tdestroy_synth_var_refs(hist_data);\n\n\tkfree(hist_data);\n}"
  },
  {
    "function_name": "destroy_field_var_hists",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4442-4450",
    "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data->field_var_hists[i]"
          ],
          "line": 4448
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
  },
  {
    "function_name": "print_actions_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4427-4440",
    "snippet": "static void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tprint_onmax_spec(m, hist_data, data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "print_onmax_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4438
        },
        "resolved": true,
        "details": {
          "function_name": "print_onmax_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4342-4358",
          "snippet": "static void print_onmax_spec(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_puts(m, \":onmax(\");\n\tseq_printf(m, \"%s\", data->onmax.var_str);\n\tseq_printf(m, \").%s(\", data->onmax.fn_name);\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tseq_printf(m, \"%s\", hist_data->max_vars[i]->var->var.name);\n\t\tif (i < hist_data->n_max_vars - 1)\n\t\t\tseq_puts(m, \",\");\n\t}\n\tseq_puts(m, \")\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_onmax_spec(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_puts(m, \":onmax(\");\n\tseq_printf(m, \"%s\", data->onmax.var_str);\n\tseq_printf(m, \").%s(\", data->onmax.fn_name);\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tseq_printf(m, \"%s\", hist_data->max_vars[i]->var->var.name);\n\t\tif (i < hist_data->n_max_vars - 1)\n\t\t\tseq_puts(m, \",\");\n\t}\n\tseq_puts(m, \")\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "print_onmatch_spec",
          "args": [
            "m",
            "hist_data",
            "data"
          ],
          "line": 4436
        },
        "resolved": true,
        "details": {
          "function_name": "print_onmatch_spec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4360-4378",
          "snippet": "static void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_printf(m, \":onmatch(%s.%s).\", data->onmatch.match_event_system,\n\t\t   data->onmatch.match_event);\n\n\tseq_printf(m, \"%s(\", data->onmatch.synth_event->name);\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\t\tseq_printf(m, \"%s\", data->params[i]);\n\t}\n\n\tseq_puts(m, \")\");\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_printf(m, \":onmatch(%s.%s).\", data->onmatch.match_event_system,\n\t\t   data->onmatch.match_event);\n\n\tseq_printf(m, \"%s(\", data->onmatch.synth_event->name);\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\t\tseq_printf(m, \"%s\", data->params[i]);\n\t}\n\n\tseq_puts(m, \")\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_actions_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tprint_onmatch_spec(m, hist_data, data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tprint_onmax_spec(m, hist_data, data);\n\t}\n}"
  },
  {
    "function_name": "actions_match",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4380-4424",
    "snippet": "static bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\n\t\tif (data->fn != data_test->fn)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->fn == action_trace) {\n\t\t\tif (strcmp(data->onmatch.synth_event_name,\n\t\t\t\t   data_test->onmatch.synth_event_name) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event_system,\n\t\t\t\t   data_test->onmatch.match_event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event,\n\t\t\t\t   data_test->onmatch.match_event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tif (strcmp(data->onmax.var_str,\n\t\t\t\t   data_test->onmax.var_str) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmax.fn_name,\n\t\t\t\t   data_test->onmax.fn_name) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->onmax.fn_name",
            "data_test->onmax.fn_name"
          ],
          "line": 4417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->onmax.var_str",
            "data_test->onmax.var_str"
          ],
          "line": 4414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->onmatch.match_event",
            "data_test->onmatch.match_event"
          ],
          "line": 4410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->onmatch.match_event_system",
            "data_test->onmatch.match_event_system"
          ],
          "line": 4407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->onmatch.synth_event_name",
            "data_test->onmatch.synth_event_name"
          ],
          "line": 4404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "data->params[j]",
            "data_test->params[j]"
          ],
          "line": 4399
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool actions_match(struct hist_trigger_data *hist_data,\n\t\t\t  struct hist_trigger_data *hist_data_test)\n{\n\tunsigned int i, j;\n\n\tif (hist_data->n_actions != hist_data_test->n_actions)\n\t\treturn false;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\t\tstruct action_data *data_test = hist_data_test->actions[i];\n\n\t\tif (data->fn != data_test->fn)\n\t\t\treturn false;\n\n\t\tif (data->n_params != data_test->n_params)\n\t\t\treturn false;\n\n\t\tfor (j = 0; j < data->n_params; j++) {\n\t\t\tif (strcmp(data->params[j], data_test->params[j]) != 0)\n\t\t\t\treturn false;\n\t\t}\n\n\t\tif (data->fn == action_trace) {\n\t\t\tif (strcmp(data->onmatch.synth_event_name,\n\t\t\t\t   data_test->onmatch.synth_event_name) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event_system,\n\t\t\t\t   data_test->onmatch.match_event_system) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmatch.match_event,\n\t\t\t\t   data_test->onmatch.match_event) != 0)\n\t\t\t\treturn false;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tif (strcmp(data->onmax.var_str,\n\t\t\t\t   data_test->onmax.var_str) != 0)\n\t\t\t\treturn false;\n\t\t\tif (strcmp(data->onmax.fn_name,\n\t\t\t\t   data_test->onmax.fn_name) != 0)\n\t\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "print_onmatch_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4360-4378",
    "snippet": "static void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_printf(m, \":onmatch(%s.%s).\", data->onmatch.match_event_system,\n\t\t   data->onmatch.match_event);\n\n\tseq_printf(m, \"%s(\", data->onmatch.synth_event->name);\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\t\tseq_printf(m, \"%s\", data->params[i]);\n\t}\n\n\tseq_puts(m, \")\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\""
          ],
          "line": 4377
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "data->params[i]"
          ],
          "line": 4374
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_onmatch_spec(struct seq_file *m,\n\t\t\t       struct hist_trigger_data *hist_data,\n\t\t\t       struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_printf(m, \":onmatch(%s.%s).\", data->onmatch.match_event_system,\n\t\t   data->onmatch.match_event);\n\n\tseq_printf(m, \"%s(\", data->onmatch.synth_event->name);\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tif (i)\n\t\t\tseq_puts(m, \",\");\n\t\tseq_printf(m, \"%s\", data->params[i]);\n\t}\n\n\tseq_puts(m, \")\");\n}"
  },
  {
    "function_name": "print_onmax_spec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4342-4358",
    "snippet": "static void print_onmax_spec(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_puts(m, \":onmax(\");\n\tseq_printf(m, \"%s\", data->onmax.var_str);\n\tseq_printf(m, \").%s(\", data->onmax.fn_name);\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tseq_printf(m, \"%s\", hist_data->max_vars[i]->var->var.name);\n\t\tif (i < hist_data->n_max_vars - 1)\n\t\t\tseq_puts(m, \",\");\n\t}\n\tseq_puts(m, \")\");\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_puts",
          "args": [
            "m",
            "\")\""
          ],
          "line": 4357
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_puts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "208-223",
          "snippet": "void trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_puts(struct trace_seq *s, const char *str)\n{\n\tunsigned int len = strlen(str);\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (len > TRACE_SEQ_BUF_LEFT(s)) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putmem(&s->seq, str, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s\"",
            "hist_data->max_vars[i]->var->var.name"
          ],
          "line": 4353
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_onmax_spec(struct seq_file *m,\n\t\t\t     struct hist_trigger_data *hist_data,\n\t\t\t     struct action_data *data)\n{\n\tunsigned int i;\n\n\tseq_puts(m, \":onmax(\");\n\tseq_printf(m, \"%s\", data->onmax.var_str);\n\tseq_printf(m, \").%s(\", data->onmax.fn_name);\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tseq_printf(m, \"%s\", hist_data->max_vars[i]->var->var.name);\n\t\tif (i < hist_data->n_max_vars - 1)\n\t\t\tseq_puts(m, \",\");\n\t}\n\tseq_puts(m, \")\");\n}"
  },
  {
    "function_name": "print_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4328-4340",
    "snippet": "static void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == onmax_save)\n\t\t\tonmax_print(m, hist_data, elt, data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onmax_print",
          "args": [
            "m",
            "hist_data",
            "elt",
            "data"
          ],
          "line": 4338
        },
        "resolved": true,
        "details": {
          "function_name": "onmax_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3264-3288",
          "snippet": "static void onmax_print(struct seq_file *m,\n\t\t\tstruct hist_trigger_data *hist_data,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct action_data *data)\n{\n\tunsigned int i, save_var_idx, max_idx = data->onmax.max_var->var.idx;\n\n\tseq_printf(m, \"\\n\\tmax: %10llu\", tracing_map_read_var(elt, max_idx));\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->max_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->max_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_print(struct seq_file *m,\n\t\t\tstruct hist_trigger_data *hist_data,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct action_data *data)\n{\n\tunsigned int i, save_var_idx, max_idx = data->onmax.max_var->var.idx;\n\n\tseq_printf(m, \"\\n\\tmax: %10llu\", tracing_map_read_var(elt, max_idx));\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->max_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->max_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void print_actions(struct seq_file *m,\n\t\t\t  struct hist_trigger_data *hist_data,\n\t\t\t  struct tracing_map_elt *elt)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == onmax_save)\n\t\t\tonmax_print(m, hist_data, elt, data);\n\t}\n}"
  },
  {
    "function_name": "create_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4304-4326",
    "snippet": "static int create_actions(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tret = onmatch_create(hist_data, file, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tret = onmax_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "onmax_create",
          "args": [
            "hist_data",
            "data"
          ],
          "line": 4319
        },
        "resolved": true,
        "details": {
          "function_name": "onmax_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3327-3399",
          "snippet": "static int onmax_create(struct hist_trigger_data *hist_data,\n\t\t\tstruct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *var_field, *ref_field, *max_var;\n\tunsigned int var_ref_idx = hist_data->n_var_refs;\n\tstruct field_var *field_var;\n\tchar *onmax_var_str, *param;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret = 0;\n\n\tonmax_var_str = data->onmax.var_str;\n\tif (onmax_var_str[0] != '$') {\n\t\thist_err(\"onmax: For onmax(x), x must be a variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\tonmax_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, onmax_var_str);\n\tif (!var_field) {\n\t\thist_err(\"onmax: Couldn't find onmax variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\n\tflags = HIST_FIELD_FL_VAR_REF;\n\tref_field = create_hist_field(hist_data, NULL, flags, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tif (init_var_ref(ref_field, var_field, NULL, NULL)) {\n\t\tdestroy_hist_field(ref_field, 0);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\tdata->onmax.var = ref_field;\n\n\tdata->fn = onmax_save;\n\tdata->onmax.max_var_ref_idx = var_ref_idx;\n\tmax_var = create_var(hist_data, file, \"max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(max_var)) {\n\t\thist_err(\"onmax: Couldn't create onmax variable: \", \"max\");\n\t\tret = PTR_ERR(max_var);\n\t\tgoto out;\n\t}\n\tdata->onmax.max_var = max_var;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\tif (IS_ERR(field_var)) {\n\t\t\thist_err(\"onmax: Couldn't create field variable: \", param);\n\t\t\tret = PTR_ERR(field_var);\n\t\t\tkfree(param);\n\t\t\tgoto out;\n\t\t}\n\n\t\thist_data->max_vars[hist_data->n_max_vars++] = field_var;\n\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\thist_data->n_max_var_str++;\n\n\t\tkfree(param);\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int onmax_create(struct hist_trigger_data *hist_data,\n\t\t\tstruct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *var_field, *ref_field, *max_var;\n\tunsigned int var_ref_idx = hist_data->n_var_refs;\n\tstruct field_var *field_var;\n\tchar *onmax_var_str, *param;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret = 0;\n\n\tonmax_var_str = data->onmax.var_str;\n\tif (onmax_var_str[0] != '$') {\n\t\thist_err(\"onmax: For onmax(x), x must be a variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\tonmax_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, onmax_var_str);\n\tif (!var_field) {\n\t\thist_err(\"onmax: Couldn't find onmax variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\n\tflags = HIST_FIELD_FL_VAR_REF;\n\tref_field = create_hist_field(hist_data, NULL, flags, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tif (init_var_ref(ref_field, var_field, NULL, NULL)) {\n\t\tdestroy_hist_field(ref_field, 0);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\tdata->onmax.var = ref_field;\n\n\tdata->fn = onmax_save;\n\tdata->onmax.max_var_ref_idx = var_ref_idx;\n\tmax_var = create_var(hist_data, file, \"max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(max_var)) {\n\t\thist_err(\"onmax: Couldn't create onmax variable: \", \"max\");\n\t\tret = PTR_ERR(max_var);\n\t\tgoto out;\n\t}\n\tdata->onmax.max_var = max_var;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\tif (IS_ERR(field_var)) {\n\t\t\thist_err(\"onmax: Couldn't create field variable: \", param);\n\t\t\tret = PTR_ERR(field_var);\n\t\t\tkfree(param);\n\t\t\tgoto out;\n\t\t}\n\n\t\thist_data->max_vars[hist_data->n_max_vars++] = field_var;\n\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\thist_data->n_max_var_str++;\n\n\t\tkfree(param);\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_create",
          "args": [
            "hist_data",
            "file",
            "data"
          ],
          "line": 4315
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3650-3748",
          "snippet": "static int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file,\n\t\t\t  struct action_data *data)\n{\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i, var_ref_idx;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tint ret = 0;\n\n\tmutex_lock(&synth_event_mutex);\n\tevent = find_synth_event(data->onmatch.synth_event_name);\n\tif (!event) {\n\t\thist_err(\"onmatch: Couldn't find synthetic event: \", data->onmatch.synth_event_name);\n\t\tmutex_unlock(&synth_event_mutex);\n\t\treturn -EINVAL;\n\t}\n\tevent->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\tvar_ref_idx = hist_data->n_var_refs;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = onmatch_find_var(hist_data, data, system,\n\t\t\t\t\t\t      event_name, param);\n\t\telse\n\t\t\thist_field = onmatch_create_field_var(hist_data, data,\n\t\t\t\t\t\t\t      system,\n\t\t\t\t\t\t\t      event_name,\n\t\t\t\t\t\t\t      param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_field, system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tsave_synth_var_ref(hist_data, var_ref);\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err_event(\"onmatch: Param type doesn't match synthetic event field type: \",\n\t\t\t       system, event_name, param);\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(\"onmatch: Param count doesn't match synthetic event field count: \", event->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->fn = action_trace;\n\tdata->onmatch.synth_event = event;\n\tdata->onmatch.var_ref_idx = var_ref_idx;\n out:\n\treturn ret;\n err:\n\tmutex_lock(&synth_event_mutex);\n\tevent->ref--;\n\tmutex_unlock(&synth_event_mutex);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(synth_event_mutex);",
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file,\n\t\t\t  struct action_data *data)\n{\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i, var_ref_idx;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tint ret = 0;\n\n\tmutex_lock(&synth_event_mutex);\n\tevent = find_synth_event(data->onmatch.synth_event_name);\n\tif (!event) {\n\t\thist_err(\"onmatch: Couldn't find synthetic event: \", data->onmatch.synth_event_name);\n\t\tmutex_unlock(&synth_event_mutex);\n\t\treturn -EINVAL;\n\t}\n\tevent->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\tvar_ref_idx = hist_data->n_var_refs;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = onmatch_find_var(hist_data, data, system,\n\t\t\t\t\t\t      event_name, param);\n\t\telse\n\t\t\thist_field = onmatch_create_field_var(hist_data, data,\n\t\t\t\t\t\t\t      system,\n\t\t\t\t\t\t\t      event_name,\n\t\t\t\t\t\t\t      param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_field, system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tsave_synth_var_ref(hist_data, var_ref);\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err_event(\"onmatch: Param type doesn't match synthetic event field type: \",\n\t\t\t       system, event_name, param);\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(\"onmatch: Param count doesn't match synthetic event field count: \", event->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->fn = action_trace;\n\tdata->onmatch.synth_event = event;\n\tdata->onmatch.var_ref_idx = var_ref_idx;\n out:\n\treturn ret;\n err:\n\tmutex_lock(&synth_event_mutex);\n\tevent->ref--;\n\tmutex_unlock(&synth_event_mutex);\n\n\tgoto out;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_actions(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file)\n{\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tdata = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tret = onmatch_create(hist_data, file, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t} else if (data->fn == onmax_save) {\n\t\t\tret = onmax_create(hist_data, data);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4264-4302",
    "snippet": "static int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif (strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmatch(\");\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = action_trace;\n\t\t} else if (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmax(\");\n\n\t\t\tdata = onmax_parse(action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = onmax_save;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 4289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 4288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmax_parse",
          "args": [
            "action_str"
          ],
          "line": 4287
        },
        "resolved": true,
        "details": {
          "function_name": "onmax_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3435-3490",
          "snippet": "static struct action_data *onmax_parse(char *str)\n{\n\tchar *onmax_fn_name, *onmax_var_str;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tonmax_var_str = strsep(&str, \")\");\n\tif (!onmax_var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->onmax.var_str = kstrdup(onmax_var_str, GFP_KERNEL);\n\tif (!data->onmax.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str)\n\t\tgoto free;\n\n\tonmax_fn_name = strsep(&str, \"(\");\n\tif (!onmax_fn_name || !str)\n\t\tgoto free;\n\n\tif (strncmp(onmax_fn_name, \"save\", strlen(\"save\")) == 0) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tret = parse_action_params(params, data);\n\t\tif (ret)\n\t\t\tgoto free;\n\t} else\n\t\tgoto free;\n\n\tdata->onmax.fn_name = kstrdup(onmax_fn_name, GFP_KERNEL);\n\tif (!data->onmax.fn_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn data;\n free:\n\tonmax_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct action_data *onmax_parse(char *str)\n{\n\tchar *onmax_fn_name, *onmax_var_str;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tonmax_var_str = strsep(&str, \")\");\n\tif (!onmax_var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->onmax.var_str = kstrdup(onmax_var_str, GFP_KERNEL);\n\tif (!data->onmax.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str)\n\t\tgoto free;\n\n\tonmax_fn_name = strsep(&str, \"(\");\n\tif (!onmax_fn_name || !str)\n\t\tgoto free;\n\n\tif (strncmp(onmax_fn_name, \"save\", strlen(\"save\")) == 0) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tret = parse_action_params(params, data);\n\t\tif (ret)\n\t\t\tgoto free;\n\t} else\n\t\tgoto free;\n\n\tdata->onmax.fn_name = kstrdup(onmax_fn_name, GFP_KERNEL);\n\tif (!data->onmax.fn_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn data;\n free:\n\tonmax_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"onmax(\""
          ],
          "line": 4285
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"onmax(\"",
            "strlen(\"onmax(\")"
          ],
          "line": 4284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "data"
          ],
          "line": 4280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "data"
          ],
          "line": 4279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmatch_parse",
          "args": [
            "tr",
            "action_str"
          ],
          "line": 4278
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3750-3824",
          "snippet": "static struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tchar *synth_event_name, *params;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(\"onmatch: Missing closing paren: \", match_event);\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(\"onmatch: Missing subsystem for match event: \", match_event_system);\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err_event(\"onmatch: Invalid subsystem or event name: \",\n\t\t\t       match_event_system, match_event, NULL);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->onmatch.match_event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->onmatch.match_event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(\"onmatch: Missing . after onmatch(): \", str);\n\t\tgoto free;\n\t}\n\n\tsynth_event_name = strsep(&str, \"(\");\n\tif (!synth_event_name || !str) {\n\t\thist_err(\"onmatch: Missing opening paramlist paren: \", synth_event_name);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.synth_event_name = kstrdup(synth_event_name, GFP_KERNEL);\n\tif (!data->onmatch.synth_event_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tparams = strsep(&str, \")\");\n\tif (!params || !str || (str && strlen(str))) {\n\t\thist_err(\"onmatch: Missing closing paramlist paren: \", params);\n\t\tgoto free;\n\t}\n\n\tret = parse_action_params(params, data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tchar *synth_event_name, *params;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(\"onmatch: Missing closing paren: \", match_event);\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(\"onmatch: Missing subsystem for match event: \", match_event_system);\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err_event(\"onmatch: Invalid subsystem or event name: \",\n\t\t\t       match_event_system, match_event, NULL);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->onmatch.match_event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->onmatch.match_event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(\"onmatch: Missing . after onmatch(): \", str);\n\t\tgoto free;\n\t}\n\n\tsynth_event_name = strsep(&str, \"(\");\n\tif (!synth_event_name || !str) {\n\t\thist_err(\"onmatch: Missing opening paramlist paren: \", synth_event_name);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.synth_event_name = kstrdup(synth_event_name, GFP_KERNEL);\n\tif (!data->onmatch.synth_event_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tparams = strsep(&str, \")\");\n\tif (!params || !str || (str && strlen(str))) {\n\t\thist_err(\"onmatch: Missing closing paramlist paren: \", params);\n\t\tgoto free;\n\t}\n\n\tret = parse_action_params(params, data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"onmatch(\"",
            "strlen(\"onmatch(\")"
          ],
          "line": 4275
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_actions(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct action_data *data;\n\tunsigned int i;\n\tint ret = 0;\n\tchar *str;\n\n\tfor (i = 0; i < hist_data->attrs->n_actions; i++) {\n\t\tstr = hist_data->attrs->action_str[i];\n\n\t\tif (strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmatch(\");\n\n\t\t\tdata = onmatch_parse(tr, action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = action_trace;\n\t\t} else if (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0) {\n\t\t\tchar *action_str = str + strlen(\"onmax(\");\n\n\t\t\tdata = onmax_parse(action_str);\n\t\t\tif (IS_ERR(data)) {\n\t\t\t\tret = PTR_ERR(data);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdata->fn = onmax_save;\n\t\t} else {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\thist_data->actions[hist_data->n_actions++] = data;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "destroy_actions",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4248-4262",
    "snippet": "static void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tonmax_destroy(data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 4260
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmax_destroy",
          "args": [
            "data"
          ],
          "line": 4258
        },
        "resolved": true,
        "details": {
          "function_name": "onmax_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3311-3325",
          "snippet": "static void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_destroy",
          "args": [
            "data"
          ],
          "line": 4256
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3492-3511",
          "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(synth_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_actions(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace)\n\t\t\tonmatch_destroy(data);\n\t\telse if (data->fn == onmax_save)\n\t\t\tonmax_destroy(data);\n\t\telse\n\t\t\tkfree(data);\n\t}\n}"
  },
  {
    "function_name": "create_sort_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4162-4246",
    "snippet": "static int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str) {\n\t\t\tif (i == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_descending",
          "args": [
            "field_str"
          ],
          "line": 4228
        },
        "resolved": true,
        "details": {
          "function_name": "is_descending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4148-4160",
          "snippet": "static int is_descending(const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int is_descending(const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "test_name"
          ],
          "line": 4226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 4224
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1687-1722",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "\"hitcount\""
          ],
          "line": 4205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&field_str",
            "\".\""
          ],
          "line": 4199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 4187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\"=\""
          ],
          "line": 4174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_sort_keys(struct hist_trigger_data *hist_data)\n{\n\tchar *fields_str = hist_data->attrs->sort_key_str;\n\tstruct tracing_map_sort_key *sort_key;\n\tint descending, ret = 0;\n\tunsigned int i, j, k;\n\n\thist_data->n_sort_keys = 1; /* we always have at least one, hitcount */\n\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < TRACING_MAP_SORT_KEYS_MAX; i++) {\n\t\tstruct hist_field *hist_field;\n\t\tchar *field_str, *field_name;\n\t\tconst char *test_name;\n\n\t\tsort_key = &hist_data->sort_keys[i];\n\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str) {\n\t\t\tif (i == 0)\n\t\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((i == TRACING_MAP_SORT_KEYS_MAX - 1) && fields_str) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tfield_name = strsep(&field_str, \".\");\n\t\tif (!field_name) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (strcmp(field_name, \"hitcount\") == 0) {\n\t\t\tdescending = is_descending(field_str);\n\t\t\tif (descending < 0) {\n\t\t\t\tret = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsort_key->descending = descending;\n\t\t\tcontinue;\n\t\t}\n\n\t\tfor (j = 1, k = 1; j < hist_data->n_fields; j++) {\n\t\t\tunsigned int idx;\n\n\t\t\thist_field = hist_data->fields[j];\n\t\t\tif (hist_field->flags & HIST_FIELD_FL_VAR)\n\t\t\t\tcontinue;\n\n\t\t\tidx = k++;\n\n\t\t\ttest_name = hist_field_name(hist_field, 0);\n\n\t\t\tif (strcmp(field_name, test_name) == 0) {\n\t\t\t\tsort_key->field_idx = idx;\n\t\t\t\tdescending = is_descending(field_str);\n\t\t\t\tif (descending < 0) {\n\t\t\t\t\tret = descending;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t\tsort_key->descending = descending;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == hist_data->n_fields) {\n\t\t\tret = -EINVAL;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\thist_data->n_sort_keys = i;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "is_descending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4148-4160",
    "snippet": "static int is_descending(const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"ascending\""
          ],
          "line": 4156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"descending\""
          ],
          "line": 4153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int is_descending(const char *str)\n{\n\tif (!str)\n\t\treturn 0;\n\n\tif (strcmp(str, \"descending\") == 0)\n\t\treturn 1;\n\n\tif (strcmp(str, \"ascending\") == 0)\n\t\treturn 0;\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "create_hist_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4122-4146",
    "snippet": "static int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4143
        },
        "resolved": true,
        "details": {
          "function_name": "free_var_defs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4058-4068",
          "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_key_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "create_key_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4004-4036",
          "snippet": "static int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4135
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4038-4056",
          "snippet": "static int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_val_fields",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 4131
        },
        "resolved": true,
        "details": {
          "function_name": "create_val_fields",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3902-3939",
          "snippet": "static int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4127
        },
        "resolved": true,
        "details": {
          "function_name": "parse_var_defs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4070-4120",
          "snippet": "static int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(\"Malformed assignment: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(\"Too many variables defined: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tkfree(hist_data->attrs->var_defs.name[n_vars]);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(\"Malformed assignment: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(\"Too many variables defined: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tkfree(hist_data->attrs->var_defs.name[n_vars]);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_hist_fields(struct hist_trigger_data *hist_data,\n\t\t\t      struct trace_event_file *file)\n{\n\tint ret;\n\n\tret = parse_var_defs(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_val_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_var_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n\n\tret = create_key_fields(hist_data, file);\n\tif (ret)\n\t\tgoto out;\n out:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_var_defs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4070-4120",
    "snippet": "static int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(\"Malformed assignment: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(\"Too many variables defined: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tkfree(hist_data->attrs->var_defs.name[n_vars]);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_var_defs",
          "args": [
            "hist_data"
          ],
          "line": 4117
        },
        "resolved": true,
        "details": {
          "function_name": "free_var_defs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4058-4068",
          "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data->attrs->var_defs.name[n_vars]"
          ],
          "line": 4105
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field_str",
            "GFP_KERNEL"
          ],
          "line": 4103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_name",
            "GFP_KERNEL"
          ],
          "line": 4096
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Too many variables defined: \"",
            "var_name"
          ],
          "line": 4091
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&field_str",
            "\"=\""
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\",\""
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_var_defs(struct hist_trigger_data *hist_data)\n{\n\tchar *s, *str, *var_name, *field_str;\n\tunsigned int i, j, n_vars = 0;\n\tint ret = 0;\n\n\tfor (i = 0; i < hist_data->attrs->n_assignments; i++) {\n\t\tstr = hist_data->attrs->assignment_str[i];\n\t\tfor (j = 0; j < TRACING_MAP_VARS_MAX; j++) {\n\t\t\tfield_str = strsep(&str, \",\");\n\t\t\tif (!field_str)\n\t\t\t\tbreak;\n\n\t\t\tvar_name = strsep(&field_str, \"=\");\n\t\t\tif (!var_name || !field_str) {\n\t\t\t\thist_err(\"Malformed assignment: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\tif (n_vars == TRACING_MAP_VARS_MAX) {\n\t\t\t\thist_err(\"Too many variables defined: \", var_name);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto free;\n\t\t\t}\n\n\t\t\ts = kstrdup(var_name, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.name[n_vars] = s;\n\n\t\t\ts = kstrdup(field_str, GFP_KERNEL);\n\t\t\tif (!s) {\n\t\t\t\tkfree(hist_data->attrs->var_defs.name[n_vars]);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto free;\n\t\t\t}\n\t\t\thist_data->attrs->var_defs.expr[n_vars++] = s;\n\n\t\t\thist_data->attrs->var_defs.n_vars = n_vars;\n\t\t}\n\t}\n\n\treturn ret;\n free:\n\tfree_var_defs(hist_data);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "free_var_defs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4058-4068",
    "snippet": "static void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_data->attrs->var_defs.expr[i]"
          ],
          "line": 4064
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_var_defs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tkfree(hist_data->attrs->var_defs.name[i]);\n\t\tkfree(hist_data->attrs->var_defs.expr[i]);\n\t}\n\n\thist_data->attrs->var_defs.n_vars = 0;\n}"
  },
  {
    "function_name": "create_var_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4038-4056",
    "snippet": "static int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_var_field",
          "args": [
            "hist_data",
            "j++",
            "file",
            "var_name",
            "expr"
          ],
          "line": 4050
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3879-3900",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, j = hist_data->n_vals;\n\tint ret = 0;\n\n\tunsigned int n_vars = hist_data->attrs->var_defs.n_vars;\n\n\tfor (i = 0; i < n_vars; i++) {\n\t\tchar *var_name = hist_data->attrs->var_defs.name[i];\n\t\tchar *expr = hist_data->attrs->var_defs.expr[i];\n\n\t\tret = create_var_field(hist_data, j++, file, var_name, expr);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_key_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "4004-4036",
    "snippet": "static int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_key_field",
          "args": [
            "hist_data",
            "i",
            "key_offset",
            "file",
            "field_str"
          ],
          "line": 4023
        },
        "resolved": true,
        "details": {
          "function_name": "create_key_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3941-4002",
          "snippet": "static int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct hist_field *hist_field = NULL;\n\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, 0);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\t\thist_err(\"Using variable references as keys not supported: \", field_str);\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
            "#define HIST_STACKTRACE_DEPTH\t16",
            "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_DEPTH\t16\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct hist_field *hist_field = NULL;\n\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, 0);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\t\thist_err(\"Using variable references as keys not supported: \", field_str);\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 4020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\"=\""
          ],
          "line": 4015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_key_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tunsigned int i, key_offset = 0, n_vals = hist_data->n_vals;\n\tchar *fields_str, *field_str;\n\tint ret = -EINVAL;\n\n\tfields_str = hist_data->attrs->keys_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = n_vals; i < n_vals + TRACING_MAP_KEYS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\t\tret = create_key_field(hist_data, i, key_offset,\n\t\t\t\t       file, field_str);\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\t\tkey_offset += ret;\n\t}\n\tif (fields_str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\tret = 0;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_key_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3941-4002",
    "snippet": "static int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct hist_field *hist_field = NULL;\n\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, 0);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\t\thist_err(\"Using variable references as keys not supported: \", field_str);\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)",
      "#define HIST_STACKTRACE_DEPTH\t16",
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_keys > TRACING_MAP_KEYS_MAX"
          ],
          "line": 3996
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "key_size",
            "sizeof(u64)"
          ],
          "line": 3982
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 3972
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Using variable references as keys not supported: \"",
            "field_str"
          ],
          "line": 3971
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "field_str",
            "flags",
            "NULL",
            "0"
          ],
          "line": 3963
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2699-2802",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "NULL"
          ],
          "line": 3961
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_str",
            "\"stacktrace\""
          ],
          "line": 3958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "key_idx >= HIST_FIELDS_MAX"
          ],
          "line": 3953
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_KEY_SIZE_MAX\t(MAX_FILTER_STR_VAL + HIST_STACKTRACE_SIZE)\n#define HIST_STACKTRACE_DEPTH\t16\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic int create_key_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int key_idx,\n\t\t\t    unsigned int key_offset,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tstruct hist_field *hist_field = NULL;\n\n\tunsigned long flags = 0;\n\tunsigned int key_size;\n\tint ret = 0;\n\n\tif (WARN_ON(key_idx >= HIST_FIELDS_MAX))\n\t\treturn -EINVAL;\n\n\tflags |= HIST_FIELD_FL_KEY;\n\n\tif (strcmp(field_str, \"stacktrace\") == 0) {\n\t\tflags |= HIST_FIELD_FL_STACKTRACE;\n\t\tkey_size = sizeof(unsigned long) * HIST_STACKTRACE_DEPTH;\n\t\thist_field = create_hist_field(hist_data, NULL, flags, NULL);\n\t} else {\n\t\thist_field = parse_expr(hist_data, file, field_str, flags,\n\t\t\t\t\tNULL, 0);\n\t\tif (IS_ERR(hist_field)) {\n\t\t\tret = PTR_ERR(hist_field);\n\t\t\tgoto out;\n\t\t}\n\n\t\tif (hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\t\thist_err(\"Using variable references as keys not supported: \", field_str);\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tkey_size = hist_field->size;\n\t}\n\n\thist_data->fields[key_idx] = hist_field;\n\n\tkey_size = ALIGN(key_size, sizeof(u64));\n\thist_data->fields[key_idx]->size = key_size;\n\thist_data->fields[key_idx]->offset = key_offset;\n\n\thist_data->key_size += key_size;\n\n\tif (hist_data->key_size > HIST_KEY_SIZE_MAX) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\thist_data->n_keys++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_keys > TRACING_MAP_KEYS_MAX))\n\t\treturn -EINVAL;\n\n\tret = key_size;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_val_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3902-3939",
    "snippet": "static int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "fields_str",
            "\"hitcount\""
          ],
          "line": 3935
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_val_field",
          "args": [
            "hist_data",
            "j++",
            "file",
            "field_str"
          ],
          "line": 3930
        },
        "resolved": true,
        "details": {
          "function_name": "create_val_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3868-3877",
          "snippet": "static int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_str",
            "\"hitcount\""
          ],
          "line": 3927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\",\""
          ],
          "line": 3923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&fields_str",
            "\"=\""
          ],
          "line": 3917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hitcount_val",
          "args": [
            "hist_data"
          ],
          "line": 3909
        },
        "resolved": true,
        "details": {
          "function_name": "create_hitcount_val",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3826-3840",
          "snippet": "static int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HITCOUNT_IDX\t\t0"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_fields(struct hist_trigger_data *hist_data,\n\t\t\t     struct trace_event_file *file)\n{\n\tchar *fields_str, *field_str;\n\tunsigned int i, j = 1;\n\tint ret;\n\n\tret = create_hitcount_val(hist_data);\n\tif (ret)\n\t\tgoto out;\n\n\tfields_str = hist_data->attrs->vals_str;\n\tif (!fields_str)\n\t\tgoto out;\n\n\tstrsep(&fields_str, \"=\");\n\tif (!fields_str)\n\t\tgoto out;\n\n\tfor (i = 0, j = 1; i < TRACING_MAP_VALS_MAX &&\n\t\t     j < TRACING_MAP_VALS_MAX; i++) {\n\t\tfield_str = strsep(&fields_str, \",\");\n\t\tif (!field_str)\n\t\t\tbreak;\n\n\t\tif (strcmp(field_str, \"hitcount\") == 0)\n\t\t\tcontinue;\n\n\t\tret = create_val_field(hist_data, j++, file, field_str);\n\t\tif (ret)\n\t\t\tgoto out;\n\t}\n\n\tif (fields_str && (strcmp(fields_str, \"hitcount\") != 0))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_var_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3879-3900",
    "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__create_val_field",
          "args": [
            "hist_data",
            "val_idx",
            "file",
            "var_name",
            "expr_str",
            "flags"
          ],
          "line": 3899
        },
        "resolved": true,
        "details": {
          "function_name": "__create_val_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3842-3866",
          "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vars > TRACING_MAP_VARS_MAX"
          ],
          "line": 3896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Variable already defined: \"",
            "var_name"
          ],
          "line": 3890
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var",
          "args": [
            "hist_data",
            "file",
            "var_name"
          ],
          "line": 3889
        },
        "resolved": true,
        "details": {
          "function_name": "find_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1489-1511",
          "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX"
          ],
          "line": 3886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}"
  },
  {
    "function_name": "create_val_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3868-3877",
    "snippet": "static int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__create_val_field",
          "args": [
            "hist_data",
            "val_idx",
            "file",
            "NULL",
            "field_str",
            "0"
          ],
          "line": 3876
        },
        "resolved": true,
        "details": {
          "function_name": "__create_val_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3842-3866",
          "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "val_idx >= TRACING_MAP_VALS_MAX"
          ],
          "line": 3873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *field_str)\n{\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, NULL, field_str, 0);\n}"
  },
  {
    "function_name": "__create_val_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3842-3866",
    "snippet": "static int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX"
          ],
          "line": 3862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "field_str",
            "flags",
            "var_name",
            "0"
          ],
          "line": 3851
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2699-2802",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int __create_val_field(struct hist_trigger_data *hist_data,\n\t\t\t      unsigned int val_idx,\n\t\t\t      struct trace_event_file *file,\n\t\t\t      char *var_name, char *field_str,\n\t\t\t      unsigned long flags)\n{\n\tstruct hist_field *hist_field;\n\tint ret = 0;\n\n\thist_field = parse_expr(hist_data, file, field_str, flags, var_name, 0);\n\tif (IS_ERR(hist_field)) {\n\t\tret = PTR_ERR(hist_field);\n\t\tgoto out;\n\t}\n\n\thist_data->fields[val_idx] = hist_field;\n\n\t++hist_data->n_vals;\n\t++hist_data->n_fields;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\tret = -EINVAL;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "create_hitcount_val",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3826-3840",
    "snippet": "static int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HITCOUNT_IDX\t\t0"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "hist_data->n_vals > TRACING_MAP_VALS_MAX"
          ],
          "line": 3836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "HIST_FIELD_FL_HITCOUNT",
            "NULL"
          ],
          "line": 3829
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HITCOUNT_IDX\t\t0\n\nstatic int create_hitcount_val(struct hist_trigger_data *hist_data)\n{\n\thist_data->fields[HITCOUNT_IDX] =\n\t\tcreate_hist_field(hist_data, NULL, HIST_FIELD_FL_HITCOUNT, NULL);\n\tif (!hist_data->fields[HITCOUNT_IDX])\n\t\treturn -ENOMEM;\n\n\thist_data->n_vals++;\n\thist_data->n_fields++;\n\n\tif (WARN_ON(hist_data->n_vals > TRACING_MAP_VALS_MAX))\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "onmatch_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3750-3824",
    "snippet": "static struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tchar *synth_event_name, *params;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(\"onmatch: Missing closing paren: \", match_event);\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(\"onmatch: Missing subsystem for match event: \", match_event_system);\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err_event(\"onmatch: Invalid subsystem or event name: \",\n\t\t\t       match_event_system, match_event, NULL);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->onmatch.match_event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->onmatch.match_event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(\"onmatch: Missing . after onmatch(): \", str);\n\t\tgoto free;\n\t}\n\n\tsynth_event_name = strsep(&str, \"(\");\n\tif (!synth_event_name || !str) {\n\t\thist_err(\"onmatch: Missing opening paramlist paren: \", synth_event_name);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.synth_event_name = kstrdup(synth_event_name, GFP_KERNEL);\n\tif (!data->onmatch.synth_event_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tparams = strsep(&str, \")\");\n\tif (!params || !str || (str && strlen(str))) {\n\t\thist_err(\"onmatch: Missing closing paramlist paren: \", params);\n\t\tgoto free;\n\t}\n\n\tret = parse_action_params(params, data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmatch_destroy",
          "args": [
            "data"
          ],
          "line": 3821
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3492-3511",
          "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(synth_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_action_params",
          "args": [
            "params",
            "data"
          ],
          "line": 3815
        },
        "resolved": true,
        "details": {
          "function_name": "parse_action_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3401-3433",
          "snippet": "static int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"onmatch: Missing closing paramlist paren: \"",
            "params"
          ],
          "line": 3811
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "str"
          ],
          "line": 3810
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "synth_event_name",
            "GFP_KERNEL"
          ],
          "line": 3803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\"(\""
          ],
          "line": 3797
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 3791
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "match_event_system",
            "GFP_KERNEL"
          ],
          "line": 3785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "match_event",
            "GFP_KERNEL"
          ],
          "line": 3779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"onmatch: Invalid subsystem or event name: \"",
            "match_event_system",
            "match_event",
            "NULL"
          ],
          "line": 3774
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event_file(tr, match_event_system, match_event)"
          ],
          "line": 3773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file",
          "args": [
            "tr",
            "match_event_system",
            "match_event"
          ],
          "line": 3773
        },
        "resolved": true,
        "details": {
          "function_name": "event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2874-2884",
          "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&match_event",
            "\".\""
          ],
          "line": 3767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 3757
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct action_data *onmatch_parse(struct trace_array *tr, char *str)\n{\n\tchar *match_event, *match_event_system;\n\tchar *synth_event_name, *params;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tmatch_event = strsep(&str, \")\");\n\tif (!match_event || !str) {\n\t\thist_err(\"onmatch: Missing closing paren: \", match_event);\n\t\tgoto free;\n\t}\n\n\tmatch_event_system = strsep(&match_event, \".\");\n\tif (!match_event) {\n\t\thist_err(\"onmatch: Missing subsystem for match event: \", match_event_system);\n\t\tgoto free;\n\t}\n\n\tif (IS_ERR(event_file(tr, match_event_system, match_event))) {\n\t\thist_err_event(\"onmatch: Invalid subsystem or event name: \",\n\t\t\t       match_event_system, match_event, NULL);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event = kstrdup(match_event, GFP_KERNEL);\n\tif (!data->onmatch.match_event) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.match_event_system = kstrdup(match_event_system, GFP_KERNEL);\n\tif (!data->onmatch.match_event_system) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str) {\n\t\thist_err(\"onmatch: Missing . after onmatch(): \", str);\n\t\tgoto free;\n\t}\n\n\tsynth_event_name = strsep(&str, \"(\");\n\tif (!synth_event_name || !str) {\n\t\thist_err(\"onmatch: Missing opening paramlist paren: \", synth_event_name);\n\t\tgoto free;\n\t}\n\n\tdata->onmatch.synth_event_name = kstrdup(synth_event_name, GFP_KERNEL);\n\tif (!data->onmatch.synth_event_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tparams = strsep(&str, \")\");\n\tif (!params || !str || (str && strlen(str))) {\n\t\thist_err(\"onmatch: Missing closing paramlist paren: \", params);\n\t\tgoto free;\n\t}\n\n\tret = parse_action_params(params, data);\n\tif (ret)\n\t\tgoto free;\n out:\n\treturn data;\n free:\n\tonmatch_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "onmatch_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3650-3748",
    "snippet": "static int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file,\n\t\t\t  struct action_data *data)\n{\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i, var_ref_idx;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tint ret = 0;\n\n\tmutex_lock(&synth_event_mutex);\n\tevent = find_synth_event(data->onmatch.synth_event_name);\n\tif (!event) {\n\t\thist_err(\"onmatch: Couldn't find synthetic event: \", data->onmatch.synth_event_name);\n\t\tmutex_unlock(&synth_event_mutex);\n\t\treturn -EINVAL;\n\t}\n\tevent->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\tvar_ref_idx = hist_data->n_var_refs;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = onmatch_find_var(hist_data, data, system,\n\t\t\t\t\t\t      event_name, param);\n\t\telse\n\t\t\thist_field = onmatch_create_field_var(hist_data, data,\n\t\t\t\t\t\t\t      system,\n\t\t\t\t\t\t\t      event_name,\n\t\t\t\t\t\t\t      param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_field, system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tsave_synth_var_ref(hist_data, var_ref);\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err_event(\"onmatch: Param type doesn't match synthetic event field type: \",\n\t\t\t       system, event_name, param);\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(\"onmatch: Param count doesn't match synthetic event field count: \", event->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->fn = action_trace;\n\tdata->onmatch.synth_event = event;\n\tdata->onmatch.var_ref_idx = var_ref_idx;\n out:\n\treturn ret;\n err:\n\tmutex_lock(&synth_event_mutex);\n\tevent->ref--;\n\tmutex_unlock(&synth_event_mutex);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);",
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 3745
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 3743
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"onmatch: Param count doesn't match synthetic event field count: \"",
            "event->name"
          ],
          "line": 3732
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 3726
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"onmatch: Param type doesn't match synthetic event field type: \"",
            "system",
            "event_name",
            "param"
          ],
          "line": 3724
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_synth_var_ref",
          "args": [
            "hist_data",
            "var_ref"
          ],
          "line": 3718
        },
        "resolved": true,
        "details": {
          "function_name": "save_synth_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3550-3557",
          "snippet": "static void save_synth_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *var_ref)\n{\n\thist_data->synth_var_refs[hist_data->n_synth_var_refs++] = var_ref;\n\n\thist_data->var_refs[hist_data->n_var_refs] = var_ref;\n\tvar_ref->var_ref_idx = hist_data->n_var_refs++;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_synth_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *var_ref)\n{\n\thist_data->synth_var_refs[hist_data->n_synth_var_refs++] = var_ref;\n\n\thist_data->var_refs[hist_data->n_var_refs] = var_ref;\n\tvar_ref->var_ref_idx = hist_data->n_var_refs++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_ref",
          "args": [
            "hist_field",
            "system",
            "event_name"
          ],
          "line": 3711
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2357-2372",
          "snippet": "static struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_synth_field",
          "args": [
            "event",
            "hist_field",
            "field_pos"
          ],
          "line": 3710
        },
        "resolved": true,
        "details": {
          "function_name": "check_synth_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3559-3574",
          "snippet": "static int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\tif (strcmp(field->type, hist_field->type) != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\tif (strcmp(field->type, hist_field->type) != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_create_field_var",
          "args": [
            "hist_data",
            "data",
            "system",
            "event_name",
            "param"
          ],
          "line": 3699
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_create_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3600-3648",
          "snippet": "static struct hist_field *\nonmatch_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data, char *system,\n\t\t\t char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specfied, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nonmatch_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data, char *system,\n\t\t\t char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specfied, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "onmatch_find_var",
          "args": [
            "hist_data",
            "data",
            "system",
            "event_name",
            "param"
          ],
          "line": 3696
        },
        "resolved": true,
        "details": {
          "function_name": "onmatch_find_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3576-3598",
          "snippet": "static struct hist_field *\nonmatch_find_var(struct hist_trigger_data *hist_data, struct action_data *data,\n\t\t char *system, char *event, char *var)\n{\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err_event(\"onmatch: Couldn't find onmatch param: $\", system, event, var);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic struct hist_field *\nonmatch_find_var(struct hist_trigger_data *hist_data, struct action_data *data,\n\t\t char *system, char *event, char *var)\n{\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err_event(\"onmatch: Couldn't find onmatch param: $\", system, event, var);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\".\""
          ],
          "line": 3687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&param",
            "\".\""
          ],
          "line": 3682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data->params[i]",
            "GFP_KERNEL"
          ],
          "line": 3676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "data->onmatch.synth_event_name"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "869-879",
          "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int onmatch_create(struct hist_trigger_data *hist_data,\n\t\t\t  struct trace_event_file *file,\n\t\t\t  struct action_data *data)\n{\n\tchar *event_name, *param, *system = NULL;\n\tstruct hist_field *hist_field, *var_ref;\n\tunsigned int i, var_ref_idx;\n\tunsigned int field_pos = 0;\n\tstruct synth_event *event;\n\tint ret = 0;\n\n\tmutex_lock(&synth_event_mutex);\n\tevent = find_synth_event(data->onmatch.synth_event_name);\n\tif (!event) {\n\t\thist_err(\"onmatch: Couldn't find synthetic event: \", data->onmatch.synth_event_name);\n\t\tmutex_unlock(&synth_event_mutex);\n\t\treturn -EINVAL;\n\t}\n\tevent->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\tvar_ref_idx = hist_data->n_var_refs;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tchar *p;\n\n\t\tp = param = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tsystem = strsep(&param, \".\");\n\t\tif (!param) {\n\t\t\tparam = (char *)system;\n\t\t\tsystem = event_name = NULL;\n\t\t} else {\n\t\t\tevent_name = strsep(&param, \".\");\n\t\t\tif (!param) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto err;\n\t\t\t}\n\t\t}\n\n\t\tif (param[0] == '$')\n\t\t\thist_field = onmatch_find_var(hist_data, data, system,\n\t\t\t\t\t\t      event_name, param);\n\t\telse\n\t\t\thist_field = onmatch_create_field_var(hist_data, data,\n\t\t\t\t\t\t\t      system,\n\t\t\t\t\t\t\t      event_name,\n\t\t\t\t\t\t\t      param);\n\n\t\tif (!hist_field) {\n\t\t\tkfree(p);\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tif (check_synth_field(event, hist_field, field_pos) == 0) {\n\t\t\tvar_ref = create_var_ref(hist_field, system, event_name);\n\t\t\tif (!var_ref) {\n\t\t\t\tkfree(p);\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto err;\n\t\t\t}\n\n\t\t\tsave_synth_var_ref(hist_data, var_ref);\n\t\t\tfield_pos++;\n\t\t\tkfree(p);\n\t\t\tcontinue;\n\t\t}\n\n\t\thist_err_event(\"onmatch: Param type doesn't match synthetic event field type: \",\n\t\t\t       system, event_name, param);\n\t\tkfree(p);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tif (field_pos != event->n_fields) {\n\t\thist_err(\"onmatch: Param count doesn't match synthetic event field count: \", event->name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tdata->fn = action_trace;\n\tdata->onmatch.synth_event = event;\n\tdata->onmatch.var_ref_idx = var_ref_idx;\n out:\n\treturn ret;\n err:\n\tmutex_lock(&synth_event_mutex);\n\tevent->ref--;\n\tmutex_unlock(&synth_event_mutex);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "onmatch_create_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3600-3648",
    "snippet": "static struct hist_field *\nonmatch_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data, char *system,\n\t\t\t char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specfied, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_field_var",
          "args": [
            "field_var"
          ],
          "line": 3645
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4442-4450",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_field_var_hist",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "create_field_var_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2932-3055",
          "snippet": "static struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_field *event_var = ERR_PTR(-EINVAL);\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err_event(\"onmatch: Too many field variables defined: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err_event(\"onmatch: Event file not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err_event(\"onmatch: Matching event histogram not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t      \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't create histogram for field: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't find synthetic variable: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [
            "static struct event_command trigger_hist_cmd;",
            "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_field *event_var = ERR_PTR(-EINVAL);\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err_event(\"onmatch: Too many field variables defined: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err_event(\"onmatch: Event file not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err_event(\"onmatch: Matching event histogram not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t      \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't create histogram for field: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't find synthetic variable: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}"
        }
      },
      {
        "call_info": {
          "callee": "save_field_var",
          "args": [
            "hist_data",
            "field_var"
          ],
          "line": 3617
        },
        "resolved": true,
        "details": {
          "function_name": "save_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3532-3539",
          "snippet": "static void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field_var"
          ],
          "line": 3616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_target_field_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3614
        },
        "resolved": true,
        "details": {
          "function_name": "create_target_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3240-3262",
          "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nonmatch_create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t struct action_data *data, char *system,\n\t\t\t char *event, char *var)\n{\n\tstruct hist_field *hist_field = NULL;\n\tstruct field_var *field_var;\n\n\t/*\n\t * First try to create a field var on the target event (the\n\t * currently being defined).  This will create a variable for\n\t * unqualified fields on the target event, or if qualified,\n\t * target fields that have qualified names matching the target.\n\t */\n\tfield_var = create_target_field_var(hist_data, system, event, var);\n\n\tif (field_var && !IS_ERR(field_var)) {\n\t\tsave_field_var(hist_data, field_var);\n\t\thist_field = field_var->var;\n\t} else {\n\t\tfield_var = NULL;\n\t\t/*\n\t\t * If no explicit system.event is specfied, default to\n\t\t * looking for fields on the onmatch(system.event.xxx)\n\t\t * event.\n\t\t */\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\t/*\n\t\t * At this point, we're looking at a field on another\n\t\t * event.  Because we can't modify a hist trigger on\n\t\t * another event to add a variable for a field, we need\n\t\t * to create a new trigger on that event and create the\n\t\t * variable at the same time.\n\t\t */\n\t\thist_field = create_field_var_hist(hist_data, system, event, var);\n\t\tif (IS_ERR(hist_field))\n\t\t\tgoto free;\n\t}\n out:\n\treturn hist_field;\n free:\n\tdestroy_field_var(field_var);\n\thist_field = NULL;\n\tgoto out;\n}"
  },
  {
    "function_name": "onmatch_find_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3576-3598",
    "snippet": "static struct hist_field *\nonmatch_find_var(struct hist_trigger_data *hist_data, struct action_data *data,\n\t\t char *system, char *event, char *var)\n{\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err_event(\"onmatch: Couldn't find onmatch param: $\", system, event, var);\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"onmatch: Couldn't find onmatch param: $\"",
            "system",
            "event",
            "var"
          ],
          "line": 3595
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3591
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1595-1619",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_target_event_var",
          "args": [
            "hist_data",
            "system",
            "event",
            "var"
          ],
          "line": 3584
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_event_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3057-3082",
          "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic struct hist_field *\nonmatch_find_var(struct hist_trigger_data *hist_data, struct action_data *data,\n\t\t char *system, char *event, char *var)\n{\n\tstruct hist_field *hist_field;\n\n\tvar++; /* skip '$' */\n\n\thist_field = find_target_event_var(hist_data, system, event, var);\n\tif (!hist_field) {\n\t\tif (!system) {\n\t\t\tsystem = data->onmatch.match_event_system;\n\t\t\tevent = data->onmatch.match_event;\n\t\t}\n\n\t\thist_field = find_event_var(hist_data, system, event, var);\n\t}\n\n\tif (!hist_field)\n\t\thist_err_event(\"onmatch: Couldn't find onmatch param: $\", system, event, var);\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "check_synth_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3559-3574",
    "snippet": "static int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\tif (strcmp(field->type, hist_field->type) != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field->type",
            "hist_field->type"
          ],
          "line": 3570
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_synth_field(struct synth_event *event,\n\t\t\t     struct hist_field *hist_field,\n\t\t\t     unsigned int field_pos)\n{\n\tstruct synth_field *field;\n\n\tif (field_pos >= event->n_fields)\n\t\treturn -EINVAL;\n\n\tfield = event->fields[field_pos];\n\n\tif (strcmp(field->type, hist_field->type) != 0)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "save_synth_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3550-3557",
    "snippet": "static void save_synth_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *var_ref)\n{\n\thist_data->synth_var_refs[hist_data->n_synth_var_refs++] = var_ref;\n\n\thist_data->var_refs[hist_data->n_var_refs] = var_ref;\n\tvar_ref->var_ref_idx = hist_data->n_var_refs++;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_synth_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *var_ref)\n{\n\thist_data->synth_var_refs[hist_data->n_synth_var_refs++] = var_ref;\n\n\thist_data->var_refs[hist_data->n_var_refs] = var_ref;\n\tvar_ref->var_ref_idx = hist_data->n_var_refs++;\n}"
  },
  {
    "function_name": "destroy_synth_var_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3542-3548",
    "snippet": "static void destroy_synth_var_refs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++)\n\t\tdestroy_hist_field(hist_data->synth_var_refs[i], 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_data->synth_var_refs[i]",
            "0"
          ],
          "line": 3547
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_synth_var_refs(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++)\n\t\tdestroy_hist_field(hist_data->synth_var_refs[i], 0);\n}"
  },
  {
    "function_name": "save_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3532-3539",
    "snippet": "static void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void save_field_var(struct hist_trigger_data *hist_data,\n\t\t\t   struct field_var *field_var)\n{\n\thist_data->field_vars[hist_data->n_field_vars++] = field_var;\n\n\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\thist_data->n_field_var_str++;\n}"
  },
  {
    "function_name": "destroy_field_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3524-3530",
    "snippet": "static void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_field_var",
          "args": [
            "hist_data->field_vars[i]"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_field_var_hists",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "4442-4450",
          "snippet": "static void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var_hists(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_var_hists; i++) {\n\t\tkfree(hist_data->field_var_hists[i]->cmd);\n\t\tkfree(hist_data->field_var_hists[i]);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_vars(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_field_vars; i++)\n\t\tdestroy_field_var(hist_data->field_vars[i]);\n}"
  },
  {
    "function_name": "destroy_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3513-3522",
    "snippet": "static void destroy_field_var(struct field_var *field_var)\n{\n\tif (!field_var)\n\t\treturn;\n\n\tdestroy_hist_field(field_var->var, 0);\n\tdestroy_hist_field(field_var->val, 0);\n\n\tkfree(field_var);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field_var"
          ],
          "line": 3521
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "field_var->val",
            "0"
          ],
          "line": 3519
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_field_var(struct field_var *field_var)\n{\n\tif (!field_var)\n\t\treturn;\n\n\tdestroy_hist_field(field_var->var, 0);\n\tdestroy_hist_field(field_var->val, 0);\n\n\tkfree(field_var);\n}"
  },
  {
    "function_name": "onmatch_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3492-3511",
    "snippet": "static void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 3510
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 3496
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void onmatch_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tmutex_lock(&synth_event_mutex);\n\n\tkfree(data->onmatch.match_event);\n\tkfree(data->onmatch.match_event_system);\n\tkfree(data->onmatch.synth_event_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tif (data->onmatch.synth_event)\n\t\tdata->onmatch.synth_event->ref--;\n\n\tkfree(data);\n\n\tmutex_unlock(&synth_event_mutex);\n}"
  },
  {
    "function_name": "onmax_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3435-3490",
    "snippet": "static struct action_data *onmax_parse(char *str)\n{\n\tchar *onmax_fn_name, *onmax_var_str;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tonmax_var_str = strsep(&str, \")\");\n\tif (!onmax_var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->onmax.var_str = kstrdup(onmax_var_str, GFP_KERNEL);\n\tif (!data->onmax.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str)\n\t\tgoto free;\n\n\tonmax_fn_name = strsep(&str, \"(\");\n\tif (!onmax_fn_name || !str)\n\t\tgoto free;\n\n\tif (strncmp(onmax_fn_name, \"save\", strlen(\"save\")) == 0) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tret = parse_action_params(params, data);\n\t\tif (ret)\n\t\t\tgoto free;\n\t} else\n\t\tgoto free;\n\n\tdata->onmax.fn_name = kstrdup(onmax_fn_name, GFP_KERNEL);\n\tif (!data->onmax.fn_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn data;\n free:\n\tonmax_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "onmax_destroy",
          "args": [
            "data"
          ],
          "line": 3487
        },
        "resolved": true,
        "details": {
          "function_name": "onmax_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3311-3325",
          "snippet": "static void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "onmax_fn_name",
            "GFP_KERNEL"
          ],
          "line": 3479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_action_params",
          "args": [
            "params",
            "data"
          ],
          "line": 3473
        },
        "resolved": true,
        "details": {
          "function_name": "parse_action_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3401-3433",
          "snippet": "static int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "onmax_fn_name",
            "\"save\"",
            "strlen(\"save\")"
          ],
          "line": 3465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"save\""
          ],
          "line": 3465
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\"(\""
          ],
          "line": 3461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 3457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "onmax_var_str",
            "GFP_KERNEL"
          ],
          "line": 3451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\")\""
          ],
          "line": 3445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*data)",
            "GFP_KERNEL"
          ],
          "line": 3441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct action_data *onmax_parse(char *str)\n{\n\tchar *onmax_fn_name, *onmax_var_str;\n\tstruct action_data *data;\n\tint ret = -EINVAL;\n\n\tdata = kzalloc(sizeof(*data), GFP_KERNEL);\n\tif (!data)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tonmax_var_str = strsep(&str, \")\");\n\tif (!onmax_var_str || !str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tdata->onmax.var_str = kstrdup(onmax_var_str, GFP_KERNEL);\n\tif (!data->onmax.var_str) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tstrsep(&str, \".\");\n\tif (!str)\n\t\tgoto free;\n\n\tonmax_fn_name = strsep(&str, \"(\");\n\tif (!onmax_fn_name || !str)\n\t\tgoto free;\n\n\tif (strncmp(onmax_fn_name, \"save\", strlen(\"save\")) == 0) {\n\t\tchar *params = strsep(&str, \")\");\n\n\t\tif (!params) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\n\t\tret = parse_action_params(params, data);\n\t\tif (ret)\n\t\t\tgoto free;\n\t} else\n\t\tgoto free;\n\n\tdata->onmax.fn_name = kstrdup(onmax_fn_name, GFP_KERNEL);\n\tif (!data->onmax.fn_name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn data;\n free:\n\tonmax_destroy(data);\n\tdata = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "parse_action_params",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3401-3433",
    "snippet": "static int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_FIELDS_MAX\t16"
    ],
    "globals_used": [
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "param",
            "GFP_KERNEL"
          ],
          "line": 3423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Invalid action param: \"",
            "param"
          ],
          "line": 3418
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "param"
          ],
          "line": 3417
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "param"
          ],
          "line": 3416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&params",
            "\",\""
          ],
          "line": 3410
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "onmax_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3327-3399",
    "snippet": "static int onmax_create(struct hist_trigger_data *hist_data,\n\t\t\tstruct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *var_field, *ref_field, *max_var;\n\tunsigned int var_ref_idx = hist_data->n_var_refs;\n\tstruct field_var *field_var;\n\tchar *onmax_var_str, *param;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret = 0;\n\n\tonmax_var_str = data->onmax.var_str;\n\tif (onmax_var_str[0] != '$') {\n\t\thist_err(\"onmax: For onmax(x), x must be a variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\tonmax_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, onmax_var_str);\n\tif (!var_field) {\n\t\thist_err(\"onmax: Couldn't find onmax variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\n\tflags = HIST_FIELD_FL_VAR_REF;\n\tref_field = create_hist_field(hist_data, NULL, flags, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tif (init_var_ref(ref_field, var_field, NULL, NULL)) {\n\t\tdestroy_hist_field(ref_field, 0);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\tdata->onmax.var = ref_field;\n\n\tdata->fn = onmax_save;\n\tdata->onmax.max_var_ref_idx = var_ref_idx;\n\tmax_var = create_var(hist_data, file, \"max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(max_var)) {\n\t\thist_err(\"onmax: Couldn't create onmax variable: \", \"max\");\n\t\tret = PTR_ERR(max_var);\n\t\tgoto out;\n\t}\n\tdata->onmax.max_var = max_var;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\tif (IS_ERR(field_var)) {\n\t\t\thist_err(\"onmax: Couldn't create field variable: \", param);\n\t\t\tret = PTR_ERR(field_var);\n\t\t\tkfree(param);\n\t\t\tgoto out;\n\t\t}\n\n\t\thist_data->max_vars[hist_data->n_max_vars++] = field_var;\n\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\thist_data->n_max_var_str++;\n\n\t\tkfree(param);\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "param"
          ],
          "line": 3395
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field_var"
          ],
          "line": 3386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"onmax: Couldn't create field variable: \"",
            "param"
          ],
          "line": 3385
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field_var"
          ],
          "line": 3384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_target_field_var",
          "args": [
            "hist_data",
            "NULL",
            "NULL",
            "param"
          ],
          "line": 3383
        },
        "resolved": true,
        "details": {
          "function_name": "create_target_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3240-3262",
          "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "data->params[i]",
            "GFP_KERNEL"
          ],
          "line": 3377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "max_var"
          ],
          "line": 3371
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "max_var"
          ],
          "line": 3369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_var",
          "args": [
            "hist_data",
            "file",
            "\"max\"",
            "sizeof(u64)",
            "\"u64\""
          ],
          "line": 3368
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3879-3900",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "ref_field",
            "0"
          ],
          "line": 3358
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_var_ref",
          "args": [
            "ref_field",
            "var_field",
            "NULL",
            "NULL"
          ],
          "line": 3357
        },
        "resolved": true,
        "details": {
          "function_name": "init_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2301-2355",
          "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "NULL"
          ],
          "line": 3353
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_target_event_var",
          "args": [
            "hist_data",
            "NULL",
            "NULL",
            "onmax_var_str"
          ],
          "line": 3346
        },
        "resolved": true,
        "details": {
          "function_name": "find_target_event_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3057-3082",
          "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int onmax_create(struct hist_trigger_data *hist_data,\n\t\t\tstruct action_data *data)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *var_field, *ref_field, *max_var;\n\tunsigned int var_ref_idx = hist_data->n_var_refs;\n\tstruct field_var *field_var;\n\tchar *onmax_var_str, *param;\n\tunsigned long flags;\n\tunsigned int i;\n\tint ret = 0;\n\n\tonmax_var_str = data->onmax.var_str;\n\tif (onmax_var_str[0] != '$') {\n\t\thist_err(\"onmax: For onmax(x), x must be a variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\tonmax_var_str++;\n\n\tvar_field = find_target_event_var(hist_data, NULL, NULL, onmax_var_str);\n\tif (!var_field) {\n\t\thist_err(\"onmax: Couldn't find onmax variable: \", onmax_var_str);\n\t\treturn -EINVAL;\n\t}\n\n\tflags = HIST_FIELD_FL_VAR_REF;\n\tref_field = create_hist_field(hist_data, NULL, flags, NULL);\n\tif (!ref_field)\n\t\treturn -ENOMEM;\n\n\tif (init_var_ref(ref_field, var_field, NULL, NULL)) {\n\t\tdestroy_hist_field(ref_field, 0);\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\thist_data->var_refs[hist_data->n_var_refs] = ref_field;\n\tref_field->var_ref_idx = hist_data->n_var_refs++;\n\tdata->onmax.var = ref_field;\n\n\tdata->fn = onmax_save;\n\tdata->onmax.max_var_ref_idx = var_ref_idx;\n\tmax_var = create_var(hist_data, file, \"max\", sizeof(u64), \"u64\");\n\tif (IS_ERR(max_var)) {\n\t\thist_err(\"onmax: Couldn't create onmax variable: \", \"max\");\n\t\tret = PTR_ERR(max_var);\n\t\tgoto out;\n\t}\n\tdata->onmax.max_var = max_var;\n\n\tfor (i = 0; i < data->n_params; i++) {\n\t\tparam = kstrdup(data->params[i], GFP_KERNEL);\n\t\tif (!param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tfield_var = create_target_field_var(hist_data, NULL, NULL, param);\n\t\tif (IS_ERR(field_var)) {\n\t\t\thist_err(\"onmax: Couldn't create field variable: \", param);\n\t\t\tret = PTR_ERR(field_var);\n\t\t\tkfree(param);\n\t\t\tgoto out;\n\t\t}\n\n\t\thist_data->max_vars[hist_data->n_max_vars++] = field_var;\n\t\tif (field_var->val->flags & HIST_FIELD_FL_STRING)\n\t\t\thist_data->n_max_var_str++;\n\n\t\tkfree(param);\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "onmax_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3311-3325",
    "snippet": "static void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 3324
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "data->onmax.var",
            "0"
          ],
          "line": 3316
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_destroy(struct action_data *data)\n{\n\tunsigned int i;\n\n\tdestroy_hist_field(data->onmax.max_var, 0);\n\tdestroy_hist_field(data->onmax.var, 0);\n\n\tkfree(data->onmax.var_str);\n\tkfree(data->onmax.fn_name);\n\n\tfor (i = 0; i < data->n_params; i++)\n\t\tkfree(data->params[i]);\n\n\tkfree(data);\n}"
  },
  {
    "function_name": "onmax_save",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3290-3309",
    "snippet": "static void onmax_save(struct hist_trigger_data *hist_data,\n\t\t       struct tracing_map_elt *elt, void *rec,\n\t\t       struct ring_buffer_event *rbe,\n\t\t       struct action_data *data, u64 *var_ref_vals)\n{\n\tunsigned int max_idx = data->onmax.max_var->var.idx;\n\tunsigned int max_var_ref_idx = data->onmax.max_var_ref_idx;\n\n\tu64 var_val, max_val;\n\n\tvar_val = var_ref_vals[max_var_ref_idx];\n\tmax_val = tracing_map_read_var(elt, max_idx);\n\n\tif (var_val <= max_val)\n\t\treturn;\n\n\ttracing_map_set_var(elt, max_idx, var_val);\n\n\tupdate_max_vars(hist_data, elt, rbe, rec);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_max_vars",
          "args": [
            "hist_data",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 3308
        },
        "resolved": true,
        "details": {
          "function_name": "update_max_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3123-3130",
          "snippet": "static void update_max_vars(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->max_vars,\n\t\t\t    hist_data->n_max_vars, hist_data->n_field_var_str);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_max_vars(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->max_vars,\n\t\t\t    hist_data->n_max_vars, hist_data->n_field_var_str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "max_idx",
            "var_val"
          ],
          "line": 3306
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "70-74",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_read_var",
          "args": [
            "elt",
            "max_idx"
          ],
          "line": 3301
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "121-125",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_save(struct hist_trigger_data *hist_data,\n\t\t       struct tracing_map_elt *elt, void *rec,\n\t\t       struct ring_buffer_event *rbe,\n\t\t       struct action_data *data, u64 *var_ref_vals)\n{\n\tunsigned int max_idx = data->onmax.max_var->var.idx;\n\tunsigned int max_var_ref_idx = data->onmax.max_var_ref_idx;\n\n\tu64 var_val, max_val;\n\n\tvar_val = var_ref_vals[max_var_ref_idx];\n\tmax_val = tracing_map_read_var(elt, max_idx);\n\n\tif (var_val <= max_val)\n\t\treturn;\n\n\ttracing_map_set_var(elt, max_idx, var_val);\n\n\tupdate_max_vars(hist_data, elt, rbe, rec);\n}"
  },
  {
    "function_name": "onmax_print",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3264-3288",
    "snippet": "static void onmax_print(struct seq_file *m,\n\t\t\tstruct hist_trigger_data *hist_data,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct action_data *data)\n{\n\tunsigned int i, save_var_idx, max_idx = data->onmax.max_var->var.idx;\n\n\tseq_printf(m, \"\\n\\tmax: %10llu\", tracing_map_read_var(elt, max_idx));\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->max_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->max_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"  %s: %10llu\"",
            "save_var->var.name",
            "val"
          ],
          "line": 3286
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_read_var",
          "args": [
            "elt",
            "save_var_idx"
          ],
          "line": 3280
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "121-125",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void onmax_print(struct seq_file *m,\n\t\t\tstruct hist_trigger_data *hist_data,\n\t\t\tstruct tracing_map_elt *elt,\n\t\t\tstruct action_data *data)\n{\n\tunsigned int i, save_var_idx, max_idx = data->onmax.max_var->var.idx;\n\n\tseq_printf(m, \"\\n\\tmax: %10llu\", tracing_map_read_var(elt, max_idx));\n\n\tfor (i = 0; i < hist_data->n_max_vars; i++) {\n\t\tstruct hist_field *save_val = hist_data->max_vars[i]->val;\n\t\tstruct hist_field *save_var = hist_data->max_vars[i]->var;\n\t\tu64 val;\n\n\t\tsave_var_idx = save_var->var.idx;\n\n\t\tval = tracing_map_read_var(elt, save_var_idx);\n\n\t\tif (save_val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tseq_printf(m, \"  %s: %-32s\", save_var->var.name,\n\t\t\t\t   (char *)(uintptr_t)(val));\n\t\t} else\n\t\t\tseq_printf(m, \"  %s: %10llu\", save_var->var.name, val);\n\t}\n}"
  },
  {
    "function_name": "create_target_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3240-3262",
    "snippet": "static struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_field_var",
          "args": [
            "target_hist_data",
            "file",
            "var_name"
          ],
          "line": 3261
        },
        "resolved": true,
        "details": {
          "function_name": "create_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3173-3218",
          "snippet": "static struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(\"Too many field variables defined: \", field_name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(\"Couldn't parse field variable: \", field_name);\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(\"Couldn't create or find variable: \", field_name);\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(\"Too many field variables defined: \", field_name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(\"Couldn't parse field variable: \", field_name);\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(\"Couldn't create or find variable: \", field_name);\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "subsys_name",
            "call->class->system"
          ],
          "line": 3254
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct field_var *\ncreate_target_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\tchar *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = target_hist_data->event_file;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn create_field_var(target_hist_data, file, var_name);\n}"
  },
  {
    "function_name": "create_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3173-3218",
    "snippet": "static struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(\"Too many field variables defined: \", field_name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(\"Couldn't parse field variable: \", field_name);\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(\"Couldn't create or find variable: \", field_name);\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_FIELDS_MAX\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct field_var)",
            "GFP_KERNEL"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "var"
          ],
          "line": 3199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Couldn't create or find variable: \"",
            "field_name"
          ],
          "line": 3197
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "var"
          ],
          "line": 3196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_var",
          "args": [
            "hist_data",
            "file",
            "field_name",
            "val->size",
            "val->type"
          ],
          "line": 3195
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3879-3900",
          "snippet": "static int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int create_var_field(struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int val_idx,\n\t\t\t    struct trace_event_file *file,\n\t\t\t    char *var_name, char *expr_str)\n{\n\tunsigned long flags = 0;\n\n\tif (WARN_ON(val_idx >= TRACING_MAP_VALS_MAX + TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\tif (find_var(hist_data, file, var_name) && !hist_data->remove) {\n\t\thist_err(\"Variable already defined: \", var_name);\n\t\treturn -EINVAL;\n\t}\n\n\tflags |= HIST_FIELD_FL_VAR;\n\thist_data->n_vars++;\n\tif (WARN_ON(hist_data->n_vars > TRACING_MAP_VARS_MAX))\n\t\treturn -EINVAL;\n\n\treturn __create_val_field(hist_data, val_idx, file, var_name, expr_str, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "val"
          ],
          "line": 3191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "val"
          ],
          "line": 3189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_atom",
          "args": [
            "hist_data",
            "file",
            "field_name",
            "&flags",
            "NULL"
          ],
          "line": 3188
        },
        "resolved": true,
        "details": {
          "function_name": "parse_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2529-2589",
          "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic struct field_var *create_field_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t  struct trace_event_file *file,\n\t\t\t\t\t  char *field_name)\n{\n\tstruct hist_field *val = NULL, *var = NULL;\n\tunsigned long flags = HIST_FIELD_FL_VAR;\n\tstruct field_var *field_var;\n\tint ret = 0;\n\n\tif (hist_data->n_field_vars >= SYNTH_FIELDS_MAX) {\n\t\thist_err(\"Too many field variables defined: \", field_name);\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tval = parse_atom(hist_data, file, field_name, &flags, NULL);\n\tif (IS_ERR(val)) {\n\t\thist_err(\"Couldn't parse field variable: \", field_name);\n\t\tret = PTR_ERR(val);\n\t\tgoto err;\n\t}\n\n\tvar = create_var(hist_data, file, field_name, val->size, val->type);\n\tif (IS_ERR(var)) {\n\t\thist_err(\"Couldn't create or find variable: \", field_name);\n\t\tkfree(val);\n\t\tret = PTR_ERR(var);\n\t\tgoto err;\n\t}\n\n\tfield_var = kzalloc(sizeof(struct field_var), GFP_KERNEL);\n\tif (!field_var) {\n\t\tkfree(val);\n\t\tkfree(var);\n\t\tret =  -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tfield_var->var = var;\n\tfield_var->val = val;\n out:\n\treturn field_var;\n err:\n\tfield_var = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "create_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3132-3171",
    "snippet": "static struct hist_field *create_var(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *name, int size, const char *type)\n{\n\tstruct hist_field *var;\n\tint idx;\n\n\tif (find_var(hist_data, file, name) && !hist_data->remove) {\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!var) {\n\t\tvar = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tidx = tracing_map_add_var(hist_data->map);\n\tif (idx < 0) {\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar->flags = HIST_FIELD_FL_VAR;\n\tvar->var.idx = idx;\n\tvar->var.hist_data = var->hist_data = hist_data;\n\tvar->size = size;\n\tvar->var.name = kstrdup(name, GFP_KERNEL);\n\tvar->type = kstrdup(type, GFP_KERNEL);\n\tif (!var->var.name || !var->type) {\n\t\tkfree(var->var.name);\n\t\tkfree(var->type);\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-ENOMEM);\n\t}\n out:\n\treturn var;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var"
          ],
          "line": 3166
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "type",
            "GFP_KERNEL"
          ],
          "line": 3162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 3161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 3153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracing_map_add_var",
          "args": [
            "hist_data->map"
          ],
          "line": 3150
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_add_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "243-251",
          "snippet": "int tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nint tracing_map_add_var(struct tracing_map *map)\n{\n\tint ret = -EINVAL;\n\n\tif (map->n_vars < TRACING_MAP_VARS_MAX)\n\t\tret = map->n_vars++;\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct hist_field)",
            "GFP_KERNEL"
          ],
          "line": 3144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 3140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_var",
          "args": [
            "hist_data",
            "file",
            "name"
          ],
          "line": 3139
        },
        "resolved": true,
        "details": {
          "function_name": "find_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1489-1511",
          "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *name, int size, const char *type)\n{\n\tstruct hist_field *var;\n\tint idx;\n\n\tif (find_var(hist_data, file, name) && !hist_data->remove) {\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!var) {\n\t\tvar = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tidx = tracing_map_add_var(hist_data->map);\n\tif (idx < 0) {\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tvar->flags = HIST_FIELD_FL_VAR;\n\tvar->var.idx = idx;\n\tvar->var.hist_data = var->hist_data = hist_data;\n\tvar->size = size;\n\tvar->var.name = kstrdup(name, GFP_KERNEL);\n\tvar->type = kstrdup(type, GFP_KERNEL);\n\tif (!var->var.name || !var->type) {\n\t\tkfree(var->var.name);\n\t\tkfree(var->type);\n\t\tkfree(var);\n\t\tvar = ERR_PTR(-ENOMEM);\n\t}\n out:\n\treturn var;\n}"
  },
  {
    "function_name": "update_max_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3123-3130",
    "snippet": "static void update_max_vars(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->max_vars,\n\t\t\t    hist_data->n_max_vars, hist_data->n_field_var_str);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_field_vars",
          "args": [
            "elt",
            "rbe",
            "rec",
            "hist_data->max_vars",
            "hist_data->n_max_vars",
            "hist_data->n_field_var_str"
          ],
          "line": 3128
        },
        "resolved": true,
        "details": {
          "function_name": "__update_field_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3084-3112",
          "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_max_vars(struct hist_trigger_data *hist_data,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->max_vars,\n\t\t\t    hist_data->n_max_vars, hist_data->n_field_var_str);\n}"
  },
  {
    "function_name": "update_field_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3114-3121",
    "snippet": "static void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__update_field_vars",
          "args": [
            "elt",
            "rbe",
            "rec",
            "hist_data->field_vars",
            "hist_data->n_field_vars",
            "0"
          ],
          "line": 3119
        },
        "resolved": true,
        "details": {
          "function_name": "__update_field_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3084-3112",
          "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void update_field_vars(struct hist_trigger_data *hist_data,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *rec)\n{\n\t__update_field_vars(elt, rbe, rec, hist_data->field_vars,\n\t\t\t    hist_data->n_field_vars, 0);\n}"
  },
  {
    "function_name": "__update_field_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3084-3112",
    "snippet": "static inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_set_var",
          "args": [
            "elt",
            "var_idx",
            "var_val"
          ],
          "line": 3110
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_set_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "70-74",
          "snippet": "void tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nvoid tracing_map_set_var(struct tracing_map_elt *elt, unsigned int i, u64 n)\n{\n\tatomic64_set(&elt->vars[i], n);\n\telt->var_set[i] = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str",
            "val_str",
            "STR_VAR_LEN_MAX"
          ],
          "line": 3107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "val->fn",
          "args": [
            "val",
            "elt",
            "rbe",
            "rec"
          ],
          "line": 3100
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic inline void __update_field_vars(struct tracing_map_elt *elt,\n\t\t\t\t       struct ring_buffer_event *rbe,\n\t\t\t\t       void *rec,\n\t\t\t\t       struct field_var **field_vars,\n\t\t\t\t       unsigned int n_field_vars,\n\t\t\t\t       unsigned int field_var_str_start)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\tunsigned int i, j, var_idx;\n\tu64 var_val;\n\n\tfor (i = 0, j = field_var_str_start; i < n_field_vars; i++) {\n\t\tstruct field_var *field_var = field_vars[i];\n\t\tstruct hist_field *var = field_var->var;\n\t\tstruct hist_field *val = field_var->val;\n\n\t\tvar_val = val->fn(val, elt, rbe, rec);\n\t\tvar_idx = var->var.idx;\n\n\t\tif (val->flags & HIST_FIELD_FL_STRING) {\n\t\t\tchar *str = elt_data->field_var_str[j++];\n\t\t\tchar *val_str = (char *)(uintptr_t)var_val;\n\n\t\t\tstrscpy(str, val_str, STR_VAR_LEN_MAX);\n\t\t\tvar_val = (u64)(uintptr_t)str;\n\t\t}\n\t\ttracing_map_set_var(elt, var_idx, var_val);\n\t}\n}"
  },
  {
    "function_name": "find_target_event_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "3057-3082",
    "snippet": "static struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 3079
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1471-1487",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 3075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "subsys_name",
            "call->class->system"
          ],
          "line": 3072
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_target_event_var(struct hist_trigger_data *hist_data,\n\t\t      char *subsys_name, char *event_name, char *var_name)\n{\n\tstruct trace_event_file *file = hist_data->event_file;\n\tstruct hist_field *hist_field = NULL;\n\n\tif (subsys_name) {\n\t\tstruct trace_event_call *call;\n\n\t\tif (!event_name)\n\t\t\treturn NULL;\n\n\t\tcall = file->event_call;\n\n\t\tif (strcmp(subsys_name, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\thist_field = find_var_field(hist_data, var_name);\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "create_field_var_hist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2932-3055",
    "snippet": "static struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_field *event_var = ERR_PTR(-EINVAL);\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err_event(\"onmatch: Too many field variables defined: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err_event(\"onmatch: Event file not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err_event(\"onmatch: Matching event histogram not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t      \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't create histogram for field: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't find synthetic variable: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_FIELDS_MAX\t16"
    ],
    "globals_used": [
      "static struct event_command trigger_hist_cmd;",
      "static struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"onmatch: Couldn't find synthetic variable: \"",
            "subsys_name",
            "event_name",
            "field_name"
          ],
          "line": 3045
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var_hist"
          ],
          "line": 3044
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "event_var"
          ],
          "line": 3042
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_synthetic_field_var",
          "args": [
            "target_hist_data",
            "subsys_name",
            "event_name",
            "field_name"
          ],
          "line": 3040
        },
        "resolved": true,
        "details": {
          "function_name": "find_synthetic_field_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2886-2905",
          "snippet": "static struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 3034
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_hist_trigger_func",
          "args": [
            "&trigger_hist_cmd",
            "file",
            "\"\"",
            "\"hist\"",
            "cmd"
          ],
          "line": 3026
        },
        "resolved": true,
        "details": {
          "function_name": "event_hist_trigger_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "5478-5652",
          "snippet": "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(synth_event_mutex);",
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param)\n{\n\tunsigned int hist_trigger_bits = TRACING_MAP_BITS_DEFAULT;\n\tstruct event_trigger_data *trigger_data;\n\tstruct hist_trigger_attrs *attrs;\n\tstruct event_trigger_ops *trigger_ops;\n\tstruct hist_trigger_data *hist_data;\n\tstruct synth_event *se;\n\tconst char *se_name;\n\tbool remove = false;\n\tchar *trigger, *p;\n\tint ret = 0;\n\n\tif (glob && strlen(glob)) {\n\t\tlast_cmd_set(param);\n\t\thist_err_clear();\n\t}\n\n\tif (!param)\n\t\treturn -EINVAL;\n\n\tif (glob[0] == '!')\n\t\tremove = true;\n\n\t/*\n\t * separate the trigger from the filter (k:v [if filter])\n\t * allowing for whitespace in the trigger\n\t */\n\tp = trigger = param;\n\tdo {\n\t\tp = strstr(p, \"if\");\n\t\tif (!p)\n\t\t\tbreak;\n\t\tif (p == param)\n\t\t\treturn -EINVAL;\n\t\tif (*(p - 1) != ' ' && *(p - 1) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (p >= param + strlen(param) - strlen(\"if\") - 1)\n\t\t\treturn -EINVAL;\n\t\tif (*(p + strlen(\"if\")) != ' ' && *(p + strlen(\"if\")) != '\\t') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tbreak;\n\t} while (p);\n\n\tif (!p)\n\t\tparam = NULL;\n\telse {\n\t\t*(p - 1) = '\\0';\n\t\tparam = strstrip(p);\n\t\ttrigger = strstrip(trigger);\n\t}\n\n\tattrs = parse_hist_trigger_attrs(trigger);\n\tif (IS_ERR(attrs))\n\t\treturn PTR_ERR(attrs);\n\n\tif (attrs->map_bits)\n\t\thist_trigger_bits = attrs->map_bits;\n\n\thist_data = create_hist_data(hist_trigger_bits, attrs, file, remove);\n\tif (IS_ERR(hist_data)) {\n\t\tdestroy_hist_trigger_attrs(attrs);\n\t\treturn PTR_ERR(hist_data);\n\t}\n\n\ttrigger_ops = cmd_ops->get_trigger_ops(cmd, trigger);\n\n\ttrigger_data = kzalloc(sizeof(*trigger_data), GFP_KERNEL);\n\tif (!trigger_data) {\n\t\tret = -ENOMEM;\n\t\tgoto out_free;\n\t}\n\n\ttrigger_data->count = -1;\n\ttrigger_data->ops = trigger_ops;\n\ttrigger_data->cmd_ops = cmd_ops;\n\n\tINIT_LIST_HEAD(&trigger_data->list);\n\tRCU_INIT_POINTER(trigger_data->filter, NULL);\n\n\ttrigger_data->private_data = hist_data;\n\n\t/* if param is non-empty, it's supposed to be a filter */\n\tif (param && cmd_ops->set_filter) {\n\t\tret = cmd_ops->set_filter(param, trigger_data, file);\n\t\tif (ret < 0)\n\t\t\tgoto out_free;\n\t}\n\n\tif (remove) {\n\t\tif (!have_hist_trigger_match(trigger_data, file))\n\t\t\tgoto out_free;\n\n\t\tif (hist_trigger_check_refs(trigger_data, file)) {\n\t\t\tret = -EBUSY;\n\t\t\tgoto out_free;\n\t\t}\n\n\t\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n\n\t\tmutex_lock(&synth_event_mutex);\n\t\tse_name = trace_event_name(file->event_call);\n\t\tse = find_synth_event(se_name);\n\t\tif (se)\n\t\t\tse->ref--;\n\t\tmutex_unlock(&synth_event_mutex);\n\n\t\tret = 0;\n\t\tgoto out_free;\n\t}\n\n\tret = cmd_ops->reg(glob, trigger_ops, trigger_data, file);\n\t/*\n\t * The above returns on success the # of triggers registered,\n\t * but if it didn't register any it returns zero.  Consider no\n\t * triggers registered a failure too.\n\t */\n\tif (!ret) {\n\t\tif (!(attrs->pause || attrs->cont || attrs->clear))\n\t\t\tret = -ENOENT;\n\t\tgoto out_free;\n\t} else if (ret < 0)\n\t\tgoto out_free;\n\n\tif (get_named_trigger_data(trigger_data))\n\t\tgoto enable;\n\n\tif (has_hist_vars(hist_data))\n\t\tsave_hist_vars(hist_data);\n\n\tret = create_actions(hist_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tret = tracing_map_init(hist_data->map);\n\tif (ret)\n\t\tgoto out_unreg;\nenable:\n\tret = hist_trigger_enable(trigger_data, file);\n\tif (ret)\n\t\tgoto out_unreg;\n\n\tmutex_lock(&synth_event_mutex);\n\tse_name = trace_event_name(file->event_call);\n\tse = find_synth_event(se_name);\n\tif (se)\n\t\tse->ref++;\n\tmutex_unlock(&synth_event_mutex);\n\n\t/* Just return zero, not the number of registered triggers */\n\tret = 0;\n out:\n\tif (ret == 0)\n\t\thist_err_clear();\n\n\treturn ret;\n out_unreg:\n\tcmd_ops->unreg(glob+1, trigger_ops, trigger_data, file);\n out_free:\n\tif (cmd_ops->set_filter)\n\t\tcmd_ops->set_filter(NULL, trigger_data, NULL);\n\n\tremove_hist_vars(hist_data);\n\n\tkfree(trigger_data);\n\n\tdestroy_hist_data(hist_data);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 3019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "cmd",
            "GFP_KERNEL"
          ],
          "line": 3015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "saved_filter"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\" if \""
          ],
          "line": 3011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_trigger_filter",
          "args": [
            "hist_data",
            "file"
          ],
          "line": 3009
        },
        "resolved": true,
        "details": {
          "function_name": "find_trigger_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2804-2817",
          "snippet": "static char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "field_name"
          ],
          "line": 3006
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\"=\""
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "field_name"
          ],
          "line": 3004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\":synthetic_\""
          ],
          "line": 3003
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "key_field->field->name"
          ],
          "line": 2998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\",\""
          ],
          "line": 2997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 2994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "cmd",
            "\"keys=\""
          ],
          "line": 2992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 2985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2983
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*var_hist)",
            "GFP_KERNEL"
          ],
          "line": 2981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR_OR_NULL",
          "args": [
            "event_var"
          ],
          "line": 2978
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_compatible_hist",
          "args": [
            "target_hist_data",
            "file"
          ],
          "line": 2968
        },
        "resolved": true,
        "details": {
          "function_name": "find_compatible_hist",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2852-2872",
          "snippet": "static struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2959
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "file"
          ],
          "line": 2958
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "file"
          ],
          "line": 2955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "event_file",
          "args": [
            "tr",
            "subsys_name",
            "event_name"
          ],
          "line": 2953
        },
        "resolved": true,
        "details": {
          "function_name": "event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2874-2884",
          "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2937
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic struct event_command trigger_hist_cmd;\nstatic struct event_command trigger_hist_cmd = {\n\t.name\t\t\t= \"hist\",\n\t.trigger_type\t\t= ETT_EVENT_HIST,\n\t.flags\t\t\t= EVENT_CMD_FL_NEEDS_REC,\n\t.func\t\t\t= event_hist_trigger_func,\n\t.reg\t\t\t= hist_register_trigger,\n\t.unreg\t\t\t= hist_unregister_trigger,\n\t.unreg_all\t\t= hist_unreg_all,\n\t.get_trigger_ops\t= event_hist_get_trigger_ops,\n\t.set_filter\t\t= set_trigger_filter,\n};\n\nstatic struct hist_field *\ncreate_field_var_hist(struct hist_trigger_data *target_hist_data,\n\t\t      char *subsys_name, char *event_name, char *field_name)\n{\n\tstruct trace_array *tr = target_hist_data->event_file->tr;\n\tstruct hist_field *event_var = ERR_PTR(-EINVAL);\n\tstruct hist_trigger_data *hist_data;\n\tunsigned int i, n, first = true;\n\tstruct field_var_hist *var_hist;\n\tstruct trace_event_file *file;\n\tstruct hist_field *key_field;\n\tchar *saved_filter;\n\tchar *cmd;\n\tint ret;\n\n\tif (target_hist_data->n_field_var_hists >= SYNTH_FIELDS_MAX) {\n\t\thist_err_event(\"onmatch: Too many field variables defined: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfile = event_file(tr, subsys_name, event_name);\n\n\tif (IS_ERR(file)) {\n\t\thist_err_event(\"onmatch: Event file not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\tret = PTR_ERR(file);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\t/*\n\t * Look for a histogram compatible with target.  We'll use the\n\t * found histogram specification to create a new matching\n\t * histogram with our variable on it.  target_hist_data is not\n\t * yet a registered histogram so we can't use that.\n\t */\n\thist_data = find_compatible_hist(target_hist_data, file);\n\tif (!hist_data) {\n\t\thist_err_event(\"onmatch: Matching event histogram not found: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/* See if a synthetic field variable has already been created */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (!IS_ERR_OR_NULL(event_var))\n\t\treturn event_var;\n\n\tvar_hist = kzalloc(sizeof(*var_hist), GFP_KERNEL);\n\tif (!var_hist)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tcmd = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!cmd) {\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Use the same keys as the compatible histogram */\n\tstrcat(cmd, \"keys=\");\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\t\tif (!first)\n\t\t\tstrcat(cmd, \",\");\n\t\tstrcat(cmd, key_field->field->name);\n\t\tfirst = false;\n\t}\n\n\t/* Create the synthetic field variable specification */\n\tstrcat(cmd, \":synthetic_\");\n\tstrcat(cmd, field_name);\n\tstrcat(cmd, \"=\");\n\tstrcat(cmd, field_name);\n\n\t/* Use the same filter as the compatible histogram */\n\tsaved_filter = find_trigger_filter(hist_data, file);\n\tif (saved_filter) {\n\t\tstrcat(cmd, \" if \");\n\t\tstrcat(cmd, saved_filter);\n\t}\n\n\tvar_hist->cmd = kstrdup(cmd, GFP_KERNEL);\n\tif (!var_hist->cmd) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\t/* Save the compatible histogram information */\n\tvar_hist->hist_data = hist_data;\n\n\t/* Create the new histogram with our variable */\n\tret = event_hist_trigger_func(&trigger_hist_cmd, file,\n\t\t\t\t      \"\", \"hist\", cmd);\n\tif (ret) {\n\t\tkfree(cmd);\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't create histogram for field: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(ret);\n\t}\n\n\tkfree(cmd);\n\n\t/* If we can't find the variable, something went wrong */\n\tevent_var = find_synthetic_field_var(target_hist_data, subsys_name,\n\t\t\t\t\t     event_name, field_name);\n\tif (IS_ERR_OR_NULL(event_var)) {\n\t\tkfree(var_hist->cmd);\n\t\tkfree(var_hist);\n\t\thist_err_event(\"onmatch: Couldn't find synthetic variable: \",\n\t\t\t       subsys_name, event_name, field_name);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tn = target_hist_data->n_field_var_hists;\n\ttarget_hist_data->field_var_hists[n] = var_hist;\n\ttarget_hist_data->n_field_var_hists++;\n\n\treturn event_var;\n}"
  },
  {
    "function_name": "find_synthetic_field_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2886-2905",
    "snippet": "static struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "synthetic_name"
          ],
          "line": 2902
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "target_hist_data",
            "system",
            "event_name",
            "synthetic_name"
          ],
          "line": 2900
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1595-1619",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "synthetic_name",
            "field_name"
          ],
          "line": 2898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "synthetic_name",
            "\"synthetic_\""
          ],
          "line": 2897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 2893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_synthetic_field_var(struct hist_trigger_data *target_hist_data,\n\t\t\t char *system, char *event_name, char *field_name)\n{\n\tstruct hist_field *event_var;\n\tchar *synthetic_name;\n\n\tsynthetic_name = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!synthetic_name)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tstrcpy(synthetic_name, \"synthetic_\");\n\tstrcat(synthetic_name, field_name);\n\n\tevent_var = find_event_var(target_hist_data, system, event_name, synthetic_name);\n\n\tkfree(synthetic_name);\n\n\treturn event_var;\n}"
  },
  {
    "function_name": "event_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2874-2884",
    "snippet": "static struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2881
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__find_event_file",
          "args": [
            "tr",
            "system",
            "event_name"
          ],
          "line": 2879
        },
        "resolved": true,
        "details": {
          "function_name": "__find_event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2480-2500",
          "snippet": "struct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct trace_event_file *\n__find_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\tstruct trace_event_call *call;\n\tconst char *name;\n\n\tlist_for_each_entry(file, &tr->events, list) {\n\n\t\tcall = file->event_call;\n\t\tname = trace_event_name(call);\n\n\t\tif (!name || !call->class)\n\t\t\tcontinue;\n\n\t\tif (strcmp(event, name) == 0 &&\n\t\t    strcmp(system, call->class->system) == 0)\n\t\t\treturn file;\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *event_file(struct trace_array *tr,\n\t\t\t\t\t   char *system, char *event_name)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event_name);\n\tif (!file)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file;\n}"
  },
  {
    "function_name": "find_compatible_hist",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2852-2872",
    "snippet": "static struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compatible_keys",
          "args": [
            "target_hist_data",
            "hist_data",
            "n_keys"
          ],
          "line": 2866
        },
        "resolved": true,
        "details": {
          "function_name": "compatible_keys",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2824-2850",
          "snippet": "static bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 2862
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_data *\nfind_compatible_hist(struct hist_trigger_data *target_hist_data,\n\t\t     struct trace_event_file *file)\n{\n\tstruct hist_trigger_data *hist_data;\n\tstruct event_trigger_data *test;\n\tunsigned int n_keys;\n\n\tn_keys = target_hist_data->n_fields - target_hist_data->n_vals;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\thist_data = test->private_data;\n\n\t\t\tif (compatible_keys(target_hist_data, hist_data, n_keys))\n\t\t\t\treturn hist_data;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "compatible_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2824-2850",
    "snippet": "static bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hist_field->type",
            "target_hist_field->type"
          ],
          "line": 2841
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool compatible_keys(struct hist_trigger_data *target_hist_data,\n\t\t\t    struct hist_trigger_data *hist_data,\n\t\t\t    unsigned int n_keys)\n{\n\tstruct hist_field *target_hist_field, *hist_field;\n\tunsigned int n, i, j;\n\n\tif (hist_data->n_fields - hist_data->n_vals != n_keys)\n\t\treturn false;\n\n\ti = hist_data->n_vals;\n\tj = target_hist_data->n_vals;\n\n\tfor (n = 0; n < n_keys; n++) {\n\t\thist_field = hist_data->fields[i + n];\n\t\ttarget_hist_field = target_hist_data->fields[j + n];\n\n\t\tif (strcmp(hist_field->type, target_hist_field->type) != 0)\n\t\t\treturn false;\n\t\tif (hist_field->size != target_hist_field->size)\n\t\t\treturn false;\n\t\tif (hist_field->is_signed != target_hist_field->is_signed)\n\t\t\treturn false;\n\t}\n\n\treturn true;\n}"
  },
  {
    "function_name": "find_trigger_filter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2804-2817",
    "snippet": "static char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 2809
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *find_trigger_filter(struct hist_trigger_data *hist_data,\n\t\t\t\t struct trace_event_file *file)\n{\n\tstruct event_trigger_data *test;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\tif (test->private_data == hist_data)\n\t\t\t\treturn test->filter_str;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "parse_expr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2699-2802",
    "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "expr",
            "0"
          ],
          "line": 2799
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "operand1->type",
            "GFP_KERNEL"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "expr",
            "0"
          ],
          "line": 2776
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2076-2126",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2764
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_expr_operands",
          "args": [
            "operand1",
            "operand2"
          ],
          "line": 2755
        },
        "resolved": true,
        "details": {
          "function_name": "check_expr_operands",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2664-2697",
          "snippet": "static int check_expr_operands(struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(\"Timestamp units in expression don't match\", NULL);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_expr_operands(struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(\"Timestamp units in expression don't match\", NULL);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "operand2"
          ],
          "line": 2750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand2"
          ],
          "line": 2749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "str",
            "operand_flags",
            "NULL",
            "++level"
          ],
          "line": 2748
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2699-2802",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "operand1"
          ],
          "line": 2741
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand1"
          ],
          "line": 2740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_atom",
          "args": [
            "hist_data",
            "file",
            "operand1_str",
            "&operand_flags",
            "NULL"
          ],
          "line": 2738
        },
        "resolved": true,
        "details": {
          "function_name": "parse_atom",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2529-2589",
          "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "sep"
          ],
          "line": 2733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_unary",
          "args": [
            "hist_data",
            "file",
            "str",
            "flags",
            "var_name",
            "++level"
          ],
          "line": 2720
        },
        "resolved": true,
        "details": {
          "function_name": "parse_unary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2596-2662",
          "snippet": "static struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s)\n\t\t*s = '\\0';\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s)\n\t\t*s = '\\0';\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "contains_operator",
          "args": [
            "str"
          ],
          "line": 2714
        },
        "resolved": true,
        "details": {
          "function_name": "contains_operator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2128-2152",
          "snippet": "static int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Too many subexpressions (3 max): \"",
            "str"
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "check_expr_operands",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2664-2697",
    "snippet": "static int check_expr_operands(struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(\"Timestamp units in expression don't match\", NULL);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Timestamp units in expression don't match\"",
            "NULL"
          ],
          "line": 2692
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "operand2->var.hist_data",
            "operand2->name"
          ],
          "line": 2684
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1471-1487",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int check_expr_operands(struct hist_field *operand1,\n\t\t\t       struct hist_field *operand2)\n{\n\tunsigned long operand1_flags = operand1->flags;\n\tunsigned long operand2_flags = operand2->flags;\n\n\tif ((operand1_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand1_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand1->var.hist_data, operand1->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand1_flags = var->flags;\n\t}\n\n\tif ((operand2_flags & HIST_FIELD_FL_VAR_REF) ||\n\t    (operand2_flags & HIST_FIELD_FL_ALIAS)) {\n\t\tstruct hist_field *var;\n\n\t\tvar = find_var_field(operand2->var.hist_data, operand2->name);\n\t\tif (!var)\n\t\t\treturn -EINVAL;\n\t\toperand2_flags = var->flags;\n\t}\n\n\tif ((operand1_flags & HIST_FIELD_FL_TIMESTAMP_USECS) !=\n\t    (operand2_flags & HIST_FIELD_FL_TIMESTAMP_USECS)) {\n\t\thist_err(\"Timestamp units in expression don't match\", NULL);\n\t\treturn -EINVAL;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "parse_unary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2596-2662",
    "snippet": "static struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s)\n\t\t*s = '\\0';\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "expr",
            "0"
          ],
          "line": 2660
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "operand1->type",
            "GFP_KERNEL"
          ],
          "line": 2652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "expr",
            "0"
          ],
          "line": 2651
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2076-2126",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "operand1"
          ],
          "line": 2642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "operand1"
          ],
          "line": 2641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_expr",
          "args": [
            "hist_data",
            "file",
            "str",
            "operand_flags",
            "NULL",
            "++level"
          ],
          "line": 2640
        },
        "resolved": true,
        "details": {
          "function_name": "parse_expr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2699-2802",
          "snippet": "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1 = NULL, *operand2 = NULL, *expr = NULL;\n\tunsigned long operand_flags;\n\tint field_op, ret = -EINVAL;\n\tchar *sep, *operand1_str;\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tfield_op = contains_operator(str);\n\n\tif (field_op == FIELD_OP_NONE)\n\t\treturn parse_atom(hist_data, file, str, &flags, var_name);\n\n\tif (field_op == FIELD_OP_UNARY_MINUS)\n\t\treturn parse_unary(hist_data, file, str, flags, var_name, ++level);\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\tsep = \"-\";\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tsep = \"+\";\n\t\tbreak;\n\tdefault:\n\t\tgoto free;\n\t}\n\n\toperand1_str = strsep(&str, sep);\n\tif (!operand1_str || !str)\n\t\tgoto free;\n\n\toperand_flags = 0;\n\toperand1 = parse_atom(hist_data, file, operand1_str,\n\t\t\t      &operand_flags, NULL);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\toperand1 = NULL;\n\t\tgoto free;\n\t}\n\n\t/* rest of string could be another expression e.g. b+c in a+b+c */\n\toperand_flags = 0;\n\toperand2 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand2)) {\n\t\tret = PTR_ERR(operand2);\n\t\toperand2 = NULL;\n\t\tgoto free;\n\t}\n\n\tret = check_expr_operands(operand1, operand2);\n\tif (ret)\n\t\tgoto free;\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\n\tflags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand1->read_once = true;\n\toperand2->read_once = true;\n\n\texpr->operands[0] = operand1;\n\texpr->operands[1] = operand2;\n\texpr->operator = field_op;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\tswitch (field_op) {\n\tcase FIELD_OP_MINUS:\n\t\texpr->fn = hist_field_minus;\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\texpr->fn = hist_field_plus;\n\t\tbreak;\n\tdefault:\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(operand1, 0);\n\tdestroy_hist_field(operand2, 0);\n\tdestroy_hist_field(expr, 0);\n\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strrchr",
          "args": [
            "str",
            "')'"
          ],
          "line": 2624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'('"
          ],
          "line": 2616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Too many subexpressions (3 max): \"",
            "str"
          ],
          "line": 2609
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *parse_unary(struct hist_trigger_data *hist_data,\n\t\t\t\t      struct trace_event_file *file,\n\t\t\t\t      char *str, unsigned long flags,\n\t\t\t\t      char *var_name, unsigned int level)\n{\n\tstruct hist_field *operand1, *expr = NULL;\n\tunsigned long operand_flags;\n\tint ret = 0;\n\tchar *s;\n\n\t/* we support only -(xxx) i.e. explicit parens required */\n\n\tif (level > 3) {\n\t\thist_err(\"Too many subexpressions (3 max): \", str);\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tstr++; /* skip leading '-' */\n\n\ts = strchr(str, '(');\n\tif (s)\n\t\tstr++;\n\telse {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\ts = strrchr(str, ')');\n\tif (s)\n\t\t*s = '\\0';\n\telse {\n\t\tret = -EINVAL; /* no closing ')' */\n\t\tgoto free;\n\t}\n\n\tflags |= HIST_FIELD_FL_EXPR;\n\texpr = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!expr) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\toperand_flags = 0;\n\toperand1 = parse_expr(hist_data, file, str, operand_flags, NULL, ++level);\n\tif (IS_ERR(operand1)) {\n\t\tret = PTR_ERR(operand1);\n\t\tgoto free;\n\t}\n\n\texpr->flags |= operand1->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\texpr->fn = hist_field_unary_minus;\n\texpr->operands[0] = operand1;\n\texpr->operator = FIELD_OP_UNARY_MINUS;\n\texpr->name = expr_str(expr, 0);\n\texpr->type = kstrdup(operand1->type, GFP_KERNEL);\n\tif (!expr->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\n\treturn expr;\n free:\n\tdestroy_hist_field(expr, 0);\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_atom",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2529-2589",
    "snippet": "static struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "field",
            "*flags",
            "var_name"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field"
          ],
          "line": 2575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_field",
          "args": [
            "hist_data",
            "file",
            "str",
            "flags"
          ],
          "line": 2574
        },
        "resolved": true,
        "details": {
          "function_name": "parse_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2451-2505",
          "snippet": "static struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\telse if (strcmp(modifier, \"sym-offset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse {\n\t\t\thist_err(\"Invalid field modifier: \", modifier);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\thist_err(\"Couldn't find field: \", field_name);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\telse if (strcmp(modifier, \"sym-offset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse {\n\t\t\thist_err(\"Invalid field modifier: \", modifier);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\thist_err(\"Couldn't find field: \", field_name);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_alias",
          "args": [
            "hist_data",
            "hist_field",
            "var_name"
          ],
          "line": 2563
        },
        "resolved": true,
        "details": {
          "function_name": "create_alias",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2507-2527",
          "snippet": "static struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\treturn alias;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\treturn alias;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_var_ref",
          "args": [
            "hist_data",
            "ref_system",
            "ref_event",
            "ref_var"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "parse_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2429-2449",
          "snippet": "static struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(var_field, system, event_name);\n\n\tif (!ref_field)\n\t\thist_err_event(\"Couldn't find variable: $\",\n\t\t\t       system, event_name, var_name);\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(var_field, system, event_name);\n\n\tif (!ref_field)\n\t\thist_err_event(\"Couldn't find variable: $\",\n\t\t\t       system, event_name, var_name);\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_field_var_ref",
          "args": [
            "hist_data",
            "ref_system",
            "ref_event",
            "ref_var"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "local_field_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2402-2427",
          "snippet": "static char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 2547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\".\""
          ],
          "line": 2542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "++s",
            "'.'"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'.'"
          ],
          "line": 2538
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_atom(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file, char *str,\n\t\t\t\t     unsigned long *flags, char *var_name)\n{\n\tchar *s, *ref_system = NULL, *ref_event = NULL, *ref_var = str;\n\tstruct ftrace_event_field *field = NULL;\n\tstruct hist_field *hist_field = NULL;\n\tint ret = 0;\n\n\ts = strchr(str, '.');\n\tif (s) {\n\t\ts = strchr(++s, '.');\n\t\tif (s) {\n\t\t\tref_system = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_event = strsep(&str, \".\");\n\t\t\tif (!str) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tref_var = str;\n\t\t}\n\t}\n\n\ts = local_field_var_ref(hist_data, ref_system, ref_event, ref_var);\n\tif (!s) {\n\t\thist_field = parse_var_ref(hist_data, ref_system, ref_event, ref_var);\n\t\tif (hist_field) {\n\t\t\thist_data->var_refs[hist_data->n_var_refs] = hist_field;\n\t\t\thist_field->var_ref_idx = hist_data->n_var_refs++;\n\t\t\tif (var_name) {\n\t\t\t\thist_field = create_alias(hist_data, hist_field, var_name);\n\t\t\t\tif (!hist_field) {\n\t\t\t\t\tret = -ENOMEM;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn hist_field;\n\t\t}\n\t} else\n\t\tstr = s;\n\n\tfield = parse_field(hist_data, file, str, flags);\n\tif (IS_ERR(field)) {\n\t\tret = PTR_ERR(field);\n\t\tgoto out;\n\t}\n\n\thist_field = create_hist_field(hist_data, field, *flags, var_name);\n\tif (!hist_field) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\treturn hist_field;\n out:\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "create_alias",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2507-2527",
    "snippet": "static struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\treturn alias;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "alias",
            "0"
          ],
          "line": 2522
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_var_ref",
          "args": [
            "alias",
            "var_ref",
            "var_ref->system",
            "var_ref->event_name"
          ],
          "line": 2521
        },
        "resolved": true,
        "details": {
          "function_name": "init_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2301-2355",
          "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "NULL",
            "flags",
            "var_name"
          ],
          "line": 2514
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_alias(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_field *var_ref,\n\t\t\t\t       char *var_name)\n{\n\tstruct hist_field *alias = NULL;\n\tunsigned long flags = HIST_FIELD_FL_ALIAS | HIST_FIELD_FL_VAR;\n\n\talias = create_hist_field(hist_data, NULL, flags, var_name);\n\tif (!alias)\n\t\treturn NULL;\n\n\talias->fn = var_ref->fn;\n\talias->operands[0] = var_ref;\n\n\tif (init_var_ref(alias, var_ref, var_ref->system, var_ref->event_name)) {\n\t\tdestroy_hist_field(alias, 0);\n\t\treturn NULL;\n\t}\n\n\treturn alias;\n}"
  },
  {
    "function_name": "parse_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2451-2505",
    "snippet": "static struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\telse if (strcmp(modifier, \"sym-offset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse {\n\t\t\thist_err(\"Invalid field modifier: \", modifier);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\thist_err(\"Couldn't find field: \", field_name);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "str"
          ],
          "line": 2502
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Couldn't find field: \"",
            "field_name"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_find_event_field",
          "args": [
            "file->event_call",
            "field_name"
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "trace_find_event_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "94-110",
          "snippet": "struct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(ftrace_generic_fields);",
            "static LIST_HEAD(ftrace_common_fields);",
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic LIST_HEAD(ftrace_generic_fields);\nstatic LIST_HEAD(ftrace_common_fields);\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nstruct ftrace_event_field *\ntrace_find_event_field(struct trace_event_call *call, char *name)\n{\n\tstruct ftrace_event_field *field;\n\tstruct list_head *head;\n\n\thead = trace_get_fields(call);\n\tfield = __find_event_field(head, name);\n\tif (field)\n\t\treturn field;\n\n\tfield = __find_event_field(&ftrace_generic_fields, name);\n\tif (field)\n\t\treturn field;\n\n\treturn __find_event_field(&ftrace_common_fields, name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "\"cpu\""
          ],
          "line": 2491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "\"common_timestamp\""
          ],
          "line": 2486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 2481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"usecs\""
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"log2\""
          ],
          "line": 2475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"syscall\""
          ],
          "line": 2473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_name",
            "\"common_pid\""
          ],
          "line": 2471
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"execname\""
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"sym-offset\""
          ],
          "line": 2468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"sym\""
          ],
          "line": 2466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "modifier",
            "\"hex\""
          ],
          "line": 2464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&modifier",
            "\".\""
          ],
          "line": 2462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 2460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field_str",
            "GFP_KERNEL"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct ftrace_event_field *\nparse_field(struct hist_trigger_data *hist_data, struct trace_event_file *file,\n\t    char *field_str, unsigned long *flags)\n{\n\tstruct ftrace_event_field *field = NULL;\n\tchar *field_name, *modifier, *str;\n\n\tmodifier = str = kstrdup(field_str, GFP_KERNEL);\n\tif (!modifier)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tfield_name = strsep(&modifier, \".\");\n\tif (modifier) {\n\t\tif (strcmp(modifier, \"hex\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_HEX;\n\t\telse if (strcmp(modifier, \"sym\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM;\n\t\telse if (strcmp(modifier, \"sym-offset\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYM_OFFSET;\n\t\telse if ((strcmp(modifier, \"execname\") == 0) &&\n\t\t\t (strcmp(field_name, \"common_pid\") == 0))\n\t\t\t*flags |= HIST_FIELD_FL_EXECNAME;\n\t\telse if (strcmp(modifier, \"syscall\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_SYSCALL;\n\t\telse if (strcmp(modifier, \"log2\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_LOG2;\n\t\telse if (strcmp(modifier, \"usecs\") == 0)\n\t\t\t*flags |= HIST_FIELD_FL_TIMESTAMP_USECS;\n\t\telse {\n\t\t\thist_err(\"Invalid field modifier: \", modifier);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tif (strcmp(field_name, \"common_timestamp\") == 0) {\n\t\t*flags |= HIST_FIELD_FL_TIMESTAMP;\n\t\thist_data->enable_timestamps = true;\n\t\tif (*flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\t\thist_data->attrs->ts_in_usecs = true;\n\t} else if (strcmp(field_name, \"cpu\") == 0)\n\t\t*flags |= HIST_FIELD_FL_CPU;\n\telse {\n\t\tfield = trace_find_event_field(file->event_call, field_name);\n\t\tif (!field || !field->size) {\n\t\t\thist_err(\"Couldn't find field: \", field_name);\n\t\t\tfield = ERR_PTR(-EINVAL);\n\t\t\tgoto out;\n\t\t}\n\t}\n out:\n\tkfree(str);\n\n\treturn field;\n}"
  },
  {
    "function_name": "parse_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2429-2449",
    "snippet": "static struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(var_field, system, event_name);\n\n\tif (!ref_field)\n\t\thist_err_event(\"Couldn't find variable: $\",\n\t\t\t       system, event_name, var_name);\n\n\treturn ref_field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"Couldn't find variable: $\"",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 2445
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_var_ref",
          "args": [
            "var_field",
            "system",
            "event_name"
          ],
          "line": 2442
        },
        "resolved": true,
        "details": {
          "function_name": "create_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2357-2372",
          "snippet": "static struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_event_var",
          "args": [
            "hist_data",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 2440
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1595-1619",
          "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "var_name"
          ],
          "line": 2435
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2374-2380",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\tchar *system, char *event_name,\n\t\t\t\t\tchar *var_name)\n{\n\tstruct hist_field *var_field = NULL, *ref_field = NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\tvar_field = find_event_var(hist_data, system, event_name, var_name);\n\tif (var_field)\n\t\tref_field = create_var_ref(var_field, system, event_name);\n\n\tif (!ref_field)\n\t\thist_err_event(\"Couldn't find variable: $\",\n\t\t\t       system, event_name, var_name);\n\n\treturn ref_field;\n}"
  },
  {
    "function_name": "local_field_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2402-2427",
    "snippet": "static char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_name_from_var",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "field_name_from_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2382-2400",
          "snippet": "static char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "var_name"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2374-2380",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event_name",
            "trace_event_name(call)"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 2414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "system",
            "call->class->system"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *local_field_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t char *system, char *event_name,\n\t\t\t\t char *var_name)\n{\n\tstruct trace_event_call *call;\n\n\tif (system && event_name) {\n\t\tcall = hist_data->event_file->event_call;\n\n\t\tif (strcmp(system, call->class->system) != 0)\n\t\t\treturn NULL;\n\n\t\tif (strcmp(event_name, trace_event_name(call)) != 0)\n\t\t\treturn NULL;\n\t}\n\n\tif (!!system != !!event_name)\n\t\treturn NULL;\n\n\tif (!is_var_ref(var_name))\n\t\treturn NULL;\n\n\tvar_name++;\n\n\treturn field_name_from_var(hist_data, var_name);\n}"
  },
  {
    "function_name": "field_name_from_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2382-2400",
    "snippet": "static char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_var_ref",
          "args": [
            "field"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "is_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2374-2380",
          "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "contains_operator",
          "args": [
            "field"
          ],
          "line": 2393
        },
        "resolved": true,
        "details": {
          "function_name": "contains_operator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2128-2152",
          "snippet": "static int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "var_name",
            "name"
          ],
          "line": 2391
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char *field_name_from_var(struct hist_trigger_data *hist_data,\n\t\t\t\t char *var_name)\n{\n\tchar *name, *field;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->attrs->var_defs.n_vars; i++) {\n\t\tname = hist_data->attrs->var_defs.name[i];\n\n\t\tif (strcmp(var_name, name) == 0) {\n\t\t\tfield = hist_data->attrs->var_defs.expr[i];\n\t\t\tif (contains_operator(field) || is_var_ref(field))\n\t\t\t\tcontinue;\n\t\t\treturn field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "is_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2374-2380",
    "snippet": "static bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var_name"
          ],
          "line": 2376
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool is_var_ref(char *var_name)\n{\n\tif (!var_name || strlen(var_name) < 2 || var_name[0] != '$')\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "create_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2357-2372",
    "snippet": "static struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "ref_field",
            "0"
          ],
          "line": 2366
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_var_ref",
          "args": [
            "ref_field",
            "var_field",
            "system",
            "event_name"
          ],
          "line": 2365
        },
        "resolved": true,
        "details": {
          "function_name": "init_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2301-2355",
          "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "var_field->hist_data",
            "NULL",
            "flags",
            "NULL"
          ],
          "line": 2363
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_var_ref(struct hist_field *var_field,\n\t\t\t\t\t char *system, char *event_name)\n{\n\tunsigned long flags = HIST_FIELD_FL_VAR_REF;\n\tstruct hist_field *ref_field;\n\n\tref_field = create_hist_field(var_field->hist_data, NULL, flags, NULL);\n\tif (ref_field) {\n\t\tif (init_var_ref(ref_field, var_field, system, event_name)) {\n\t\t\tdestroy_hist_field(ref_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\treturn ref_field;\n}"
  },
  {
    "function_name": "init_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2301-2355",
    "snippet": "static int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ref_field->name"
          ],
          "line": 2352
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_field->type",
            "GFP_KERNEL"
          ],
          "line": 2342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_field->name",
            "GFP_KERNEL"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_field->var.name",
            "GFP_KERNEL"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event_name",
            "GFP_KERNEL"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "system",
            "GFP_KERNEL"
          ],
          "line": 2315
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int init_var_ref(struct hist_field *ref_field,\n\t\t\tstruct hist_field *var_field,\n\t\t\tchar *system, char *event_name)\n{\n\tint err = 0;\n\n\tref_field->var.idx = var_field->var.idx;\n\tref_field->var.hist_data = var_field->hist_data;\n\tref_field->size = var_field->size;\n\tref_field->is_signed = var_field->is_signed;\n\tref_field->flags |= var_field->flags &\n\t\t(HIST_FIELD_FL_TIMESTAMP | HIST_FIELD_FL_TIMESTAMP_USECS);\n\n\tif (system) {\n\t\tref_field->system = kstrdup(system, GFP_KERNEL);\n\t\tif (!ref_field->system)\n\t\t\treturn -ENOMEM;\n\t}\n\n\tif (event_name) {\n\t\tref_field->event_name = kstrdup(event_name, GFP_KERNEL);\n\t\tif (!ref_field->event_name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (var_field->var.name) {\n\t\tref_field->name = kstrdup(var_field->var.name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t} else if (var_field->name) {\n\t\tref_field->name = kstrdup(var_field->name, GFP_KERNEL);\n\t\tif (!ref_field->name) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\tref_field->type = kstrdup(var_field->type, GFP_KERNEL);\n\tif (!ref_field->type) {\n\t\terr = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn err;\n free:\n\tkfree(ref_field->system);\n\tkfree(ref_field->event_name);\n\tkfree(ref_field->name);\n\n\tgoto out;\n}"
  },
  {
    "function_name": "destroy_hist_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2289-2299",
    "snippet": "static void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_data->fields[i]",
            "0"
          ],
          "line": 2295
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELDS_MAX\t\t(TRACING_MAP_FIELDS_MAX + TRACING_MAP_VARS_MAX)\n\nstatic void destroy_hist_fields(struct hist_trigger_data *hist_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < HIST_FIELDS_MAX; i++) {\n\t\tif (hist_data->fields[i]) {\n\t\t\tdestroy_hist_field(hist_data->fields[i], 0);\n\t\t\thist_data->fields[i] = NULL;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "create_hist_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2175-2287",
    "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "var_name",
            "GFP_KERNEL"
          ],
          "line": 2278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "select_value_fn",
          "args": [
            "field->size",
            "field->is_signed"
          ],
          "line": 2266
        },
        "resolved": true,
        "details": {
          "function_name": "select_value_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1724-1756",
          "snippet": "static hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field->type",
            "GFP_KERNEL"
          ],
          "line": 2262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field->type",
            "GFP_KERNEL"
          ],
          "line": 2249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_string_field",
          "args": [
            "field"
          ],
          "line": 2245
        },
        "resolved": true,
        "details": {
          "function_name": "is_string_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1417-1423",
          "snippet": "static inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_string_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_DYN_STRING ||\n\t       field->filter_type == FILTER_STATIC_STRING ||\n\t       field->filter_type == FILTER_PTR_STRING ||\n\t       field->filter_type == FILTER_COMM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!field"
          ],
          "line": 2242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"unsigned int\"",
            "GFP_KERNEL"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"u64\"",
            "GFP_KERNEL"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "hist_field->operands[0]->type",
            "GFP_KERNEL"
          ],
          "line": 2218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_hist_field",
          "args": [
            "hist_data",
            "field",
            "fl",
            "NULL"
          ],
          "line": 2216
        },
        "resolved": true,
        "details": {
          "function_name": "create_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2175-2287",
          "snippet": "static struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"u64\"",
            "GFP_KERNEL"
          ],
          "line": 2202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct hist_field)",
            "GFP_KERNEL"
          ],
          "line": 2185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_function_field",
          "args": [
            "field"
          ],
          "line": 2182
        },
        "resolved": true,
        "details": {
          "function_name": "is_function_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.h",
          "lines": "1425-1428",
          "snippet": "static inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include <asm/syscall.h>\t/* some archs define it here */",
            "#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */",
            "#include <linux/glob.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/compiler.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/mmiotrace.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/sched.h>",
            "#include <linux/atomic.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include <asm/syscall.h>\t/* some archs define it here */\n#include <asm/unistd.h>\t\t/* For NR_SYSCALLS\t     */\n#include <linux/glob.h>\n#include <linux/trace_seq.h>\n#include <linux/compiler.h>\n#include <linux/trace_events.h>\n#include <linux/trace_seq.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <linux/mmiotrace.h>\n#include <linux/ring_buffer.h>\n#include <linux/clocksource.h>\n#include <linux/sched.h>\n#include <linux/atomic.h>\n#include <linux/fs.h>\n\nstatic inline bool is_function_field(struct ftrace_event_field *field)\n{\n\treturn field->filter_type == FILTER_TRACE_FN;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *create_hist_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t    struct ftrace_event_field *field,\n\t\t\t\t\t    unsigned long flags,\n\t\t\t\t\t    char *var_name)\n{\n\tstruct hist_field *hist_field;\n\n\tif (field && is_function_field(field))\n\t\treturn NULL;\n\n\thist_field = kzalloc(sizeof(struct hist_field), GFP_KERNEL);\n\tif (!hist_field)\n\t\treturn NULL;\n\n\thist_field->hist_data = hist_data;\n\n\tif (flags & HIST_FIELD_FL_EXPR || flags & HIST_FIELD_FL_ALIAS)\n\t\tgoto out; /* caller will populate */\n\n\tif (flags & HIST_FIELD_FL_VAR_REF) {\n\t\thist_field->fn = hist_field_var_ref;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_HITCOUNT) {\n\t\thist_field->fn = hist_field_counter;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_STACKTRACE) {\n\t\thist_field->fn = hist_field_none;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_LOG2) {\n\t\tunsigned long fl = flags & ~HIST_FIELD_FL_LOG2;\n\t\thist_field->fn = hist_field_log2;\n\t\thist_field->operands[0] = create_hist_field(hist_data, field, fl, NULL);\n\t\thist_field->size = hist_field->operands[0]->size;\n\t\thist_field->type = kstrdup(hist_field->operands[0]->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_TIMESTAMP) {\n\t\thist_field->fn = hist_field_timestamp;\n\t\thist_field->size = sizeof(u64);\n\t\thist_field->type = kstrdup(\"u64\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (flags & HIST_FIELD_FL_CPU) {\n\t\thist_field->fn = hist_field_cpu;\n\t\thist_field->size = sizeof(int);\n\t\thist_field->type = kstrdup(\"unsigned int\", GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\t\tgoto out;\n\t}\n\n\tif (WARN_ON_ONCE(!field))\n\t\tgoto out;\n\n\tif (is_string_field(field)) {\n\t\tflags |= HIST_FIELD_FL_STRING;\n\n\t\thist_field->size = MAX_FILTER_STR_VAL;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\tif (field->filter_type == FILTER_STATIC_STRING)\n\t\t\thist_field->fn = hist_field_string;\n\t\telse if (field->filter_type == FILTER_DYN_STRING)\n\t\t\thist_field->fn = hist_field_dynstring;\n\t\telse\n\t\t\thist_field->fn = hist_field_pstring;\n\t} else {\n\t\thist_field->size = field->size;\n\t\thist_field->is_signed = field->is_signed;\n\t\thist_field->type = kstrdup(field->type, GFP_KERNEL);\n\t\tif (!hist_field->type)\n\t\t\tgoto free;\n\n\t\thist_field->fn = select_value_fn(field->size,\n\t\t\t\t\t\t field->is_signed);\n\t\tif (!hist_field->fn) {\n\t\t\tdestroy_hist_field(hist_field, 0);\n\t\t\treturn NULL;\n\t\t}\n\t}\n out:\n\thist_field->field = field;\n\thist_field->flags = flags;\n\n\tif (var_name) {\n\t\thist_field->var.name = kstrdup(var_name, GFP_KERNEL);\n\t\tif (!hist_field->var.name)\n\t\t\tgoto free;\n\t}\n\n\treturn hist_field;\n free:\n\tdestroy_hist_field(hist_field, 0);\n\treturn NULL;\n}"
  },
  {
    "function_name": "destroy_hist_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2154-2173",
    "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELD_OPERANDS_MAX\t2"
    ],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "hist_field"
          ],
          "line": 2172
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_hist_field",
          "args": [
            "hist_field->operands[i]",
            "level + 1"
          ],
          "line": 2166
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2154-2173",
          "snippet": "static void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic void destroy_hist_field(struct hist_field *hist_field,\n\t\t\t       unsigned int level)\n{\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn;\n\n\tif (!hist_field)\n\t\treturn;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++)\n\t\tdestroy_hist_field(hist_field->operands[i], level + 1);\n\n\tkfree(hist_field->var.name);\n\tkfree(hist_field->name);\n\tkfree(hist_field->type);\n\n\tkfree(hist_field);\n}"
  },
  {
    "function_name": "contains_operator",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2128-2152",
    "snippet": "static int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "str",
            "\"+-\""
          ],
          "line": 2133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int contains_operator(char *str)\n{\n\tenum field_op_id field_op = FIELD_OP_NONE;\n\tchar *op;\n\n\top = strpbrk(str, \"+-\");\n\tif (!op)\n\t\treturn FIELD_OP_NONE;\n\n\tswitch (*op) {\n\tcase '-':\n\t\tif (*str == '-')\n\t\t\tfield_op = FIELD_OP_UNARY_MINUS;\n\t\telse\n\t\t\tfield_op = FIELD_OP_MINUS;\n\t\tbreak;\n\tcase '+':\n\t\tfield_op = FIELD_OP_PLUS;\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\n\treturn field_op;\n}"
  },
  {
    "function_name": "expr_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2076-2126",
    "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "expr_field_str",
          "args": [
            "field->operands[1]",
            "expr"
          ],
          "line": 2123
        },
        "resolved": true,
        "details": {
          "function_name": "expr_field_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2059-2074",
          "snippet": "static void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "expr"
          ],
          "line": 2119
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"+\""
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"-\""
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\")\""
          ],
          "line": 2102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "subexpr"
          ],
          "line": 2101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "expr_str",
          "args": [
            "field->operands[0]",
            "++level"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "expr_str",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2076-2126",
          "snippet": "static char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"-(\""
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "MAX_FILTER_STR_VAL",
            "GFP_KERNEL"
          ],
          "line": 2083
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic char *expr_str(struct hist_field *field, unsigned int level)\n{\n\tchar *expr;\n\n\tif (level > 1)\n\t\treturn NULL;\n\n\texpr = kzalloc(MAX_FILTER_STR_VAL, GFP_KERNEL);\n\tif (!expr)\n\t\treturn NULL;\n\n\tif (!field->operands[0]) {\n\t\texpr_field_str(field, expr);\n\t\treturn expr;\n\t}\n\n\tif (field->operator == FIELD_OP_UNARY_MINUS) {\n\t\tchar *subexpr;\n\n\t\tstrcat(expr, \"-(\");\n\t\tsubexpr = expr_str(field->operands[0], ++level);\n\t\tif (!subexpr) {\n\t\t\tkfree(expr);\n\t\t\treturn NULL;\n\t\t}\n\t\tstrcat(expr, subexpr);\n\t\tstrcat(expr, \")\");\n\n\t\tkfree(subexpr);\n\n\t\treturn expr;\n\t}\n\n\texpr_field_str(field->operands[0], expr);\n\n\tswitch (field->operator) {\n\tcase FIELD_OP_MINUS:\n\t\tstrcat(expr, \"-\");\n\t\tbreak;\n\tcase FIELD_OP_PLUS:\n\t\tstrcat(expr, \"+\");\n\t\tbreak;\n\tdefault:\n\t\tkfree(expr);\n\t\treturn NULL;\n\t}\n\n\texpr_field_str(field->operands[1], expr);\n\n\treturn expr;\n}"
  },
  {
    "function_name": "expr_field_str",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2059-2074",
    "snippet": "static void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "flags_str"
          ],
          "line": 2071
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\".\""
          ],
          "line": 2070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_hist_field_flags",
          "args": [
            "field"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "get_hist_field_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "2037-2057",
          "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "hist_field_name(field, 0)"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "field",
            "0"
          ],
          "line": 2064
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1687-1722",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "expr",
            "\"$\""
          ],
          "line": 2062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void expr_field_str(struct hist_field *field, char *expr)\n{\n\tif (field->flags & HIST_FIELD_FL_VAR_REF)\n\t\tstrcat(expr, \"$\");\n\n\tstrcat(expr, hist_field_name(field, 0));\n\n\tif (field->flags && !(field->flags & HIST_FIELD_FL_VAR_REF)) {\n\t\tconst char *flags_str = get_hist_field_flags(field);\n\n\t\tif (flags_str) {\n\t\t\tstrcat(expr, \".\");\n\t\t\tstrcat(expr, flags_str);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "get_hist_field_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2037-2057",
    "snippet": "static const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *get_hist_field_flags(struct hist_field *hist_field)\n{\n\tconst char *flags_str = NULL;\n\n\tif (hist_field->flags & HIST_FIELD_FL_HEX)\n\t\tflags_str = \"hex\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM)\n\t\tflags_str = \"sym\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYM_OFFSET)\n\t\tflags_str = \"sym-offset\";\n\telse if (hist_field->flags & HIST_FIELD_FL_EXECNAME)\n\t\tflags_str = \"execname\";\n\telse if (hist_field->flags & HIST_FIELD_FL_SYSCALL)\n\t\tflags_str = \"syscall\";\n\telse if (hist_field->flags & HIST_FIELD_FL_LOG2)\n\t\tflags_str = \"log2\";\n\telse if (hist_field->flags & HIST_FIELD_FL_TIMESTAMP_USECS)\n\t\tflags_str = \"usecs\";\n\n\treturn flags_str;\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "2023-2029",
    "snippet": "static void hist_trigger_elt_data_init(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\tif (elt_data->comm)\n\t\tsave_comm(elt_data->comm, current);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "save_comm",
          "args": [
            "elt_data->comm",
            "current"
          ],
          "line": 2028
        },
        "resolved": true,
        "details": {
          "function_name": "save_comm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1948-1961",
          "snippet": "static inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tmemcpy(comm, task->comm, TASK_COMM_LEN);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tmemcpy(comm, task->comm, TASK_COMM_LEN);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_data_init(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\tif (elt_data->comm)\n\t\tsave_comm(elt_data->comm, current);\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1981-2021",
    "snippet": "static int hist_trigger_elt_data_alloc(struct tracing_map_elt *elt)\n{\n\tstruct hist_trigger_data *hist_data = elt->map->private_data;\n\tunsigned int size = TASK_COMM_LEN;\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *key_field;\n\tunsigned int i, n_str;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\telt_data->comm = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!elt_data->comm) {\n\t\t\t\tkfree(elt_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn_str = hist_data->n_field_var_str + hist_data->n_max_var_str;\n\n\tsize = STR_VAR_LEN_MAX;\n\n\tfor (i = 0; i < n_str; i++) {\n\t\telt_data->field_var_str[i] = kzalloc(size, GFP_KERNEL);\n\t\tif (!elt_data->field_var_str[i]) {\n\t\t\thist_elt_data_free(elt_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\telt->private_data = elt_data;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_elt_data_free",
          "args": [
            "elt_data"
          ],
          "line": 2013
        },
        "resolved": true,
        "details": {
          "function_name": "hist_elt_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1963-1972",
          "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 2011
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt_data"
          ],
          "line": 1999
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 1997
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_key_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*elt_data)",
            "GFP_KERNEL"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic int hist_trigger_elt_data_alloc(struct tracing_map_elt *elt)\n{\n\tstruct hist_trigger_data *hist_data = elt->map->private_data;\n\tunsigned int size = TASK_COMM_LEN;\n\tstruct hist_elt_data *elt_data;\n\tstruct hist_field *key_field;\n\tunsigned int i, n_str;\n\n\telt_data = kzalloc(sizeof(*elt_data), GFP_KERNEL);\n\tif (!elt_data)\n\t\treturn -ENOMEM;\n\n\tfor_each_hist_key_field(i, hist_data) {\n\t\tkey_field = hist_data->fields[i];\n\n\t\tif (key_field->flags & HIST_FIELD_FL_EXECNAME) {\n\t\t\telt_data->comm = kzalloc(size, GFP_KERNEL);\n\t\t\tif (!elt_data->comm) {\n\t\t\t\tkfree(elt_data);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tn_str = hist_data->n_field_var_str + hist_data->n_max_var_str;\n\n\tsize = STR_VAR_LEN_MAX;\n\n\tfor (i = 0; i < n_str; i++) {\n\t\telt_data->field_var_str[i] = kzalloc(size, GFP_KERNEL);\n\t\tif (!elt_data->field_var_str[i]) {\n\t\t\thist_elt_data_free(elt_data);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t}\n\n\telt->private_data = elt_data;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "hist_trigger_elt_data_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1974-1979",
    "snippet": "static void hist_trigger_elt_data_free(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\thist_elt_data_free(elt_data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_elt_data_free",
          "args": [
            "elt_data"
          ],
          "line": 1978
        },
        "resolved": true,
        "details": {
          "function_name": "hist_elt_data_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1963-1972",
          "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_trigger_elt_data_free(struct tracing_map_elt *elt)\n{\n\tstruct hist_elt_data *elt_data = elt->private_data;\n\n\thist_elt_data_free(elt_data);\n}"
  },
  {
    "function_name": "hist_elt_data_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1963-1972",
    "snippet": "static void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_FIELDS_MAX\t16"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "elt_data"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic void hist_elt_data_free(struct hist_elt_data *elt_data)\n{\n\tunsigned int i;\n\n\tfor (i = 0; i < SYNTH_FIELDS_MAX; i++)\n\t\tkfree(elt_data->field_var_str[i]);\n\n\tkfree(elt_data->comm);\n\tkfree(elt_data);\n}"
  },
  {
    "function_name": "save_comm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1948-1961",
    "snippet": "static inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tmemcpy(comm, task->comm, TASK_COMM_LEN);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "comm",
            "task->comm",
            "TASK_COMM_LEN"
          ],
          "line": 1960
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "comm",
            "\"<XXX>\""
          ],
          "line": 1956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "task->pid < 0"
          ],
          "line": 1955
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "comm",
            "\"<idle>\""
          ],
          "line": 1951
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void save_comm(char *comm, struct task_struct *task)\n{\n\tif (!task->pid) {\n\t\tstrcpy(comm, \"<idle>\");\n\t\treturn;\n\t}\n\n\tif (WARN_ON_ONCE(task->pid < 0)) {\n\t\tstrcpy(comm, \"<XXX>\");\n\t\treturn;\n\t}\n\n\tmemcpy(comm, task->comm, TASK_COMM_LEN);\n}"
  },
  {
    "function_name": "parse_hist_trigger_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1898-1946",
    "snippet": "static struct hist_trigger_attrs *parse_hist_trigger_attrs(char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\n\t\tif (strchr(str, '=')) {\n\t\t\tret = parse_assignment(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_hist_trigger_attrs",
          "args": [
            "attrs"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_hist_trigger_attrs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1783-1802",
          "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "\"global\"",
            "GFP_KERNEL"
          ],
          "line": 1934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_action",
          "args": [
            "str",
            "attrs"
          ],
          "line": 1922
        },
        "resolved": true,
        "details": {
          "function_name": "parse_action_params",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "3401-3433",
          "snippet": "static int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define SYNTH_FIELDS_MAX\t16"
          ],
          "globals_used": [
            "static int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic int event_hist_trigger_func(struct event_command *cmd_ops,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   char *glob, char *cmd, char *param);\n\nstatic int parse_action_params(char *params, struct action_data *data)\n{\n\tchar *param, *saved_param;\n\tint ret = 0;\n\n\twhile (params) {\n\t\tif (data->n_params >= SYNTH_FIELDS_MAX)\n\t\t\tgoto out;\n\n\t\tparam = strsep(&params, \",\");\n\t\tif (!param) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tparam = strstrip(param);\n\t\tif (strlen(param) < 2) {\n\t\t\thist_err(\"Invalid action param: \", param);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tsaved_param = kstrdup(param, GFP_KERNEL);\n\t\tif (!saved_param) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tdata->params[data->n_params++] = saved_param;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"clear\""
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"continue\""
          ],
          "line": 1917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"cont\""
          ],
          "line": 1916
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "str",
            "\"pause\""
          ],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_assignment",
          "args": [
            "str",
            "attrs"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "parse_assignment",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1825-1896",
          "snippet": "static int parse_assignment(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = 0;\n\n\tif ((strncmp(str, \"key=\", strlen(\"key=\")) == 0) ||\n\t    (strncmp(str, \"keys=\", strlen(\"keys=\")) == 0)) {\n\t\tattrs->keys_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((strncmp(str, \"val=\", strlen(\"val=\")) == 0) ||\n\t\t (strncmp(str, \"vals=\", strlen(\"vals=\")) == 0) ||\n\t\t (strncmp(str, \"values=\", strlen(\"values=\")) == 0)) {\n\t\tattrs->vals_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"sort=\", strlen(\"sort=\")) == 0) {\n\t\tattrs->sort_key_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"name=\", strlen(\"name=\")) == 0) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"clock=\", strlen(\"clock=\")) == 0) {\n\t\tstrsep(&str, \"=\");\n\t\tif (!str) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"size=\", strlen(\"size=\")) == 0) {\n\t\tint map_bits = parse_map_size(str);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(\"Too many variables defined: \", str);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_assignment(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = 0;\n\n\tif ((strncmp(str, \"key=\", strlen(\"key=\")) == 0) ||\n\t    (strncmp(str, \"keys=\", strlen(\"keys=\")) == 0)) {\n\t\tattrs->keys_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((strncmp(str, \"val=\", strlen(\"val=\")) == 0) ||\n\t\t (strncmp(str, \"vals=\", strlen(\"vals=\")) == 0) ||\n\t\t (strncmp(str, \"values=\", strlen(\"values=\")) == 0)) {\n\t\tattrs->vals_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"sort=\", strlen(\"sort=\")) == 0) {\n\t\tattrs->sort_key_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"name=\", strlen(\"name=\")) == 0) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"clock=\", strlen(\"clock=\")) == 0) {\n\t\tstrsep(&str, \"=\");\n\t\tif (!str) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"size=\", strlen(\"size=\")) == 0) {\n\t\tint map_bits = parse_map_size(str);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(\"Too many variables defined: \", str);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "str",
            "'='"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&trigger_str",
            "\":\""
          ],
          "line": 1908
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 1905
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*attrs)",
            "GFP_KERNEL"
          ],
          "line": 1903
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_trigger_attrs *parse_hist_trigger_attrs(char *trigger_str)\n{\n\tstruct hist_trigger_attrs *attrs;\n\tint ret = 0;\n\n\tattrs = kzalloc(sizeof(*attrs), GFP_KERNEL);\n\tif (!attrs)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\twhile (trigger_str) {\n\t\tchar *str = strsep(&trigger_str, \":\");\n\n\t\tif (strchr(str, '=')) {\n\t\t\tret = parse_assignment(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t} else if (strcmp(str, \"pause\") == 0)\n\t\t\tattrs->pause = true;\n\t\telse if ((strcmp(str, \"cont\") == 0) ||\n\t\t\t (strcmp(str, \"continue\") == 0))\n\t\t\tattrs->cont = true;\n\t\telse if (strcmp(str, \"clear\") == 0)\n\t\t\tattrs->clear = true;\n\t\telse {\n\t\t\tret = parse_action(str, attrs);\n\t\t\tif (ret)\n\t\t\t\tgoto free;\n\t\t}\n\t}\n\n\tif (!attrs->keys_str) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (!attrs->clock) {\n\t\tattrs->clock = kstrdup(\"global\", GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t}\n\n\treturn attrs;\n free:\n\tdestroy_hist_trigger_attrs(attrs);\n\n\treturn ERR_PTR(ret);\n}"
  },
  {
    "function_name": "parse_assignment",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1825-1896",
    "snippet": "static int parse_assignment(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = 0;\n\n\tif ((strncmp(str, \"key=\", strlen(\"key=\")) == 0) ||\n\t    (strncmp(str, \"keys=\", strlen(\"keys=\")) == 0)) {\n\t\tattrs->keys_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((strncmp(str, \"val=\", strlen(\"val=\")) == 0) ||\n\t\t (strncmp(str, \"vals=\", strlen(\"vals=\")) == 0) ||\n\t\t (strncmp(str, \"values=\", strlen(\"values=\")) == 0)) {\n\t\tattrs->vals_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"sort=\", strlen(\"sort=\")) == 0) {\n\t\tattrs->sort_key_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"name=\", strlen(\"name=\")) == 0) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"clock=\", strlen(\"clock=\")) == 0) {\n\t\tstrsep(&str, \"=\");\n\t\tif (!str) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"size=\", strlen(\"size=\")) == 0) {\n\t\tint map_bits = parse_map_size(str);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(\"Too many variables defined: \", str);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "\"Too many variables defined: \"",
            "str"
          ],
          "line": 1881
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_map_size",
          "args": [
            "str"
          ],
          "line": 1870
        },
        "resolved": true,
        "details": {
          "function_name": "parse_map_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1758-1781",
          "snippet": "static int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tstrsep(&str, \"=\");\n\tif (!str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tstrsep(&str, \"=\");\n\tif (!str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"size=\"",
            "strlen(\"size=\")"
          ],
          "line": 1869
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"size=\""
          ],
          "line": 1869
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strstrip",
          "args": [
            "str"
          ],
          "line": 1863
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\"=\""
          ],
          "line": 1857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"clock=\"",
            "strlen(\"clock=\")"
          ],
          "line": 1856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1851
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"name=\"",
            "strlen(\"name=\")"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1845
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"sort=\"",
            "strlen(\"sort=\")"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"values=\"",
            "strlen(\"values=\")"
          ],
          "line": 1838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"vals=\"",
            "strlen(\"vals=\")"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"val=\"",
            "strlen(\"val=\")"
          ],
          "line": 1836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"keys=\"",
            "strlen(\"keys=\")"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"key=\"",
            "strlen(\"key=\")"
          ],
          "line": 1829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_assignment(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = 0;\n\n\tif ((strncmp(str, \"key=\", strlen(\"key=\")) == 0) ||\n\t    (strncmp(str, \"keys=\", strlen(\"keys=\")) == 0)) {\n\t\tattrs->keys_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->keys_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if ((strncmp(str, \"val=\", strlen(\"val=\")) == 0) ||\n\t\t (strncmp(str, \"vals=\", strlen(\"vals=\")) == 0) ||\n\t\t (strncmp(str, \"values=\", strlen(\"values=\")) == 0)) {\n\t\tattrs->vals_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->vals_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"sort=\", strlen(\"sort=\")) == 0) {\n\t\tattrs->sort_key_str = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->sort_key_str) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"name=\", strlen(\"name=\")) == 0) {\n\t\tattrs->name = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->name) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"clock=\", strlen(\"clock=\")) == 0) {\n\t\tstrsep(&str, \"=\");\n\t\tif (!str) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tstr = strstrip(str);\n\t\tattrs->clock = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->clock) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\t} else if (strncmp(str, \"size=\", strlen(\"size=\")) == 0) {\n\t\tint map_bits = parse_map_size(str);\n\n\t\tif (map_bits < 0) {\n\t\t\tret = map_bits;\n\t\t\tgoto out;\n\t\t}\n\t\tattrs->map_bits = map_bits;\n\t} else {\n\t\tchar *assignment;\n\n\t\tif (attrs->n_assignments == TRACING_MAP_VARS_MAX) {\n\t\t\thist_err(\"Too many variables defined: \", str);\n\t\t\tret = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\n\t\tassignment = kstrdup(str, GFP_KERNEL);\n\t\tif (!assignment) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\tattrs->assignment_str[attrs->n_assignments++] = assignment;\n\t}\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "parse_action",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1804-1823",
    "snippet": "static int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) ||\n\t    (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0)) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_ACTIONS_MAX\t8"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "str",
            "GFP_KERNEL"
          ],
          "line": 1813
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"onmax(\"",
            "strlen(\"onmax(\")"
          ],
          "line": 1812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"onmax(\""
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "str",
            "\"onmatch(\"",
            "strlen(\"onmatch(\")"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_ACTIONS_MAX\t8\n\nstatic int parse_action(char *str, struct hist_trigger_attrs *attrs)\n{\n\tint ret = -EINVAL;\n\n\tif (attrs->n_actions >= HIST_ACTIONS_MAX)\n\t\treturn ret;\n\n\tif ((strncmp(str, \"onmatch(\", strlen(\"onmatch(\")) == 0) ||\n\t    (strncmp(str, \"onmax(\", strlen(\"onmax(\")) == 0)) {\n\t\tattrs->action_str[attrs->n_actions] = kstrdup(str, GFP_KERNEL);\n\t\tif (!attrs->action_str[attrs->n_actions]) {\n\t\t\tret = -ENOMEM;\n\t\t\treturn ret;\n\t\t}\n\t\tattrs->n_actions++;\n\t\tret = 0;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "destroy_hist_trigger_attrs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1783-1802",
    "snippet": "static void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "attrs"
          ],
          "line": 1801
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void destroy_hist_trigger_attrs(struct hist_trigger_attrs *attrs)\n{\n\tunsigned int i;\n\n\tif (!attrs)\n\t\treturn;\n\n\tfor (i = 0; i < attrs->n_assignments; i++)\n\t\tkfree(attrs->assignment_str[i]);\n\n\tfor (i = 0; i < attrs->n_actions; i++)\n\t\tkfree(attrs->action_str[i]);\n\n\tkfree(attrs->name);\n\tkfree(attrs->sort_key_str);\n\tkfree(attrs->keys_str);\n\tkfree(attrs->vals_str);\n\tkfree(attrs->clock);\n\tkfree(attrs);\n}"
  },
  {
    "function_name": "parse_map_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1758-1781",
    "snippet": "static int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tstrsep(&str, \"=\");\n\tif (!str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "roundup_pow_of_two(size)"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "size"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "str",
            "0",
            "&size"
          ],
          "line": 1769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strsep",
          "args": [
            "&str",
            "\"=\""
          ],
          "line": 1763
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int parse_map_size(char *str)\n{\n\tunsigned long size, map_bits;\n\tint ret;\n\n\tstrsep(&str, \"=\");\n\tif (!str) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = kstrtoul(str, 0, &size);\n\tif (ret)\n\t\tgoto out;\n\n\tmap_bits = ilog2(roundup_pow_of_two(size));\n\tif (map_bits < TRACING_MAP_BITS_MIN ||\n\t    map_bits > TRACING_MAP_BITS_MAX)\n\t\tret = -EINVAL;\n\telse\n\t\tret = map_bits;\n out:\n\treturn ret;\n}"
  },
  {
    "function_name": "select_value_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1724-1756",
    "snippet": "static hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic hist_field_fn_t select_value_fn(int field_size, int field_is_signed)\n{\n\thist_field_fn_t fn = NULL;\n\n\tswitch (field_size) {\n\tcase 8:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s64;\n\t\telse\n\t\t\tfn = hist_field_u64;\n\t\tbreak;\n\tcase 4:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s32;\n\t\telse\n\t\t\tfn = hist_field_u32;\n\t\tbreak;\n\tcase 2:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s16;\n\t\telse\n\t\t\tfn = hist_field_u16;\n\t\tbreak;\n\tcase 1:\n\t\tif (field_is_signed)\n\t\t\tfn = hist_field_s8;\n\t\telse\n\t\t\tfn = hist_field_u8;\n\t\tbreak;\n\t}\n\n\treturn fn;\n}"
  },
  {
    "function_name": "hist_field_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1687-1722",
    "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->name"
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "\".\""
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->event_name"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "\".\""
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "full_name",
            "field->system"
          ],
          "line": 1707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_field_name",
          "args": [
            "field->operands[0]",
            "++level"
          ],
          "line": 1699
        },
        "resolved": true,
        "details": {
          "function_name": "hist_field_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1687-1722",
          "snippet": "static const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic const char *hist_field_name(struct hist_field *field,\n\t\t\t\t   unsigned int level)\n{\n\tconst char *field_name = \"\";\n\n\tif (level > 1)\n\t\treturn field_name;\n\n\tif (field->field)\n\t\tfield_name = field->field->name;\n\telse if (field->flags & HIST_FIELD_FL_LOG2 ||\n\t\t field->flags & HIST_FIELD_FL_ALIAS)\n\t\tfield_name = hist_field_name(field->operands[0], ++level);\n\telse if (field->flags & HIST_FIELD_FL_CPU)\n\t\tfield_name = \"cpu\";\n\telse if (field->flags & HIST_FIELD_FL_EXPR ||\n\t\t field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (field->system) {\n\t\t\tstatic char full_name[MAX_FILTER_STR_VAL];\n\n\t\t\tstrcat(full_name, field->system);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->event_name);\n\t\t\tstrcat(full_name, \".\");\n\t\t\tstrcat(full_name, field->name);\n\t\t\tfield_name = full_name;\n\t\t} else\n\t\t\tfield_name = field->name;\n\t} else if (field->flags & HIST_FIELD_FL_TIMESTAMP)\n\t\tfield_name = \"common_timestamp\";\n\n\tif (field_name == NULL)\n\t\tfield_name = \"\";\n\n\treturn field_name;\n}"
  },
  {
    "function_name": "resolve_var_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1641-1685",
    "snippet": "static bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_map_read_var_once",
          "args": [
            "var_elt",
            "var_idx"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_read_var_once",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "121-125",
          "snippet": "u64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nu64 tracing_map_read_var_once(struct tracing_map_elt *elt, unsigned int i)\n{\n\telt->var_set[i] = false;\n\treturn (u64)atomic64_read(&elt->vars[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_var_set",
          "args": [
            "var_elt",
            "var_idx"
          ],
          "line": 1671
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_var_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "85-88",
          "snippet": "bool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nbool tracing_map_var_set(struct tracing_map_elt *elt, unsigned int i)\n{\n\treturn elt->var_set[i];\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracing_map_lookup",
          "args": [
            "var_data->map",
            "key"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_map_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "653-656",
          "snippet": "struct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstruct tracing_map_elt *tracing_map_lookup(struct tracing_map *map, void *key)\n{\n\treturn __tracing_map_insert(map, key, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool resolve_var_refs(struct hist_trigger_data *hist_data, void *key,\n\t\t\t     u64 *var_ref_vals, bool self)\n{\n\tstruct hist_trigger_data *var_data;\n\tstruct tracing_map_elt *var_elt;\n\tstruct hist_field *hist_field;\n\tunsigned int i, var_idx;\n\tbool resolved = true;\n\tu64 var_val = 0;\n\n\tfor (i = 0; i < hist_data->n_var_refs; i++) {\n\t\thist_field = hist_data->var_refs[i];\n\t\tvar_idx = hist_field->var.idx;\n\t\tvar_data = hist_field->var.hist_data;\n\n\t\tif (var_data == NULL) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif ((self && var_data != hist_data) ||\n\t\t    (!self && var_data == hist_data))\n\t\t\tcontinue;\n\n\t\tvar_elt = tracing_map_lookup(var_data->map, key);\n\t\tif (!var_elt) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!tracing_map_var_set(var_elt, var_idx)) {\n\t\t\tresolved = false;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (self || !hist_field->read_once)\n\t\t\tvar_val = tracing_map_read_var(var_elt, var_idx);\n\t\telse\n\t\t\tvar_val = tracing_map_read_var_once(var_elt, var_idx);\n\n\t\tvar_ref_vals[i] = var_val;\n\t}\n\n\treturn resolved;\n}"
  },
  {
    "function_name": "hist_field_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1627-1639",
    "snippet": "static u64 hist_field_var_ref(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\tu64 var_val = 0;\n\n\telt_data = elt->private_data;\n\tvar_val = elt_data->var_ref_vals[hist_field->var_ref_idx];\n\n\treturn var_val;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_var_ref(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tstruct hist_elt_data *elt_data;\n\tu64 var_val = 0;\n\n\telt_data = elt->private_data;\n\tvar_val = elt_data->var_ref_vals[hist_field->var_ref_idx];\n\n\treturn var_val;\n}"
  },
  {
    "function_name": "find_event_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1595-1619",
    "snippet": "static struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_file_var",
          "args": [
            "file",
            "var_name"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1544-1561",
          "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_file",
          "args": [
            "tr",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1612
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1513-1542",
          "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "hist_field"
          ],
          "line": 1606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_match_var",
          "args": [
            "hist_data",
            "var_name"
          ],
          "line": 1605
        },
        "resolved": true,
        "details": {
          "function_name": "find_match_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1563-1593",
          "snippet": "static struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tchar *system = data->onmatch.match_event_system;\n\t\t\tchar *event_name = data->onmatch.match_event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tchar *system = data->onmatch.match_event_system;\n\t\t\tchar *event_name = data->onmatch.match_event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_event_var(struct hist_trigger_data *hist_data,\n\t\t\t\t\t char *system,\n\t\t\t\t\t char *event_name,\n\t\t\t\t\t char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field = NULL;\n\tstruct trace_event_file *file;\n\n\tif (!system || !event_name) {\n\t\thist_field = find_match_var(hist_data, var_name);\n\t\tif (IS_ERR(hist_field))\n\t\t\treturn NULL;\n\t\tif (hist_field)\n\t\t\treturn hist_field;\n\t}\n\n\tfile = find_var_file(tr, system, event_name, var_name);\n\tif (!file)\n\t\treturn NULL;\n\n\thist_field = find_file_var(file, var_name);\n\n\treturn hist_field;\n}"
  },
  {
    "function_name": "find_match_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1563-1593",
    "snippet": "static struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tchar *system = data->onmatch.match_event_system;\n\t\t\tchar *event_name = data->onmatch.match_event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \"",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_file_var",
          "args": [
            "file",
            "var_name"
          ],
          "line": 1581
        },
        "resolved": true,
        "details": {
          "function_name": "find_file_var",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1544-1561",
          "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_file",
          "args": [
            "tr",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1513-1542",
          "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\nfind_match_var(struct hist_trigger_data *hist_data, char *var_name)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *hist_field, *found = NULL;\n\tstruct trace_event_file *file;\n\tunsigned int i;\n\n\tfor (i = 0; i < hist_data->n_actions; i++) {\n\t\tstruct action_data *data = hist_data->actions[i];\n\n\t\tif (data->fn == action_trace) {\n\t\t\tchar *system = data->onmatch.match_event_system;\n\t\t\tchar *event_name = data->onmatch.match_event;\n\n\t\t\tfile = find_var_file(tr, system, event_name, var_name);\n\t\t\tif (!file)\n\t\t\t\tcontinue;\n\t\t\thist_field = find_file_var(file, var_name);\n\t\t\tif (hist_field) {\n\t\t\t\tif (found) {\n\t\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\t\treturn ERR_PTR(-EINVAL);\n\t\t\t\t}\n\n\t\t\t\tfound = hist_field;\n\t\t\t}\n\t\t}\n\t}\n\treturn found;\n}"
  },
  {
    "function_name": "find_file_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1544-1561",
    "snippet": "static struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "test_data",
            "var_name"
          ],
          "line": 1554
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1471-1487",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1551
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_file_var(struct trace_event_file *file,\n\t\t\t\t\tconst char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_var_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1513-1542",
    "snippet": "static struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err_event",
          "args": [
            "\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \"",
            "system",
            "event_name",
            "var_name"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "378-390",
          "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "var_hist_data",
            "var_name"
          ],
          "line": 1531
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1471-1487",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 1525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_event_file",
          "args": [
            "tr",
            "system",
            "event_name"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "find_event_file",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2503-2514",
          "snippet": "struct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int ftrace_event_avail_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_set_pid_open(struct inode *inode, struct file *file);",
            "static int ftrace_event_release(struct inode *inode, struct file *file);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic int ftrace_event_avail_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_set_pid_open(struct inode *inode, struct file *file);\nstatic int ftrace_event_release(struct inode *inode, struct file *file);\n\nstruct trace_event_file *\nfind_event_file(struct trace_array *tr, const char *system, const char *event)\n{\n\tstruct trace_event_file *file;\n\n\tfile = __find_event_file(tr, system, event);\n\tif (!file || !file->event_call->class->reg ||\n\t    file->event_call->flags & TRACE_EVENT_FL_IGNORE_ENABLE)\n\t\treturn NULL;\n\n\treturn file;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct trace_event_file *find_var_file(struct trace_array *tr,\n\t\t\t\t\t      char *system,\n\t\t\t\t\t      char *event_name,\n\t\t\t\t\t      char *var_name)\n{\n\tstruct hist_trigger_data *var_hist_data;\n\tstruct hist_var_data *var_data;\n\tstruct trace_event_file *file, *found = NULL;\n\n\tif (system)\n\t\treturn find_event_file(tr, system, event_name);\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tvar_hist_data = var_data->hist_data;\n\t\tfile = var_hist_data->event_file;\n\t\tif (file == found)\n\t\t\tcontinue;\n\n\t\tif (find_var_field(var_hist_data, var_name)) {\n\t\t\tif (found) {\n\t\t\t\thist_err_event(\"Variable name not unique, need to use fully qualified name (subsys.event.var) for variable: \", system, event_name, var_name);\n\t\t\t\treturn NULL;\n\t\t\t}\n\n\t\t\tfound = file;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_var",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1489-1511",
    "snippet": "static struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_field",
          "args": [
            "test_data",
            "var_name"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1471-1487",
          "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "test",
            "&file->triggers",
            "list"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var(struct hist_trigger_data *hist_data,\n\t\t\t\t   struct trace_event_file *file,\n\t\t\t\t   const char *var_name)\n{\n\tstruct hist_trigger_data *test_data;\n\tstruct event_trigger_data *test;\n\tstruct hist_field *hist_field;\n\n\thist_field = find_var_field(hist_data, var_name);\n\tif (hist_field)\n\t\treturn hist_field;\n\n\tlist_for_each_entry_rcu(test, &file->triggers, list) {\n\t\tif (test->cmd_ops->trigger_type == ETT_EVENT_HIST) {\n\t\t\ttest_data = test->private_data;\n\t\t\thist_field = find_var_field(test_data, var_name);\n\t\t\tif (hist_field)\n\t\t\t\treturn hist_field;\n\t\t}\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "find_var_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1471-1487",
    "snippet": "static struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "hist_field->var.name",
            "var_name"
          ],
          "line": 1480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_field(struct hist_trigger_data *hist_data,\n\t\t\t\t\t const char *var_name)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR &&\n\t\t    strcmp(hist_field->var.name, var_name) == 0) {\n\t\t\tfound = hist_field;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "remove_hist_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1452-1469",
    "snippet": "static void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "var_data"
          ],
          "line": 1466
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&var_data->list"
          ],
          "line": 1464
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "check_var_refs(hist_data)"
          ],
          "line": 1461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_var_refs",
          "args": [
            "hist_data"
          ],
          "line": 1461
        },
        "resolved": true,
        "details": {
          "function_name": "check_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1354-1371",
          "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 1457
        },
        "resolved": true,
        "details": {
          "function_name": "find_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1373-1386",
          "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void remove_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (!var_data)\n\t\treturn;\n\n\tif (WARN_ON(check_var_refs(hist_data)))\n\t\treturn;\n\n\tlist_del(&var_data->list);\n\n\tkfree(var_data);\n\n\ttrace_array_put(tr);\n}"
  },
  {
    "function_name": "save_hist_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1428-1450",
    "snippet": "static int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&var_data->list",
            "&tr->hist_vars"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_array_put",
          "args": [
            "tr"
          ],
          "line": 1442
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "298-303",
          "snippet": "void trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid trace_array_put(struct trace_array *this_tr)\n{\n\tmutex_lock(&trace_types_lock);\n\t__trace_array_put(this_tr);\n\tmutex_unlock(&trace_types_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*var_data)",
            "GFP_KERNEL"
          ],
          "line": 1440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_array_get",
          "args": [
            "tr"
          ],
          "line": 1437
        },
        "resolved": true,
        "details": {
          "function_name": "trace_array_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "274-290",
          "snippet": "int trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nint trace_array_get(struct trace_array *this_tr)\n{\n\tstruct trace_array *tr;\n\tint ret = -ENODEV;\n\n\tmutex_lock(&trace_types_lock);\n\tlist_for_each_entry(tr, &ftrace_trace_arrays, list) {\n\t\tif (tr == this_tr) {\n\t\t\ttr->ref++;\n\t\t\tret = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&trace_types_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_hist_vars",
          "args": [
            "hist_data"
          ],
          "line": 1433
        },
        "resolved": true,
        "details": {
          "function_name": "find_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1373-1386",
          "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int save_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data;\n\n\tvar_data = find_hist_vars(hist_data);\n\tif (var_data)\n\t\treturn 0;\n\n\tif (trace_array_get(tr) < 0)\n\t\treturn -ENODEV;\n\n\tvar_data = kzalloc(sizeof(*var_data), GFP_KERNEL);\n\tif (!var_data) {\n\t\ttrace_array_put(tr);\n\t\treturn -ENOMEM;\n\t}\n\n\tvar_data->hist_data = hist_data;\n\tlist_add(&var_data->list, &tr->hist_vars);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "has_hist_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1414-1426",
    "snippet": "static bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_has_hist_vars",
          "args": [
            "hist_field",
            "0"
          ],
          "line": 1421
        },
        "resolved": true,
        "details": {
          "function_name": "field_has_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1388-1412",
          "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool has_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *hist_field;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tif (field_has_hist_vars(hist_field, 0))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "field_has_hist_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1388-1412",
    "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELD_OPERANDS_MAX\t2"
    ],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "field_has_hist_vars",
          "args": [
            "operand",
            "level + 1"
          ],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "field_has_hist_vars",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1388-1412",
          "snippet": "static bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic bool field_has_hist_vars(struct hist_field *hist_field,\n\t\t\t\tunsigned int level)\n{\n\tint i;\n\n\tif (level > 3)\n\t\treturn false;\n\n\tif (!hist_field)\n\t\treturn false;\n\n\tif (hist_field->flags & HIST_FIELD_FL_VAR ||\n\t    hist_field->flags & HIST_FIELD_FL_VAR_REF)\n\t\treturn true;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tif (field_has_hist_vars(operand, level + 1))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "find_hist_vars",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1373-1386",
    "snippet": "static struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 1378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_var_data *find_hist_vars(struct hist_trigger_data *hist_data)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_var_data *var_data, *found = NULL;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data) {\n\t\t\tfound = var_data;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "check_var_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1354-1371",
    "snippet": "static bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_any_var_ref",
          "args": [
            "hist_data",
            "field->var.idx"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "find_any_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1336-1352",
          "snippet": "static struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool check_var_refs(struct hist_trigger_data *hist_data)\n{\n\tstruct hist_field *field;\n\tbool found = false;\n\tint i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\tfield = hist_data->fields[i];\n\t\tif (field && field->flags & HIST_FIELD_FL_VAR) {\n\t\t\tif (find_any_var_ref(hist_data, field->var.idx)) {\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_any_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1336-1352",
    "snippet": "static struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_var_ref",
          "args": [
            "var_data->hist_data",
            "hist_data",
            "var_idx"
          ],
          "line": 1346
        },
        "resolved": true,
        "details": {
          "function_name": "find_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1310-1334",
          "snippet": "static struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tunsigned int i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++) {\n\t\thist_field = hist_data->synth_var_refs[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tunsigned int i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++) {\n\t\thist_field = hist_data->synth_var_refs[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "var_data",
            "&tr->hist_vars",
            "list"
          ],
          "line": 1343
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_any_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t\t   unsigned int var_idx)\n{\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\tstruct hist_field *found = NULL;\n\tstruct hist_var_data *var_data;\n\n\tlist_for_each_entry(var_data, &tr->hist_vars, list) {\n\t\tif (var_data->hist_data == hist_data)\n\t\t\tcontinue;\n\t\tfound = find_var_ref(var_data->hist_data, hist_data, var_idx);\n\t\tif (found)\n\t\t\tbreak;\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "find_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1310-1334",
    "snippet": "static struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tunsigned int i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++) {\n\t\thist_field = hist_data->synth_var_refs[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_field_for_var_refs",
          "args": [
            "hist_data",
            "hist_field",
            "var_data",
            "var_idx",
            "0"
          ],
          "line": 1327
        },
        "resolved": true,
        "details": {
          "function_name": "check_field_for_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1277-1308",
          "snippet": "static struct hist_field *\ncheck_field_for_var_refs(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *hist_field,\n\t\t\t struct hist_trigger_data *var_data,\n\t\t\t unsigned int var_idx,\n\t\t\t unsigned int level)\n{\n\tstruct hist_field *found = NULL;\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn found;\n\n\tif (!hist_field)\n\t\treturn found;\n\n\tfound = check_field_for_var_ref(hist_field, var_data, var_idx);\n\tif (found)\n\t\treturn found;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tfound = check_field_for_var_refs(hist_data, operand, var_data,\n\t\t\t\t\t\t var_idx, level + 1);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define HIST_FIELD_OPERANDS_MAX\t2"
          ],
          "globals_used": [
            "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *\ncheck_field_for_var_refs(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *hist_field,\n\t\t\t struct hist_trigger_data *var_data,\n\t\t\t unsigned int var_idx,\n\t\t\t unsigned int level)\n{\n\tstruct hist_field *found = NULL;\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn found;\n\n\tif (!hist_field)\n\t\treturn found;\n\n\tfound = check_field_for_var_ref(hist_field, var_data, var_idx);\n\tif (found)\n\t\treturn found;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tfound = check_field_for_var_refs(hist_data, operand, var_data,\n\t\t\t\t\t\t var_idx, level + 1);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_hist_field",
          "args": [
            "i",
            "hist_data"
          ],
          "line": 1317
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *find_var_ref(struct hist_trigger_data *hist_data,\n\t\t\t\t       struct hist_trigger_data *var_data,\n\t\t\t\t       unsigned int var_idx)\n{\n\tstruct hist_field *hist_field, *found = NULL;\n\tunsigned int i;\n\n\tfor_each_hist_field(i, hist_data) {\n\t\thist_field = hist_data->fields[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\tfor (i = 0; i < hist_data->n_synth_var_refs; i++) {\n\t\thist_field = hist_data->synth_var_refs[i];\n\t\tfound = check_field_for_var_refs(hist_data, hist_field,\n\t\t\t\t\t\t var_data, var_idx, 0);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "check_field_for_var_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1277-1308",
    "snippet": "static struct hist_field *\ncheck_field_for_var_refs(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *hist_field,\n\t\t\t struct hist_trigger_data *var_data,\n\t\t\t unsigned int var_idx,\n\t\t\t unsigned int level)\n{\n\tstruct hist_field *found = NULL;\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn found;\n\n\tif (!hist_field)\n\t\treturn found;\n\n\tfound = check_field_for_var_ref(hist_field, var_data, var_idx);\n\tif (found)\n\t\treturn found;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tfound = check_field_for_var_refs(hist_data, operand, var_data,\n\t\t\t\t\t\t var_idx, level + 1);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define HIST_FIELD_OPERANDS_MAX\t2"
    ],
    "globals_used": [
      "static struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_field_for_var_refs",
          "args": [
            "hist_data",
            "operand",
            "var_data",
            "var_idx",
            "level + 1"
          ],
          "line": 1301
        },
        "resolved": true,
        "details": {
          "function_name": "check_field_for_var_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1277-1308",
          "snippet": "static struct hist_field *\ncheck_field_for_var_refs(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *hist_field,\n\t\t\t struct hist_trigger_data *var_data,\n\t\t\t unsigned int var_idx,\n\t\t\t unsigned int level)\n{\n\tstruct hist_field *found = NULL;\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn found;\n\n\tif (!hist_field)\n\t\treturn found;\n\n\tfound = check_field_for_var_ref(hist_field, var_data, var_idx);\n\tif (found)\n\t\treturn found;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tfound = check_field_for_var_refs(hist_data, operand, var_data,\n\t\t\t\t\t\t var_idx, level + 1);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "check_field_for_var_ref",
          "args": [
            "hist_field",
            "var_data",
            "var_idx"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "check_field_for_var_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1260-1275",
          "snippet": "static struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tstruct hist_field *found = NULL;\n\n\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (hist_field->var.idx == var_idx &&\n\t\t    hist_field->var.hist_data == var_data) {\n\t\t\tfound = hist_field;\n\t\t}\n\t}\n\n\treturn found;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tstruct hist_field *found = NULL;\n\n\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (hist_field->var.idx == var_idx &&\n\t\t    hist_field->var.hist_data == var_data) {\n\t\t\tfound = hist_field;\n\t\t}\n\t}\n\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define HIST_FIELD_OPERANDS_MAX\t2\n\nstatic struct hist_field *parse_expr(struct hist_trigger_data *hist_data,\n\t\t\t\t     struct trace_event_file *file,\n\t\t\t\t     char *str, unsigned long flags,\n\t\t\t\t     char *var_name, unsigned int level);\n\nstatic struct hist_field *\ncheck_field_for_var_refs(struct hist_trigger_data *hist_data,\n\t\t\t struct hist_field *hist_field,\n\t\t\t struct hist_trigger_data *var_data,\n\t\t\t unsigned int var_idx,\n\t\t\t unsigned int level)\n{\n\tstruct hist_field *found = NULL;\n\tunsigned int i;\n\n\tif (level > 3)\n\t\treturn found;\n\n\tif (!hist_field)\n\t\treturn found;\n\n\tfound = check_field_for_var_ref(hist_field, var_data, var_idx);\n\tif (found)\n\t\treturn found;\n\n\tfor (i = 0; i < HIST_FIELD_OPERANDS_MAX; i++) {\n\t\tstruct hist_field *operand;\n\n\t\toperand = hist_field->operands[i];\n\t\tfound = check_field_for_var_refs(hist_data, operand, var_data,\n\t\t\t\t\t\t var_idx, level + 1);\n\t\tif (found)\n\t\t\treturn found;\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "check_field_for_var_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1260-1275",
    "snippet": "static struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tstruct hist_field *found = NULL;\n\n\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (hist_field->var.idx == var_idx &&\n\t\t    hist_field->var.hist_data == var_data) {\n\t\t\tfound = hist_field;\n\t\t}\n\t}\n\n\treturn found;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct hist_field *\ncheck_field_for_var_ref(struct hist_field *hist_field,\n\t\t\tstruct hist_trigger_data *var_data,\n\t\t\tunsigned int var_idx)\n{\n\tstruct hist_field *found = NULL;\n\n\tif (hist_field && hist_field->flags & HIST_FIELD_FL_VAR_REF) {\n\t\tif (hist_field->var.idx == var_idx &&\n\t\t    hist_field->var.hist_data == var_data) {\n\t\t\tfound = hist_field;\n\t\t}\n\t}\n\n\treturn found;\n}"
  },
  {
    "function_name": "hist_field_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1250-1258",
    "snippet": "static u64 hist_field_cpu(struct hist_field *hist_field,\n\t\t\t  struct tracing_map_elt *elt,\n\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t  void *event)\n{\n\tint cpu = smp_processor_id();\n\n\treturn cpu;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_cpu(struct hist_field *hist_field,\n\t\t\t  struct tracing_map_elt *elt,\n\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t  void *event)\n{\n\tint cpu = smp_processor_id();\n\n\treturn cpu;\n}"
  },
  {
    "function_name": "hist_field_timestamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1234-1248",
    "snippet": "static u64 hist_field_timestamp(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_trigger_data *hist_data = hist_field->hist_data;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tu64 ts = ring_buffer_event_time_stamp(rbe);\n\n\tif (hist_data->attrs->ts_in_usecs && trace_clock_in_ns(tr))\n\t\tts = ns2usecs(ts);\n\n\treturn ts;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns2usecs",
          "args": [
            "ts"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "ns2usecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "241-246",
          "snippet": "unsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nunsigned long long ns2usecs(u64 nsec)\n{\n\tnsec += 500;\n\tdo_div(nsec, 1000);\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_clock_in_ns",
          "args": [
            "tr"
          ],
          "line": 1244
        },
        "resolved": true,
        "details": {
          "function_name": "trace_clock_in_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "1173-1179",
          "snippet": "bool trace_clock_in_ns(struct trace_array *tr)\n{\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct",
            "static struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\nstatic struct {\n\tu64 (*func)(void);\n\tconst char *name;\n\tint in_ns;\t\t/* is this clock in nanoseconds? */\n} trace_clocks[] = {\n\t{ trace_clock_local,\t\t\"local\",\t1 },\n\t{ trace_clock_global,\t\t\"global\",\t1 },\n\t{ trace_clock_counter,\t\t\"counter\",\t0 },\n\t{ trace_clock_jiffies,\t\t\"uptime\",\t0 },\n\t{ trace_clock,\t\t\t\"perf\",\t\t1 },\n\t{ ktime_get_mono_fast_ns,\t\"mono\",\t\t1 },\n\t{ ktime_get_raw_fast_ns,\t\"mono_raw\",\t1 },\n\t{ ktime_get_boot_fast_ns,\t\"boot\",\t\t1 },\n\tARCH_TRACE_CLOCKS\n};\n\nbool trace_clock_in_ns(struct trace_array *tr)\n{\n\tif (trace_clocks[tr->clock_id].in_ns)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_event_time_stamp",
          "args": [
            "rbe"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_event_time_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "295-304",
          "snippet": "u64 ring_buffer_event_time_stamp(struct ring_buffer_event *event)\n{\n\tu64 ts;\n\n\tts = event->array[0];\n\tts <<= TS_SHIFT;\n\tts += event->time_delta;\n\n\treturn ts;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [
            "#define TS_SHIFT\t27"
          ],
          "globals_used": [
            "static __always_inline struct",
            "static __always_inline struct",
            "static noinline struct",
            "static noinline struct",
            "static inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\n#define TS_SHIFT\t27\n\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic noinline struct;\nstatic noinline struct;\nstatic inline bool rb_event_is_commit(struct ring_buffer_per_cpu *cpu_buffer,\n\t\t\t\t     struct ring_buffer_event *event);\nstatic __always_inline struct;\n\nu64 ring_buffer_event_time_stamp(struct ring_buffer_event *event)\n{\n\tu64 ts;\n\n\tts = event->array[0];\n\tts <<= TS_SHIFT;\n\tts += event->time_delta;\n\n\treturn ts;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_timestamp(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tstruct hist_trigger_data *hist_data = hist_field->hist_data;\n\tstruct trace_array *tr = hist_data->event_file->tr;\n\n\tu64 ts = ring_buffer_event_time_stamp(rbe);\n\n\tif (hist_data->attrs->ts_in_usecs && trace_clock_in_ns(tr))\n\t\tts = ns2usecs(ts);\n\n\treturn ts;\n}"
  },
  {
    "function_name": "synth_events_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1218-1224",
    "snippet": "static ssize_t synth_events_write(struct file *file,\n\t\t\t\t  const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_synth_event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_parse_run_command",
          "args": [
            "file",
            "buffer",
            "count",
            "ppos",
            "create_synth_event"
          ],
          "line": 1222
        },
        "resolved": true,
        "details": {
          "function_name": "trace_parse_run_command",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "8407-8470",
          "snippet": "ssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [
            "#define WRITE_BUFSIZE  4096"
          ],
          "globals_used": [
            "static int tracing_set_tracer(struct trace_array *tr, const char *buf);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\n#define WRITE_BUFSIZE  4096\n\nstatic int tracing_set_tracer(struct trace_array *tr, const char *buf);\nstatic __always_inline struct;\n\nssize_t trace_parse_run_command(struct file *file, const char __user *buffer,\n\t\t\t\tsize_t count, loff_t *ppos,\n\t\t\t\tint (*createfn)(int, char **))\n{\n\tchar *kbuf, *buf, *tmp;\n\tint ret = 0;\n\tsize_t done = 0;\n\tsize_t size;\n\n\tkbuf = kmalloc(WRITE_BUFSIZE, GFP_KERNEL);\n\tif (!kbuf)\n\t\treturn -ENOMEM;\n\n\twhile (done < count) {\n\t\tsize = count - done;\n\n\t\tif (size >= WRITE_BUFSIZE)\n\t\t\tsize = WRITE_BUFSIZE - 1;\n\n\t\tif (copy_from_user(kbuf, buffer + done, size)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\tkbuf[size] = '\\0';\n\t\tbuf = kbuf;\n\t\tdo {\n\t\t\ttmp = strchr(buf, '\\n');\n\t\t\tif (tmp) {\n\t\t\t\t*tmp = '\\0';\n\t\t\t\tsize = tmp - buf + 1;\n\t\t\t} else {\n\t\t\t\tsize = strlen(buf);\n\t\t\t\tif (done + size < count) {\n\t\t\t\t\tif (buf != kbuf)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t/* This can accept WRITE_BUFSIZE - 2 ('\\n' + '\\0') */\n\t\t\t\t\tpr_warn(\"Line length is too long: Should be less than %d\\n\",\n\t\t\t\t\t\tWRITE_BUFSIZE - 2);\n\t\t\t\t\tret = -EINVAL;\n\t\t\t\t\tgoto out;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdone += size;\n\n\t\t\t/* Remove comments */\n\t\t\ttmp = strchr(buf, '#');\n\n\t\t\tif (tmp)\n\t\t\t\t*tmp = '\\0';\n\n\t\t\tret = trace_run_command(buf, createfn);\n\t\t\tif (ret)\n\t\t\t\tgoto out;\n\t\t\tbuf += size;\n\n\t\t} while (done < count);\n\t}\n\tret = done;\n\nout:\n\tkfree(kbuf);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic ssize_t synth_events_write(struct file *file,\n\t\t\t\t  const char __user *buffer,\n\t\t\t\t  size_t count, loff_t *ppos)\n{\n\treturn trace_parse_run_command(file, buffer, count, ppos,\n\t\t\t\t       create_synth_event);\n}"
  },
  {
    "function_name": "synth_events_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1205-1216",
    "snippet": "static int synth_events_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = release_all_synth_events();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &synth_events_seq_op);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct seq_operations synth_events_seq_op = {\n\t.start  = synth_events_seq_start,\n\t.next   = synth_events_seq_next,\n\t.stop   = synth_events_seq_stop,\n\t.show   = synth_events_seq_show\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_open",
          "args": [
            "file",
            "&synth_events_seq_op"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "gcov_seq_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/gcov/fs.c",
          "lines": "179-213",
          "snippet": "static int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}",
          "includes": [
            "#include \"gcov.h\"",
            "#include <linux/seq_file.h>",
            "#include <linux/mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/string.h>",
            "#include <linux/list.h>",
            "#include <linux/fs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(node_lock);",
            "static const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};",
            "static void remove_node(struct gcov_node *node);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"gcov.h\"\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/slab.h>\n#include <linux/string.h>\n#include <linux/list.h>\n#include <linux/fs.h>\n#include <linux/debugfs.h>\n#include <linux/module.h>\n#include <linux/init.h>\n\nstatic DEFINE_MUTEX(node_lock);\nstatic const struct seq_operations gcov_seq_ops = {\n\t.start\t= gcov_seq_start,\n\t.next\t= gcov_seq_next,\n\t.show\t= gcov_seq_show,\n\t.stop\t= gcov_seq_stop,\n};\nstatic void remove_node(struct gcov_node *node);\n\nstatic int gcov_seq_open(struct inode *inode, struct file *file)\n{\n\tstruct gcov_node *node = inode->i_private;\n\tstruct gcov_iterator *iter;\n\tstruct seq_file *seq;\n\tstruct gcov_info *info;\n\tint rc = -ENOMEM;\n\n\tmutex_lock(&node_lock);\n\t/*\n\t * Read from a profiling data copy to minimize reference tracking\n\t * complexity and concurrent access and to keep accumulating multiple\n\t * profiling data sets associated with one node simple.\n\t */\n\tinfo = get_accumulated_info(node);\n\tif (!info)\n\t\tgoto out_unlock;\n\titer = gcov_iter_new(info);\n\tif (!iter)\n\t\tgoto err_free_info;\n\trc = seq_open(file, &gcov_seq_ops);\n\tif (rc)\n\t\tgoto err_free_iter_info;\n\tseq = file->private_data;\n\tseq->private = iter;\nout_unlock:\n\tmutex_unlock(&node_lock);\n\treturn rc;\n\nerr_free_iter_info:\n\tgcov_iter_free(iter);\nerr_free_info:\n\tgcov_info_free(info);\n\tgoto out_unlock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "release_all_synth_events",
          "args": [],
          "line": 1210
        },
        "resolved": true,
        "details": {
          "function_name": "release_all_synth_events",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1128-1157",
          "snippet": "static int release_all_synth_events(void)\n{\n\tstruct list_head release_events;\n\tstruct synth_event *event, *e;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&release_events);\n\n\tmutex_lock(&synth_event_mutex);\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (event->ref) {\n\t\t\tmutex_unlock(&synth_event_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tlist_splice_init(&event->list, &release_events);\n\n\tmutex_unlock(&synth_event_mutex);\n\n\tlist_for_each_entry_safe(event, e, &release_events, list) {\n\t\tlist_del(&event->list);\n\n\t\tret = unregister_synth_event(event);\n\t\tadd_or_delete_synth_event(event, !ret);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);",
            "static DEFINE_MUTEX(synth_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic int release_all_synth_events(void)\n{\n\tstruct list_head release_events;\n\tstruct synth_event *event, *e;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&release_events);\n\n\tmutex_lock(&synth_event_mutex);\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (event->ref) {\n\t\t\tmutex_unlock(&synth_event_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tlist_splice_init(&event->list, &release_events);\n\n\tmutex_unlock(&synth_event_mutex);\n\n\tlist_for_each_entry_safe(event, e, &release_events, list) {\n\t\tlist_del(&event->list);\n\n\t\tret = unregister_synth_event(event);\n\t\tadd_or_delete_synth_event(event, !ret);\n\t}\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const struct seq_operations synth_events_seq_op = {\n\t.start  = synth_events_seq_start,\n\t.next   = synth_events_seq_next,\n\t.stop   = synth_events_seq_stop,\n\t.show   = synth_events_seq_show\n};\n\nstatic int synth_events_open(struct inode *inode, struct file *file)\n{\n\tint ret;\n\n\tif ((file->f_mode & FMODE_WRITE) && (file->f_flags & O_TRUNC)) {\n\t\tret = release_all_synth_events();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\treturn seq_open(file, &synth_events_seq_op);\n}"
  },
  {
    "function_name": "synth_events_seq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1177-1196",
    "snippet": "static int synth_events_seq_show(struct seq_file *m, void *v)\n{\n\tstruct synth_field *field;\n\tstruct synth_event *event = v;\n\tunsigned int i;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", field->type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_putc",
          "args": [
            "m",
            "'\\n'"
          ],
          "line": 1193
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%s %s%s\"",
            "field->type",
            "field->name",
            "i == event->n_fields - 1 ? \"\" : \"; \""
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_events_seq_show(struct seq_file *m, void *v)\n{\n\tstruct synth_field *field;\n\tstruct synth_event *event = v;\n\tunsigned int i;\n\n\tseq_printf(m, \"%s\\t\", event->name);\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfield = event->fields[i];\n\n\t\t/* parameter values */\n\t\tseq_printf(m, \"%s %s%s\", field->type, field->name,\n\t\t\t   i == event->n_fields - 1 ? \"\" : \"; \");\n\t}\n\n\tseq_putc(m, '\\n');\n\n\treturn 0;\n}"
  },
  {
    "function_name": "synth_events_seq_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1172-1175",
    "snippet": "static void synth_events_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&synth_event_mutex);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1174
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void synth_events_seq_stop(struct seq_file *m, void *v)\n{\n\tmutex_unlock(&synth_event_mutex);\n}"
  },
  {
    "function_name": "synth_events_seq_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1167-1170",
    "snippet": "static void *synth_events_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &synth_event_list, pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(synth_event_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_next",
          "args": [
            "v",
            "&synth_event_list",
            "pos"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic void *synth_events_seq_next(struct seq_file *m, void *v, loff_t *pos)\n{\n\treturn seq_list_next(v, &synth_event_list, pos);\n}"
  },
  {
    "function_name": "synth_events_seq_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1160-1165",
    "snippet": "static void *synth_events_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&synth_event_mutex);\n\n\treturn seq_list_start(&synth_event_list, *pos);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(synth_event_list);",
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_list_start",
          "args": [
            "&synth_event_list",
            "*pos"
          ],
          "line": 1164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void *synth_events_seq_start(struct seq_file *m, loff_t *pos)\n{\n\tmutex_lock(&synth_event_mutex);\n\n\treturn seq_list_start(&synth_event_list, *pos);\n}"
  },
  {
    "function_name": "release_all_synth_events",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1128-1157",
    "snippet": "static int release_all_synth_events(void)\n{\n\tstruct list_head release_events;\n\tstruct synth_event *event, *e;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&release_events);\n\n\tmutex_lock(&synth_event_mutex);\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (event->ref) {\n\t\t\tmutex_unlock(&synth_event_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tlist_splice_init(&event->list, &release_events);\n\n\tmutex_unlock(&synth_event_mutex);\n\n\tlist_for_each_entry_safe(event, e, &release_events, list) {\n\t\tlist_del(&event->list);\n\n\t\tret = unregister_synth_event(event);\n\t\tadd_or_delete_synth_event(event, !ret);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(synth_event_list);",
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_or_delete_synth_event",
          "args": [
            "event",
            "!ret"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_delete_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1011-1023",
          "snippet": "static void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);",
            "static DEFINE_MUTEX(synth_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_synth_event",
          "args": [
            "event"
          ],
          "line": 1152
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "934-942",
          "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 1150
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "event",
            "e",
            "&release_events",
            "list"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_splice_init",
          "args": [
            "&event->list",
            "&release_events"
          ],
          "line": 1145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "event",
            "&synth_event_list",
            "list"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1136
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&release_events"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic int release_all_synth_events(void)\n{\n\tstruct list_head release_events;\n\tstruct synth_event *event, *e;\n\tint ret = 0;\n\n\tINIT_LIST_HEAD(&release_events);\n\n\tmutex_lock(&synth_event_mutex);\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (event->ref) {\n\t\t\tmutex_unlock(&synth_event_mutex);\n\t\t\treturn -EBUSY;\n\t\t}\n\t}\n\n\tlist_splice_init(&event->list, &release_events);\n\n\tmutex_unlock(&synth_event_mutex);\n\n\tlist_for_each_entry_safe(event, e, &release_events, list) {\n\t\tlist_del(&event->list);\n\n\t\tret = unregister_synth_event(event);\n\t\tadd_or_delete_synth_event(event, !ret);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "create_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1025-1126",
    "snippet": "static int create_synth_event(int argc, char **argv)\n{\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tstruct synth_event *event = NULL;\n\tbool delete_event = false;\n\tint i, consumed = 0, n_fields = 0, ret = 0;\n\tchar *name;\n\n\tmutex_lock(&synth_event_mutex);\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\tif (argc < 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tname = argv[0];\n\tif (name[0] == '!') {\n\t\tdelete_event = true;\n\t\tname++;\n\t}\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tif (delete_event) {\n\t\t\tif (event->ref) {\n\t\t\t\tevent = NULL;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist_del(&event->list);\n\t\t\tgoto out;\n\t\t}\n\t\tevent = NULL;\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t} else if (delete_event) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (argc < 2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 1; i < argc - 1; i++) {\n\t\tif (strcmp(argv[i], \";\") == 0)\n\t\t\tcontinue;\n\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tfield = parse_synth_field(argc - i, &argv[i], &consumed);\n\t\tif (IS_ERR(field)) {\n\t\t\tret = PTR_ERR(field);\n\t\t\tgoto err;\n\t\t}\n\t\tfields[n_fields++] = field;\n\t\ti += consumed - 1;\n\t}\n\n\tif (i < argc && strcmp(argv[i], \";\") != 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n out:\n\tmutex_unlock(&synth_event_mutex);\n\n\tif (event) {\n\t\tif (delete_event) {\n\t\t\tret = unregister_synth_event(event);\n\t\t\tadd_or_delete_synth_event(event, !ret);\n\t\t} else {\n\t\t\tret = register_synth_event(event);\n\t\t\tadd_or_delete_synth_event(event, ret);\n\t\t}\n\t}\n\n\treturn ret;\n err:\n\tmutex_unlock(&synth_event_mutex);\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\tfree_synth_event(event);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_FIELDS_MAX\t16"
    ],
    "globals_used": [
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-960",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "fields[i]"
          ],
          "line": 1122
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "734-739",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "add_or_delete_synth_event",
          "args": [
            "event",
            "ret"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "add_or_delete_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "1011-1023",
          "snippet": "static void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);",
            "static DEFINE_MUTEX(synth_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "register_synth_event",
          "args": [
            "event"
          ],
          "line": 1112
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "934-942",
          "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event"
          ],
          "line": 1100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event"
          ],
          "line": 1099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_synth_event",
          "args": [
            "name",
            "n_fields",
            "fields"
          ],
          "line": 1098
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "962-994",
          "snippet": "static struct synth_event *alloc_synth_event(char *event_name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tstruct synth_event *event;\n\tunsigned int i;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(event_name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tevent->fields[i] = fields[i];\n\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_event *alloc_synth_event(char *event_name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tstruct synth_event *event;\n\tunsigned int i;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(event_name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tevent->fields[i] = fields[i];\n\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\";\""
          ],
          "line": 1093
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "field"
          ],
          "line": 1086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "field"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "parse_synth_field",
          "args": [
            "argc - i",
            "&argv[i]",
            "&consumed"
          ],
          "line": 1084
        },
        "resolved": true,
        "details": {
          "function_name": "parse_synth_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "741-814",
          "snippet": "static struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed)\n{\n\tstruct synth_field *field;\n\tconst char *prefix = NULL;\n\tchar *field_type = argv[0], *field_name;\n\tint len, ret = 0;\n\tchar *array;\n\n\tif (field_type[0] == ';')\n\t\tfield_type++;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed = 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed = 2;\n\t}\n\n\tlen = strlen(field_name);\n\tif (field_name[len - 1] == ';')\n\t\tfield_name[len - 1] = '\\0';\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_type) + 1;\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen += strlen(array);\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tif (prefix)\n\t\tstrcat(field->type, prefix);\n\tstrcat(field->type, field_type);\n\tif (array) {\n\t\tstrcat(field->type, array);\n\t\t*array = '\\0';\n\t}\n\n\tfield->size = synth_field_size(field->type);\n\tif (!field->size) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n\n\tfield->name = kstrdup(field_name, GFP_KERNEL);\n\tif (!field->name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed)\n{\n\tstruct synth_field *field;\n\tconst char *prefix = NULL;\n\tchar *field_type = argv[0], *field_name;\n\tint len, ret = 0;\n\tchar *array;\n\n\tif (field_type[0] == ';')\n\t\tfield_type++;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed = 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed = 2;\n\t}\n\n\tlen = strlen(field_name);\n\tif (field_name[len - 1] == ';')\n\t\tfield_name[len - 1] = '\\0';\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_type) + 1;\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen += strlen(array);\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tif (prefix)\n\t\tstrcat(field->type, prefix);\n\tstrcat(field->type, field_type);\n\tif (array) {\n\t\tstrcat(field->type, array);\n\t\t*array = '\\0';\n\t}\n\n\tfield->size = synth_field_size(field->type);\n\tif (!field->size) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n\n\tfield->name = kstrdup(field_name, GFP_KERNEL);\n\tif (!field->name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[i]",
            "\";\""
          ],
          "line": 1077
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&event->list"
          ],
          "line": 1060
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "name"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "869-879",
          "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1033
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_FIELDS_MAX\t16\n\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic int create_synth_event(int argc, char **argv)\n{\n\tstruct synth_field *field, *fields[SYNTH_FIELDS_MAX];\n\tstruct synth_event *event = NULL;\n\tbool delete_event = false;\n\tint i, consumed = 0, n_fields = 0, ret = 0;\n\tchar *name;\n\n\tmutex_lock(&synth_event_mutex);\n\n\t/*\n\t * Argument syntax:\n\t *  - Add synthetic event: <event_name> field[;field] ...\n\t *  - Remove synthetic event: !<event_name> field[;field] ...\n\t *      where 'field' = type field_name\n\t */\n\tif (argc < 1) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tname = argv[0];\n\tif (name[0] == '!') {\n\t\tdelete_event = true;\n\t\tname++;\n\t}\n\n\tevent = find_synth_event(name);\n\tif (event) {\n\t\tif (delete_event) {\n\t\t\tif (event->ref) {\n\t\t\t\tevent = NULL;\n\t\t\t\tret = -EBUSY;\n\t\t\t\tgoto out;\n\t\t\t}\n\t\t\tlist_del(&event->list);\n\t\t\tgoto out;\n\t\t}\n\t\tevent = NULL;\n\t\tret = -EEXIST;\n\t\tgoto out;\n\t} else if (delete_event) {\n\t\tret = -ENOENT;\n\t\tgoto out;\n\t}\n\n\tif (argc < 2) {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tfor (i = 1; i < argc - 1; i++) {\n\t\tif (strcmp(argv[i], \";\") == 0)\n\t\t\tcontinue;\n\t\tif (n_fields == SYNTH_FIELDS_MAX) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto err;\n\t\t}\n\n\t\tfield = parse_synth_field(argc - i, &argv[i], &consumed);\n\t\tif (IS_ERR(field)) {\n\t\t\tret = PTR_ERR(field);\n\t\t\tgoto err;\n\t\t}\n\t\tfields[n_fields++] = field;\n\t\ti += consumed - 1;\n\t}\n\n\tif (i < argc && strcmp(argv[i], \";\") != 0) {\n\t\tret = -EINVAL;\n\t\tgoto err;\n\t}\n\n\tevent = alloc_synth_event(name, n_fields, fields);\n\tif (IS_ERR(event)) {\n\t\tret = PTR_ERR(event);\n\t\tevent = NULL;\n\t\tgoto err;\n\t}\n out:\n\tmutex_unlock(&synth_event_mutex);\n\n\tif (event) {\n\t\tif (delete_event) {\n\t\t\tret = unregister_synth_event(event);\n\t\t\tadd_or_delete_synth_event(event, !ret);\n\t\t} else {\n\t\t\tret = register_synth_event(event);\n\t\t\tadd_or_delete_synth_event(event, ret);\n\t\t}\n\t}\n\n\treturn ret;\n err:\n\tmutex_unlock(&synth_event_mutex);\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tfree_synth_field(fields[i]);\n\tfree_synth_event(event);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "add_or_delete_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "1011-1023",
    "snippet": "static void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(synth_event_list);",
      "static DEFINE_MUTEX(synth_event_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 1020
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-960",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&event->list",
            "&synth_event_list"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_synth_event",
          "args": [
            "event->name"
          ],
          "line": 1017
        },
        "resolved": true,
        "details": {
          "function_name": "find_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "869-879",
          "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(synth_event_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&synth_event_mutex"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\nstatic DEFINE_MUTEX(synth_event_mutex);\n\nstatic void add_or_delete_synth_event(struct synth_event *event, int delete)\n{\n\tif (delete)\n\t\tfree_synth_event(event);\n\telse {\n\t\tmutex_lock(&synth_event_mutex);\n\t\tif (!find_synth_event(event->name))\n\t\t\tlist_add(&event->list, &synth_event_list);\n\t\telse\n\t\t\tfree_synth_event(event);\n\t\tmutex_unlock(&synth_event_mutex);\n\t}\n}"
  },
  {
    "function_name": "action_trace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "996-1004",
    "snippet": "static void action_trace(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt, void *rec,\n\t\t\t struct ring_buffer_event *rbe,\n\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\tstruct synth_event *event = data->onmatch.synth_event;\n\n\ttrace_synth(event, var_ref_vals, data->onmatch.var_ref_idx);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_synth",
          "args": [
            "event",
            "var_ref_vals",
            "data->onmatch.var_ref_idx"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "trace_synth",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "845-867",
          "snippet": "static inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void action_trace(struct hist_trigger_data *hist_data,\n\t\t\t struct tracing_map_elt *elt, void *rec,\n\t\t\t struct ring_buffer_event *rbe,\n\t\t\t struct action_data *data, u64 *var_ref_vals)\n{\n\tstruct synth_event *event = data->onmatch.synth_event;\n\n\ttrace_synth(event, var_ref_vals, data->onmatch.var_ref_idx);\n}"
  },
  {
    "function_name": "alloc_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "962-994",
    "snippet": "static struct synth_event *alloc_synth_event(char *event_name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tstruct synth_event *event;\n\tunsigned int i;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(event_name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tevent->fields[i] = fields[i];\n\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 984
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_synth_event",
          "args": [
            "event"
          ],
          "line": 983
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "944-960",
          "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "n_fields",
            "sizeof(*event->fields)",
            "GFP_KERNEL"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 977
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "event_name",
            "GFP_KERNEL"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*event)",
            "GFP_KERNEL"
          ],
          "line": 968
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_event *alloc_synth_event(char *event_name, int n_fields,\n\t\t\t\t\t     struct synth_field **fields)\n{\n\tstruct synth_event *event;\n\tunsigned int i;\n\n\tevent = kzalloc(sizeof(*event), GFP_KERNEL);\n\tif (!event) {\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->name = kstrdup(event_name, GFP_KERNEL);\n\tif (!event->name) {\n\t\tkfree(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tevent->fields = kcalloc(n_fields, sizeof(*event->fields), GFP_KERNEL);\n\tif (!event->fields) {\n\t\tfree_synth_event(event);\n\t\tevent = ERR_PTR(-ENOMEM);\n\t\tgoto out;\n\t}\n\n\tfor (i = 0; i < n_fields; i++)\n\t\tevent->fields[i] = fields[i];\n\n\tevent->n_fields = n_fields;\n out:\n\treturn event;\n}"
  },
  {
    "function_name": "free_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "944-960",
    "snippet": "static void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "event"
          ],
          "line": 959
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_event_print_fmt",
          "args": [
            "&event->call"
          ],
          "line": 958
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_event_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "676-682",
          "snippet": "static void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_tracepoint",
          "args": [
            "event->tp"
          ],
          "line": 957
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_tracepoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "816-823",
          "snippet": "static void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "event->fields[i]"
          ],
          "line": 952
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "734-739",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event(struct synth_event *event)\n{\n\tunsigned int i;\n\n\tif (!event)\n\t\treturn;\n\n\tfor (i = 0; i < event->n_fields; i++)\n\t\tfree_synth_field(event->fields[i]);\n\n\tkfree(event->fields);\n\tkfree(event->name);\n\tkfree(event->class.system);\n\tfree_synth_tracepoint(event->tp);\n\tfree_synth_event_print_fmt(&event->call);\n\tkfree(event);\n}"
  },
  {
    "function_name": "unregister_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "934-942",
    "snippet": "static int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 939
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2370-2383",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int unregister_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret;\n\n\tret = trace_remove_event_call(call);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "register_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "881-932",
    "snippet": "static int register_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret = 0;\n\n\tevent->call.class = &event->class;\n\tevent->class.system = kstrdup(SYNTH_SYSTEM, GFP_KERNEL);\n\tif (!event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevent->tp = alloc_synth_tracepoint(event->name);\n\tif (IS_ERR(event->tp)) {\n\t\tret = PTR_ERR(event->tp);\n\t\tevent->tp = NULL;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &synth_event_funcs;\n\tcall->class->define_fields = synth_event_define_fields;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tcall->flags = TRACE_EVENT_FL_TRACEPOINT;\n\tcall->class->reg = trace_event_reg;\n\tcall->class->probe = trace_event_raw_event_synth;\n\tcall->data = event;\n\tcall->tp = event->tp;\n\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register synthetic event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tgoto err;\n\t}\n\n\tret = set_synth_event_print_fmt(call);\n\tif (ret < 0) {\n\t\ttrace_remove_event_call(call);\n\t\tgoto err;\n\t}\n out:\n\treturn ret;\n err:\n\tunregister_trace_event(&call->event);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define SYNTH_SYSTEM\t\t\"synthetic\""
    ],
    "globals_used": [
      "static struct trace_event_functions synth_event_funcs = {\n\t.trace\t\t= print_synth_event\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unregister_trace_event",
          "args": [
            "&call->event"
          ],
          "line": 930
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_trace_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_output.c",
          "lines": "818-825",
          "snippet": "int unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/ftrace.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_trace_event(struct trace_event *event)\n{\n\tdown_write(&trace_event_sem);\n\t__unregister_trace_event(event);\n\tup_write(&trace_event_sem);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_remove_event_call",
          "args": [
            "call"
          ],
          "line": 924
        },
        "resolved": true,
        "details": {
          "function_name": "trace_remove_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2370-2383",
          "snippet": "int trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_remove_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\tdown_write(&trace_event_sem);\n\tret = probe_remove_event_call(call);\n\tup_write(&trace_event_sem);\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_synth_event_print_fmt",
          "args": [
            "call"
          ],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "set_synth_event_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "714-732",
          "snippet": "static int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register synthetic event: %s\\n\"",
            "trace_event_name(call)"
          ],
          "line": 917
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_name",
          "args": [
            "call"
          ],
          "line": 918
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_add_event_call",
          "args": [
            "call"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "trace_add_event_call",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "2309-2322",
          "snippet": "int trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_add_event_call(struct trace_event_call *call)\n{\n\tint ret;\n\tmutex_lock(&event_mutex);\n\tmutex_lock(&trace_types_lock);\n\n\tret = __register_event(call, NULL);\n\tif (ret >= 0)\n\t\t__add_event_to_tracers(call);\n\n\tmutex_unlock(&trace_types_lock);\n\tmutex_unlock(&event_mutex);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&call->class->fields"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "event->tp"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event->tp"
          ],
          "line": 894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_synth_tracepoint",
          "args": [
            "event->name"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "alloc_synth_tracepoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "825-840",
          "snippet": "static struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "SYNTH_SYSTEM",
            "GFP_KERNEL"
          ],
          "line": 887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define SYNTH_SYSTEM\t\t\"synthetic\"\n\nstatic struct trace_event_functions synth_event_funcs = {\n\t.trace\t\t= print_synth_event\n};\n\nstatic int register_synth_event(struct synth_event *event)\n{\n\tstruct trace_event_call *call = &event->call;\n\tint ret = 0;\n\n\tevent->call.class = &event->class;\n\tevent->class.system = kstrdup(SYNTH_SYSTEM, GFP_KERNEL);\n\tif (!event->class.system) {\n\t\tret = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tevent->tp = alloc_synth_tracepoint(event->name);\n\tif (IS_ERR(event->tp)) {\n\t\tret = PTR_ERR(event->tp);\n\t\tevent->tp = NULL;\n\t\tgoto out;\n\t}\n\n\tINIT_LIST_HEAD(&call->class->fields);\n\tcall->event.funcs = &synth_event_funcs;\n\tcall->class->define_fields = synth_event_define_fields;\n\n\tret = register_trace_event(&call->event);\n\tif (!ret) {\n\t\tret = -ENODEV;\n\t\tgoto out;\n\t}\n\tcall->flags = TRACE_EVENT_FL_TRACEPOINT;\n\tcall->class->reg = trace_event_reg;\n\tcall->class->probe = trace_event_raw_event_synth;\n\tcall->data = event;\n\tcall->tp = event->tp;\n\n\tret = trace_add_event_call(call);\n\tif (ret) {\n\t\tpr_warn(\"Failed to register synthetic event: %s\\n\",\n\t\t\ttrace_event_name(call));\n\t\tgoto err;\n\t}\n\n\tret = set_synth_event_print_fmt(call);\n\tif (ret < 0) {\n\t\ttrace_remove_event_call(call);\n\t\tgoto err;\n\t}\n out:\n\treturn ret;\n err:\n\tunregister_trace_event(&call->event);\n\tgoto out;\n}"
  },
  {
    "function_name": "find_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "869-879",
    "snippet": "static struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(synth_event_list);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "event->name",
            "name"
          ],
          "line": 874
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "event",
            "&synth_event_list",
            "list"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic LIST_HEAD(synth_event_list);\n\nstatic struct synth_event *find_synth_event(const char *name)\n{\n\tstruct synth_event *event;\n\n\tlist_for_each_entry(event, &synth_event_list, list) {\n\t\tif (strcmp(event->name, name) == 0)\n\t\t\treturn event;\n\t}\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "trace_synth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "845-867",
    "snippet": "static inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "probe_func",
          "args": [
            "__data",
            "var_ref_vals",
            "var_ref_idx"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function_probe_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "4393-4520",
          "snippet": "int\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [
            "#define FTRACE_HASH_DEFAULT_BITS 10"
          ],
          "globals_used": [
            "int ftrace_enabled",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\n#define FTRACE_HASH_DEFAULT_BITS 10\n\nint ftrace_enabled;\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint\nunregister_ftrace_function_probe_func(char *glob, struct trace_array *tr,\n\t\t\t\t      struct ftrace_probe_ops *probe_ops)\n{\n\tstruct ftrace_ops_hash old_hash_ops;\n\tstruct ftrace_func_entry *entry;\n\tstruct ftrace_func_probe *probe;\n\tstruct ftrace_glob func_g;\n\tstruct ftrace_hash **orig_hash;\n\tstruct ftrace_hash *old_hash;\n\tstruct ftrace_hash *hash = NULL;\n\tstruct hlist_node *tmp;\n\tstruct hlist_head hhd;\n\tchar str[KSYM_SYMBOL_LEN];\n\tint count = 0;\n\tint i, ret = -ENODEV;\n\tint size;\n\n\tif (!glob || !strlen(glob) || !strcmp(glob, \"*\"))\n\t\tfunc_g.search = NULL;\n\telse {\n\t\tint not;\n\n\t\tfunc_g.type = filter_parse_regex(glob, strlen(glob),\n\t\t\t\t\t\t &func_g.search, &not);\n\t\tfunc_g.len = strlen(func_g.search);\n\n\t\t/* we do not support '!' for function probes */\n\t\tif (WARN_ON(not))\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\t/* Check if the probe_ops is already registered */\n\tlist_for_each_entry(probe, &tr->func_probes, list) {\n\t\tif (probe->probe_ops == probe_ops)\n\t\t\tbreak;\n\t}\n\tif (&probe->list == &tr->func_probes)\n\t\tgoto err_unlock_ftrace;\n\n\tret = -EINVAL;\n\tif (!(probe->ops.flags & FTRACE_OPS_FL_INITIALIZED))\n\t\tgoto err_unlock_ftrace;\n\n\tacquire_probe_locked(probe);\n\n\tmutex_unlock(&ftrace_lock);\n\n\tmutex_lock(&probe->ops.func_hash->regex_lock);\n\n\torig_hash = &probe->ops.func_hash->filter_hash;\n\told_hash = *orig_hash;\n\n\tif (ftrace_hash_empty(old_hash))\n\t\tgoto out_unlock;\n\n\told_hash_ops.filter_hash = old_hash;\n\t/* Probes only have filters */\n\told_hash_ops.notrace_hash = NULL;\n\n\tret = -ENOMEM;\n\thash = alloc_and_copy_ftrace_hash(FTRACE_HASH_DEFAULT_BITS, old_hash);\n\tif (!hash)\n\t\tgoto out_unlock;\n\n\tINIT_HLIST_HEAD(&hhd);\n\n\tsize = 1 << hash->size_bits;\n\tfor (i = 0; i < size; i++) {\n\t\thlist_for_each_entry_safe(entry, tmp, &hash->buckets[i], hlist) {\n\n\t\t\tif (func_g.search) {\n\t\t\t\tkallsyms_lookup(entry->ip, NULL, NULL,\n\t\t\t\t\t\tNULL, str);\n\t\t\t\tif (!ftrace_match(str, &func_g))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tcount++;\n\t\t\tremove_hash_entry(hash, entry);\n\t\t\thlist_add_head(&entry->hlist, &hhd);\n\t\t}\n\t}\n\n\t/* Nothing found? */\n\tif (!count) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\tmutex_lock(&ftrace_lock);\n\n\tWARN_ON(probe->ref < count);\n\n\tprobe->ref -= count;\n\n\tif (ftrace_hash_empty(hash))\n\t\tftrace_shutdown(&probe->ops, 0);\n\n\tret = ftrace_hash_move_and_update_ops(&probe->ops, orig_hash,\n\t\t\t\t\t      hash, 1);\n\n\t/* still need to update the function call sites */\n\tif (ftrace_enabled && !ftrace_hash_empty(hash))\n\t\tftrace_run_modify_code(&probe->ops, FTRACE_UPDATE_CALLS,\n\t\t\t\t       &old_hash_ops);\n\tsynchronize_sched();\n\n\thlist_for_each_entry_safe(entry, tmp, &hhd, hlist) {\n\t\thlist_del(&entry->hlist);\n\t\tif (probe_ops->free)\n\t\t\tprobe_ops->free(probe_ops, tr, entry->ip, probe->data);\n\t\tkfree(entry);\n\t}\n\tmutex_unlock(&ftrace_lock);\n\n out_unlock:\n\tmutex_unlock(&probe->ops.func_hash->regex_lock);\n\tfree_ftrace_hash(hash);\n\n\trelease_probe(probe);\n\n\treturn ret;\n\n err_unlock_ftrace:\n\tmutex_unlock(&ftrace_lock);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_sched",
          "args": [
            "(tp)->funcs"
          ],
          "line": 858
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "atomic_read(&tp->key.enabled) > 0"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tp->key.enabled"
          ],
          "line": 850
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic inline void trace_synth(struct synth_event *event, u64 *var_ref_vals,\n\t\t\t       unsigned int var_ref_idx)\n{\n\tstruct tracepoint *tp = event->tp;\n\n\tif (unlikely(atomic_read(&tp->key.enabled) > 0)) {\n\t\tstruct tracepoint_func *probe_func_ptr;\n\t\tsynth_probe_func_t probe_func;\n\t\tvoid *__data;\n\n\t\tif (!(cpu_online(raw_smp_processor_id())))\n\t\t\treturn;\n\n\t\tprobe_func_ptr = rcu_dereference_sched((tp)->funcs);\n\t\tif (probe_func_ptr) {\n\t\t\tdo {\n\t\t\t\tprobe_func = probe_func_ptr->func;\n\t\t\t\t__data = probe_func_ptr->data;\n\t\t\t\tprobe_func(__data, var_ref_vals, var_ref_idx);\n\t\t\t} while ((++probe_func_ptr)->func);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "alloc_synth_tracepoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "825-840",
    "snippet": "static struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 836
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp"
          ],
          "line": 835
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tp)",
            "GFP_KERNEL"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct tracepoint *alloc_synth_tracepoint(char *name)\n{\n\tstruct tracepoint *tp;\n\n\ttp = kzalloc(sizeof(*tp), GFP_KERNEL);\n\tif (!tp)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\ttp->name = kstrdup(name, GFP_KERNEL);\n\tif (!tp->name) {\n\t\tkfree(tp);\n\t\treturn ERR_PTR(-ENOMEM);\n\t}\n\n\treturn tp;\n}"
  },
  {
    "function_name": "free_synth_tracepoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "816-823",
    "snippet": "static void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_tracepoint(struct tracepoint *tp)\n{\n\tif (!tp)\n\t\treturn;\n\n\tkfree(tp->name);\n\tkfree(tp);\n}"
  },
  {
    "function_name": "parse_synth_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "741-814",
    "snippet": "static struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed)\n{\n\tstruct synth_field *field;\n\tconst char *prefix = NULL;\n\tchar *field_type = argv[0], *field_name;\n\tint len, ret = 0;\n\tchar *array;\n\n\tif (field_type[0] == ';')\n\t\tfield_type++;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed = 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed = 2;\n\t}\n\n\tlen = strlen(field_name);\n\tif (field_name[len - 1] == ';')\n\t\tfield_name[len - 1] = '\\0';\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_type) + 1;\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen += strlen(array);\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tif (prefix)\n\t\tstrcat(field->type, prefix);\n\tstrcat(field->type, field_type);\n\tif (array) {\n\t\tstrcat(field->type, array);\n\t\t*array = '\\0';\n\t}\n\n\tfield->size = synth_field_size(field->type);\n\tif (!field->size) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n\n\tfield->name = kstrdup(field_name, GFP_KERNEL);\n\tif (!field->name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "ret"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_synth_field",
          "args": [
            "field"
          ],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "free_synth_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "734-739",
          "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "field_name",
            "GFP_KERNEL"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_field_signed",
          "args": [
            "field->type"
          ],
          "line": 801
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_signed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "447-453",
          "snippet": "static bool synth_field_signed(char *type)\n{\n\tif (strncmp(type, \"u\", 1) == 0)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool synth_field_signed(char *type)\n{\n\tif (strncmp(type, \"u\", 1) == 0)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "field->type"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "455-461",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_size",
          "args": [
            "field->type"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "495-533",
          "snippet": "static int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "field->type",
            "array"
          ],
          "line": 788
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "field->type",
            "field_type"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "field->type",
            "prefix"
          ],
          "line": 785
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "prefix"
          ],
          "line": 778
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "field_name",
            "'['"
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*field)",
            "GFP_KERNEL"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "field_type",
            "\"unsigned\""
          ],
          "line": 753
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic struct synth_field *parse_synth_field(int argc, char **argv,\n\t\t\t\t\t     int *consumed)\n{\n\tstruct synth_field *field;\n\tconst char *prefix = NULL;\n\tchar *field_type = argv[0], *field_name;\n\tint len, ret = 0;\n\tchar *array;\n\n\tif (field_type[0] == ';')\n\t\tfield_type++;\n\n\tif (!strcmp(field_type, \"unsigned\")) {\n\t\tif (argc < 3)\n\t\t\treturn ERR_PTR(-EINVAL);\n\t\tprefix = \"unsigned \";\n\t\tfield_type = argv[1];\n\t\tfield_name = argv[2];\n\t\t*consumed = 3;\n\t} else {\n\t\tfield_name = argv[1];\n\t\t*consumed = 2;\n\t}\n\n\tlen = strlen(field_name);\n\tif (field_name[len - 1] == ';')\n\t\tfield_name[len - 1] = '\\0';\n\n\tfield = kzalloc(sizeof(*field), GFP_KERNEL);\n\tif (!field)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlen = strlen(field_type) + 1;\n\tarray = strchr(field_name, '[');\n\tif (array)\n\t\tlen += strlen(array);\n\tif (prefix)\n\t\tlen += strlen(prefix);\n\tfield->type = kzalloc(len, GFP_KERNEL);\n\tif (!field->type) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n\tif (prefix)\n\t\tstrcat(field->type, prefix);\n\tstrcat(field->type, field_type);\n\tif (array) {\n\t\tstrcat(field->type, array);\n\t\t*array = '\\0';\n\t}\n\n\tfield->size = synth_field_size(field->type);\n\tif (!field->size) {\n\t\tret = -EINVAL;\n\t\tgoto free;\n\t}\n\n\tif (synth_field_is_string(field->type))\n\t\tfield->is_string = true;\n\n\tfield->is_signed = synth_field_signed(field->type);\n\n\tfield->name = kstrdup(field_name, GFP_KERNEL);\n\tif (!field->name) {\n\t\tret = -ENOMEM;\n\t\tgoto free;\n\t}\n out:\n\treturn field;\n free:\n\tfree_synth_field(field);\n\tfield = ERR_PTR(ret);\n\tgoto out;\n}"
  },
  {
    "function_name": "free_synth_field",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "734-739",
    "snippet": "static void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "field"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_field(struct synth_field *field)\n{\n\tkfree(field->type);\n\tkfree(field->name);\n\tkfree(field);\n}"
  },
  {
    "function_name": "set_synth_event_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "714-732",
    "snippet": "static int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_synth_event_print_fmt",
          "args": [
            "event",
            "print_fmt",
            "len + 1"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__set_synth_event_print_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "684-712",
          "snippet": "static int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define LEN_OR_ZERO (len ? len - pos : 0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len + 1",
            "GFP_KERNEL"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int set_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tstruct synth_event *event = call->data;\n\tchar *print_fmt;\n\tint len;\n\n\t/* First: called with 0 length to calculate the needed length */\n\tlen = __set_synth_event_print_fmt(event, NULL, 0);\n\n\tprint_fmt = kmalloc(len + 1, GFP_KERNEL);\n\tif (!print_fmt)\n\t\treturn -ENOMEM;\n\n\t/* Second: actually write the @print_fmt */\n\t__set_synth_event_print_fmt(event, print_fmt, len + 1);\n\tcall->print_fmt = print_fmt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_synth_event_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "684-712",
    "snippet": "static int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define LEN_OR_ZERO (len ? len - pos : 0)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\", REC->%s\"",
            "event->fields[i]->name"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"%s=%s%s\"",
            "event->fields[i]->name",
            "fmt",
            "i == event->n_fields - 1 ? \"\" : \", \""
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_field_fmt",
          "args": [
            "event->fields[i]->type"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "535-573",
          "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf + pos",
            "LEN_OR_ZERO",
            "\"\\\"\""
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\nstatic int __set_synth_event_print_fmt(struct synth_event *event,\n\t\t\t\t       char *buf, int len)\n{\n\tconst char *fmt;\n\tint pos = 0;\n\tint i;\n\n\t/* When len=0, we just calculate the needed length */\n#define LEN_OR_ZERO (len ? len - pos : 0)\n\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tfmt = synth_field_fmt(event->fields[i]->type);\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"%s=%s%s\",\n\t\t\t\tevent->fields[i]->name, fmt,\n\t\t\t\ti == event->n_fields - 1 ? \"\" : \", \");\n\t}\n\tpos += snprintf(buf + pos, LEN_OR_ZERO, \"\\\"\");\n\n\tfor (i = 0; i < event->n_fields; i++) {\n\t\tpos += snprintf(buf + pos, LEN_OR_ZERO,\n\t\t\t\t\", REC->%s\", event->fields[i]->name);\n\t}\n\n#undef LEN_OR_ZERO\n\n\t/* return the length of print_fmt */\n\treturn pos;\n}"
  },
  {
    "function_name": "free_synth_event_print_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "676-682",
    "snippet": "static void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "call->print_fmt"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void free_synth_event_print_fmt(struct trace_event_call *call)\n{\n\tif (call) {\n\t\tkfree(call->print_fmt);\n\t\tcall->print_fmt = NULL;\n\t}\n}"
  },
  {
    "function_name": "trace_event_raw_event_synth",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "627-674",
    "snippet": "static notrace void trace_event_raw_event_synth(void *__data,\n\t\t\t\t\t\tu64 *var_ref_vals,\n\t\t\t\t\t\tunsigned int var_ref_idx)\n{\n\tstruct trace_event_file *trace_file = __data;\n\tstruct synth_trace_event *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct ring_buffer *buffer;\n\tstruct synth_event *event;\n\tunsigned int i, n_u64;\n\tint fields_size = 0;\n\n\tevent = trace_file->event_call->data;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tfields_size = event->n_u64 * sizeof(u64);\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\tbuffer = trace_file->tr->trace_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + fields_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)var_ref_vals[var_ref_idx + i];\n\t\t\tchar *str_field = (char *)&entry->fields[n_u64];\n\n\t\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\tentry->fields[n_u64] = var_ref_vals[var_ref_idx + i];\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\ttrace_event_buffer_commit(&fbuffer);\nout:\n\tring_buffer_nest_end(buffer);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ring_buffer_nest_end",
          "args": [
            "buffer"
          ],
          "line": 673
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "2716-2727",
          "snippet": "void ring_buffer_nest_end(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 4"
          ],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\n#define NESTED_BITS 4\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_end(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* disabled by ring_buffer_nest_start() */\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest -= NESTED_BITS;\n\tpreempt_enable_notrace();\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_commit",
          "args": [
            "&fbuffer"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_commit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2379-2387",
          "snippet": "void trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tevent_trigger_unlock_commit(fbuffer->trace_file, fbuffer->buffer,\n\t\t\t\t    fbuffer->event, fbuffer->entry,\n\t\t\t\t    fbuffer->flags, fbuffer->pc);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic DEFINE_STATIC_KEY_FALSE(tracepoint_printk_key);\nstatic __always_inline struct;\n\nvoid trace_event_buffer_commit(struct trace_event_buffer *fbuffer)\n{\n\tif (static_key_false(&tracepoint_printk_key.key))\n\t\toutput_printk(fbuffer);\n\n\tevent_trigger_unlock_commit(fbuffer->trace_file, fbuffer->buffer,\n\t\t\t\t    fbuffer->event, fbuffer->entry,\n\t\t\t\t    fbuffer->flags, fbuffer->pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "str_field",
            "str_val",
            "STR_VAR_LEN_MAX"
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_event_buffer_reserve",
          "args": [
            "&fbuffer",
            "trace_file",
            "sizeof(*entry) + fields_size"
          ],
          "line": 653
        },
        "resolved": true,
        "details": {
          "function_name": "trace_event_buffer_reserve",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "253-284",
          "snippet": "void *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\tlocal_save_flags(fbuffer->flags);\n\tfbuffer->pc = preempt_count();\n\t/*\n\t * If CONFIG_PREEMPT is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\tfbuffer->pc--;\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->flags, fbuffer->pc);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nvoid *trace_event_buffer_reserve(struct trace_event_buffer *fbuffer,\n\t\t\t\t struct trace_event_file *trace_file,\n\t\t\t\t unsigned long len)\n{\n\tstruct trace_event_call *event_call = trace_file->event_call;\n\n\tif ((trace_file->flags & EVENT_FILE_FL_PID_FILTER) &&\n\t    trace_event_ignore_this_pid(trace_file))\n\t\treturn NULL;\n\n\tlocal_save_flags(fbuffer->flags);\n\tfbuffer->pc = preempt_count();\n\t/*\n\t * If CONFIG_PREEMPT is enabled, then the tracepoint itself disables\n\t * preemption (adding one to the preempt_count). Since we are\n\t * interested in the preempt_count at the time the tracepoint was\n\t * hit, we need to subtract one to offset the increment.\n\t */\n\tif (IS_ENABLED(CONFIG_PREEMPT))\n\t\tfbuffer->pc--;\n\tfbuffer->trace_file = trace_file;\n\n\tfbuffer->event =\n\t\ttrace_event_buffer_lock_reserve(&fbuffer->buffer, trace_file,\n\t\t\t\t\t\tevent_call->event.type, len,\n\t\t\t\t\t\tfbuffer->flags, fbuffer->pc);\n\tif (!fbuffer->event)\n\t\treturn NULL;\n\n\tfbuffer->entry = ring_buffer_event_data(fbuffer->event);\n\treturn fbuffer->entry;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ring_buffer_nest_start",
          "args": [
            "buffer"
          ],
          "line": 651
        },
        "resolved": true,
        "details": {
          "function_name": "ring_buffer_nest_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ring_buffer.c",
          "lines": "2696-2707",
          "snippet": "void ring_buffer_nest_start(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}",
          "includes": [
            "#include <asm/local.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/list.h>",
            "#include <linux/hash.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/delay.h>",
            "#include <linux/mutex.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>\t/* for self test */",
            "#include <linux/hardirq.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/trace_seq.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/ring_buffer.h>",
            "#include <linux/trace_events.h>"
          ],
          "macros_used": [
            "#define NESTED_BITS 4"
          ],
          "globals_used": [
            "static void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);",
            "static __always_inline struct",
            "static __always_inline struct",
            "static inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);",
            "static noinline struct",
            "static noinline struct",
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/local.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/list.h>\n#include <linux/hash.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/delay.h>\n#include <linux/mutex.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\t/* for self test */\n#include <linux/hardirq.h>\n#include <linux/uaccess.h>\n#include <linux/irq_work.h>\n#include <linux/spinlock.h>\n#include <linux/trace_seq.h>\n#include <linux/sched/clock.h>\n#include <linux/trace_clock.h>\n#include <linux/ring_buffer.h>\n#include <linux/trace_events.h>\n\n#define NESTED_BITS 4\n\nstatic void rb_reset_cpu(struct ring_buffer_per_cpu *cpu_buffer);\nstatic __always_inline struct;\nstatic __always_inline struct;\nstatic inline void rb_end_commit(struct ring_buffer_per_cpu *cpu_buffer);\nstatic noinline struct;\nstatic noinline struct;\nstatic __always_inline struct;\n\nvoid ring_buffer_nest_start(struct ring_buffer *buffer)\n{\n\tstruct ring_buffer_per_cpu *cpu_buffer;\n\tint cpu;\n\n\t/* Enabled by ring_buffer_nest_end() */\n\tpreempt_disable_notrace();\n\tcpu = raw_smp_processor_id();\n\tcpu_buffer = buffer->buffers[cpu];\n\t/* This is the shift value for the above recursive locking */\n\tcpu_buffer->nest += NESTED_BITS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_trigger_soft_disabled",
          "args": [
            "trace_file"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic notrace void trace_event_raw_event_synth(void *__data,\n\t\t\t\t\t\tu64 *var_ref_vals,\n\t\t\t\t\t\tunsigned int var_ref_idx)\n{\n\tstruct trace_event_file *trace_file = __data;\n\tstruct synth_trace_event *entry;\n\tstruct trace_event_buffer fbuffer;\n\tstruct ring_buffer *buffer;\n\tstruct synth_event *event;\n\tunsigned int i, n_u64;\n\tint fields_size = 0;\n\n\tevent = trace_file->event_call->data;\n\n\tif (trace_trigger_soft_disabled(trace_file))\n\t\treturn;\n\n\tfields_size = event->n_u64 * sizeof(u64);\n\n\t/*\n\t * Avoid ring buffer recursion detection, as this event\n\t * is being performed within another event.\n\t */\n\tbuffer = trace_file->tr->trace_buffer.buffer;\n\tring_buffer_nest_start(buffer);\n\n\tentry = trace_event_buffer_reserve(&fbuffer, trace_file,\n\t\t\t\t\t   sizeof(*entry) + fields_size);\n\tif (!entry)\n\t\tgoto out;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tif (event->fields[i]->is_string) {\n\t\t\tchar *str_val = (char *)(long)var_ref_vals[var_ref_idx + i];\n\t\t\tchar *str_field = (char *)&entry->fields[n_u64];\n\n\t\t\tstrscpy(str_field, str_val, STR_VAR_LEN_MAX);\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\tentry->fields[n_u64] = var_ref_vals[var_ref_idx + i];\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\ttrace_event_buffer_commit(&fbuffer);\nout:\n\tring_buffer_nest_end(buffer);\n}"
  },
  {
    "function_name": "print_synth_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "575-621",
    "snippet": "static enum print_line_t print_synth_event(struct trace_iterator *iter,\n\t\t\t\t\t   int flags,\n\t\t\t\t\t   struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *se;\n\tunsigned int i, n_u64;\n\tchar print_fmt[32];\n\tconst char *fmt;\n\n\tentry = (struct synth_trace_event *)iter->ent;\n\tse = container_of(event, struct synth_event, call.event);\n\n\ttrace_seq_printf(s, \"%s: \", se->name);\n\n\tfor (i = 0, n_u64 = 0; i < se->n_fields; i++) {\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\tfmt = synth_field_fmt(se->fields[i]->type);\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", fmt);\n\n\t\tsnprintf(print_fmt, sizeof(print_fmt), \"%%s=%s%%s\", fmt);\n\n\t\t/* parameter values */\n\t\tif (se->fields[i]->is_string) {\n\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t (char *)&entry->fields[n_u64],\n\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t entry->fields[n_u64],\n\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\tn_u64++;\n\t\t}\n\t}\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_handle_return",
          "args": [
            "s"
          ],
          "line": 620
        },
        "resolved": true,
        "details": {
          "function_name": "trace_handle_return",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2123-2127",
          "snippet": "enum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nenum print_line_t trace_handle_return(struct trace_seq *s)\n{\n\treturn trace_seq_has_overflowed(s) ?\n\t\tTRACE_TYPE_PARTIAL_LINE : TRACE_TYPE_HANDLED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_putc",
          "args": [
            "s",
            "'\\n'"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_putc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "236-249",
          "snippet": "void trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_putc(struct trace_seq *s, unsigned char c)\n{\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tif (TRACE_SEQ_BUF_LEFT(s) < 1) {\n\t\ts->full = 1;\n\t\treturn;\n\t}\n\n\tseq_buf_putc(&s->seq, c);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_printf",
          "args": [
            "s",
            "print_fmt",
            "se->fields[i]->name",
            "entry->fields[n_u64]",
            "i == se->n_fields - 1 ? \"\" : \" \""
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "print_fmt",
            "sizeof(print_fmt)",
            "\"%%s=%s%%s\"",
            "fmt"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synth_field_fmt",
          "args": [
            "se->fields[i]->type"
          ],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_fmt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "535-573",
          "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_seq_has_overflowed",
          "args": [
            "s"
          ],
          "line": 593
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "event",
            "structsynth_event",
            "call.event"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic enum print_line_t print_synth_event(struct trace_iterator *iter,\n\t\t\t\t\t   int flags,\n\t\t\t\t\t   struct trace_event *event)\n{\n\tstruct trace_array *tr = iter->tr;\n\tstruct trace_seq *s = &iter->seq;\n\tstruct synth_trace_event *entry;\n\tstruct synth_event *se;\n\tunsigned int i, n_u64;\n\tchar print_fmt[32];\n\tconst char *fmt;\n\n\tentry = (struct synth_trace_event *)iter->ent;\n\tse = container_of(event, struct synth_event, call.event);\n\n\ttrace_seq_printf(s, \"%s: \", se->name);\n\n\tfor (i = 0, n_u64 = 0; i < se->n_fields; i++) {\n\t\tif (trace_seq_has_overflowed(s))\n\t\t\tgoto end;\n\n\t\tfmt = synth_field_fmt(se->fields[i]->type);\n\n\t\t/* parameter types */\n\t\tif (tr->trace_flags & TRACE_ITER_VERBOSE)\n\t\t\ttrace_seq_printf(s, \"%s \", fmt);\n\n\t\tsnprintf(print_fmt, sizeof(print_fmt), \"%%s=%s%%s\", fmt);\n\n\t\t/* parameter values */\n\t\tif (se->fields[i]->is_string) {\n\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t (char *)&entry->fields[n_u64],\n\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\ttrace_seq_printf(s, print_fmt, se->fields[i]->name,\n\t\t\t\t\t entry->fields[n_u64],\n\t\t\t\t\t i == se->n_fields - 1 ? \"\" : \" \");\n\t\t\tn_u64++;\n\t\t}\n\t}\nend:\n\ttrace_seq_putc(s, '\\n');\n\n\treturn trace_handle_return(s);\n}"
  },
  {
    "function_name": "synth_field_fmt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "535-573",
    "snippet": "static const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "type"
          ],
          "line": 569
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "455-461",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"pid_t\""
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned long\""
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"long\""
          ],
          "line": 563
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned int\""
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"int\""
          ],
          "line": 559
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned char\""
          ],
          "line": 557
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u8\""
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s8\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u16\""
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s16\""
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u32\""
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s32\""
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u64\""
          ],
          "line": 541
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s64\""
          ],
          "line": 539
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic const char *synth_field_fmt(char *type)\n{\n\tconst char *fmt = \"%llu\";\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tfmt = \"%lld\";\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tfmt = \"%llu\";\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"char\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"int\") == 0)\n\t\tfmt = \"%d\";\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tfmt = \"%u\";\n\telse if (strcmp(type, \"long\") == 0)\n\t\tfmt = \"%ld\";\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tfmt = \"%lu\";\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tfmt = \"%d\";\n\telse if (synth_field_is_string(type))\n\t\tfmt = \"%s\";\n\n\treturn fmt;\n}"
  },
  {
    "function_name": "synth_field_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "495-533",
    "snippet": "static int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synth_field_string_size",
          "args": [
            "type"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_string_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "463-493",
          "snippet": "static int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += strlen(\"char[\");\n\n\tend = strchr(type, ']');\n\tif (!end || end < start)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += strlen(\"char[\");\n\n\tend = strchr(type, ']');\n\tif (!end || end < start)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}"
        }
      },
      {
        "call_info": {
          "callee": "synth_field_is_string",
          "args": [
            "type"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "synth_field_is_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "455-461",
          "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"pid_t\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned long\""
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"long\""
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned int\""
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"int\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"unsigned char\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"char\""
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u8\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s8\""
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u16\""
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s16\""
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u32\""
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s32\""
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"u64\""
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "type",
            "\"s64\""
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_size(char *type)\n{\n\tint size = 0;\n\n\tif (strcmp(type, \"s64\") == 0)\n\t\tsize = sizeof(s64);\n\telse if (strcmp(type, \"u64\") == 0)\n\t\tsize = sizeof(u64);\n\telse if (strcmp(type, \"s32\") == 0)\n\t\tsize = sizeof(s32);\n\telse if (strcmp(type, \"u32\") == 0)\n\t\tsize = sizeof(u32);\n\telse if (strcmp(type, \"s16\") == 0)\n\t\tsize = sizeof(s16);\n\telse if (strcmp(type, \"u16\") == 0)\n\t\tsize = sizeof(u16);\n\telse if (strcmp(type, \"s8\") == 0)\n\t\tsize = sizeof(s8);\n\telse if (strcmp(type, \"u8\") == 0)\n\t\tsize = sizeof(u8);\n\telse if (strcmp(type, \"char\") == 0)\n\t\tsize = sizeof(char);\n\telse if (strcmp(type, \"unsigned char\") == 0)\n\t\tsize = sizeof(unsigned char);\n\telse if (strcmp(type, \"int\") == 0)\n\t\tsize = sizeof(int);\n\telse if (strcmp(type, \"unsigned int\") == 0)\n\t\tsize = sizeof(unsigned int);\n\telse if (strcmp(type, \"long\") == 0)\n\t\tsize = sizeof(long);\n\telse if (strcmp(type, \"unsigned long\") == 0)\n\t\tsize = sizeof(unsigned long);\n\telse if (strcmp(type, \"pid_t\") == 0)\n\t\tsize = sizeof(pid_t);\n\telse if (synth_field_is_string(type))\n\t\tsize = synth_field_string_size(type);\n\n\treturn size;\n}"
  },
  {
    "function_name": "synth_field_string_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "463-493",
    "snippet": "static int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += strlen(\"char[\");\n\n\tend = strchr(type, ']');\n\tif (!end || end < start)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "0",
            "&size"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "buf",
            "start",
            "len"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "type",
            "']'"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "\"char[\""
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char[\""
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic int synth_field_string_size(char *type)\n{\n\tchar buf[4], *end, *start;\n\tunsigned int len;\n\tint size, err;\n\n\tstart = strstr(type, \"char[\");\n\tif (start == NULL)\n\t\treturn -EINVAL;\n\tstart += strlen(\"char[\");\n\n\tend = strchr(type, ']');\n\tif (!end || end < start)\n\t\treturn -EINVAL;\n\n\tlen = end - start;\n\tif (len > 3)\n\t\treturn -EINVAL;\n\n\tstrncpy(buf, start, len);\n\tbuf[len] = '\\0';\n\n\terr = kstrtouint(buf, 0, &size);\n\tif (err)\n\t\treturn err;\n\n\tif (size > STR_VAR_LEN_MAX)\n\t\treturn -EINVAL;\n\n\treturn size;\n}"
  },
  {
    "function_name": "synth_field_is_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "455-461",
    "snippet": "static int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strstr",
          "args": [
            "type",
            "\"char[\""
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic int synth_field_is_string(char *type)\n{\n\tif (strstr(type, \"char[\") != NULL)\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "synth_field_signed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "447-453",
    "snippet": "static bool synth_field_signed(char *type)\n{\n\tif (strncmp(type, \"u\", 1) == 0)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "type",
            "\"u\"",
            "1"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic bool synth_field_signed(char *type)\n{\n\tif (strncmp(type, \"u\", 1) == 0)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "synth_event_define_fields",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "413-445",
    "snippet": "static int synth_event_define_fields(struct trace_event_call *call)\n{\n\tstruct synth_trace_event trace;\n\tint offset = offsetof(typeof(trace), fields);\n\tstruct synth_event *event = call->data;\n\tunsigned int i, size, n_u64;\n\tchar *name, *type;\n\tbool is_signed;\n\tint ret = 0;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tsize = event->fields[i]->size;\n\t\tis_signed = event->fields[i]->is_signed;\n\t\ttype = event->fields[i]->type;\n\t\tname = event->fields[i]->name;\n\t\tret = trace_define_field(call, type, name, offset, size,\n\t\t\t\t\t is_signed, FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (event->fields[i]->is_string) {\n\t\t\toffset += STR_VAR_LEN_MAX;\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\toffset += sizeof(u64);\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\tevent->n_u64 = n_u64;\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_define_field",
          "args": [
            "call",
            "type",
            "name",
            "offset",
            "size",
            "is_signed",
            "FILTER_OTHER"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "trace_define_field",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events.c",
          "lines": "139-151",
          "snippet": "int trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}",
          "includes": [
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/delay.h>",
            "#include <linux/slab.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/kthread.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/workqueue.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void __add_event_to_tracers(struct trace_event_call *call);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <trace/events/sched.h>\n#include <linux/delay.h>\n#include <linux/slab.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/tracefs.h>\n#include <linux/kthread.h>\n#include <linux/spinlock.h>\n#include <linux/workqueue.h>\n\nstatic void __add_event_to_tracers(struct trace_event_call *call);\n\nint trace_define_field(struct trace_event_call *call, const char *type,\n\t\t       const char *name, int offset, int size, int is_signed,\n\t\t       int filter_type)\n{\n\tstruct list_head *head;\n\n\tif (WARN_ON(!call->class))\n\t\treturn 0;\n\n\thead = trace_get_fields(call);\n\treturn __trace_define_field(head, type, name, offset, size,\n\t\t\t\t    is_signed, filter_type);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\n#define STR_VAR_LEN_MAX\t\t32 /* must be multiple of sizeof(u64) */\n\nstatic int synth_event_define_fields(struct trace_event_call *call)\n{\n\tstruct synth_trace_event trace;\n\tint offset = offsetof(typeof(trace), fields);\n\tstruct synth_event *event = call->data;\n\tunsigned int i, size, n_u64;\n\tchar *name, *type;\n\tbool is_signed;\n\tint ret = 0;\n\n\tfor (i = 0, n_u64 = 0; i < event->n_fields; i++) {\n\t\tsize = event->fields[i]->size;\n\t\tis_signed = event->fields[i]->is_signed;\n\t\ttype = event->fields[i]->type;\n\t\tname = event->fields[i]->name;\n\t\tret = trace_define_field(call, type, name, offset, size,\n\t\t\t\t\t is_signed, FILTER_OTHER);\n\t\tif (ret)\n\t\t\tbreak;\n\n\t\tif (event->fields[i]->is_string) {\n\t\t\toffset += STR_VAR_LEN_MAX;\n\t\t\tn_u64 += STR_VAR_LEN_MAX / sizeof(u64);\n\t\t} else {\n\t\t\toffset += sizeof(u64);\n\t\t\tn_u64++;\n\t\t}\n\t}\n\n\tevent->n_u64 = n_u64;\n\n\treturn ret;\n}"
  },
  {
    "function_name": "have_hist_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "397-403",
    "snippet": "static bool have_hist_err(void)\n{\n\tif (strlen(hist_err_str))\n\t\treturn true;\n\n\treturn false;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char hist_err_str[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "hist_err_str"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic bool have_hist_err(void)\n{\n\tif (strlen(hist_err_str))\n\t\treturn true;\n\n\treturn false;\n}"
  },
  {
    "function_name": "hist_err_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "392-395",
    "snippet": "static void hist_err_clear(void)\n{\n\thist_err_str[0] = '\\0';\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char hist_err_str[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err_clear(void)\n{\n\thist_err_str[0] = '\\0';\n}"
  },
  {
    "function_name": "hist_err_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "378-390",
    "snippet": "static void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hist_err",
          "args": [
            "str",
            "err"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "hist_err",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
          "lines": "358-376",
          "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/tracefs.h>",
            "#include <linux/rculist.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char hist_err_str[MAX_FILTER_STR_VAL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strscpy",
          "args": [
            "err",
            "var",
            "MAX_FILTER_STR_VAL"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err",
            "MAX_FILTER_STR_VAL",
            "\"%s.%s\"",
            "system",
            "event"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "err",
            "MAX_FILTER_STR_VAL",
            "\"%s.%s.%s\"",
            "system",
            "event",
            "var"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic void hist_err_event(char *str, char *system, char *event, char *var)\n{\n\tchar err[MAX_FILTER_STR_VAL];\n\n\tif (system && var)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s.%s\", system, event, var);\n\telse if (system)\n\t\tsnprintf(err, MAX_FILTER_STR_VAL, \"%s.%s\", system, event);\n\telse\n\t\tstrscpy(err, var, MAX_FILTER_STR_VAL);\n\n\thist_err(str, err);\n}"
  },
  {
    "function_name": "hist_err",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "358-376",
    "snippet": "static void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char hist_err_str[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "hist_err_str",
            "var"
          ],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcat",
          "args": [
            "hist_err_str",
            "str"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "var"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char hist_err_str[MAX_FILTER_STR_VAL];\n\nstatic void hist_err(char *str, char *var)\n{\n\tint maxlen = MAX_FILTER_STR_VAL - 1;\n\n\tif (!str)\n\t\treturn;\n\n\tif (strlen(hist_err_str))\n\t\treturn;\n\n\tif (!var)\n\t\tvar = \"\";\n\n\tif (strlen(hist_err_str) + strlen(str) + strlen(var) > maxlen)\n\t\treturn;\n\n\tstrcat(hist_err_str, str);\n\tstrcat(hist_err_str, var);\n}"
  },
  {
    "function_name": "last_cmd_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "350-356",
    "snippet": "static void last_cmd_set(char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_hist_cmd, str, MAX_FILTER_STR_VAL - 1);\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char last_hist_cmd[MAX_FILTER_STR_VAL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "last_hist_cmd",
            "str",
            "MAX_FILTER_STR_VAL - 1"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic char last_hist_cmd[MAX_FILTER_STR_VAL];\n\nstatic void last_cmd_set(char *str)\n{\n\tif (!str)\n\t\treturn;\n\n\tstrncpy(last_hist_cmd, str, MAX_FILTER_STR_VAL - 1);\n}"
  },
  {
    "function_name": "hist_field_unary_minus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "156-167",
    "snippet": "static u64 hist_field_unary_minus(struct hist_field *hist_field,\n\t\t\t\t  struct tracing_map_elt *elt,\n\t\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t\t  void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\ts64 sval = (s64)operand->fn(operand, elt, rbe, event);\n\tu64 val = (u64)-sval;\n\n\treturn val;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand->fn",
          "args": [
            "operand",
            "elt",
            "rbe",
            "event"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_unary_minus(struct hist_field *hist_field,\n\t\t\t\t  struct tracing_map_elt *elt,\n\t\t\t\t  struct ring_buffer_event *rbe,\n\t\t\t\t  void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\ts64 sval = (s64)operand->fn(operand, elt, rbe, event);\n\tu64 val = (u64)-sval;\n\n\treturn val;\n}"
  },
  {
    "function_name": "hist_field_minus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "142-154",
    "snippet": "static u64 hist_field_minus(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, rbe, event);\n\n\treturn val1 - val2;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "rbe",
            "event"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "rbe",
            "event"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_minus(struct hist_field *hist_field,\n\t\t\t    struct tracing_map_elt *elt,\n\t\t\t    struct ring_buffer_event *rbe,\n\t\t\t    void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, rbe, event);\n\n\treturn val1 - val2;\n}"
  },
  {
    "function_name": "hist_field_plus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "128-140",
    "snippet": "static u64 hist_field_plus(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, rbe, event);\n\n\treturn val1 + val2;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "operand2->fn",
          "args": [
            "operand2",
            "elt",
            "rbe",
            "event"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand1->fn",
          "args": [
            "operand1",
            "elt",
            "rbe",
            "event"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_plus(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand1 = hist_field->operands[0];\n\tstruct hist_field *operand2 = hist_field->operands[1];\n\n\tu64 val1 = operand1->fn(operand1, elt, rbe, event);\n\tu64 val2 = operand2->fn(operand2, elt, rbe, event);\n\n\treturn val1 + val2;\n}"
  },
  {
    "function_name": "hist_field_log2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "116-126",
    "snippet": "static u64 hist_field_log2(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\tu64 val = operand->fn(operand, elt, rbe, event);\n\n\treturn (u64) ilog2(roundup_pow_of_two(val));\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ilog2",
          "args": [
            "roundup_pow_of_two(val)"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "roundup_pow_of_two",
          "args": [
            "val"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "operand->fn",
          "args": [
            "operand",
            "elt",
            "rbe",
            "event"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_log2(struct hist_field *hist_field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\tstruct hist_field *operand = hist_field->operands[0];\n\n\tu64 val = operand->fn(operand, elt, rbe, event);\n\n\treturn (u64) ilog2(roundup_pow_of_two(val));\n}"
  },
  {
    "function_name": "hist_field_pstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "106-114",
    "snippet": "static u64 hist_field_pstring(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tchar **addr = (char **)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)*addr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_pstring(struct hist_field *hist_field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\tchar **addr = (char **)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)*addr;\n}"
  },
  {
    "function_name": "hist_field_dynstring",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "94-104",
    "snippet": "static u64 hist_field_dynstring(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_dynstring(struct hist_field *hist_field,\n\t\t\t\tstruct tracing_map_elt *elt,\n\t\t\t\tstruct ring_buffer_event *rbe,\n\t\t\t\tvoid *event)\n{\n\tu32 str_item = *(u32 *)(event + hist_field->field->offset);\n\tint str_loc = str_item & 0xffff;\n\tchar *addr = (char *)(event + str_loc);\n\n\treturn (u64)(unsigned long)addr;\n}"
  },
  {
    "function_name": "hist_field_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "84-92",
    "snippet": "static u64 hist_field_string(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tchar *addr = (char *)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)addr;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_string(struct hist_field *hist_field,\n\t\t\t     struct tracing_map_elt *elt,\n\t\t\t     struct ring_buffer_event *rbe,\n\t\t\t     void *event)\n{\n\tchar *addr = (char *)(event + hist_field->field->offset);\n\n\treturn (u64)(unsigned long)addr;\n}"
  },
  {
    "function_name": "hist_field_counter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "76-82",
    "snippet": "static u64 hist_field_counter(struct hist_field *field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\treturn 1;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_counter(struct hist_field *field,\n\t\t\t      struct tracing_map_elt *elt,\n\t\t\t      struct ring_buffer_event *rbe,\n\t\t\t      void *event)\n{\n\treturn 1;\n}"
  },
  {
    "function_name": "hist_field_none",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_events_hist.c",
    "lines": "68-74",
    "snippet": "static u64 hist_field_none(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn 0;\n}",
    "includes": [
      "#include \"trace.h\"",
      "#include \"tracing_map.h\"",
      "#include <linux/tracefs.h>",
      "#include <linux/rculist.h>",
      "#include <linux/stacktrace.h>",
      "#include <linux/slab.h>",
      "#include <linux/mutex.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/tracefs.h>\n#include <linux/rculist.h>\n#include <linux/stacktrace.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/kallsyms.h>\n#include <linux/module.h>\n\nstatic u64 hist_field_none(struct hist_field *field,\n\t\t\t   struct tracing_map_elt *elt,\n\t\t\t   struct ring_buffer_event *rbe,\n\t\t\t   void *event)\n{\n\treturn 0;\n}"
  }
]