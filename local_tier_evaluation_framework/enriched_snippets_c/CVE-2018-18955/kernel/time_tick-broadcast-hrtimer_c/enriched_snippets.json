[
  {
    "function_name": "tick_setup_hrtimer_broadcast",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "107-112",
    "snippet": "void tick_setup_hrtimer_broadcast(void)\n{\n\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tbctimer.function = bc_handler;\n\tclockevents_register_device(&ce_broadcast_hrtimer);\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;",
      "static struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevents_register_device",
          "args": [
            "&ce_broadcast_hrtimer"
          ],
          "line": 111
        },
        "resolved": true,
        "details": {
          "function_name": "clockevents_register_device",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clockevents.c",
          "lines": "454-479",
          "snippet": "void clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <linux/device.h>",
            "#include <linux/smp.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/clockchips.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(clockevent_devices);",
            "static DEFINE_RAW_SPINLOCK(clockevents_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/device.h>\n#include <linux/smp.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/hrtimer.h>\n#include <linux/clockchips.h>\n\nstatic LIST_HEAD(clockevent_devices);\nstatic DEFINE_RAW_SPINLOCK(clockevents_lock);\n\nvoid clockevents_register_device(struct clock_event_device *dev)\n{\n\tunsigned long flags;\n\n\t/* Initialize state to DETACHED */\n\tclockevent_set_state(dev, CLOCK_EVT_STATE_DETACHED);\n\n\tif (!dev->cpumask) {\n\t\tWARN_ON(num_possible_cpus() > 1);\n\t\tdev->cpumask = cpumask_of(smp_processor_id());\n\t}\n\n\tif (dev->cpumask == cpu_all_mask) {\n\t\tWARN(1, \"%s cpumask == cpu_all_mask, using cpu_possible_mask instead\\n\",\n\t\t     dev->name);\n\t\tdev->cpumask = cpu_possible_mask;\n\t}\n\n\traw_spin_lock_irqsave(&clockevents_lock, flags);\n\n\tlist_add(&dev->list, &clockevent_devices);\n\ttick_check_new_device(dev);\n\tclockevents_notify_released();\n\n\traw_spin_unlock_irqrestore(&clockevents_lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_init",
          "args": [
            "&bctimer",
            "CLOCK_MONOTONIC",
            "HRTIMER_MODE_ABS"
          ],
          "line": 109
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1305-1310",
          "snippet": "void hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nvoid hrtimer_init(struct hrtimer *timer, clockid_t clock_id,\n\t\t  enum hrtimer_mode mode)\n{\n\tdebug_init(timer, clock_id, mode);\n\t__hrtimer_init(timer, clock_id, mode);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\nstatic struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};\n\nvoid tick_setup_hrtimer_broadcast(void)\n{\n\thrtimer_init(&bctimer, CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\tbctimer.function = bc_handler;\n\tclockevents_register_device(&ce_broadcast_hrtimer);\n}"
  },
  {
    "function_name": "bc_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "96-105",
    "snippet": "static enum hrtimer_restart bc_handler(struct hrtimer *t)\n{\n\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);\n\n\tif (clockevent_state_oneshot(&ce_broadcast_hrtimer))\n\t\tif (ce_broadcast_hrtimer.next_event != KTIME_MAX)\n\t\t\treturn HRTIMER_RESTART;\n\n\treturn HRTIMER_NORESTART;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clockevent_state_oneshot",
          "args": [
            "&ce_broadcast_hrtimer"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ce_broadcast_hrtimer.event_handler",
          "args": [
            "&ce_broadcast_hrtimer"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};\n\nstatic enum hrtimer_restart bc_handler(struct hrtimer *t)\n{\n\tce_broadcast_hrtimer.event_handler(&ce_broadcast_hrtimer);\n\n\tif (clockevent_state_oneshot(&ce_broadcast_hrtimer))\n\t\tif (ce_broadcast_hrtimer.next_event != KTIME_MAX)\n\t\t\treturn HRTIMER_RESTART;\n\n\treturn HRTIMER_NORESTART;\n}"
  },
  {
    "function_name": "bc_set_next",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "45-76",
    "snippet": "static int bc_set_next(ktime_t expires, struct clock_event_device *bc)\n{\n\tint bc_moved;\n\t/*\n\t * We try to cancel the timer first. If the callback is on\n\t * flight on some other cpu then we let it handle it. If we\n\t * were able to cancel the timer nothing can rearm it as we\n\t * own broadcast_lock.\n\t *\n\t * However we can also be called from the event handler of\n\t * ce_broadcast_hrtimer itself when it expires. We cannot\n\t * restart the timer because we are in the callback, but we\n\t * can set the expiry time and let the callback return\n\t * HRTIMER_RESTART.\n\t *\n\t * Since we are in the idle loop at this point and because\n\t * hrtimer_{start/cancel} functions call into tracing,\n\t * calls to these functions must be bound within RCU_NONIDLE.\n\t */\n\tRCU_NONIDLE({\n\t\t\tbc_moved = hrtimer_try_to_cancel(&bctimer) >= 0;\n\t\t\tif (bc_moved)\n\t\t\t\thrtimer_start(&bctimer, expires,\n\t\t\t\t\t      HRTIMER_MODE_ABS_PINNED);});\n\tif (bc_moved) {\n\t\t/* Bind the \"device\" to the cpu */\n\t\tbc->bound_on = smp_processor_id();\n\t} else if (bc->bound_on == smp_processor_id()) {\n\t\thrtimer_set_expires(&bctimer, expires);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;",
      "static struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_set_expires",
          "args": [
            "&bctimer",
            "expires"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RCU_NONIDLE",
          "args": [
            "{\n\t\t\tbc_moved = hrtimer_try_to_cancel(&bctimer) >= 0;\n\t\t\tif (bc_moved)\n\t\t\t\thrtimer_start(&bctimer, expires,\n\t\t\t\t\t      HRTIMER_MODE_ABS_PINNED);}"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_start",
          "args": [
            "&bctimer",
            "expires",
            "HRTIMER_MODE_ABS_PINNED"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&bctimer"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\nstatic struct clock_event_device ce_broadcast_hrtimer = {\n\t.name\t\t\t= \"bc_hrtimer\",\n\t.set_state_shutdown\t= bc_shutdown,\n\t.set_next_ktime\t\t= bc_set_next,\n\t.features\t\t= CLOCK_EVT_FEAT_ONESHOT |\n\t\t\t\t  CLOCK_EVT_FEAT_KTIME |\n\t\t\t\t  CLOCK_EVT_FEAT_HRTIMER,\n\t.rating\t\t\t= 0,\n\t.bound_on\t\t= -1,\n\t.min_delta_ns\t\t= 1,\n\t.max_delta_ns\t\t= KTIME_MAX,\n\t.min_delta_ticks\t= 1,\n\t.max_delta_ticks\t= ULONG_MAX,\n\t.mult\t\t\t= 1,\n\t.shift\t\t\t= 0,\n\t.cpumask\t\t= cpu_possible_mask,\n};\n\nstatic int bc_set_next(ktime_t expires, struct clock_event_device *bc)\n{\n\tint bc_moved;\n\t/*\n\t * We try to cancel the timer first. If the callback is on\n\t * flight on some other cpu then we let it handle it. If we\n\t * were able to cancel the timer nothing can rearm it as we\n\t * own broadcast_lock.\n\t *\n\t * However we can also be called from the event handler of\n\t * ce_broadcast_hrtimer itself when it expires. We cannot\n\t * restart the timer because we are in the callback, but we\n\t * can set the expiry time and let the callback return\n\t * HRTIMER_RESTART.\n\t *\n\t * Since we are in the idle loop at this point and because\n\t * hrtimer_{start/cancel} functions call into tracing,\n\t * calls to these functions must be bound within RCU_NONIDLE.\n\t */\n\tRCU_NONIDLE({\n\t\t\tbc_moved = hrtimer_try_to_cancel(&bctimer) >= 0;\n\t\t\tif (bc_moved)\n\t\t\t\thrtimer_start(&bctimer, expires,\n\t\t\t\t\t      HRTIMER_MODE_ABS_PINNED);});\n\tif (bc_moved) {\n\t\t/* Bind the \"device\" to the cpu */\n\t\tbc->bound_on = smp_processor_id();\n\t} else if (bc->bound_on == smp_processor_id()) {\n\t\thrtimer_set_expires(&bctimer, expires);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bc_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-broadcast-hrtimer.c",
    "lines": "22-39",
    "snippet": "static int bc_shutdown(struct clock_event_device *evt)\n{\n\t/*\n\t * Note, we cannot cancel the timer here as we might\n\t * run into the following live lock scenario:\n\t *\n\t * cpu 0\t\tcpu1\n\t * lock(broadcast_lock);\n\t *\t\t\thrtimer_interrupt()\n\t *\t\t\tbc_handler()\n\t *\t\t\t   tick_handle_oneshot_broadcast();\n\t *\t\t\t    lock(broadcast_lock);\n\t * hrtimer_cancel()\n\t *  wait_for_callback()\n\t */\n\thrtimer_try_to_cancel(&bctimer);\n\treturn 0;\n}",
    "includes": [
      "#include \"tick-internal.h\"",
      "#include <linux/module.h>",
      "#include <linux/smp.h>",
      "#include <linux/sched.h>",
      "#include <linux/clockchips.h>",
      "#include <linux/profile.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/err.h>",
      "#include <linux/cpu.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct hrtimer bctimer;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hrtimer_try_to_cancel",
          "args": [
            "&bctimer"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "common_hrtimer_try_to_cancel",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "827-830",
          "snippet": "static int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic int common_hrtimer_try_to_cancel(struct k_itimer *timr)\n{\n\treturn hrtimer_try_to_cancel(&timr->it.real.timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"tick-internal.h\"\n#include <linux/module.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/clockchips.h>\n#include <linux/profile.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nstatic struct hrtimer bctimer;\n\nstatic int bc_shutdown(struct clock_event_device *evt)\n{\n\t/*\n\t * Note, we cannot cancel the timer here as we might\n\t * run into the following live lock scenario:\n\t *\n\t * cpu 0\t\tcpu1\n\t * lock(broadcast_lock);\n\t *\t\t\thrtimer_interrupt()\n\t *\t\t\tbc_handler()\n\t *\t\t\t   tick_handle_oneshot_broadcast();\n\t *\t\t\t    lock(broadcast_lock);\n\t * hrtimer_cancel()\n\t *  wait_for_callback()\n\t */\n\thrtimer_try_to_cancel(&bctimer);\n\treturn 0;\n}"
  }
]