[
  {
    "function_name": "irq_domain_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1747-1761",
    "snippet": "void __init irq_domain_debugfs_init(struct dentry *root)\n{\n\tstruct irq_domain *d;\n\n\tdomain_dir = debugfs_create_dir(\"domains\", root);\n\tif (!domain_dir)\n\t\treturn;\n\n\tdebugfs_create_file(\"default\", 0444, domain_dir, NULL,\n\t\t\t    &irq_domain_debug_fops);\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(d, &irq_domain_list, link)\n\t\tdebugfs_add_domain_dir(d);\n\tmutex_unlock(&irq_domain_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "d"
          ],
          "line": 1759
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1733-1739",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "d",
            "&irq_domain_list",
            "link"
          ],
          "line": 1758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1757
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"default\"",
            "0444",
            "domain_dir",
            "NULL",
            "&irq_domain_debug_fops"
          ],
          "line": 1755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_create_dir",
          "args": [
            "\"domains\"",
            "root"
          ],
          "line": 1751
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\n\nvoid __init irq_domain_debugfs_init(struct dentry *root)\n{\n\tstruct irq_domain *d;\n\n\tdomain_dir = debugfs_create_dir(\"domains\", root);\n\tif (!domain_dir)\n\t\treturn;\n\n\tdebugfs_create_file(\"default\", 0444, domain_dir, NULL,\n\t\t\t    &irq_domain_debug_fops);\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(d, &irq_domain_list, link)\n\t\tdebugfs_add_domain_dir(d);\n\tmutex_unlock(&irq_domain_mutex);\n}"
  },
  {
    "function_name": "debugfs_remove_domain_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1741-1745",
    "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_remove",
          "args": [
            "d->debugfs_file"
          ],
          "line": 1743
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1745",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}"
  },
  {
    "function_name": "debugfs_add_domain_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1733-1739",
    "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "d->name",
            "0444",
            "domain_dir",
            "d",
            "&irq_domain_debug_fops"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}"
  },
  {
    "function_name": "irq_domain_debug_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1718-1730",
    "snippet": "static int irq_domain_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_domain *d = m->private;\n\n\t/* Default domain? Might be NULL */\n\tif (!d) {\n\t\tif (!irq_default_domain)\n\t\t\treturn 0;\n\t\td = irq_default_domain;\n\t}\n\tirq_domain_debug_show_one(m, d, 0);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_debug_show_one",
          "args": [
            "m",
            "d",
            "0"
          ],
          "line": 1728
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_debug_show_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1700-1716",
          "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\",\n\t\t   d->revmap_size + d->revmap_direct_max_irq);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\",\n\t\t   d->revmap_size + d->revmap_direct_max_irq);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_debug_show(struct seq_file *m, void *p)\n{\n\tstruct irq_domain *d = m->private;\n\n\t/* Default domain? Might be NULL */\n\tif (!d) {\n\t\tif (!irq_default_domain)\n\t\t\treturn 0;\n\t\td = irq_default_domain;\n\t}\n\tirq_domain_debug_show_one(m, d, 0);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_debug_show_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1700-1716",
    "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\",\n\t\t   d->revmap_size + d->revmap_direct_max_irq);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_debug_show_one",
          "args": [
            "m",
            "d->parent",
            "ind + 4"
          ],
          "line": 1714
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_debug_show_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1700-1716",
          "snippet": "static void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\",\n\t\t   d->revmap_size + d->revmap_direct_max_irq);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"%*sparent: %s\\n\"",
            "ind + 1",
            "\"\"",
            "d->parent->name"
          ],
          "line": 1713
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "d->ops->debug_show",
          "args": [
            "m",
            "d",
            "NULL",
            "ind + 1"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void\nirq_domain_debug_show_one(struct seq_file *m, struct irq_domain *d, int ind)\n{\n\tseq_printf(m, \"%*sname:   %s\\n\", ind, \"\", d->name);\n\tseq_printf(m, \"%*ssize:   %u\\n\", ind + 1, \"\",\n\t\t   d->revmap_size + d->revmap_direct_max_irq);\n\tseq_printf(m, \"%*smapped: %u\\n\", ind + 1, \"\", d->mapcount);\n\tseq_printf(m, \"%*sflags:  0x%08x\\n\", ind +1 , \"\", d->flags);\n\tif (d->ops && d->ops->debug_show)\n\t\td->ops->debug_show(m, d, NULL, ind + 1);\n#ifdef\tCONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (!d->parent)\n\t\treturn;\n\tseq_printf(m, \"%*sparent: %s\\n\", ind + 1, \"\", d->parent->name);\n\tirq_domain_debug_show_one(m, d->parent, ind + 4);\n#endif\n}"
  },
  {
    "function_name": "irq_domain_check_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1692-1694",
    "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}"
  },
  {
    "function_name": "irq_domain_set_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1682-1690",
    "snippet": "void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_set_chip_and_handler_name(virq, chip, handler, handler_name);\n\tirq_set_chip_data(virq, chip_data);\n\tirq_set_handler_data(virq, handler_data);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_handler_data",
          "args": [
            "virq",
            "handler_data"
          ],
          "line": 1689
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_data",
          "args": [
            "virq",
            "chip_data"
          ],
          "line": 1688
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "145-155",
          "snippet": "int irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_chip_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_data.chip_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler_name",
          "args": [
            "virq",
            "chip",
            "handler",
            "handler_name"
          ],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_chip_and_handler_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "1013-1019",
          "snippet": "void\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\nirq_set_chip_and_handler_name(unsigned int irq, struct irq_chip *chip,\n\t\t\t      irq_flow_handler_t handle, const char *name)\n{\n\tirq_set_chip(irq, chip);\n\t__irq_set_handler(irq, handle, 0, name);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_set_chip_and_handler_name(virq, chip, handler, handler_name);\n\tirq_set_chip_data(virq, chip_data);\n\tirq_set_handler_data(virq, handler_data);\n}"
  },
  {
    "function_name": "irq_domain_get_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1662-1668",
    "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
  },
  {
    "function_name": "irq_domain_hierarchical_is_msi_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1648-1655",
    "snippet": "bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_is_msi_remap",
          "args": [
            "domain"
          ],
          "line": 1651
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nbool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "irq_domain_check_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1636-1641",
    "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t/* Hierarchy irq_domains must implement callback alloc() */\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n\t/* Hierarchy irq_domains must implement callback alloc() */\n\tif (domain->ops->alloc)\n\t\tdomain->flags |= IRQ_DOMAIN_FLAG_HIERARCHY;\n}"
  },
  {
    "function_name": "irq_domain_deactivate_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1628-1634",
    "snippet": "void irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irqd_is_activated(irq_data)) {\n\t\t__irq_domain_deactivate_irq(irq_data);\n\t\tirqd_clr_activated(irq_data);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_clr_activated",
          "args": [
            "irq_data"
          ],
          "line": 1632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irq_data"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1568-1578",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "irq_data"
          ],
          "line": 1630
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irqd_is_activated(irq_data)) {\n\t\t__irq_domain_deactivate_irq(irq_data);\n\t\tirqd_clr_activated(irq_data);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_activate_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1609-1618",
    "snippet": "int irq_domain_activate_irq(struct irq_data *irq_data, bool reserve)\n{\n\tint ret = 0;\n\n\tif (!irqd_is_activated(irq_data))\n\t\tret = __irq_domain_activate_irq(irq_data, reserve);\n\tif (!ret)\n\t\tirqd_set_activated(irq_data);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set_activated",
          "args": [
            "irq_data"
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_activate_irq",
          "args": [
            "irq_data",
            "reserve"
          ],
          "line": 1614
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_activate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1580-1598",
          "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irqd_is_activated",
          "args": [
            "irq_data"
          ],
          "line": 1613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_activate_irq(struct irq_data *irq_data, bool reserve)\n{\n\tint ret = 0;\n\n\tif (!irqd_is_activated(irq_data))\n\t\tret = __irq_domain_activate_irq(irq_data, reserve);\n\tif (!ret)\n\t\tirqd_set_activated(irq_data);\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_domain_activate_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1580-1598",
    "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irqd->parent_data"
          ],
          "line": 1594
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1568-1578",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "domain->ops->activate",
          "args": [
            "domain",
            "irqd",
            "reserve"
          ],
          "line": 1591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_activate_irq",
          "args": [
            "irqd->parent_data",
            "reserve"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_activate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1580-1598",
          "snippet": "static int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int __irq_domain_activate_irq(struct irq_data *irqd, bool reserve)\n{\n\tint ret = 0;\n\n\tif (irqd && irqd->domain) {\n\t\tstruct irq_domain *domain = irqd->domain;\n\n\t\tif (irqd->parent_data)\n\t\t\tret = __irq_domain_activate_irq(irqd->parent_data,\n\t\t\t\t\t\t\treserve);\n\t\tif (!ret && domain->ops->activate) {\n\t\t\tret = domain->ops->activate(domain, irqd, reserve);\n\t\t\t/* Rollback in case of error */\n\t\t\tif (ret && irqd->parent_data)\n\t\t\t\t__irq_domain_deactivate_irq(irqd->parent_data);\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__irq_domain_deactivate_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1568-1578",
    "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_domain_deactivate_irq",
          "args": [
            "irq_data->parent_data"
          ],
          "line": 1576
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_deactivate_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1568-1578",
          "snippet": "static void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "domain->ops->deactivate",
          "args": [
            "domain",
            "irq_data"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void __irq_domain_deactivate_irq(struct irq_data *irq_data)\n{\n\tif (irq_data && irq_data->domain) {\n\t\tstruct irq_domain *domain = irq_data->domain;\n\n\t\tif (domain->ops->deactivate)\n\t\t\tdomain->ops->deactivate(domain, irq_data);\n\t\tif (irq_data->parent_data)\n\t\t\t__irq_domain_deactivate_irq(irq_data->parent_data);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1558-1565",
    "snippet": "void irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "domain->parent",
            "irq_base",
            "nr_irqs"
          ],
          "line": 1564
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1245-1251",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_alloc_irqs_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1538-1547",
    "snippet": "int irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain->parent",
            "irq_base",
            "nr_irqs",
            "arg"
          ],
          "line": 1545
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1253-1258",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1510-1527",
    "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "677-690",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1525
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1085-1102",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "data->domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1522
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1245-1251",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_remove_irq",
          "args": [
            "virq + i"
          ],
          "line": 1521
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_remove_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1050-1066",
          "snippet": "static void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1519
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!data || !data->domain || !data->domain->ops->free",
            "\"NULL pointer, cannot free irq\\n\""
          ],
          "line": 1515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_pop_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1444-1502",
    "snippet": "int irq_domain_pop_irq(struct irq_domain *domain, int virq)\n{\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *tmp_irq_data;\n\tstruct irq_desc *desc;\n\n\t/*\n\t * Check that no action is set, which indicates the virq is in\n\t * a state where this function doesn't have to deal with races\n\t * between interrupt handling and maintaining the hierarchy.\n\t * This will catch gross misuse.  Attempting to make the check\n\t * race free would require holding locks across calls to\n\t * struct irq_domain_ops->free(), which could lead to\n\t * deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\ttmp_irq_data = irq_domain_get_irq_data(domain, virq);\n\n\t/* We can only \"pop\" if this domain is at the top of the list */\n\tif (WARN_ON(root_irq_data != tmp_irq_data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(root_irq_data->domain != domain))\n\t\treturn -EINVAL;\n\n\tchild_irq_data = root_irq_data->parent_data;\n\tif (WARN_ON(!child_irq_data))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\troot_irq_data->parent_data = NULL;\n\n\tirq_domain_clear_mapping(domain, root_irq_data->hwirq);\n\tirq_domain_free_irqs_hierarchy(domain, virq, 1);\n\n\t/* Restore the original irq_data. */\n\t*root_irq_data = *child_irq_data;\n\n\tirq_domain_fix_revmap(root_irq_data);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tkfree(child_irq_data);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "child_irq_data"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_fix_revmap",
          "args": [
            "root_irq_data"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_fix_revmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1337-1350",
          "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "1"
          ],
          "line": 1490
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1245-1251",
          "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "root_irq_data->hwirq"
          ],
          "line": 1489
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "461-471",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!child_irq_data"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_irq_data->domain != domain"
          ],
          "line": 1478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "root_irq_data != tmp_irq_data"
          ],
          "line": 1475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1662-1668",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->action"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 1460
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_pop_irq(struct irq_domain *domain, int virq)\n{\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *tmp_irq_data;\n\tstruct irq_desc *desc;\n\n\t/*\n\t * Check that no action is set, which indicates the virq is in\n\t * a state where this function doesn't have to deal with races\n\t * between interrupt handling and maintaining the hierarchy.\n\t * This will catch gross misuse.  Attempting to make the check\n\t * race free would require holding locks across calls to\n\t * struct irq_domain_ops->free(), which could lead to\n\t * deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\ttmp_irq_data = irq_domain_get_irq_data(domain, virq);\n\n\t/* We can only \"pop\" if this domain is at the top of the list */\n\tif (WARN_ON(root_irq_data != tmp_irq_data))\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(root_irq_data->domain != domain))\n\t\treturn -EINVAL;\n\n\tchild_irq_data = root_irq_data->parent_data;\n\tif (WARN_ON(!child_irq_data))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\troot_irq_data->parent_data = NULL;\n\n\tirq_domain_clear_mapping(domain, root_irq_data->hwirq);\n\tirq_domain_free_irqs_hierarchy(domain, virq, 1);\n\n\t/* Restore the original irq_data. */\n\t*root_irq_data = *child_irq_data;\n\n\tirq_domain_fix_revmap(root_irq_data);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tkfree(child_irq_data);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_push_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1363-1433",
    "snippet": "int irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg)\n{\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_desc *desc;\n\tint rv = 0;\n\n\t/*\n\t * Check that no action has been set, which indicates the virq\n\t * is in a state where this function doesn't have to deal with\n\t * races between interrupt handling and maintaining the\n\t * hierarchy.  This will catch gross misuse.  Attempting to\n\t * make the check race free would require holding locks across\n\t * calls to struct irq_domain_ops->alloc(), which could lead\n\t * to deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!irq_domain_is_hierarchy(domain)))\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\tif (domain->parent != root_irq_data->domain)\n\t\treturn -EINVAL;\n\n\tchild_irq_data = kzalloc_node(sizeof(*child_irq_data), GFP_KERNEL,\n\t\t\t\t      irq_data_get_node(root_irq_data));\n\tif (!child_irq_data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\t/* Copy the original irq_data. */\n\t*child_irq_data = *root_irq_data;\n\n\t/*\n\t * Overwrite the root_irq_data, which is embedded in struct\n\t * irq_desc, with values for this domain.\n\t */\n\troot_irq_data->parent_data = child_irq_data;\n\troot_irq_data->domain = domain;\n\troot_irq_data->mask = 0;\n\troot_irq_data->hwirq = 0;\n\troot_irq_data->chip = NULL;\n\troot_irq_data->chip_data = NULL;\n\n\t/* May (probably does) set hwirq, chip, etc. */\n\trv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\tif (rv) {\n\t\t/* Restore the original irq_data. */\n\t\t*root_irq_data = *child_irq_data;\n\t\tgoto error;\n\t}\n\n\tirq_domain_fix_revmap(child_irq_data);\n\tirq_domain_set_mapping(domain, root_irq_data->hwirq, root_irq_data);\n\nerror:\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn rv;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1430
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "root_irq_data->hwirq",
            "root_irq_data"
          ],
          "line": 1427
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "473-484",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_fix_revmap",
          "args": [
            "child_irq_data"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_fix_revmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1337-1350",
          "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "1",
            "arg"
          ],
          "line": 1419
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1253-1258",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1402
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*child_irq_data)",
            "GFP_KERNEL",
            "irq_data_get_node(root_irq_data)"
          ],
          "line": 1397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_node",
          "args": [
            "root_irq_data"
          ],
          "line": 1398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!irq_domain_is_hierarchy(domain)"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "desc->action"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "virq"
          ],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1366
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_push_irq(struct irq_domain *domain, int virq, void *arg)\n{\n\tstruct irq_data *child_irq_data;\n\tstruct irq_data *root_irq_data = irq_get_irq_data(virq);\n\tstruct irq_desc *desc;\n\tint rv = 0;\n\n\t/*\n\t * Check that no action has been set, which indicates the virq\n\t * is in a state where this function doesn't have to deal with\n\t * races between interrupt handling and maintaining the\n\t * hierarchy.  This will catch gross misuse.  Attempting to\n\t * make the check race free would require holding locks across\n\t * calls to struct irq_domain_ops->alloc(), which could lead\n\t * to deadlock, so we just do a simple check before starting.\n\t */\n\tdesc = irq_to_desc(virq);\n\tif (!desc)\n\t\treturn -EINVAL;\n\tif (WARN_ON(desc->action))\n\t\treturn -EBUSY;\n\n\tif (domain == NULL)\n\t\treturn -EINVAL;\n\n\tif (WARN_ON(!irq_domain_is_hierarchy(domain)))\n\t\treturn -EINVAL;\n\n\tif (!root_irq_data)\n\t\treturn -EINVAL;\n\n\tif (domain->parent != root_irq_data->domain)\n\t\treturn -EINVAL;\n\n\tchild_irq_data = kzalloc_node(sizeof(*child_irq_data), GFP_KERNEL,\n\t\t\t\t      irq_data_get_node(root_irq_data));\n\tif (!child_irq_data)\n\t\treturn -ENOMEM;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\t/* Copy the original irq_data. */\n\t*child_irq_data = *root_irq_data;\n\n\t/*\n\t * Overwrite the root_irq_data, which is embedded in struct\n\t * irq_desc, with values for this domain.\n\t */\n\troot_irq_data->parent_data = child_irq_data;\n\troot_irq_data->domain = domain;\n\troot_irq_data->mask = 0;\n\troot_irq_data->hwirq = 0;\n\troot_irq_data->chip = NULL;\n\troot_irq_data->chip_data = NULL;\n\n\t/* May (probably does) set hwirq, chip, etc. */\n\trv = irq_domain_alloc_irqs_hierarchy(domain, virq, 1, arg);\n\tif (rv) {\n\t\t/* Restore the original irq_data. */\n\t\t*root_irq_data = *child_irq_data;\n\t\tgoto error;\n\t}\n\n\tirq_domain_fix_revmap(child_irq_data);\n\tirq_domain_set_mapping(domain, root_irq_data->hwirq, root_irq_data);\n\nerror:\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn rv;\n}"
  },
  {
    "function_name": "irq_domain_fix_revmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1337-1350",
    "snippet": "static void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&d->domain->revmap_tree_mutex"
          ],
          "line": 1349
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_replace_slot",
          "args": [
            "&d->domain->revmap_tree",
            "slot",
            "d"
          ],
          "line": 1348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup_slot",
          "args": [
            "&d->domain->revmap_tree",
            "d->hwirq"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&d->domain->revmap_tree_mutex"
          ],
          "line": 1345
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_fix_revmap(struct irq_data *d)\n{\n\tvoid __rcu **slot;\n\n\tif (d->hwirq < d->domain->revmap_size)\n\t\treturn; /* Not using radix tree. */\n\n\t/* Fix up the revmap. */\n\tmutex_lock(&d->domain->revmap_tree_mutex);\n\tslot = radix_tree_lookup_slot(&d->domain->revmap_tree, d->hwirq);\n\tif (slot)\n\t\tradix_tree_replace_slot(&d->domain->revmap_tree, slot, d);\n\tmutex_unlock(&d->domain->revmap_tree_mutex);\n}"
  },
  {
    "function_name": "__irq_domain_alloc_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1282-1334",
    "snippet": "int __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_descs",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1332
        },
        "resolved": true,
        "details": {
          "function_name": "irq_free_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "677-690",
          "snippet": "void irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\n\nvoid irq_free_descs(unsigned int from, unsigned int cnt)\n{\n\tint i;\n\n\tif (from >= nr_irqs || (from + cnt) > nr_irqs)\n\t\treturn;\n\n\tmutex_lock(&sparse_irq_lock);\n\tfor (i = 0; i < cnt; i++)\n\t\tfree_desc(from + i);\n\n\tbitmap_clear(allocated_irqs, from, cnt);\n\tmutex_unlock(&sparse_irq_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "nr_irqs"
          ],
          "line": 1330
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1085-1102",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_insert_irq",
          "args": [
            "virq + i"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_insert_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1032-1048",
          "snippet": "static void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs_hierarchy",
          "args": [
            "domain",
            "virq",
            "nr_irqs",
            "arg"
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1253-1258",
          "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 1317
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"cannot allocate memory for IRQ%d\\n\"",
            "virq"
          ],
          "line": 1312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irq_data",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1104-1126",
          "snippet": "static int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"cannot allocate IRQ(base %d, count %d)\\n\"",
            "irq_base",
            "nr_irqs"
          ],
          "line": 1305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_descs",
          "args": [
            "irq_base",
            "nr_irqs",
            "0",
            "node",
            "affinity"
          ],
          "line": 1302
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "971-992",
          "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"domain->ops->alloc() is NULL\\n\""
          ],
          "line": 1295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!domain",
            "\"domain is NULL; cannot allocate IRQ\\n\""
          ],
          "line": 1290
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint __irq_domain_alloc_irqs(struct irq_domain *domain, int irq_base,\n\t\t\t    unsigned int nr_irqs, int node, void *arg,\n\t\t\t    bool realloc, const struct cpumask *affinity)\n{\n\tint i, ret, virq;\n\n\tif (domain == NULL) {\n\t\tdomain = irq_default_domain;\n\t\tif (WARN(!domain, \"domain is NULL; cannot allocate IRQ\\n\"))\n\t\t\treturn -EINVAL;\n\t}\n\n\tif (!domain->ops->alloc) {\n\t\tpr_debug(\"domain->ops->alloc() is NULL\\n\");\n\t\treturn -ENOSYS;\n\t}\n\n\tif (realloc && irq_base >= 0) {\n\t\tvirq = irq_base;\n\t} else {\n\t\tvirq = irq_domain_alloc_descs(irq_base, nr_irqs, 0, node,\n\t\t\t\t\t      affinity);\n\t\tif (virq < 0) {\n\t\t\tpr_debug(\"cannot allocate IRQ(base %d, count %d)\\n\",\n\t\t\t\t irq_base, nr_irqs);\n\t\t\treturn virq;\n\t\t}\n\t}\n\n\tif (irq_domain_alloc_irq_data(domain, virq, nr_irqs)) {\n\t\tpr_debug(\"cannot allocate memory for IRQ%d\\n\", virq);\n\t\tret = -ENOMEM;\n\t\tgoto out_free_desc;\n\t}\n\n\tmutex_lock(&irq_domain_mutex);\n\tret = irq_domain_alloc_irqs_hierarchy(domain, virq, nr_irqs, arg);\n\tif (ret < 0) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\tgoto out_free_irq_data;\n\t}\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_insert_irq(virq + i);\n\tmutex_unlock(&irq_domain_mutex);\n\n\treturn virq;\n\nout_free_irq_data:\n\tirq_domain_free_irq_data(virq, nr_irqs);\nout_free_desc:\n\tirq_free_descs(virq, nr_irqs);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_domain_alloc_irqs_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1253-1258",
    "snippet": "int irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain->ops->alloc",
          "args": [
            "domain",
            "irq_base",
            "nr_irqs",
            "arg"
          ],
          "line": 1257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t    unsigned int irq_base,\n\t\t\t\t    unsigned int nr_irqs, void *arg)\n{\n\treturn domain->ops->alloc(domain, irq_base, nr_irqs, arg);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1245-1251",
    "snippet": "static void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "domain->ops->free",
          "args": [
            "domain",
            "irq_base",
            "nr_irqs"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irqs_hierarchy(struct irq_domain *domain,\n\t\t\t\t\t   unsigned int irq_base,\n\t\t\t\t\t   unsigned int nr_irqs)\n{\n\tif (domain->ops->free)\n\t\tdomain->ops->free(domain, irq_base, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_top",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1233-1243",
    "snippet": "void irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_common",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1212-1224",
          "snippet": "void irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_handler",
          "args": [
            "virq + i",
            "NULL"
          ],
          "line": 1240
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_top(struct irq_domain *domain, unsigned int virq,\n\t\t\t      unsigned int nr_irqs)\n{\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_set_handler_data(virq + i, NULL);\n\t\tirq_set_handler(virq + i, NULL);\n\t}\n\tirq_domain_free_irqs_common(domain, virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_free_irqs_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1212-1224",
    "snippet": "void irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irqs_parent",
          "args": [
            "domain",
            "virq",
            "nr_irqs"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1558-1565",
          "snippet": "void irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs)\n{\n\tif (!domain->parent)\n\t\treturn;\n\n\tirq_domain_free_irqs_hierarchy(domain->parent, irq_base, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_reset_irq_data",
          "args": [
            "irq_data"
          ],
          "line": 1221
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_reset_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1198-1203",
          "snippet": "void irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq + i"
          ],
          "line": 1219
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1662-1668",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs_common(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_domain_get_irq_data(domain, virq + i);\n\t\tif (irq_data)\n\t\t\tirq_domain_reset_irq_data(irq_data);\n\t}\n\tirq_domain_free_irqs_parent(domain, virq, nr_irqs);\n}"
  },
  {
    "function_name": "irq_domain_reset_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1198-1203",
    "snippet": "void irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_reset_irq_data(struct irq_data *irq_data)\n{\n\tirq_data->hwirq = 0;\n\tirq_data->chip = &no_irq_chip;\n\tirq_data->chip_data = NULL;\n}"
  },
  {
    "function_name": "irq_domain_set_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1183-1191",
    "snippet": "void irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_set_handler_data",
          "args": [
            "virq",
            "handler_data"
          ],
          "line": 1190
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_handler_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "90-100",
          "snippet": "int irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nint irq_set_handler_data(unsigned int irq, void *data)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_lock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn -EINVAL;\n\tdesc->irq_common_data.handler_data = data;\n\tirq_put_desc_unlock(desc, flags);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_set_handler",
          "args": [
            "virq",
            "handler",
            "0",
            "handler_name"
          ],
          "line": 1189
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_set_handler",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "981-993",
          "snippet": "void\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nvoid\n__irq_set_handler(unsigned int irq, irq_flow_handler_t handle, int is_chained,\n\t\t  const char *name)\n{\n\tunsigned long flags;\n\tstruct irq_desc *desc = irq_get_desc_buslock(irq, &flags, 0);\n\n\tif (!desc)\n\t\treturn;\n\n\t__irq_do_set_handler(desc, handle, is_chained, name);\n\tirq_put_desc_busunlock(desc, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_hwirq_and_chip",
          "args": [
            "domain",
            "virq",
            "hwirq",
            "chip",
            "chip_data"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_hwirq_and_chip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1155-1169",
          "snippet": "int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_set_info(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t void *chip_data, irq_flow_handler_t handler,\n\t\t\t void *handler_data, const char *handler_name)\n{\n\tirq_domain_set_hwirq_and_chip(domain, virq, hwirq, chip, chip_data);\n\t__irq_set_handler(virq, handler, 0, handler_name);\n\tirq_set_handler_data(virq, handler_data);\n}"
  },
  {
    "function_name": "irq_domain_set_hwirq_and_chip",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1155-1169",
    "snippet": "int irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "virq"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1662-1668",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_set_hwirq_and_chip(struct irq_domain *domain, unsigned int virq,\n\t\t\t\t  irq_hw_number_t hwirq, struct irq_chip *chip,\n\t\t\t\t  void *chip_data)\n{\n\tstruct irq_data *irq_data = irq_domain_get_irq_data(domain, virq);\n\n\tif (!irq_data)\n\t\treturn -ENOENT;\n\n\tirq_data->hwirq = hwirq;\n\tirq_data->chip = chip ? chip : &no_irq_chip;\n\tirq_data->chip_data = chip_data;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_get_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1133-1144",
    "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data;\n\n\tfor (irq_data = irq_get_irq_data(virq); irq_data;\n\t     irq_data = irq_data->parent_data)\n\t\tif (irq_data->domain == domain)\n\t\t\treturn irq_data;\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "irq_domain_alloc_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1104-1126",
    "snippet": "static int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_free_irq_data",
          "args": [
            "virq",
            "i + 1"
          ],
          "line": 1119
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1085-1102",
          "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_insert_irq_data",
          "args": [
            "parent",
            "irq_data"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_insert_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1068-1083",
          "snippet": "static struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq + i"
          ],
          "line": 1113
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_alloc_irq_data(struct irq_domain *domain,\n\t\t\t\t     unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data;\n\tstruct irq_domain *parent;\n\tint i;\n\n\t/* The outermost irq_data is embedded in struct irq_desc */\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\tirq_data->domain = domain;\n\n\t\tfor (parent = domain->parent; parent; parent = parent->parent) {\n\t\t\tirq_data = irq_domain_insert_irq_data(parent, irq_data);\n\t\t\tif (!irq_data) {\n\t\t\t\tirq_domain_free_irq_data(virq, i + 1);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_free_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1085-1102",
    "snippet": "static void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "irq_data"
          ],
          "line": 1099
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq + i"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_free_irq_data(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *irq_data, *tmp;\n\tint i;\n\n\tfor (i = 0; i < nr_irqs; i++) {\n\t\tirq_data = irq_get_irq_data(virq + i);\n\t\ttmp = irq_data->parent_data;\n\t\tirq_data->parent_data = NULL;\n\t\tirq_data->domain = NULL;\n\n\t\twhile (tmp) {\n\t\t\tirq_data = tmp;\n\t\t\ttmp = tmp->parent_data;\n\t\t\tkfree(irq_data);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "irq_domain_insert_irq_data",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1068-1083",
    "snippet": "static struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*irq_data)",
            "GFP_KERNEL",
            "irq_data_get_node(child)"
          ],
          "line": 1073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_data_get_node",
          "args": [
            "child"
          ],
          "line": 1074
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic struct irq_data *irq_domain_insert_irq_data(struct irq_domain *domain,\n\t\t\t\t\t\t   struct irq_data *child)\n{\n\tstruct irq_data *irq_data;\n\n\tirq_data = kzalloc_node(sizeof(*irq_data), GFP_KERNEL,\n\t\t\t\tirq_data_get_node(child));\n\tif (irq_data) {\n\t\tchild->parent_data = irq_data;\n\t\tirq_data->irq = child->irq;\n\t\tirq_data->common = child->common;\n\t\tirq_data->domain = domain;\n\t}\n\n\treturn irq_data;\n}"
  },
  {
    "function_name": "irq_domain_remove_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1050-1066",
    "snippet": "static void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 1064
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "461-471",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "virq"
          ],
          "line": 1056
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "100-114",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler",
          "args": [
            "virq",
            "NULL",
            "NULL"
          ],
          "line": 1055
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_remove_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tirq_set_status_flags(virq, IRQ_NOREQUEST);\n\tirq_set_chip_and_handler(virq, NULL, NULL);\n\tsynchronize_irq(virq);\n\tsmp_mb();\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\t\tirq_hw_number_t hwirq = data->hwirq;\n\n\t\tdomain->mapcount--;\n\t\tirq_domain_clear_mapping(domain, hwirq);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_insert_irq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1032-1048",
    "snippet": "static void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_clear_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 1047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "data->hwirq",
            "data"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "473-484",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 1036
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_insert_irq(int virq)\n{\n\tstruct irq_data *data;\n\n\tfor (data = irq_get_irq_data(virq); data; data = data->parent_data) {\n\t\tstruct irq_domain *domain = data->domain;\n\n\t\tdomain->mapcount++;\n\t\tirq_domain_set_mapping(domain, data->hwirq, data);\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && data->chip)\n\t\t\tdomain->name = data->chip->name;\n\t}\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n}"
  },
  {
    "function_name": "irq_domain_create_hierarchy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "1010-1029",
    "snippet": "struct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_create_tree",
          "args": [
            "fwnode",
            "ops",
            "host_data"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_create_linear",
          "args": [
            "fwnode",
            "size",
            "ops",
            "host_data"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_create_hierarchy(struct irq_domain *parent,\n\t\t\t\t\t    unsigned int flags,\n\t\t\t\t\t    unsigned int size,\n\t\t\t\t\t    struct fwnode_handle *fwnode,\n\t\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t\t    void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tif (size)\n\t\tdomain = irq_domain_create_linear(fwnode, size, ops, host_data);\n\telse\n\t\tdomain = irq_domain_create_tree(fwnode, ops, host_data);\n\tif (domain) {\n\t\tdomain->parent = parent;\n\t\tdomain->flags |= flags;\n\t}\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_alloc_descs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "971-992",
    "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__irq_alloc_descs",
          "args": [
            "-1",
            "1",
            "cnt",
            "node",
            "THIS_MODULE",
            "affinity"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_alloc_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "706-745",
          "snippet": "int __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct cpumask *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int nr_irqs = NR_IRQS;",
            "static DEFINE_MUTEX(sparse_irq_lock);",
            "static DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nint nr_irqs = NR_IRQS;\nstatic DEFINE_MUTEX(sparse_irq_lock);\nstatic DECLARE_BITMAP(allocated_irqs, IRQ_BITMAP_BITS);\n\nint __ref\n__irq_alloc_descs(int irq, unsigned int from, unsigned int cnt, int node,\n\t\t  struct module *owner, const struct cpumask *affinity)\n{\n\tint start, ret;\n\n\tif (!cnt)\n\t\treturn -EINVAL;\n\n\tif (irq >= 0) {\n\t\tif (from > irq)\n\t\t\treturn -EINVAL;\n\t\tfrom = irq;\n\t} else {\n\t\t/*\n\t\t * For interrupts which are freely allocated the\n\t\t * architecture can force a lower bound to the @from\n\t\t * argument. x86 uses this to exclude the GSI space.\n\t\t */\n\t\tfrom = arch_dynirq_lower_bound(from);\n\t}\n\n\tmutex_lock(&sparse_irq_lock);\n\n\tstart = bitmap_find_next_zero_area(allocated_irqs, IRQ_BITMAP_BITS,\n\t\t\t\t\t   from, cnt, 0);\n\tret = -EEXIST;\n\tif (irq >=0 && start != irq)\n\t\tgoto unlock;\n\n\tif (start + cnt > nr_irqs) {\n\t\tret = irq_expand_nr_irqs(start + cnt);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\tret = alloc_descs(start, cnt, node, affinity, owner);\nunlock:\n\tmutex_unlock(&sparse_irq_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_domain_xlate_onetwocell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "950-963",
    "snippet": "int irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "intsize < 1"
          ],
          "line": 955
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_onetwocell(struct irq_domain *d,\n\t\t\t\tstruct device_node *ctrlr,\n\t\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\t\tunsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\tif (intsize > 1)\n\t\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\telse\n\t\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_xlate_twocell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "927-936",
    "snippet": "int irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "intsize < 2"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_twocell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\tconst u32 *intspec, unsigned int intsize,\n\t\t\tirq_hw_number_t *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 2))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = intspec[1] & IRQ_TYPE_SENSE_MASK;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_xlate_onecell",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "908-917",
    "snippet": "int irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "intsize < 1"
          ],
          "line": 912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_xlate_onecell(struct irq_domain *d, struct device_node *ctrlr,\n\t\t\t     const u32 *intspec, unsigned int intsize,\n\t\t\t     unsigned long *out_hwirq, unsigned int *out_type)\n{\n\tif (WARN_ON(intsize < 1))\n\t\treturn -EINVAL;\n\t*out_hwirq = intspec[0];\n\t*out_type = IRQ_TYPE_NONE;\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_find_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "874-899",
    "snippet": "unsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 897
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_lookup",
          "args": [
            "&domain->revmap_tree",
            "hwirq"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 895
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_get_irq_data",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 886
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1662-1668",
          "snippet": "struct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_data *irq_domain_get_irq_data(struct irq_domain *domain,\n\t\t\t\t\t unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\n\treturn (irq_data && irq_data->domain == domain) ? irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}"
  },
  {
    "function_name": "irq_dispose_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "848-866",
    "snippet": "void irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 864
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_disassociate",
          "args": [
            "domain",
            "virq"
          ],
          "line": 863
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_disassociate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "486-515",
          "snippet": "void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "virq",
            "1"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1510-1527",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "domain == NULL"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 850
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}"
  },
  {
    "function_name": "irq_create_of_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "835-841",
    "snippet": "unsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(irq_data, &fwspec);\n\treturn irq_create_fwspec_mapping(&fwspec);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_create_fwspec_mapping",
          "args": [
            "&fwspec"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "irq_create_fwspec_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "744-832",
          "snippet": "unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_phandle_args_to_fwspec",
          "args": [
            "irq_data",
            "&fwspec"
          ],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "of_phandle_args_to_fwspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "732-742",
          "snippet": "static void of_phandle_args_to_fwspec(struct of_phandle_args *irq_data,\n\t\t\t\t      struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = irq_data->np ? &irq_data->np->fwnode : NULL;\n\tfwspec->param_count = irq_data->args_count;\n\n\tfor (i = 0; i < irq_data->args_count; i++)\n\t\tfwspec->param[i] = irq_data->args[i];\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void of_phandle_args_to_fwspec(struct of_phandle_args *irq_data,\n\t\t\t\t      struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = irq_data->np ? &irq_data->np->fwnode : NULL;\n\tfwspec->param_count = irq_data->args_count;\n\n\tfor (i = 0; i < irq_data->args_count; i++)\n\t\tfwspec->param[i] = irq_data->args[i];\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nunsigned int irq_create_of_mapping(struct of_phandle_args *irq_data)\n{\n\tstruct irq_fwspec fwspec;\n\n\tof_phandle_args_to_fwspec(irq_data, &fwspec);\n\treturn irq_create_fwspec_mapping(&fwspec);\n}"
  },
  {
    "function_name": "irq_create_fwspec_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "744-832",
    "snippet": "unsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "irq_data",
            "type"
          ],
          "line": 829
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_dispose_mapping",
          "args": [
            "virq"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "irq_dispose_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "848-866",
          "snippet": "void irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_dispose_mapping(unsigned int virq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tstruct irq_domain *domain;\n\n\tif (!virq || !irq_data)\n\t\treturn;\n\n\tdomain = irq_data->domain;\n\tif (WARN_ON(domain == NULL))\n\t\treturn;\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tirq_domain_free_irqs(virq, 1);\n\t} else {\n\t\tirq_domain_disassociate(domain, virq);\n\t\tirq_free_desc(virq);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_free_irqs",
          "args": [
            "virq",
            "1"
          ],
          "line": 822
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_free_irqs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1510-1527",
          "snippet": "void irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_free_irqs(unsigned int virq, unsigned int nr_irqs)\n{\n\tstruct irq_data *data = irq_get_irq_data(virq);\n\tint i;\n\n\tif (WARN(!data || !data->domain || !data->domain->ops->free,\n\t\t \"NULL pointer, cannot free irq\\n\"))\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\tfor (i = 0; i < nr_irqs; i++)\n\t\tirq_domain_remove_irq(virq + i);\n\tirq_domain_free_irqs_hierarchy(data->domain, virq, nr_irqs);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_domain_free_irq_data(virq, nr_irqs);\n\tirq_free_descs(virq, nr_irqs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 819
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_create_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 814
        },
        "resolved": true,
        "details": {
          "function_name": "irq_create_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "634-676",
          "snippet": "unsigned int irq_create_mapping(struct irq_domain *domain,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_mapping(struct irq_domain *domain,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_irqs",
          "args": [
            "domain",
            "1",
            "NUMA_NO_NODE",
            "fwspec"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_irqs_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1538-1547",
          "snippet": "int irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_alloc_irqs_parent(struct irq_domain *domain,\n\t\t\t\t unsigned int irq_base, unsigned int nr_irqs,\n\t\t\t\t void *arg)\n{\n\tif (!domain->parent)\n\t\treturn -ENOSYS;\n\n\treturn irq_domain_alloc_irqs_hierarchy(domain->parent, irq_base,\n\t\t\t\t\t       nr_irqs, arg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_hierarchy",
          "args": [
            "domain"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"type mismatch, failed to map hwirq-%lu for %s!\\n\"",
            "hwirq",
            "of_node_full_name(to_of_node(fwspec->fwnode))"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "to_of_node(fwspec->fwnode)"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irqd_set_trigger_type",
          "args": [
            "irq_data",
            "type"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_trigger_type",
          "args": [
            "virq"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_trigger_type",
          "args": [
            "virq"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "irq_find_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "874-899",
          "snippet": "unsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "type & ~IRQ_TYPE_SENSE_MASK"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_translate",
          "args": [
            "domain",
            "fwspec",
            "&hwirq",
            "&type"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_translate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "714-730",
          "snippet": "static int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"no irq domain found for %s !\\n\"",
            "of_node_full_name(to_of_node(fwspec->fwnode))"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "to_of_node(fwspec->fwnode)"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_matching_fwspec",
          "args": [
            "fwspec",
            "DOMAIN_BUS_ANY"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "irq_find_matching_fwspec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "382-416",
          "snippet": "struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_fwspec_mapping(struct irq_fwspec *fwspec)\n{\n\tstruct irq_domain *domain;\n\tstruct irq_data *irq_data;\n\tirq_hw_number_t hwirq;\n\tunsigned int type = IRQ_TYPE_NONE;\n\tint virq;\n\n\tif (fwspec->fwnode) {\n\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_WIRED);\n\t\tif (!domain)\n\t\t\tdomain = irq_find_matching_fwspec(fwspec, DOMAIN_BUS_ANY);\n\t} else {\n\t\tdomain = irq_default_domain;\n\t}\n\n\tif (!domain) {\n\t\tpr_warn(\"no irq domain found for %s !\\n\",\n\t\t\tof_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_translate(domain, fwspec, &hwirq, &type))\n\t\treturn 0;\n\n\t/*\n\t * WARN if the irqchip returns a type with bits\n\t * outside the sense mask set and clear these bits.\n\t */\n\tif (WARN_ON(type & ~IRQ_TYPE_SENSE_MASK))\n\t\ttype &= IRQ_TYPE_SENSE_MASK;\n\n\t/*\n\t * If we've already configured this interrupt,\n\t * don't do it again, or hell will break loose.\n\t */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\t/*\n\t\t * If the trigger type is not specified or matches the\n\t\t * current trigger type then we are done so return the\n\t\t * interrupt number.\n\t\t */\n\t\tif (type == IRQ_TYPE_NONE || type == irq_get_trigger_type(virq))\n\t\t\treturn virq;\n\n\t\t/*\n\t\t * If the trigger type has not been set yet, then set\n\t\t * it now and return the interrupt number.\n\t\t */\n\t\tif (irq_get_trigger_type(virq) == IRQ_TYPE_NONE) {\n\t\t\tirq_data = irq_get_irq_data(virq);\n\t\t\tif (!irq_data)\n\t\t\t\treturn 0;\n\n\t\t\tirqd_set_trigger_type(irq_data, type);\n\t\t\treturn virq;\n\t\t}\n\n\t\tpr_warn(\"type mismatch, failed to map hwirq-%lu for %s!\\n\",\n\t\t\thwirq, of_node_full_name(to_of_node(fwspec->fwnode)));\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_is_hierarchy(domain)) {\n\t\tvirq = irq_domain_alloc_irqs(domain, 1, NUMA_NO_NODE, fwspec);\n\t\tif (virq <= 0)\n\t\t\treturn 0;\n\t} else {\n\t\t/* Create mapping */\n\t\tvirq = irq_create_mapping(domain, hwirq);\n\t\tif (!virq)\n\t\t\treturn virq;\n\t}\n\n\tirq_data = irq_get_irq_data(virq);\n\tif (!irq_data) {\n\t\tif (irq_domain_is_hierarchy(domain))\n\t\t\tirq_domain_free_irqs(virq, 1);\n\t\telse\n\t\t\tirq_dispose_mapping(virq);\n\t\treturn 0;\n\t}\n\n\t/* Store trigger type */\n\tirqd_set_trigger_type(irq_data, type);\n\n\treturn virq;\n}"
  },
  {
    "function_name": "of_phandle_args_to_fwspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "732-742",
    "snippet": "static void of_phandle_args_to_fwspec(struct of_phandle_args *irq_data,\n\t\t\t\t      struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = irq_data->np ? &irq_data->np->fwnode : NULL;\n\tfwspec->param_count = irq_data->args_count;\n\n\tfor (i = 0; i < irq_data->args_count; i++)\n\t\tfwspec->param[i] = irq_data->args[i];\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void of_phandle_args_to_fwspec(struct of_phandle_args *irq_data,\n\t\t\t\t      struct irq_fwspec *fwspec)\n{\n\tint i;\n\n\tfwspec->fwnode = irq_data->np ? &irq_data->np->fwnode : NULL;\n\tfwspec->param_count = irq_data->args_count;\n\n\tfor (i = 0; i < irq_data->args_count; i++)\n\t\tfwspec->param[i] = irq_data->args[i];\n}"
  },
  {
    "function_name": "irq_domain_translate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "714-730",
    "snippet": "static int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "d->ops->xlate",
          "args": [
            "d",
            "to_of_node(fwspec->fwnode)",
            "fwspec->param",
            "fwspec->param_count",
            "hwirq",
            "type"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwspec->fwnode"
          ],
          "line": 723
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d->ops->translate",
          "args": [
            "d",
            "fwspec",
            "hwirq",
            "type"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic int irq_domain_translate(struct irq_domain *d,\n\t\t\t\tstruct irq_fwspec *fwspec,\n\t\t\t\tirq_hw_number_t *hwirq, unsigned int *type)\n{\n#ifdef CONFIG_IRQ_DOMAIN_HIERARCHY\n\tif (d->ops->translate)\n\t\treturn d->ops->translate(d, fwspec, hwirq, type);\n#endif\n\tif (d->ops->xlate)\n\t\treturn d->ops->xlate(d, to_of_node(fwspec->fwnode),\n\t\t\t\t     fwspec->param, fwspec->param_count,\n\t\t\t\t     hwirq, type);\n\n\t/* If domain has no translation, then we assume interrupt line */\n\t*hwirq = fwspec->param[0];\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_create_strict_mappings",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "697-711",
    "snippet": "int irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint ret;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tret = irq_alloc_descs(irq_base, irq_base, count,\n\t\t\t      of_node_to_nid(of_node));\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tirq_domain_associate_many(domain, irq_base, hwirq_base, count);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate_many",
          "args": [
            "domain",
            "irq_base",
            "hwirq_base",
            "count"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "567-580",
          "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ret < 0"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_alloc_descs",
          "args": [
            "irq_base",
            "irq_base",
            "count",
            "of_node_to_nid(of_node)"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 705
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_create_strict_mappings(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint ret;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tret = irq_alloc_descs(irq_base, irq_base, count,\n\t\t\t      of_node_to_nid(of_node));\n\tif (unlikely(ret < 0))\n\t\treturn ret;\n\n\tirq_domain_associate_many(domain, irq_base, hwirq_base, count);\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_create_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "634-676",
    "snippet": "unsigned int irq_create_mapping(struct irq_domain *domain,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"irq %lu on domain %s mapped to virtual irq %u\\n\"",
            "hwirq",
            "of_node_full_name(of_node)",
            "virq"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "of_node"
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "virq",
            "hwirq"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "517-564",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> virq allocation failed\\n\""
          ],
          "line": 663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_alloc_descs",
          "args": [
            "-1",
            "1",
            "hwirq",
            "of_node_to_nid(of_node)",
            "NULL"
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_alloc_descs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "971-992",
          "snippet": "int irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nint irq_domain_alloc_descs(int virq, unsigned int cnt, irq_hw_number_t hwirq,\n\t\t\t   int node, const struct cpumask *affinity)\n{\n\tunsigned int hint;\n\n\tif (virq >= 0) {\n\t\tvirq = __irq_alloc_descs(virq, virq, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t} else {\n\t\thint = hwirq % nr_irqs;\n\t\tif (hint == 0)\n\t\t\thint++;\n\t\tvirq = __irq_alloc_descs(-1, hint, cnt, node, THIS_MODULE,\n\t\t\t\t\t affinity);\n\t\tif (virq <= 0 && hint > 1) {\n\t\t\tvirq = __irq_alloc_descs(-1, 1, cnt, node, THIS_MODULE,\n\t\t\t\t\t\t affinity);\n\t\t}\n\t}\n\n\treturn virq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> existing mapping on virq %d\\n\"",
            "virq"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_find_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "irq_find_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "874-899",
          "snippet": "unsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_find_mapping(struct irq_domain *domain,\n\t\t\t      irq_hw_number_t hwirq)\n{\n\tstruct irq_data *data;\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL)\n\t\treturn 0;\n\n\tif (hwirq < domain->revmap_direct_max_irq) {\n\t\tdata = irq_domain_get_irq_data(domain, hwirq);\n\t\tif (data && data->hwirq == hwirq)\n\t\t\treturn hwirq;\n\t}\n\n\t/* Check if the hwirq is in the linear revmap. */\n\tif (hwirq < domain->revmap_size)\n\t\treturn domain->linear_revmap[hwirq];\n\n\trcu_read_lock();\n\tdata = radix_tree_lookup(&domain->revmap_tree, hwirq);\n\trcu_read_unlock();\n\treturn data ? data->irq : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"-> using domain @%p\\n\"",
            "domain"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"%s(, %lx) called with NULL domain\\n\"",
            "__func__",
            "hwirq"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"irq_create_mapping(0x%p, 0x%lx)\\n\"",
            "domain",
            "hwirq"
          ],
          "line": 640
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_mapping(struct irq_domain *domain,\n\t\t\t\tirq_hw_number_t hwirq)\n{\n\tstruct device_node *of_node;\n\tint virq;\n\n\tpr_debug(\"irq_create_mapping(0x%p, 0x%lx)\\n\", domain, hwirq);\n\n\t/* Look for default domain if nececssary */\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\tif (domain == NULL) {\n\t\tWARN(1, \"%s(, %lx) called with NULL domain\\n\", __func__, hwirq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"-> using domain @%p\\n\", domain);\n\n\tof_node = irq_domain_get_of_node(domain);\n\n\t/* Check if mapping already exists */\n\tvirq = irq_find_mapping(domain, hwirq);\n\tif (virq) {\n\t\tpr_debug(\"-> existing mapping on virq %d\\n\", virq);\n\t\treturn virq;\n\t}\n\n\t/* Allocate a virtual interrupt number */\n\tvirq = irq_domain_alloc_descs(-1, 1, hwirq, of_node_to_nid(of_node), NULL);\n\tif (virq <= 0) {\n\t\tpr_debug(\"-> virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\n\tif (irq_domain_associate(domain, virq, hwirq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\tpr_debug(\"irq %lu on domain %s mapped to virtual irq %u\\n\",\n\t\thwirq, of_node_full_name(of_node), virq);\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_create_direct_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "593-621",
    "snippet": "unsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tstruct device_node *of_node;\n\tunsigned int virq;\n\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(of_node));\n\tif (!virq) {\n\t\tpr_debug(\"create_direct virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\tif (virq >= domain->revmap_direct_max_irq) {\n\t\tpr_err(\"ERROR: no free irqs available below %i maximum\\n\",\n\t\t\tdomain->revmap_direct_max_irq);\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"create_direct obtained virq %d\\n\", virq);\n\n\tif (irq_domain_associate(domain, virq, virq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\treturn virq;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "virq",
            "virq"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "517-564",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create_direct obtained virq %d\\n\"",
            "virq"
          ],
          "line": 613
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_free_desc",
          "args": [
            "virq"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"ERROR: no free irqs available below %i maximum\\n\"",
            "domain->revmap_direct_max_irq"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"create_direct virq allocation failed\\n\""
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_alloc_desc_from",
          "args": [
            "1",
            "of_node_to_nid(of_node)"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nunsigned int irq_create_direct_mapping(struct irq_domain *domain)\n{\n\tstruct device_node *of_node;\n\tunsigned int virq;\n\n\tif (domain == NULL)\n\t\tdomain = irq_default_domain;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tvirq = irq_alloc_desc_from(1, of_node_to_nid(of_node));\n\tif (!virq) {\n\t\tpr_debug(\"create_direct virq allocation failed\\n\");\n\t\treturn 0;\n\t}\n\tif (virq >= domain->revmap_direct_max_irq) {\n\t\tpr_err(\"ERROR: no free irqs available below %i maximum\\n\",\n\t\t\tdomain->revmap_direct_max_irq);\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\tpr_debug(\"create_direct obtained virq %d\\n\", virq);\n\n\tif (irq_domain_associate(domain, virq, virq)) {\n\t\tirq_free_desc(virq);\n\t\treturn 0;\n\t}\n\n\treturn virq;\n}"
  },
  {
    "function_name": "irq_domain_associate_many",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "567-580",
    "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate",
          "args": [
            "domain",
            "irq_base + i",
            "hwirq_base + i"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "517-564",
          "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\"",
            "__func__",
            "of_node_full_name(of_node)",
            "irq_base",
            "(int)hwirq_base",
            "count"
          ],
          "line": 574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_full_name",
          "args": [
            "of_node"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_associate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "517-564",
    "snippet": "int irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_clear_status_flags",
          "args": [
            "virq",
            "IRQ_NOREQUEST"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_set_mapping",
          "args": [
            "domain",
            "hwirq",
            "irq_data"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_set_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "473-484",
          "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\"",
            "domain->name",
            "hwirq",
            "virq",
            "ret"
          ],
          "line": 543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->ops->map",
          "args": [
            "domain",
            "virq",
            "hwirq"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "irq_data->domain",
            "\"error: virq%i is already associated\"",
            "virq"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!irq_data",
            "\"error: virq%i is not allocated\"",
            "virq"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "hwirq >= domain->hwirq_max",
            "\"error: hwirq 0x%x is too large for %s\\n\"",
            "(int)hwirq",
            "domain->name"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "virq"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nint irq_domain_associate(struct irq_domain *domain, unsigned int virq,\n\t\t\t irq_hw_number_t hwirq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(virq);\n\tint ret;\n\n\tif (WARN(hwirq >= domain->hwirq_max,\n\t\t \"error: hwirq 0x%x is too large for %s\\n\", (int)hwirq, domain->name))\n\t\treturn -EINVAL;\n\tif (WARN(!irq_data, \"error: virq%i is not allocated\", virq))\n\t\treturn -EINVAL;\n\tif (WARN(irq_data->domain, \"error: virq%i is already associated\", virq))\n\t\treturn -EINVAL;\n\n\tmutex_lock(&irq_domain_mutex);\n\tirq_data->hwirq = hwirq;\n\tirq_data->domain = domain;\n\tif (domain->ops->map) {\n\t\tret = domain->ops->map(domain, virq, hwirq);\n\t\tif (ret != 0) {\n\t\t\t/*\n\t\t\t * If map() returns -EPERM, this interrupt is protected\n\t\t\t * by the firmware or some other service and shall not\n\t\t\t * be mapped. Don't bother telling the user about it.\n\t\t\t */\n\t\t\tif (ret != -EPERM) {\n\t\t\t\tpr_info(\"%s didn't like hwirq-0x%lx to VIRQ%i mapping (rc=%d)\\n\",\n\t\t\t\t       domain->name, hwirq, virq, ret);\n\t\t\t}\n\t\t\tirq_data->domain = NULL;\n\t\t\tirq_data->hwirq = 0;\n\t\t\tmutex_unlock(&irq_domain_mutex);\n\t\t\treturn ret;\n\t\t}\n\n\t\t/* If not already assigned, give the domain the chip's name */\n\t\tif (!domain->name && irq_data->chip)\n\t\t\tdomain->name = irq_data->chip->name;\n\t}\n\n\tdomain->mapcount++;\n\tirq_domain_set_mapping(domain, hwirq, irq_data);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tirq_clear_status_flags(virq, IRQ_NOREQUEST);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "irq_domain_disassociate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "486-515",
    "snippet": "void irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_clear_mapping",
          "args": [
            "domain",
            "hwirq"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_clear_mapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "461-471",
          "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "domain->ops->unmap",
          "args": [
            "domain",
            "irq"
          ],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "synchronize_irq",
          "args": [
            "irq"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/manage.c",
          "lines": "100-114",
          "snippet": "void synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/task_work.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/task_work.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/task.h>\n#include <linux/sched/rt.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/irq.h>\n\nvoid synchronize_irq(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\tif (desc) {\n\t\t__synchronize_hardirq(desc);\n\t\t/*\n\t\t * We made sure that no hardirq handler is\n\t\t * running. Now verify that no threaded handlers are\n\t\t * active.\n\t\t */\n\t\twait_event(desc->wait_for_threads,\n\t\t\t   !atomic_read(&desc->threads_active));\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_chip_and_handler",
          "args": [
            "irq",
            "NULL",
            "NULL"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_set_status_flags",
          "args": [
            "irq",
            "IRQ_NOREQUEST"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "!irq_data || irq_data->domain != domain",
            "\"virq%i doesn't exist; cannot disassociate\\n\"",
            "irq"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_get_irq_data",
          "args": [
            "irq"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "irq_get_irq_data",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/chip.c",
          "lines": "158-163",
          "snippet": "struct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <trace/events/irq.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/msi.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <trace/events/irq.h>\n#include <linux/irqdomain.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/msi.h>\n#include <linux/irq.h>\n\nstruct irq_data *irq_get_irq_data(unsigned int irq)\n{\n\tstruct irq_desc *desc = irq_to_desc(irq);\n\n\treturn desc ? &desc->irq_data : NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_disassociate(struct irq_domain *domain, unsigned int irq)\n{\n\tstruct irq_data *irq_data = irq_get_irq_data(irq);\n\tirq_hw_number_t hwirq;\n\n\tif (WARN(!irq_data || irq_data->domain != domain,\n\t\t \"virq%i doesn't exist; cannot disassociate\\n\", irq))\n\t\treturn;\n\n\thwirq = irq_data->hwirq;\n\tirq_set_status_flags(irq, IRQ_NOREQUEST);\n\n\t/* remove chip and handler */\n\tirq_set_chip_and_handler(irq, NULL, NULL);\n\n\t/* Make sure it's completed */\n\tsynchronize_irq(irq);\n\n\t/* Tell the PIC about it */\n\tif (domain->ops->unmap)\n\t\tdomain->ops->unmap(domain, irq);\n\tsmp_mb();\n\n\tirq_data->domain = NULL;\n\tirq_data->hwirq = 0;\n\tdomain->mapcount--;\n\n\t/* Clear reverse map for this hwirq */\n\tirq_domain_clear_mapping(domain, hwirq);\n}"
  },
  {
    "function_name": "irq_domain_set_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "473-484",
    "snippet": "static void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&domain->revmap_tree_mutex"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_insert",
          "args": [
            "&domain->revmap_tree",
            "hwirq",
            "irq_data"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&domain->revmap_tree_mutex"
          ],
          "line": 480
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_set_mapping(struct irq_domain *domain,\n\t\t\t\t   irq_hw_number_t hwirq,\n\t\t\t\t   struct irq_data *irq_data)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = irq_data->irq;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_insert(&domain->revmap_tree, hwirq, irq_data);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
  },
  {
    "function_name": "irq_domain_clear_mapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "461-471",
    "snippet": "static void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&domain->revmap_tree_mutex"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "radix_tree_delete",
          "args": [
            "&domain->revmap_tree",
            "hwirq"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&domain->revmap_tree_mutex"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_clear_mapping(struct irq_domain *domain,\n\t\t\t\t     irq_hw_number_t hwirq)\n{\n\tif (hwirq < domain->revmap_size) {\n\t\tdomain->linear_revmap[hwirq] = 0;\n\t} else {\n\t\tmutex_lock(&domain->revmap_tree_mutex);\n\t\tradix_tree_delete(&domain->revmap_tree, hwirq);\n\t\tmutex_unlock(&domain->revmap_tree_mutex);\n\t}\n}"
  },
  {
    "function_name": "irq_set_default_host",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "453-458",
    "snippet": "void irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Default domain set to @0x%p\\n\"",
            "domain"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}"
  },
  {
    "function_name": "irq_domain_check_msi_remap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "426-441",
    "snippet": "bool irq_domain_check_msi_remap(void)\n{\n\tstruct irq_domain *h;\n\tbool ret = true;\n\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (irq_domain_is_msi(h) &&\n\t\t    !irq_domain_hierarchical_is_msi_remap(h)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_hierarchical_is_msi_remap",
          "args": [
            "h"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_hierarchical_is_msi_remap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1648-1655",
          "snippet": "bool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nbool irq_domain_hierarchical_is_msi_remap(struct irq_domain *domain)\n{\n\tfor (; domain; domain = domain->parent) {\n\t\tif (irq_domain_is_msi_remap(domain))\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_is_msi",
          "args": [
            "h"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "h",
            "&irq_domain_list",
            "link"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\n\nbool irq_domain_check_msi_remap(void)\n{\n\tstruct irq_domain *h;\n\tbool ret = true;\n\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (irq_domain_is_msi(h) &&\n\t\t    !irq_domain_hierarchical_is_msi_remap(h)) {\n\t\t\tret = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "irq_find_matching_fwspec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "382-416",
    "snippet": "struct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "h->ops->match",
          "args": [
            "h",
            "to_of_node(fwnode)",
            "bus_token"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwnode"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "h->ops->select",
          "args": [
            "h",
            "fwspec",
            "bus_token"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "h",
            "&irq_domain_list",
            "link"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 398
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_find_matching_fwspec(struct irq_fwspec *fwspec,\n\t\t\t\t\t    enum irq_domain_bus_token bus_token)\n{\n\tstruct irq_domain *h, *found = NULL;\n\tstruct fwnode_handle *fwnode = fwspec->fwnode;\n\tint rc;\n\n\t/* We might want to match the legacy controller last since\n\t * it might potentially be set to match all interrupts in\n\t * the absence of a device node. This isn't a problem so far\n\t * yet though...\n\t *\n\t * bus_token == DOMAIN_BUS_ANY matches any domain, any other\n\t * values must generate an exact match for the domain to be\n\t * selected.\n\t */\n\tmutex_lock(&irq_domain_mutex);\n\tlist_for_each_entry(h, &irq_domain_list, link) {\n\t\tif (h->ops->select && fwspec->param_count)\n\t\t\trc = h->ops->select(h, fwspec, bus_token);\n\t\telse if (h->ops->match)\n\t\t\trc = h->ops->match(h, to_of_node(fwnode), bus_token);\n\t\telse\n\t\t\trc = ((fwnode != NULL) && (h->fwnode == fwnode) &&\n\t\t\t      ((bus_token == DOMAIN_BUS_ANY) ||\n\t\t\t       (h->bus_token == bus_token)));\n\n\t\tif (rc) {\n\t\t\tfound = h;\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&irq_domain_mutex);\n\treturn found;\n}"
  },
  {
    "function_name": "irq_domain_add_legacy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "359-374",
    "snippet": "struct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node_to_fwnode(of_node), first_hwirq + size,\n\t\t\t\t  first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate_many",
          "args": [
            "domain",
            "first_irq",
            "first_hwirq",
            "size"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "567-580",
          "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__irq_domain_add",
          "args": [
            "of_node_to_fwnode(of_node)",
            "first_hwirq + size",
            "first_hwirq + size",
            "0",
            "ops",
            "host_data"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "129-230",
          "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_to_fwnode",
          "args": [
            "of_node"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_add_legacy(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t irq_hw_number_t first_hwirq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node_to_fwnode(of_node), first_hwirq + size,\n\t\t\t\t  first_hwirq + size, 0, ops, host_data);\n\tif (domain)\n\t\tirq_domain_associate_many(domain, first_irq, first_hwirq, size);\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_add_simple",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "316-341",
    "snippet": "struct irq_domain *irq_domain_add_simple(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (first_irq > 0) {\n\t\tif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\n\t\t\t/* attempt to allocated irq_descs */\n\t\t\tint rc = irq_alloc_descs(first_irq, first_irq, size,\n\t\t\t\t\t\t of_node_to_nid(of_node));\n\t\t\tif (rc < 0)\n\t\t\t\tpr_info(\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_domain_associate_many",
          "args": [
            "domain",
            "first_irq",
            "0",
            "size"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_associate_many",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "567-580",
          "snippet": "void irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_associate_many(struct irq_domain *domain, unsigned int irq_base,\n\t\t\t       irq_hw_number_t hwirq_base, int count)\n{\n\tstruct device_node *of_node;\n\tint i;\n\n\tof_node = irq_domain_get_of_node(domain);\n\tpr_debug(\"%s(%s, irqbase=%i, hwbase=%i, count=%i)\\n\", __func__,\n\t\tof_node_full_name(of_node), irq_base, (int)hwirq_base, count);\n\n\tfor (i = 0; i < count; i++) {\n\t\tirq_domain_associate(domain, irq_base + i, hwirq_base + i);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\"",
            "first_irq"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_alloc_descs",
          "args": [
            "first_irq",
            "first_irq",
            "size",
            "of_node_to_nid(of_node)"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_SPARSE_IRQ"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__irq_domain_add",
          "args": [
            "of_node_to_fwnode(of_node)",
            "size",
            "size",
            "0",
            "ops",
            "host_data"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__irq_domain_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "129-230",
          "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(irq_domain_list);",
            "static DEFINE_MUTEX(irq_domain_mutex);",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_to_fwnode",
          "args": [
            "of_node"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *irq_domain_add_simple(struct device_node *of_node,\n\t\t\t\t\t unsigned int size,\n\t\t\t\t\t unsigned int first_irq,\n\t\t\t\t\t const struct irq_domain_ops *ops,\n\t\t\t\t\t void *host_data)\n{\n\tstruct irq_domain *domain;\n\n\tdomain = __irq_domain_add(of_node_to_fwnode(of_node), size, size, 0, ops, host_data);\n\tif (!domain)\n\t\treturn NULL;\n\n\tif (first_irq > 0) {\n\t\tif (IS_ENABLED(CONFIG_SPARSE_IRQ)) {\n\t\t\t/* attempt to allocated irq_descs */\n\t\t\tint rc = irq_alloc_descs(first_irq, first_irq, size,\n\t\t\t\t\t\t of_node_to_nid(of_node));\n\t\t\tif (rc < 0)\n\t\t\t\tpr_info(\"Cannot allocate irq_descs @ IRQ%d, assuming pre-allocated\\n\",\n\t\t\t\t\tfirst_irq);\n\t\t}\n\t\tirq_domain_associate_many(domain, first_irq, 0, size);\n\t}\n\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_update_bus_token",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "267-296",
    "snippet": "void irq_domain_update_bus_token(struct irq_domain *domain,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tchar *name;\n\n\tif (domain->bus_token == bus_token)\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\tdomain->bus_token = bus_token;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%d\", domain->name, bus_token);\n\tif (!name) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\treturn;\n\t}\n\n\tdebugfs_remove_domain_dir(domain);\n\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\telse\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\n\tdomain->name = name;\n\tdebugfs_add_domain_dir(domain);\n\n\tmutex_unlock(&irq_domain_mutex);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "domain"
          ],
          "line": 293
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1733-1739",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain->name"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_remove_domain_dir",
          "args": [
            "domain"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1745",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s-%d\"",
            "domain->name",
            "bus_token"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_update_bus_token(struct irq_domain *domain,\n\t\t\t\t enum irq_domain_bus_token bus_token)\n{\n\tchar *name;\n\n\tif (domain->bus_token == bus_token)\n\t\treturn;\n\n\tmutex_lock(&irq_domain_mutex);\n\n\tdomain->bus_token = bus_token;\n\n\tname = kasprintf(GFP_KERNEL, \"%s-%d\", domain->name, bus_token);\n\tif (!name) {\n\t\tmutex_unlock(&irq_domain_mutex);\n\t\treturn;\n\t}\n\n\tdebugfs_remove_domain_dir(domain);\n\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\telse\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\n\tdomain->name = name;\n\tdebugfs_add_domain_dir(domain);\n\n\tmutex_unlock(&irq_domain_mutex);\n}"
  },
  {
    "function_name": "irq_domain_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "241-264",
    "snippet": "void irq_domain_remove(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_remove_domain_dir(domain);\n\n\tWARN_ON(!radix_tree_empty(&domain->revmap_tree));\n\n\tlist_del(&domain->link);\n\n\t/*\n\t * If the going away domain is the default one, reset it.\n\t */\n\tif (unlikely(irq_default_domain == domain))\n\t\tirq_set_default_host(NULL);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Removed domain %s\\n\", domain->name);\n\n\tof_node_put(irq_domain_get_of_node(domain));\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\tkfree(domain);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static struct irq_domain *irq_default_domain;",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "of_node_put",
          "args": [
            "irq_domain_get_of_node(domain)"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_domain_get_of_node",
          "args": [
            "domain"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Removed domain %s\\n\"",
            "domain->name"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 256
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_set_default_host",
          "args": [
            "NULL"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "irq_set_default_host",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "453-458",
          "snippet": "void irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct irq_domain *irq_default_domain;",
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_set_default_host(struct irq_domain *domain)\n{\n\tpr_debug(\"Default domain set to @0x%p\\n\", domain);\n\n\tirq_default_domain = domain;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irq_default_domain == domain"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&domain->link"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!radix_tree_empty(&domain->revmap_tree)"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "radix_tree_empty",
          "args": [
            "&domain->revmap_tree"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debugfs_remove_domain_dir",
          "args": [
            "domain"
          ],
          "line": 244
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_remove_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1741-1745",
          "snippet": "static void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_remove_domain_dir(struct irq_domain *d)\n{\n\tdebugfs_remove(d->debugfs_file);\n\td->debugfs_file = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic struct irq_domain *irq_default_domain;\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nvoid irq_domain_remove(struct irq_domain *domain)\n{\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_remove_domain_dir(domain);\n\n\tWARN_ON(!radix_tree_empty(&domain->revmap_tree));\n\n\tlist_del(&domain->link);\n\n\t/*\n\t * If the going away domain is the default one, reset it.\n\t */\n\tif (unlikely(irq_default_domain == domain))\n\t\tirq_set_default_host(NULL);\n\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Removed domain %s\\n\", domain->name);\n\n\tof_node_put(irq_domain_get_of_node(domain));\n\tif (domain->flags & IRQ_DOMAIN_NAME_ALLOCATED)\n\t\tkfree(domain->name);\n\tkfree(domain);\n}"
  },
  {
    "function_name": "__irq_domain_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "129-230",
    "snippet": "struct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static LIST_HEAD(irq_domain_list);",
      "static DEFINE_MUTEX(irq_domain_mutex);",
      "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_debug",
          "args": [
            "\"Added domain %s\\n\"",
            "domain->name"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&domain->link",
            "&irq_domain_list"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "debugfs_add_domain_dir",
          "args": [
            "domain"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "debugfs_add_domain_dir",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1733-1739",
          "snippet": "static void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void debugfs_add_domain_dir(struct irq_domain *d)\n{\n\tif (!d->name || !domain_dir || d->debugfs_file)\n\t\treturn;\n\td->debugfs_file = debugfs_create_file(d->name, 0444, domain_dir, d,\n\t\t\t\t\t      &irq_domain_debug_fops);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&irq_domain_mutex"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_domain_check_hierarchy",
          "args": [
            "domain"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "irq_domain_check_hierarchy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
          "lines": "1692-1694",
          "snippet": "static void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}",
          "includes": [
            "#include <linux/fs.h>",
            "#include <linux/smp.h>",
            "#include <linux/slab.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/topology.h>",
            "#include <linux/of_irq.h>",
            "#include <linux/of_address.h>",
            "#include <linux/of.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/irqdesc.h>",
            "#include <linux/irq.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/acpi.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void irq_domain_check_hierarchy(struct irq_domain *domain);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&domain->revmap_tree_mutex"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_RADIX_TREE",
          "args": [
            "&domain->revmap_tree",
            "GFP_KERNEL"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_get",
          "args": [
            "of_node"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "domain"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"unknown-%d\"",
            "atomic_inc_return(&unknown_domains)"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&unknown_domains"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"Invalid fwnode type for irqdomain\\n\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strreplace",
          "args": [
            "name",
            "'/'",
            "':'"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%pOF\"",
            "of_node"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acpi_get_name",
          "args": [
            "handle",
            "ACPI_FULL_PATHNAME",
            "&buf"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "acpi_device_handle",
          "args": [
            "to_acpi_device_node(fwnode)"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_acpi_device_node",
          "args": [
            "fwnode"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_acpi_device_node",
          "args": [
            "fwnode"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "fwid->name",
            "GFP_KERNEL"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fwnode",
            "structirqchip_fwid",
            "fwnode"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fwnode_irqchip",
          "args": [
            "fwnode"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!domain"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc_node",
          "args": [
            "sizeof(*domain) + (sizeof(unsigned int) * size)",
            "GFP_KERNEL",
            "of_node_to_nid(of_node)"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "of_node_to_nid",
          "args": [
            "of_node"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_of_node",
          "args": [
            "fwnode"
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic LIST_HEAD(irq_domain_list);\nstatic DEFINE_MUTEX(irq_domain_mutex);\nstatic void irq_domain_check_hierarchy(struct irq_domain *domain);\n\nstruct irq_domain *__irq_domain_add(struct fwnode_handle *fwnode, int size,\n\t\t\t\t    irq_hw_number_t hwirq_max, int direct_max,\n\t\t\t\t    const struct irq_domain_ops *ops,\n\t\t\t\t    void *host_data)\n{\n\tstruct device_node *of_node = to_of_node(fwnode);\n\tstruct irqchip_fwid *fwid;\n\tstruct irq_domain *domain;\n\n\tstatic atomic_t unknown_domains;\n\n\tdomain = kzalloc_node(sizeof(*domain) + (sizeof(unsigned int) * size),\n\t\t\t      GFP_KERNEL, of_node_to_nid(of_node));\n\tif (WARN_ON(!domain))\n\t\treturn NULL;\n\n\tif (fwnode && is_fwnode_irqchip(fwnode)) {\n\t\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\n\t\tswitch (fwid->type) {\n\t\tcase IRQCHIP_FWNODE_NAMED:\n\t\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\t\tdomain->name = kstrdup(fwid->name, GFP_KERNEL);\n\t\t\tif (!domain->name) {\n\t\t\t\tkfree(domain);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tdomain->fwnode = fwnode;\n\t\t\tdomain->name = fwid->name;\n\t\t\tbreak;\n\t\t}\n#ifdef CONFIG_ACPI\n\t} else if (is_acpi_device_node(fwnode)) {\n\t\tstruct acpi_buffer buf = {\n\t\t\t.length = ACPI_ALLOCATE_BUFFER,\n\t\t};\n\t\tacpi_handle handle;\n\n\t\thandle = acpi_device_handle(to_acpi_device_node(fwnode));\n\t\tif (acpi_get_name(handle, ACPI_FULL_PATHNAME, &buf) == AE_OK) {\n\t\t\tdomain->name = buf.pointer;\n\t\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t\t}\n\n\t\tdomain->fwnode = fwnode;\n#endif\n\t} else if (of_node) {\n\t\tchar *name;\n\n\t\t/*\n\t\t * DT paths contain '/', which debugfs is legitimately\n\t\t * unhappy about. Replace them with ':', which does\n\t\t * the trick and is not as offensive as '\\'...\n\t\t */\n\t\tname = kasprintf(GFP_KERNEL, \"%pOF\", of_node);\n\t\tif (!name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tstrreplace(name, '/', ':');\n\n\t\tdomain->name = name;\n\t\tdomain->fwnode = fwnode;\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tif (!domain->name) {\n\t\tif (fwnode)\n\t\t\tpr_err(\"Invalid fwnode type for irqdomain\\n\");\n\t\tdomain->name = kasprintf(GFP_KERNEL, \"unknown-%d\",\n\t\t\t\t\t atomic_inc_return(&unknown_domains));\n\t\tif (!domain->name) {\n\t\t\tkfree(domain);\n\t\t\treturn NULL;\n\t\t}\n\t\tdomain->flags |= IRQ_DOMAIN_NAME_ALLOCATED;\n\t}\n\n\tof_node_get(of_node);\n\n\t/* Fill structure */\n\tINIT_RADIX_TREE(&domain->revmap_tree, GFP_KERNEL);\n\tmutex_init(&domain->revmap_tree_mutex);\n\tdomain->ops = ops;\n\tdomain->host_data = host_data;\n\tdomain->hwirq_max = hwirq_max;\n\tdomain->revmap_size = size;\n\tdomain->revmap_direct_max_irq = direct_max;\n\tirq_domain_check_hierarchy(domain);\n\n\tmutex_lock(&irq_domain_mutex);\n\tdebugfs_add_domain_dir(domain);\n\tlist_add(&domain->link, &irq_domain_list);\n\tmutex_unlock(&irq_domain_mutex);\n\n\tpr_debug(\"Added domain %s\\n\", domain->name);\n\treturn domain;\n}"
  },
  {
    "function_name": "irq_domain_free_fwnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "103-113",
    "snippet": "void irq_domain_free_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid;\n\n\tif (WARN_ON(!is_fwnode_irqchip(fwnode)))\n\t\treturn;\n\n\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\tkfree(fwid->name);\n\tkfree(fwid);\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "fwid"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "fwnode",
            "structirqchip_fwid",
            "fwnode"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!is_fwnode_irqchip(fwnode)"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_fwnode_irqchip",
          "args": [
            "fwnode"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nvoid irq_domain_free_fwnode(struct fwnode_handle *fwnode)\n{\n\tstruct irqchip_fwid *fwid;\n\n\tif (WARN_ON(!is_fwnode_irqchip(fwnode)))\n\t\treturn;\n\n\tfwid = container_of(fwnode, struct irqchip_fwid, fwnode);\n\tkfree(fwid->name);\n\tkfree(fwid);\n}"
  },
  {
    "function_name": "__irq_domain_alloc_fwnode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "64-95",
    "snippet": "struct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,\n\t\t\t\t\t\tconst char *name, void *data)\n{\n\tstruct irqchip_fwid *fwid;\n\tchar *n;\n\n\tfwid = kzalloc(sizeof(*fwid), GFP_KERNEL);\n\n\tswitch (type) {\n\tcase IRQCHIP_FWNODE_NAMED:\n\t\tn = kasprintf(GFP_KERNEL, \"%s\", name);\n\t\tbreak;\n\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\tn = kasprintf(GFP_KERNEL, \"%s-%d\", name, id);\n\t\tbreak;\n\tdefault:\n\t\tn = kasprintf(GFP_KERNEL, \"irqchip@%p\", data);\n\t\tbreak;\n\t}\n\n\tif (!fwid || !n) {\n\t\tkfree(fwid);\n\t\tkfree(n);\n\t\treturn NULL;\n\t}\n\n\tfwid->type = type;\n\tfwid->name = n;\n\tfwid->data = data;\n\tfwid->fwnode.ops = &irqchip_fwnode_ops;\n\treturn &fwid->fwnode;\n}",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct fwnode_operations irqchip_fwnode_ops;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"irqchip@%p\"",
            "data"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s-%d\"",
            "name",
            "id"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kasprintf",
          "args": [
            "GFP_KERNEL",
            "\"%s\"",
            "name"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*fwid)",
            "GFP_KERNEL"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nconst struct fwnode_operations irqchip_fwnode_ops;\n\nstruct fwnode_handle *__irq_domain_alloc_fwnode(unsigned int type, int id,\n\t\t\t\t\t\tconst char *name, void *data)\n{\n\tstruct irqchip_fwid *fwid;\n\tchar *n;\n\n\tfwid = kzalloc(sizeof(*fwid), GFP_KERNEL);\n\n\tswitch (type) {\n\tcase IRQCHIP_FWNODE_NAMED:\n\t\tn = kasprintf(GFP_KERNEL, \"%s\", name);\n\t\tbreak;\n\tcase IRQCHIP_FWNODE_NAMED_ID:\n\t\tn = kasprintf(GFP_KERNEL, \"%s-%d\", name, id);\n\t\tbreak;\n\tdefault:\n\t\tn = kasprintf(GFP_KERNEL, \"irqchip@%p\", data);\n\t\tbreak;\n\t}\n\n\tif (!fwid || !n) {\n\t\tkfree(fwid);\n\t\tkfree(n);\n\t\treturn NULL;\n\t}\n\n\tfwid->type = type;\n\tfwid->name = n;\n\tfwid->data = data;\n\tfwid->fwnode.ops = &irqchip_fwnode_ops;\n\treturn &fwid->fwnode;\n}"
  },
  {
    "function_name": "debugfs_remove_domain_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "42-42",
    "snippet": "static inline void debugfs_remove_domain_dir(struct irq_domain *d) { }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic inline void debugfs_remove_domain_dir(struct irq_domain *d) { }"
  },
  {
    "function_name": "debugfs_add_domain_dir",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdomain.c",
    "lines": "41-41",
    "snippet": "static inline void debugfs_add_domain_dir(struct irq_domain *d) { }",
    "includes": [
      "#include <linux/fs.h>",
      "#include <linux/smp.h>",
      "#include <linux/slab.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/topology.h>",
      "#include <linux/of_irq.h>",
      "#include <linux/of_address.h>",
      "#include <linux/of.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>",
      "#include <linux/irqdomain.h>",
      "#include <linux/irqdesc.h>",
      "#include <linux/irq.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/hardirq.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/acpi.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/fs.h>\n#include <linux/smp.h>\n#include <linux/slab.h>\n#include <linux/seq_file.h>\n#include <linux/topology.h>\n#include <linux/of_irq.h>\n#include <linux/of_address.h>\n#include <linux/of.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/irqdomain.h>\n#include <linux/irqdesc.h>\n#include <linux/irq.h>\n#include <linux/interrupt.h>\n#include <linux/hardirq.h>\n#include <linux/debugfs.h>\n#include <linux/acpi.h>\n\nstatic inline void debugfs_add_domain_dir(struct irq_domain *d) { }"
  }
]