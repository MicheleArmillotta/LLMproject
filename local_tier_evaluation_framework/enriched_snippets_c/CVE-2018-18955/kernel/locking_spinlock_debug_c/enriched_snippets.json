[
  {
    "function_name": "do_raw_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "222-226",
    "snippet": "void do_raw_write_unlock(rwlock_t *lock)\n{\n\tdebug_write_unlock(lock);\n\tarch_write_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_write_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_unlock",
          "args": [
            "lock"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "190-198",
          "snippet": "static inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_write_unlock(rwlock_t *lock)\n{\n\tdebug_write_unlock(lock);\n\tarch_write_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_write_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "207-220",
    "snippet": "int do_raw_write_trylock(rwlock_t *lock)\n{\n\tint ret = arch_write_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_write_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_lock_after",
          "args": [
            "lock"
          ],
          "line": 212
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "184-188",
          "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_write_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 209
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_write_trylock(rwlock_t *lock)\n{\n\tint ret = arch_write_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_write_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_write_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "200-205",
    "snippet": "void do_raw_write_lock(rwlock_t *lock)\n{\n\tdebug_write_lock_before(lock);\n\tarch_write_lock(&lock->raw_lock);\n\tdebug_write_lock_after(lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_write_lock_after",
          "args": [
            "lock"
          ],
          "line": 204
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "184-188",
          "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_write_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_write_lock_before",
          "args": [
            "lock"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "debug_write_lock_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "176-182",
          "snippet": "static inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_write_lock(rwlock_t *lock)\n{\n\tdebug_write_lock_before(lock);\n\tarch_write_lock(&lock->raw_lock);\n\tdebug_write_lock_after(lock);\n}"
  },
  {
    "function_name": "debug_write_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "190-198",
    "snippet": "static inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner_cpu != raw_smp_processor_id()",
            "lock",
            "\"wrong CPU\""
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner != current",
            "lock",
            "\"wrong owner\""
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tRWLOCK_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  },
  {
    "function_name": "debug_write_lock_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "184-188",
    "snippet": "static inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_after(rwlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
  },
  {
    "function_name": "debug_write_lock_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "176-182",
    "snippet": "static inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner_cpu == raw_smp_processor_id()",
            "lock",
            "\"cpu recursion\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->owner == current",
            "lock",
            "\"recursion\""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_write_lock_before(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tRWLOCK_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tRWLOCK_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
  },
  {
    "function_name": "do_raw_read_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "170-174",
    "snippet": "void do_raw_read_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_read_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_read_unlock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_read_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "157-168",
    "snippet": "int do_raw_read_trylock(rwlock_t *lock)\n{\n\tint ret = arch_read_trylock(&lock->raw_lock);\n\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_read_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_read_trylock(rwlock_t *lock)\n{\n\tint ret = arch_read_trylock(&lock->raw_lock);\n\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tRWLOCK_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_read_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "151-155",
    "snippet": "void do_raw_read_lock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_lock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_read_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "RWLOCK_BUG_ON",
          "args": [
            "lock->magic != RWLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_read_lock(rwlock_t *lock)\n{\n\tRWLOCK_BUG_ON(lock->magic != RWLOCK_MAGIC, lock, \"bad magic\");\n\tarch_read_lock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "rwlock_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "138-147",
    "snippet": "static void rwlock_bug(rwlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tprintk(KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\",\n\t\tmsg, raw_smp_processor_id(), current->comm,\n\t\ttask_pid_nr(current), lock);\n\tdump_stack();\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\"",
            "msg",
            "raw_smp_processor_id()",
            "current->comm",
            "task_pid_nr(current)",
            "lock"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void rwlock_bug(rwlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tprintk(KERN_EMERG \"BUG: rwlock %s on CPU#%d, %s/%d, %p\\n\",\n\t\tmsg, raw_smp_processor_id(), current->comm,\n\t\ttask_pid_nr(current), lock);\n\tdump_stack();\n}"
  },
  {
    "function_name": "do_raw_spin_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "132-136",
    "snippet": "void do_raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tdebug_spin_unlock(lock);\n\tarch_spin_unlock(&lock->raw_lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_spin_unlock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_unlock",
          "args": [
            "lock"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "95-104",
          "snippet": "static inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_spin_unlock(raw_spinlock_t *lock)\n{\n\tdebug_spin_unlock(lock);\n\tarch_spin_unlock(&lock->raw_lock);\n}"
  },
  {
    "function_name": "do_raw_spin_trylock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "117-130",
    "snippet": "int do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_spin_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tSPIN_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "!ret",
            "lock",
            "\"trylock failure on UP\""
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_lock_after",
          "args": [
            "lock"
          ],
          "line": 122
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "89-93",
          "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_trylock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nint do_raw_spin_trylock(raw_spinlock_t *lock)\n{\n\tint ret = arch_spin_trylock(&lock->raw_lock);\n\n\tif (ret)\n\t\tdebug_spin_lock_after(lock);\n#ifndef CONFIG_SMP\n\t/*\n\t * Must not happen on UP:\n\t */\n\tSPIN_BUG_ON(!ret, lock, \"trylock failure on UP\");\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "do_raw_spin_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "110-115",
    "snippet": "void do_raw_spin_lock(raw_spinlock_t *lock)\n{\n\tdebug_spin_lock_before(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tdebug_spin_lock_after(lock);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_spin_lock_after",
          "args": [
            "lock"
          ],
          "line": 114
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_after",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "89-93",
          "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_spin_lock",
          "args": [
            "&lock->raw_lock"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_spin_lock_before",
          "args": [
            "lock"
          ],
          "line": 112
        },
        "resolved": true,
        "details": {
          "function_name": "debug_spin_lock_before",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "80-87",
          "snippet": "static inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tSPIN_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tSPIN_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid do_raw_spin_lock(raw_spinlock_t *lock)\n{\n\tdebug_spin_lock_before(lock);\n\tarch_spin_lock(&lock->raw_lock);\n\tdebug_spin_lock_after(lock);\n}"
  },
  {
    "function_name": "debug_spin_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "95-104",
    "snippet": "static inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner_cpu != raw_smp_processor_id()",
            "lock",
            "\"wrong CPU\""
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner != current",
            "lock",
            "\"wrong owner\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "!raw_spin_is_locked(lock)",
            "lock",
            "\"already unlocked\""
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_is_locked",
          "args": [
            "lock"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->magic != SPINLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_unlock(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(!raw_spin_is_locked(lock), lock, \"already unlocked\");\n\tSPIN_BUG_ON(lock->owner != current, lock, \"wrong owner\");\n\tSPIN_BUG_ON(lock->owner_cpu != raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"wrong CPU\");\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  },
  {
    "function_name": "debug_spin_lock_after",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "89-93",
    "snippet": "static inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void debug_spin_lock_after(raw_spinlock_t *lock)\n{\n\tlock->owner_cpu = raw_smp_processor_id();\n\tlock->owner = current;\n}"
  },
  {
    "function_name": "debug_spin_lock_before",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "80-87",
    "snippet": "static inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tSPIN_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner_cpu == raw_smp_processor_id()",
            "lock",
            "\"cpu recursion\""
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->owner == current",
            "lock",
            "\"recursion\""
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "SPIN_BUG_ON",
          "args": [
            "lock->magic != SPINLOCK_MAGIC",
            "lock",
            "\"bad magic\""
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic inline void\ndebug_spin_lock_before(raw_spinlock_t *lock)\n{\n\tSPIN_BUG_ON(lock->magic != SPINLOCK_MAGIC, lock, \"bad magic\");\n\tSPIN_BUG_ON(lock->owner == current, lock, \"recursion\");\n\tSPIN_BUG_ON(lock->owner_cpu == raw_smp_processor_id(),\n\t\t\t\t\t\t\tlock, \"cpu recursion\");\n}"
  },
  {
    "function_name": "spin_bug",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "70-76",
    "snippet": "static void spin_bug(raw_spinlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tspin_dump(lock, msg);\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_dump",
          "args": [
            "lock",
            "msg"
          ],
          "line": 75
        },
        "resolved": true,
        "details": {
          "function_name": "spin_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
          "lines": "52-68",
          "snippet": "static void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = NULL;\n\n\tif (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)\n\t\towner = lock->owner;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, lock->magic,\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tlock->owner_cpu);\n\tdump_stack();\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/delay.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/nmi.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = NULL;\n\n\tif (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)\n\t\towner = lock->owner;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, lock->magic,\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tlock->owner_cpu);\n\tdump_stack();\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_locks_off",
          "args": [],
          "line": 72
        },
        "resolved": true,
        "details": {
          "function_name": "debug_locks_off_graph_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "122-129",
          "snippet": "static inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nstatic arch_spinlock_t lockdep_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\nstatic inline int debug_locks_off_graph_unlock(void)\n{\n\tint ret = debug_locks_off();\n\n\tarch_spin_unlock(&lockdep_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_bug(raw_spinlock_t *lock, const char *msg)\n{\n\tif (!debug_locks_off())\n\t\treturn;\n\n\tspin_dump(lock, msg);\n}"
  },
  {
    "function_name": "spin_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "52-68",
    "snippet": "static void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = NULL;\n\n\tif (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)\n\t\towner = lock->owner;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, lock->magic,\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tlock->owner_cpu);\n\tdump_stack();\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\"",
            "lock",
            "lock->magic",
            "owner ? owner->comm : \"<none>\"",
            "owner ? task_pid_nr(owner) : -1",
            "lock->owner_cpu"
          ],
          "line": 61
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "owner"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr",
          "args": [
            "current"
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nstatic void spin_dump(raw_spinlock_t *lock, const char *msg)\n{\n\tstruct task_struct *owner = NULL;\n\n\tif (lock->owner && lock->owner != SPINLOCK_OWNER_INIT)\n\t\towner = lock->owner;\n\tprintk(KERN_EMERG \"BUG: spinlock %s on CPU#%d, %s/%d\\n\",\n\t\tmsg, raw_smp_processor_id(),\n\t\tcurrent->comm, task_pid_nr(current));\n\tprintk(KERN_EMERG \" lock: %pS, .magic: %08x, .owner: %s/%d, \"\n\t\t\t\".owner_cpu: %d\\n\",\n\t\tlock, lock->magic,\n\t\towner ? owner->comm : \"<none>\",\n\t\towner ? task_pid_nr(owner) : -1,\n\t\tlock->owner_cpu);\n\tdump_stack();\n}"
  },
  {
    "function_name": "__rwlock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "34-48",
    "snippet": "void __rwlock_init(rwlock_t *lock, const char *name,\n\t\t   struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n\tlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\n\tlock->magic = RWLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 42
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 41
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid __rwlock_init(rwlock_t *lock, const char *name,\n\t\t   struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n\tlock->raw_lock = (arch_rwlock_t) __ARCH_RW_LOCK_UNLOCKED;\n\tlock->magic = RWLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  },
  {
    "function_name": "__raw_spin_lock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock_debug.c",
    "lines": "16-30",
    "snippet": "void __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t  struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n\tlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tlock->magic = SPINLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}",
    "includes": [
      "#include <linux/export.h>",
      "#include <linux/delay.h>",
      "#include <linux/debug_locks.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/nmi.h>",
      "#include <linux/spinlock.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&lock->dep_map",
            "name",
            "key",
            "0"
          ],
          "line": 24
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_check_no_locks_freed",
          "args": [
            "(void *)lock",
            "sizeof(*lock)"
          ],
          "line": 23
        },
        "resolved": true,
        "details": {
          "function_name": "debug_check_no_locks_freed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "4322-4344",
          "snippet": "void debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid debug_check_no_locks_freed(const void *mem_from, unsigned long mem_len)\n{\n\tstruct task_struct *curr = current;\n\tstruct held_lock *hlock;\n\tunsigned long flags;\n\tint i;\n\n\tif (unlikely(!debug_locks))\n\t\treturn;\n\n\traw_local_irq_save(flags);\n\tfor (i = 0; i < curr->lockdep_depth; i++) {\n\t\thlock = curr->held_locks + i;\n\n\t\tif (not_in_range(mem_from, mem_len, hlock->instance,\n\t\t\t\t\tsizeof(*hlock->instance)))\n\t\t\tcontinue;\n\n\t\tprint_freed_lock_bug(curr, mem_from, mem_from + mem_len, hlock);\n\t\tbreak;\n\t}\n\traw_local_irq_restore(flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/export.h>\n#include <linux/delay.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/nmi.h>\n#include <linux/spinlock.h>\n\nvoid __raw_spin_lock_init(raw_spinlock_t *lock, const char *name,\n\t\t\t  struct lock_class_key *key)\n{\n#ifdef CONFIG_DEBUG_LOCK_ALLOC\n\t/*\n\t * Make sure we are not reinitializing a held lock:\n\t */\n\tdebug_check_no_locks_freed((void *)lock, sizeof(*lock));\n\tlockdep_init_map(&lock->dep_map, name, key, 0);\n#endif\n\tlock->raw_lock = (arch_spinlock_t)__ARCH_SPIN_LOCK_UNLOCKED;\n\tlock->magic = SPINLOCK_MAGIC;\n\tlock->owner = SPINLOCK_OWNER_INIT;\n\tlock->owner_cpu = -1;\n}"
  }
]