[
  {
    "function_name": "bpf_task_fd_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2374-2449",
    "snippet": "static int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\tif (!files)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\terr = -EBADF;\n\telse\n\t\tget_file(file);\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (file->f_op == &bpf_raw_tp_fops) {\n\t\tstruct bpf_raw_tracepoint *raw_tp = file->private_data;\n\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t     raw_tp->prog->aux->id,\n\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\tgoto put_file;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\nout:\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_raw_tp_fops = {\n\t.release\t= bpf_raw_tracepoint_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fput",
          "args": [
            "file"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_task_fd_query_copy",
          "args": [
            "attr",
            "uattr",
            "prog_id",
            "fd_type",
            "buf",
            "probe_offset",
            "probe_addr"
          ],
          "line": 2437
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_task_fd_query_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2325-2370",
          "snippet": "static int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_perf_event_info",
          "args": [
            "event",
            "&prog_id",
            "&fd_type",
            "&buf",
            "&probe_offset",
            "&probe_addr"
          ],
          "line": 2433
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_perf_event_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1177-1222",
          "snippet": "int bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nint bpf_get_perf_event_info(const struct perf_event *event, u32 *prog_id,\n\t\t\t    u32 *fd_type, const char **buf,\n\t\t\t    u64 *probe_offset, u64 *probe_addr)\n{\n\tbool is_tracepoint, is_syscall_tp;\n\tstruct bpf_prog *prog;\n\tint flags, err = 0;\n\n\tprog = event->prog;\n\tif (!prog)\n\t\treturn -ENOENT;\n\n\t/* not supporting BPF_PROG_TYPE_PERF_EVENT yet */\n\tif (prog->type == BPF_PROG_TYPE_PERF_EVENT)\n\t\treturn -EOPNOTSUPP;\n\n\t*prog_id = prog->aux->id;\n\tflags = event->tp_event->flags;\n\tis_tracepoint = flags & TRACE_EVENT_FL_TRACEPOINT;\n\tis_syscall_tp = is_syscall_trace_event(event->tp_event);\n\n\tif (is_tracepoint || is_syscall_tp) {\n\t\t*buf = is_tracepoint ? event->tp_event->tp->name\n\t\t\t\t     : event->tp_event->name;\n\t\t*fd_type = BPF_FD_TYPE_TRACEPOINT;\n\t\t*probe_offset = 0x0;\n\t\t*probe_addr = 0x0;\n\t} else {\n\t\t/* kprobe/uprobe */\n\t\terr = -EOPNOTSUPP;\n#ifdef CONFIG_KPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_KPROBE)\n\t\t\terr = bpf_get_kprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset, probe_addr,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n#ifdef CONFIG_UPROBE_EVENTS\n\t\tif (flags & TRACE_EVENT_FL_UPROBE)\n\t\t\terr = bpf_get_uprobe_info(event, fd_type, buf,\n\t\t\t\t\t\t  probe_offset,\n\t\t\t\t\t\t  event->attr.type == PERF_TYPE_TRACEPOINT);\n#endif\n\t}\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "event"
          ],
          "line": 2428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_get_event",
          "args": [
            "file"
          ],
          "line": 2427
        },
        "resolved": true,
        "details": {
          "function_name": "perf_get_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "11252-11258",
          "snippet": "const struct perf_event *perf_get_event(struct file *file)\n{\n\tif (file->f_op != &perf_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file->private_data;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static const struct file_operations perf_fops;",
            "static const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic const struct file_operations perf_fops;\nstatic const struct file_operations perf_fops = {\n\t.llseek\t\t\t= no_llseek,\n\t.release\t\t= perf_release,\n\t.read\t\t\t= perf_read,\n\t.poll\t\t\t= perf_poll,\n\t.unlocked_ioctl\t\t= perf_ioctl,\n\t.compat_ioctl\t\t= perf_compat_ioctl,\n\t.mmap\t\t\t= perf_mmap,\n\t.fasync\t\t\t= perf_fasync,\n};\n\nconst struct perf_event *perf_get_event(struct file *file)\n{\n\tif (file->f_op != &perf_fops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_files_struct",
          "args": [
            "files"
          ],
          "line": 2411
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&files->file_lock"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_file",
          "args": [
            "file"
          ],
          "line": 2409
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "416-425",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fcheck_files",
          "args": [
            "files",
            "fd"
          ],
          "line": 2405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&files->file_lock"
          ],
          "line": 2404
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "task"
          ],
          "line": 2399
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_files_struct",
          "args": [
            "task"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_task",
          "args": [
            "find_vpid(pid)",
            "PIDTYPE_PID"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "pid"
          ],
          "line": 2394
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "262-265",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2388
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_TASK_FD_QUERY"
          ],
          "line": 2385
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_raw_tp_fops = {\n\t.release\t= bpf_raw_tracepoint_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic int bpf_task_fd_query(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tpid_t pid = attr->task_fd_query.pid;\n\tu32 fd = attr->task_fd_query.fd;\n\tconst struct perf_event *event;\n\tstruct files_struct *files;\n\tstruct task_struct *task;\n\tstruct file *file;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_TASK_FD_QUERY))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tif (attr->task_fd_query.flags != 0)\n\t\treturn -EINVAL;\n\n\ttask = get_pid_task(find_vpid(pid), PIDTYPE_PID);\n\tif (!task)\n\t\treturn -ENOENT;\n\n\tfiles = get_files_struct(task);\n\tput_task_struct(task);\n\tif (!files)\n\t\treturn -ENOENT;\n\n\terr = 0;\n\tspin_lock(&files->file_lock);\n\tfile = fcheck_files(files, fd);\n\tif (!file)\n\t\terr = -EBADF;\n\telse\n\t\tget_file(file);\n\tspin_unlock(&files->file_lock);\n\tput_files_struct(files);\n\n\tif (err)\n\t\tgoto out;\n\n\tif (file->f_op == &bpf_raw_tp_fops) {\n\t\tstruct bpf_raw_tracepoint *raw_tp = file->private_data;\n\t\tstruct bpf_raw_event_map *btp = raw_tp->btp;\n\n\t\terr = bpf_task_fd_query_copy(attr, uattr,\n\t\t\t\t\t     raw_tp->prog->aux->id,\n\t\t\t\t\t     BPF_FD_TYPE_RAW_TRACEPOINT,\n\t\t\t\t\t     btp->tp->name, 0, 0);\n\t\tgoto put_file;\n\t}\n\n\tevent = perf_get_event(file);\n\tif (!IS_ERR(event)) {\n\t\tu64 probe_offset, probe_addr;\n\t\tu32 prog_id, fd_type;\n\t\tconst char *buf;\n\n\t\terr = bpf_get_perf_event_info(event, &prog_id, &fd_type,\n\t\t\t\t\t      &buf, &probe_offset,\n\t\t\t\t\t      &probe_addr);\n\t\tif (!err)\n\t\t\terr = bpf_task_fd_query_copy(attr, uattr, prog_id,\n\t\t\t\t\t\t     fd_type, buf,\n\t\t\t\t\t\t     probe_offset,\n\t\t\t\t\t\t     probe_addr);\n\t\tgoto put_file;\n\t}\n\n\terr = -ENOTSUPP;\nput_file:\n\tfput(file);\nout:\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_task_fd_query_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2325-2370",
    "snippet": "static int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "probe_addr",
            "&uattr->task_fd_query.probe_addr"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "probe_offset",
            "&uattr->task_fd_query.probe_offset"
          ],
          "line": 2365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "fd_type",
            "&uattr->task_fd_query.fd_type"
          ],
          "line": 2364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "prog_id",
            "&uattr->task_fd_query.prog_id"
          ],
          "line": 2363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf + input_len - 1"
          ],
          "line": 2358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ubuf",
            "buf",
            "input_len - 1"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "zero",
            "ubuf"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "len",
            "&uattr->task_fd_query.buf_len"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 2332
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->task_fd_query.buf"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_task_fd_query_copy(const union bpf_attr *attr,\n\t\t\t\t    union bpf_attr __user *uattr,\n\t\t\t\t    u32 prog_id, u32 fd_type,\n\t\t\t\t    const char *buf, u64 probe_offset,\n\t\t\t\t    u64 probe_addr)\n{\n\tchar __user *ubuf = u64_to_user_ptr(attr->task_fd_query.buf);\n\tu32 len = buf ? strlen(buf) : 0, input_len;\n\tint err = 0;\n\n\tif (put_user(len, &uattr->task_fd_query.buf_len))\n\t\treturn -EFAULT;\n\tinput_len = attr->task_fd_query.buf_len;\n\tif (input_len && ubuf) {\n\t\tif (!len) {\n\t\t\t/* nothing to copy, just make ubuf NULL terminated */\n\t\t\tchar zero = '\\0';\n\n\t\t\tif (put_user(zero, ubuf))\n\t\t\t\treturn -EFAULT;\n\t\t} else if (input_len >= len + 1) {\n\t\t\t/* ubuf can hold the string with NULL terminator */\n\t\t\tif (copy_to_user(ubuf, buf, len + 1))\n\t\t\t\treturn -EFAULT;\n\t\t} else {\n\t\t\t/* ubuf cannot hold the string with NULL terminator,\n\t\t\t * do a partial copy with NULL terminator.\n\t\t\t */\n\t\t\tchar zero = '\\0';\n\n\t\t\terr = -ENOSPC;\n\t\t\tif (copy_to_user(ubuf, buf, input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (put_user(zero, ubuf + input_len - 1))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tif (put_user(prog_id, &uattr->task_fd_query.prog_id) ||\n\t    put_user(fd_type, &uattr->task_fd_query.fd_type) ||\n\t    put_user(probe_offset, &uattr->task_fd_query.probe_offset) ||\n\t    put_user(probe_addr, &uattr->task_fd_query.probe_addr))\n\t\treturn -EFAULT;\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_btf_get_fd_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2314-2323",
    "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_get_fd_by_id",
          "args": [
            "attr->btf_id"
          ],
          "line": 2322
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_fd_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2314-2323",
          "snippet": "static int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2319
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_BTF_GET_FD_BY_ID"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_fd_by_id(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_get_fd_by_id(attr->btf_id);\n}"
  },
  {
    "function_name": "bpf_btf_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2301-2310",
    "snippet": "static int bpf_btf_load(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_new_fd",
          "args": [
            "attr"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "btf_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2247-2276",
          "snippet": "int btf_new_fd(const union bpf_attr *attr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(u64_to_user_ptr(attr->btf),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nint btf_new_fd(const union bpf_attr *attr)\n{\n\tstruct btf *btf;\n\tint ret;\n\n\tbtf = btf_parse(u64_to_user_ptr(attr->btf),\n\t\t\tattr->btf_size, attr->btf_log_level,\n\t\t\tu64_to_user_ptr(attr->btf_log_buf),\n\t\t\tattr->btf_log_size);\n\tif (IS_ERR(btf))\n\t\treturn PTR_ERR(btf);\n\n\tret = btf_alloc_id(btf);\n\tif (ret) {\n\t\tbtf_free(btf);\n\t\treturn ret;\n\t}\n\n\t/*\n\t * The BTF ID is published to the userspace.\n\t * All BTF free must go through call_rcu() from\n\t * now on (i.e. free by calling btf_put()).\n\t */\n\n\tret = __btf_new_fd(btf);\n\tif (ret < 0)\n\t\tbtf_put(btf);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2306
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_BTF_LOAD"
          ],
          "line": 2303
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_load(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_BTF_LOAD))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn btf_new_fd(attr);\n}"
  },
  {
    "function_name": "bpf_obj_get_info_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2270-2297",
    "snippet": "static int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file->private_data, attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};",
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_btf_get_info_by_fd",
          "args": [
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 2291
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_info_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2253-2266",
          "snippet": "static int bpf_btf_get_info_by_fd(struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_info_by_fd(struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_get_info_by_fd",
          "args": [
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 2288
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_get_info_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2212-2251",
          "snippet": "static int bpf_map_get_info_by_fd(struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_get_info_by_fd(struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_info_by_fd",
          "args": [
            "f.file->private_data",
            "attr",
            "uattr"
          ],
          "line": 2285
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_info_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2035-2210",
          "snippet": "static int bpf_prog_get_info_by_fd(struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i]))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok()) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt;\n\tif (info.nr_jited_ksyms && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu64 __user *user_ksyms;\n\t\t\tulong ksym_addr;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tksym_addr = (ulong) prog->aux->func[i]->bpf_func;\n\t\t\t\tksym_addr &= PAGE_MASK;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt;\n\tif (info.nr_jited_func_lens && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tfunc_len = prog->aux->func[i]->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_info_by_fd(struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i]))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok()) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt;\n\tif (info.nr_jited_ksyms && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu64 __user *user_ksyms;\n\t\t\tulong ksym_addr;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tksym_addr = (ulong) prog->aux->func[i]->bpf_func;\n\t\t\t\tksym_addr &= PAGE_MASK;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt;\n\tif (info.nr_jited_func_lens && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tfunc_len = prog->aux->func[i]->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 2280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ_GET_INFO_BY_FD"
          ],
          "line": 2277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic int bpf_obj_get_info_by_fd(const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tint ufd = attr->info.bpf_fd;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_INFO_BY_FD))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tif (!f.file)\n\t\treturn -EBADFD;\n\n\tif (f.file->f_op == &bpf_prog_fops)\n\t\terr = bpf_prog_get_info_by_fd(f.file->private_data, attr,\n\t\t\t\t\t      uattr);\n\telse if (f.file->f_op == &bpf_map_fops)\n\t\terr = bpf_map_get_info_by_fd(f.file->private_data, attr,\n\t\t\t\t\t     uattr);\n\telse if (f.file->f_op == &btf_fops)\n\t\terr = bpf_btf_get_info_by_fd(f.file->private_data, attr, uattr);\n\telse\n\t\terr = -EINVAL;\n\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_btf_get_info_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2253-2266",
    "snippet": "static int bpf_btf_get_info_by_fd(struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "btf_get_info_by_fd",
          "args": [
            "btf",
            "attr",
            "uattr"
          ],
          "line": 2265
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_btf_get_info_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "2253-2266",
          "snippet": "static int bpf_btf_get_info_by_fd(struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "uinfo",
            "sizeof(*uinfo)",
            "info_len"
          ],
          "line": 2261
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "70-100",
          "snippet": "int bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 2257
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_btf_get_info_by_fd(struct btf *btf,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_btf_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(*uinfo), info_len);\n\tif (err)\n\t\treturn err;\n\n\treturn btf_get_info_by_fd(btf, attr, uattr);\n}"
  },
  {
    "function_name": "bpf_map_get_info_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2212-2251",
    "snippet": "static int bpf_map_get_info_by_fd(struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_len",
            "&uattr->info.info_len"
          ],
          "line": 2247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_len"
          ],
          "line": 2246
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_info_fill",
          "args": [
            "&info",
            "map"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_info_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "507-530",
          "snippet": "int bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map)\n{\n\tstruct ns_get_path_bpf_map_args args = {\n\t\t.offmap\t= map_to_offmap(map),\n\t\t.info\t= info,\n\t};\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tvoid *res;\n\n\tres = ns_get_path_cb(&ns_path, bpf_map_offload_info_fill_ns, &args);\n\tif (IS_ERR(res)) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn PTR_ERR(res);\n\t}\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nint bpf_map_offload_info_fill(struct bpf_map_info *info, struct bpf_map *map)\n{\n\tstruct ns_get_path_bpf_map_args args = {\n\t\t.offmap\t= map_to_offmap(map),\n\t\t.info\t= info,\n\t};\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tvoid *res;\n\n\tres = ns_get_path_cb(&ns_path, bpf_map_offload_info_fill_ns, &args);\n\tif (IS_ERR(res)) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn PTR_ERR(res);\n\t}\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 2240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_id",
          "args": [
            "map->btf"
          ],
          "line": 2235
        },
        "resolved": true,
        "details": {
          "function_name": "btf_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2352-2355",
          "snippet": "u32 btf_id(const struct btf *btf)\n{\n\treturn btf->id;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nu32 btf_id(const struct btf *btf)\n{\n\treturn btf->id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "info.name",
            "map->name",
            "sizeof(map->name)"
          ],
          "line": 2232
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sizeof(info)",
            "info_len"
          ],
          "line": 2224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "uinfo",
            "sizeof(info)",
            "info_len"
          ],
          "line": 2221
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "70-100",
          "snippet": "int bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_get_info_by_fd(struct bpf_map *map,\n\t\t\t\t  const union bpf_attr *attr,\n\t\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct bpf_map_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_map_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tinfo.type = map->map_type;\n\tinfo.id = map->id;\n\tinfo.key_size = map->key_size;\n\tinfo.value_size = map->value_size;\n\tinfo.max_entries = map->max_entries;\n\tinfo.map_flags = map->map_flags;\n\tmemcpy(info.name, map->name, sizeof(map->name));\n\n\tif (map->btf) {\n\t\tinfo.btf_id = btf_id(map->btf);\n\t\tinfo.btf_key_type_id = map->btf_key_type_id;\n\t\tinfo.btf_value_type_id = map->btf_value_type_id;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_info_fill(&info, map);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_get_info_by_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2035-2210",
    "snippet": "static int bpf_prog_get_info_by_fd(struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i]))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok()) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt;\n\tif (info.nr_jited_ksyms && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu64 __user *user_ksyms;\n\t\t\tulong ksym_addr;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tksym_addr = (ulong) prog->aux->func[i]->bpf_func;\n\t\t\t\tksym_addr &= PAGE_MASK;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt;\n\tif (info.nr_jited_func_lens && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tfunc_len = prog->aux->func[i]->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "info_len",
            "&uattr->info.info_len"
          ],
          "line": 2206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uinfo",
            "&info",
            "info_len"
          ],
          "line": 2205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "func_len",
            "&user_lens[i]"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_func_lens"
          ],
          "line": 2193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_jited_func_lens",
            "ulen"
          ],
          "line": 2192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "(u64) ksym_addr",
            "&user_ksyms[i]"
          ],
          "line": 2176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_ksyms"
          ],
          "line": 2172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_jited_ksyms",
            "ulen"
          ],
          "line": 2171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "len",
            "free"
          ],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.jited_prog_len",
            "ulen"
          ],
          "line": 2130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.jited_prog_insns"
          ],
          "line": 2129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_info_fill",
          "args": [
            "&info",
            "prog"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_info_fill",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "280-327",
          "snippet": "int bpf_prog_offload_info_fill(struct bpf_prog_info *info,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct ns_get_path_bpf_prog_args args = {\n\t\t.prog\t= prog,\n\t\t.info\t= info,\n\t};\n\tstruct bpf_prog_aux *aux = prog->aux;\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tchar __user *uinsns;\n\tvoid *res;\n\tu32 ulen;\n\n\tres = ns_get_path_cb(&ns_path, bpf_prog_offload_info_fill_ns, &args);\n\tif (IS_ERR(res)) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn PTR_ERR(res);\n\t}\n\n\tdown_read(&bpf_devs_lock);\n\n\tif (!aux->offload) {\n\t\tup_read(&bpf_devs_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tulen = info->jited_prog_len;\n\tinfo->jited_prog_len = aux->offload->jited_len;\n\tif (info->jited_prog_len & ulen) {\n\t\tuinsns = u64_to_user_ptr(info->jited_prog_insns);\n\t\tulen = min_t(u32, info->jited_prog_len, ulen);\n\t\tif (copy_to_user(uinsns, aux->offload->jited_image, ulen)) {\n\t\t\tup_read(&bpf_devs_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tup_read(&bpf_devs_lock);\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_prog_offload_info_fill(struct bpf_prog_info *info,\n\t\t\t       struct bpf_prog *prog)\n{\n\tstruct ns_get_path_bpf_prog_args args = {\n\t\t.prog\t= prog,\n\t\t.info\t= info,\n\t};\n\tstruct bpf_prog_aux *aux = prog->aux;\n\tstruct inode *ns_inode;\n\tstruct path ns_path;\n\tchar __user *uinsns;\n\tvoid *res;\n\tu32 ulen;\n\n\tres = ns_get_path_cb(&ns_path, bpf_prog_offload_info_fill_ns, &args);\n\tif (IS_ERR(res)) {\n\t\tif (!info->ifindex)\n\t\t\treturn -ENODEV;\n\t\treturn PTR_ERR(res);\n\t}\n\n\tdown_read(&bpf_devs_lock);\n\n\tif (!aux->offload) {\n\t\tup_read(&bpf_devs_lock);\n\t\treturn -ENODEV;\n\t}\n\n\tulen = info->jited_prog_len;\n\tinfo->jited_prog_len = aux->offload->jited_len;\n\tif (info->jited_prog_len & ulen) {\n\t\tuinsns = u64_to_user_ptr(info->jited_prog_insns);\n\t\tulen = min_t(u32, info->jited_prog_len, ulen);\n\t\tif (copy_to_user(uinsns, aux->offload->jited_image, ulen)) {\n\t\t\tup_read(&bpf_devs_lock);\n\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\tup_read(&bpf_devs_lock);\n\n\tns_inode = ns_path.dentry->d_inode;\n\tinfo->netns_dev = new_encode_dev(ns_inode->i_sb->s_dev);\n\tinfo->netns_ino = ns_inode->i_ino;\n\tpath_put(&ns_path);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 2105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "insns_sanitized"
          ],
          "line": 2100
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.xlated_prog_len",
            "ulen"
          ],
          "line": 2098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.xlated_prog_insns"
          ],
          "line": 2097
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_insn_prepare_dump",
          "args": [
            "prog"
          ],
          "line": 2094
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_insn_prepare_dump",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1985-2033",
          "snippet": "static struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu64 imm;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tif (insns[i].code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (insns[i].code == (BPF_JMP | BPF_CALL) ||\n\t\t    insns[i].code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (insns[i].code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok())\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insns[i].code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = BPF_PSEUDO_MAP_FD;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bpf_dump_raw_ok() &&\n\t\t    imm == (unsigned long)prog->aux) {\n\t\t\tinsns[i].imm = 0;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu64 imm;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tif (insns[i].code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (insns[i].code == (BPF_JMP | BPF_CALL) ||\n\t\t    insns[i].code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (insns[i].code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok())\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insns[i].code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = BPF_PSEUDO_MAP_FD;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bpf_dump_raw_ok() &&\n\t\t    imm == (unsigned long)prog->aux) {\n\t\t\tinsns[i].imm = 0;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 2085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 2077
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "prog->aux->used_maps[i]->id",
            "&user_map_ids[i]"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "info.map_ids"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "info.nr_map_ids",
            "ulen"
          ],
          "line": 2066
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "info.name",
            "prog->aux->name",
            "sizeof(prog->aux->name)"
          ],
          "line": 2062
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "prog->aux->user->uid"
          ],
          "line": 2057
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&info",
            "uinfo",
            "info_len"
          ],
          "line": 2051
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "min_t",
          "args": [
            "u32",
            "sizeof(info)",
            "info_len"
          ],
          "line": 2049
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_check_uarg_tail_zero",
          "args": [
            "uinfo",
            "sizeof(info)",
            "info_len"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check_uarg_tail_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "70-100",
          "snippet": "int bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->info.info"
          ],
          "line": 2039
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_get_info_by_fd(struct bpf_prog *prog,\n\t\t\t\t   const union bpf_attr *attr,\n\t\t\t\t   union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog_info __user *uinfo = u64_to_user_ptr(attr->info.info);\n\tstruct bpf_prog_info info = {};\n\tu32 info_len = attr->info.info_len;\n\tchar __user *uinsns;\n\tu32 ulen;\n\tint err;\n\n\terr = bpf_check_uarg_tail_zero(uinfo, sizeof(info), info_len);\n\tif (err)\n\t\treturn err;\n\tinfo_len = min_t(u32, sizeof(info), info_len);\n\n\tif (copy_from_user(&info, uinfo, info_len))\n\t\treturn -EFAULT;\n\n\tinfo.type = prog->type;\n\tinfo.id = prog->aux->id;\n\tinfo.load_time = prog->aux->load_time;\n\tinfo.created_by_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t       prog->aux->user->uid);\n\tinfo.gpl_compatible = prog->gpl_compatible;\n\n\tmemcpy(info.tag, prog->tag, sizeof(prog->tag));\n\tmemcpy(info.name, prog->aux->name, sizeof(prog->aux->name));\n\n\tulen = info.nr_map_ids;\n\tinfo.nr_map_ids = prog->aux->used_map_cnt;\n\tulen = min_t(u32, info.nr_map_ids, ulen);\n\tif (ulen) {\n\t\tu32 __user *user_map_ids = u64_to_user_ptr(info.map_ids);\n\t\tu32 i;\n\n\t\tfor (i = 0; i < ulen; i++)\n\t\t\tif (put_user(prog->aux->used_maps[i]->id,\n\t\t\t\t     &user_map_ids[i]))\n\t\t\t\treturn -EFAULT;\n\t}\n\n\tif (!capable(CAP_SYS_ADMIN)) {\n\t\tinfo.jited_prog_len = 0;\n\t\tinfo.xlated_prog_len = 0;\n\t\tinfo.nr_jited_ksyms = 0;\n\t\tgoto done;\n\t}\n\n\tulen = info.xlated_prog_len;\n\tinfo.xlated_prog_len = bpf_prog_insn_size(prog);\n\tif (info.xlated_prog_len && ulen) {\n\t\tstruct bpf_insn *insns_sanitized;\n\t\tbool fault;\n\n\t\tif (prog->blinded && !bpf_dump_raw_ok()) {\n\t\t\tinfo.xlated_prog_insns = 0;\n\t\t\tgoto done;\n\t\t}\n\t\tinsns_sanitized = bpf_insn_prepare_dump(prog);\n\t\tif (!insns_sanitized)\n\t\t\treturn -ENOMEM;\n\t\tuinsns = u64_to_user_ptr(info.xlated_prog_insns);\n\t\tulen = min_t(u32, info.xlated_prog_len, ulen);\n\t\tfault = copy_to_user(uinsns, insns_sanitized, ulen);\n\t\tkfree(insns_sanitized);\n\t\tif (fault)\n\t\t\treturn -EFAULT;\n\t}\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_info_fill(&info, prog);\n\t\tif (err)\n\t\t\treturn err;\n\t\tgoto done;\n\t}\n\n\t/* NOTE: the following code is supposed to be skipped for offload.\n\t * bpf_prog_offload_info_fill() is the place to fill similar fields\n\t * for offload.\n\t */\n\tulen = info.jited_prog_len;\n\tif (prog->aux->func_cnt) {\n\t\tu32 i;\n\n\t\tinfo.jited_prog_len = 0;\n\t\tfor (i = 0; i < prog->aux->func_cnt; i++)\n\t\t\tinfo.jited_prog_len += prog->aux->func[i]->jited_len;\n\t} else {\n\t\tinfo.jited_prog_len = prog->jited_len;\n\t}\n\n\tif (info.jited_prog_len && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tuinsns = u64_to_user_ptr(info.jited_prog_insns);\n\t\t\tulen = min_t(u32, info.jited_prog_len, ulen);\n\n\t\t\t/* for multi-function programs, copy the JITed\n\t\t\t * instructions for all the functions\n\t\t\t */\n\t\t\tif (prog->aux->func_cnt) {\n\t\t\t\tu32 len, free, i;\n\t\t\t\tu8 *img;\n\n\t\t\t\tfree = ulen;\n\t\t\t\tfor (i = 0; i < prog->aux->func_cnt; i++) {\n\t\t\t\t\tlen = prog->aux->func[i]->jited_len;\n\t\t\t\t\tlen = min_t(u32, len, free);\n\t\t\t\t\timg = (u8 *) prog->aux->func[i]->bpf_func;\n\t\t\t\t\tif (copy_to_user(uinsns, img, len))\n\t\t\t\t\t\treturn -EFAULT;\n\t\t\t\t\tuinsns += len;\n\t\t\t\t\tfree -= len;\n\t\t\t\t\tif (!free)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (copy_to_user(uinsns, prog->bpf_func, ulen))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_prog_insns = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_ksyms;\n\tinfo.nr_jited_ksyms = prog->aux->func_cnt;\n\tif (info.nr_jited_ksyms && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu64 __user *user_ksyms;\n\t\t\tulong ksym_addr;\n\t\t\tu32 i;\n\n\t\t\t/* copy the address of the kernel symbol\n\t\t\t * corresponding to each function\n\t\t\t */\n\t\t\tulen = min_t(u32, info.nr_jited_ksyms, ulen);\n\t\t\tuser_ksyms = u64_to_user_ptr(info.jited_ksyms);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tksym_addr = (ulong) prog->aux->func[i]->bpf_func;\n\t\t\t\tksym_addr &= PAGE_MASK;\n\t\t\t\tif (put_user((u64) ksym_addr, &user_ksyms[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_ksyms = 0;\n\t\t}\n\t}\n\n\tulen = info.nr_jited_func_lens;\n\tinfo.nr_jited_func_lens = prog->aux->func_cnt;\n\tif (info.nr_jited_func_lens && ulen) {\n\t\tif (bpf_dump_raw_ok()) {\n\t\t\tu32 __user *user_lens;\n\t\t\tu32 func_len, i;\n\n\t\t\t/* copy the JITed image lengths for each function */\n\t\t\tulen = min_t(u32, info.nr_jited_func_lens, ulen);\n\t\t\tuser_lens = u64_to_user_ptr(info.jited_func_lens);\n\t\t\tfor (i = 0; i < ulen; i++) {\n\t\t\t\tfunc_len = prog->aux->func[i]->jited_len;\n\t\t\t\tif (put_user(func_len, &user_lens[i]))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t}\n\t\t} else {\n\t\t\tinfo.jited_func_lens = 0;\n\t\t}\n\t}\n\ndone:\n\tif (copy_to_user(uinfo, &info, info_len) ||\n\t    put_user(info_len, &uattr->info.info_len))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_insn_prepare_dump",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1985-2033",
    "snippet": "static struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu64 imm;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tif (insns[i].code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (insns[i].code == (BPF_JMP | BPF_CALL) ||\n\t\t    insns[i].code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (insns[i].code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok())\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insns[i].code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = BPF_PSEUDO_MAP_FD;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bpf_dump_raw_ok() &&\n\t\t    imm == (unsigned long)prog->aux) {\n\t\t\tinsns[i].imm = 0;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2024
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_from_imm",
          "args": [
            "prog",
            "imm"
          ],
          "line": 2016
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_from_imm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1974-1983",
          "snippet": "static const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (prog->aux->used_maps[i] == (void *)addr)\n\t\t\treturn prog->aux->used_maps[i];\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (prog->aux->used_maps[i] == (void *)addr)\n\t\t\treturn prog->aux->used_maps[i];\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_dump_raw_ok",
          "args": [],
          "line": 2007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmemdup",
          "args": [
            "prog->insnsi",
            "bpf_prog_insn_size(prog)",
            "GFP_USER"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 1992
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_insn *bpf_insn_prepare_dump(const struct bpf_prog *prog)\n{\n\tconst struct bpf_map *map;\n\tstruct bpf_insn *insns;\n\tu64 imm;\n\tint i;\n\n\tinsns = kmemdup(prog->insnsi, bpf_prog_insn_size(prog),\n\t\t\tGFP_USER);\n\tif (!insns)\n\t\treturn insns;\n\n\tfor (i = 0; i < prog->len; i++) {\n\t\tif (insns[i].code == (BPF_JMP | BPF_TAIL_CALL)) {\n\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tinsns[i].imm = BPF_FUNC_tail_call;\n\t\t\t/* fall-through */\n\t\t}\n\t\tif (insns[i].code == (BPF_JMP | BPF_CALL) ||\n\t\t    insns[i].code == (BPF_JMP | BPF_CALL_ARGS)) {\n\t\t\tif (insns[i].code == (BPF_JMP | BPF_CALL_ARGS))\n\t\t\t\tinsns[i].code = BPF_JMP | BPF_CALL;\n\t\t\tif (!bpf_dump_raw_ok())\n\t\t\t\tinsns[i].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (insns[i].code != (BPF_LD | BPF_IMM | BPF_DW))\n\t\t\tcontinue;\n\n\t\timm = ((u64)insns[i + 1].imm << 32) | (u32)insns[i].imm;\n\t\tmap = bpf_map_from_imm(prog, imm);\n\t\tif (map) {\n\t\t\tinsns[i].src_reg = BPF_PSEUDO_MAP_FD;\n\t\t\tinsns[i].imm = map->id;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!bpf_dump_raw_ok() &&\n\t\t    imm == (unsigned long)prog->aux) {\n\t\t\tinsns[i].imm = 0;\n\t\t\tinsns[i + 1].imm = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n\n\treturn insns;\n}"
  },
  {
    "function_name": "bpf_map_from_imm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1974-1983",
    "snippet": "static const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (prog->aux->used_maps[i] == (void *)addr)\n\t\t\treturn prog->aux->used_maps[i];\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map *bpf_map_from_imm(const struct bpf_prog *prog,\n\t\t\t\t\t      unsigned long addr)\n{\n\tint i;\n\n\tfor (i = 0; i < prog->aux->used_map_cnt; i++)\n\t\tif (prog->aux->used_maps[i] == (void *)addr)\n\t\t\treturn prog->aux->used_maps[i];\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_map_get_fd_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1938-1972",
    "snippet": "static int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put(map);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_new_fd",
          "args": [
            "map",
            "f_flags"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "404-414",
          "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1964
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 1962
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc_not_zero",
          "args": [
            "map",
            "true"
          ],
          "line": 1959
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "628-647",
          "snippet": "static struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstatic struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&map_idr",
            "id"
          ],
          "line": 1957
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_get_file_flag",
          "args": [
            "attr->open_flags"
          ],
          "line": 1952
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "416-425",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1949
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_GET_FD_BY_ID"
          ],
          "line": 1945
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_map *map;\n\tu32 id = attr->map_id;\n\tint f_flags;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_FD_BY_ID) ||\n\t    attr->open_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tf_flags = bpf_get_file_flag(attr->open_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tspin_lock_bh(&map_idr_lock);\n\tmap = idr_find(&map_idr, id);\n\tif (map)\n\t\tmap = bpf_map_inc_not_zero(map, true);\n\telse\n\t\tmap = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&map_idr_lock);\n\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tfd = bpf_map_new_fd(map, f_flags);\n\tif (fd < 0)\n\t\tbpf_map_put(map);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_prog_get_fd_by_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1906-1934",
    "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1931
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_new_fd",
          "args": [
            "prog"
          ],
          "line": 1929
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1265-1275",
          "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1924
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc_not_zero",
          "args": [
            "prog"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1317-1332",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_find",
          "args": [
            "&prog_idr",
            "id"
          ],
          "line": 1919
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1915
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_GET_FD_BY_ID"
          ],
          "line": 1912
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
  },
  {
    "function_name": "bpf_obj_get_next_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1878-1902",
    "snippet": "static int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_user",
          "args": [
            "next_id",
            "&uattr->next_id"
          ],
          "line": 1899
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "lock"
          ],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_next",
          "args": [
            "idr",
            "&next_id"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "lock"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1889
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ_GET_NEXT_ID"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_get_next_id(const union bpf_attr *attr,\n\t\t\t       union bpf_attr __user *uattr,\n\t\t\t       struct idr *idr,\n\t\t\t       spinlock_t *lock)\n{\n\tu32 next_id = attr->start_id;\n\tint err = 0;\n\n\tif (CHECK_ATTR(BPF_OBJ_GET_NEXT_ID) || next_id >= INT_MAX)\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tnext_id++;\n\tspin_lock_bh(lock);\n\tif (!idr_get_next(idr, &next_id))\n\t\terr = -ENOENT;\n\tspin_unlock_bh(lock);\n\n\tif (!err)\n\t\terr = put_user(next_id, &uattr->next_id);\n\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_prog_test_run",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1854-1874",
    "snippet": "static int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prog->aux->ops->test_run",
          "args": [
            "prog",
            "attr",
            "uattr"
          ],
          "line": 1870
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get",
          "args": [
            "attr->test.prog_fd"
          ],
          "line": 1865
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_fd_by_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1906-1934",
          "snippet": "static int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_get_fd_by_id(const union bpf_attr *attr)\n{\n\tstruct bpf_prog *prog;\n\tu32 id = attr->prog_id;\n\tint fd;\n\n\tif (CHECK_ATTR(BPF_PROG_GET_FD_BY_ID))\n\t\treturn -EINVAL;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tspin_lock_bh(&prog_idr_lock);\n\tprog = idr_find(&prog_idr, id);\n\tif (prog)\n\t\tprog = bpf_prog_inc_not_zero(prog);\n\telse\n\t\tprog = ERR_PTR(-ENOENT);\n\tspin_unlock_bh(&prog_idr_lock);\n\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tfd = bpf_prog_new_fd(prog);\n\tif (fd < 0)\n\t\tbpf_prog_put(prog);\n\n\treturn fd;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_TEST_RUN"
          ],
          "line": 1862
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1860
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_test_run(const union bpf_attr *attr,\n\t\t\t     union bpf_attr __user *uattr)\n{\n\tstruct bpf_prog *prog;\n\tint ret = -ENOTSUPP;\n\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_TEST_RUN))\n\t\treturn -EINVAL;\n\n\tprog = bpf_prog_get(attr->test.prog_fd);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (prog->aux->ops->test_run)\n\t\tret = prog->aux->ops->test_run(prog, attr, uattr);\n\n\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_prog_query",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1818-1850",
    "snippet": "static int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\t\tbreak;\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cgroup_bpf_prog_query(attr, uattr);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_query",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_query",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "519-533",
          "snippet": "int cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->query.target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_query(cgrp, attr, uattr);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lirc_prog_query",
          "args": [
            "attr",
            "uattr"
          ],
          "line": 1844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_QUERY"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 1821
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_query(const union bpf_attr *attr,\n\t\t\t  union bpf_attr __user *uattr)\n{\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\tif (CHECK_ATTR(BPF_PROG_QUERY))\n\t\treturn -EINVAL;\n\tif (attr->query.query_flags & ~BPF_F_QUERY_EFFECTIVE)\n\t\treturn -EINVAL;\n\n\tswitch (attr->query.attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\tcase BPF_CGROUP_SOCK_OPS:\n\tcase BPF_CGROUP_DEVICE:\n\t\tbreak;\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_query(attr, uattr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cgroup_bpf_prog_query(attr, uattr);\n}"
  },
  {
    "function_name": "bpf_prog_detach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1766-1814",
    "snippet": "static int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tswitch (attr->attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SKB;\n\t\tbreak;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK;\n\t\tbreak;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\t\tbreak;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\tptype = BPF_PROG_TYPE_SOCK_OPS;\n\t\tbreak;\n\tcase BPF_CGROUP_DEVICE:\n\t\tptype = BPF_PROG_TYPE_CGROUP_DEVICE;\n\t\tbreak;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn sock_map_get_from_fd(attr, NULL);\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\t\treturn sock_map_get_from_fd(attr, NULL);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn skb_flow_dissector_bpf_prog_detach(attr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cgroup_bpf_prog_detach(attr, ptype);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_detach",
          "args": [
            "attr",
            "ptype"
          ],
          "line": 1813
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_detach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "497-517",
          "snippet": "int cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type, 0);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_detach(const union bpf_attr *attr, enum bpf_prog_type ptype)\n{\n\tstruct bpf_prog *prog;\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\tprog = NULL;\n\n\tret = cgroup_bpf_detach(cgrp, prog, attr->attach_type, 0);\n\tif (prog)\n\t\tbpf_prog_put(prog);\n\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_flow_dissector_bpf_prog_detach",
          "args": [
            "attr"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lirc_prog_detach",
          "args": [
            "attr"
          ],
          "line": 1806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_get_from_fd",
          "args": [
            "attr",
            "NULL"
          ],
          "line": 1804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_get_from_fd",
          "args": [
            "attr",
            "NULL"
          ],
          "line": 1801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_DETACH"
          ],
          "line": 1773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 1770
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_detach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (CHECK_ATTR(BPF_PROG_DETACH))\n\t\treturn -EINVAL;\n\n\tswitch (attr->attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SKB;\n\t\tbreak;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK;\n\t\tbreak;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\t\tbreak;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\tptype = BPF_PROG_TYPE_SOCK_OPS;\n\t\tbreak;\n\tcase BPF_CGROUP_DEVICE:\n\t\tptype = BPF_PROG_TYPE_CGROUP_DEVICE;\n\t\tbreak;\n\tcase BPF_SK_MSG_VERDICT:\n\t\treturn sock_map_get_from_fd(attr, NULL);\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\t\treturn sock_map_get_from_fd(attr, NULL);\n\tcase BPF_LIRC_MODE2:\n\t\treturn lirc_prog_detach(attr);\n\tcase BPF_FLOW_DISSECTOR:\n\t\treturn skb_flow_dissector_bpf_prog_detach(attr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\treturn cgroup_bpf_prog_detach(attr, ptype);\n}"
  },
  {
    "function_name": "bpf_prog_attach",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1679-1762",
    "snippet": "static int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tswitch (attr->attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SKB;\n\t\tbreak;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK;\n\t\tbreak;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\t\tbreak;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\tptype = BPF_PROG_TYPE_SOCK_OPS;\n\t\tbreak;\n\tcase BPF_CGROUP_DEVICE:\n\t\tptype = BPF_PROG_TYPE_CGROUP_DEVICE;\n\t\tbreak;\n\tcase BPF_SK_MSG_VERDICT:\n\t\tptype = BPF_PROG_TYPE_SK_MSG;\n\t\tbreak;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\t\tptype = BPF_PROG_TYPE_SK_SKB;\n\t\tbreak;\n\tcase BPF_LIRC_MODE2:\n\t\tptype = BPF_PROG_TYPE_LIRC_MODE2;\n\t\tbreak;\n\tcase BPF_FLOW_DISSECTOR:\n\t\tptype = BPF_PROG_TYPE_FLOW_DISSECTOR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = skb_flow_dissector_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1760
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_bpf_prog_attach",
          "args": [
            "attr",
            "ptype",
            "prog"
          ],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_bpf_prog_attach",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/cgroup.c",
          "lines": "481-495",
          "snippet": "int cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_attach(cgrp, prog, attr->attach_type,\n\t\t\t\tattr->attach_flags);\n\tcgroup_put(cgrp);\n\treturn ret;\n}",
          "includes": [
            "#include <net/sock.h>",
            "#include <linux/bpf-cgroup.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock.h>\n#include <linux/bpf-cgroup.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/cgroup.h>\n#include <linux/atomic.h>\n#include <linux/kernel.h>\n\nint cgroup_bpf_prog_attach(const union bpf_attr *attr,\n\t\t\t   enum bpf_prog_type ptype, struct bpf_prog *prog)\n{\n\tstruct cgroup *cgrp;\n\tint ret;\n\n\tcgrp = cgroup_get_from_fd(attr->target_fd);\n\tif (IS_ERR(cgrp))\n\t\treturn PTR_ERR(cgrp);\n\n\tret = cgroup_bpf_attach(cgrp, prog, attr->attach_type,\n\t\t\t\tattr->attach_flags);\n\tcgroup_put(cgrp);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "skb_flow_dissector_bpf_prog_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lirc_prog_attach",
          "args": [
            "attr",
            "prog"
          ],
          "line": 1750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sock_map_get_from_fd",
          "args": [
            "attr",
            "prog"
          ],
          "line": 1747
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_attach_check_attach_type",
          "args": [
            "prog",
            "attr->attach_type"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_attach_check_attach_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1662-1672",
          "snippet": "static int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->attach_bpf_fd",
            "ptype"
          ],
          "line": 1735
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "542-554",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_ATTACH"
          ],
          "line": 1688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_NET_ADMIN"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_F_ATTACH_MASK \\\n\t(BPF_F_ALLOW_OVERRIDE | BPF_F_ALLOW_MULTI)\n\nstatic int bpf_prog_attach(const union bpf_attr *attr)\n{\n\tenum bpf_prog_type ptype;\n\tstruct bpf_prog *prog;\n\tint ret;\n\n\tif (!capable(CAP_NET_ADMIN))\n\t\treturn -EPERM;\n\n\tif (CHECK_ATTR(BPF_PROG_ATTACH))\n\t\treturn -EINVAL;\n\n\tif (attr->attach_flags & ~BPF_F_ATTACH_MASK)\n\t\treturn -EINVAL;\n\n\tswitch (attr->attach_type) {\n\tcase BPF_CGROUP_INET_INGRESS:\n\tcase BPF_CGROUP_INET_EGRESS:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SKB;\n\t\tbreak;\n\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\tcase BPF_CGROUP_INET4_POST_BIND:\n\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK;\n\t\tbreak;\n\tcase BPF_CGROUP_INET4_BIND:\n\tcase BPF_CGROUP_INET6_BIND:\n\tcase BPF_CGROUP_INET4_CONNECT:\n\tcase BPF_CGROUP_INET6_CONNECT:\n\tcase BPF_CGROUP_UDP4_SENDMSG:\n\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\tptype = BPF_PROG_TYPE_CGROUP_SOCK_ADDR;\n\t\tbreak;\n\tcase BPF_CGROUP_SOCK_OPS:\n\t\tptype = BPF_PROG_TYPE_SOCK_OPS;\n\t\tbreak;\n\tcase BPF_CGROUP_DEVICE:\n\t\tptype = BPF_PROG_TYPE_CGROUP_DEVICE;\n\t\tbreak;\n\tcase BPF_SK_MSG_VERDICT:\n\t\tptype = BPF_PROG_TYPE_SK_MSG;\n\t\tbreak;\n\tcase BPF_SK_SKB_STREAM_PARSER:\n\tcase BPF_SK_SKB_STREAM_VERDICT:\n\t\tptype = BPF_PROG_TYPE_SK_SKB;\n\t\tbreak;\n\tcase BPF_LIRC_MODE2:\n\t\tptype = BPF_PROG_TYPE_LIRC_MODE2;\n\t\tbreak;\n\tcase BPF_FLOW_DISSECTOR:\n\t\tptype = BPF_PROG_TYPE_FLOW_DISSECTOR;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tprog = bpf_prog_get_type(attr->attach_bpf_fd, ptype);\n\tif (IS_ERR(prog))\n\t\treturn PTR_ERR(prog);\n\n\tif (bpf_prog_attach_check_attach_type(prog, attr->attach_type)) {\n\t\tbpf_prog_put(prog);\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (ptype) {\n\tcase BPF_PROG_TYPE_SK_SKB:\n\tcase BPF_PROG_TYPE_SK_MSG:\n\t\tret = sock_map_get_from_fd(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_LIRC_MODE2:\n\t\tret = lirc_prog_attach(attr, prog);\n\t\tbreak;\n\tcase BPF_PROG_TYPE_FLOW_DISSECTOR:\n\t\tret = skb_flow_dissector_bpf_prog_attach(attr, prog);\n\t\tbreak;\n\tdefault:\n\t\tret = cgroup_bpf_prog_attach(attr, ptype, prog);\n\t}\n\n\tif (ret)\n\t\tbpf_prog_put(prog);\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_prog_attach_check_attach_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1662-1672",
    "snippet": "static int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_attach_check_attach_type(const struct bpf_prog *prog,\n\t\t\t\t\t     enum bpf_attach_type attach_type)\n{\n\tswitch (prog->type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\treturn attach_type == prog->expected_attach_type ? 0 : -EINVAL;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "bpf_raw_tracepoint_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1612-1660",
    "snippet": "static int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_raw_tracepoint *raw_tp;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tchar tp_name[128];\n\tint tp_fd, err;\n\n\tif (strncpy_from_user(tp_name, u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t      sizeof(tp_name) - 1) < 0)\n\t\treturn -EFAULT;\n\ttp_name[sizeof(tp_name) - 1] = 0;\n\n\tbtp = bpf_find_raw_tracepoint(tp_name);\n\tif (!btp)\n\t\treturn -ENOENT;\n\n\traw_tp = kzalloc(sizeof(*raw_tp), GFP_USER);\n\tif (!raw_tp)\n\t\treturn -ENOMEM;\n\traw_tp->btp = btp;\n\n\tprog = bpf_prog_get_type(attr->raw_tracepoint.prog_fd,\n\t\t\t\t BPF_PROG_TYPE_RAW_TRACEPOINT);\n\tif (IS_ERR(prog)) {\n\t\terr = PTR_ERR(prog);\n\t\tgoto out_free_tp;\n\t}\n\n\terr = bpf_probe_register(raw_tp->btp, prog);\n\tif (err)\n\t\tgoto out_put_prog;\n\n\traw_tp->prog = prog;\n\ttp_fd = anon_inode_getfd(\"bpf-raw-tracepoint\", &bpf_raw_tp_fops, raw_tp,\n\t\t\t\t O_CLOEXEC);\n\tif (tp_fd < 0) {\n\t\tbpf_probe_unregister(raw_tp->btp, prog);\n\t\terr = tp_fd;\n\t\tgoto out_put_prog;\n\t}\n\treturn tp_fd;\n\nout_put_prog:\n\tbpf_prog_put(prog);\nout_free_tp:\n\tkfree(raw_tp);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct file_operations bpf_raw_tp_fops = {\n\t.release\t= bpf_raw_tracepoint_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "raw_tp"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_probe_unregister",
          "args": [
            "raw_tp->btp",
            "prog"
          ],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_probe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1167-1175",
          "snippet": "int bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(bpf_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-raw-tracepoint\"",
            "&bpf_raw_tp_fops",
            "raw_tp",
            "O_CLOEXEC"
          ],
          "line": 1646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_probe_register",
          "args": [
            "raw_tp->btp",
            "prog"
          ],
          "line": 1641
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_probe_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1157-1165",
          "snippet": "int bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = __bpf_probe_register(btp, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(bpf_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint bpf_probe_register(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = __bpf_probe_register(btp, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "prog"
          ],
          "line": 1637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_type",
          "args": [
            "attr->raw_tracepoint.prog_fd",
            "BPF_PROG_TYPE_RAW_TRACEPOINT"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_type_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "542-554",
          "snippet": "struct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nstruct bpf_prog *bpf_prog_get_type_path(const char *name, enum bpf_prog_type type)\n{\n\tstruct bpf_prog *prog;\n\tstruct path path;\n\tint ret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\tprog = __get_prog_inode(d_backing_inode(path.dentry), type);\n\tif (!IS_ERR(prog))\n\t\ttouch_atime(&path);\n\tpath_put(&path);\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*raw_tp)",
            "GFP_USER"
          ],
          "line": 1629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_find_raw_tracepoint",
          "args": [
            "tp_name"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_find_raw_tracepoint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1077-1086",
          "snippet": "struct bpf_raw_event_map *bpf_find_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern struct bpf_raw_event_map __start__bpf_raw_tp[];",
            "extern struct bpf_raw_event_map __stop__bpf_raw_tp[];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nextern struct bpf_raw_event_map __start__bpf_raw_tp[];\nextern struct bpf_raw_event_map __stop__bpf_raw_tp[];\n\nstruct bpf_raw_event_map *bpf_find_raw_tracepoint(const char *name)\n{\n\tstruct bpf_raw_event_map *btp = __start__bpf_raw_tp;\n\n\tfor (; btp < __stop__bpf_raw_tp; btp++) {\n\t\tif (!strcmp(btp->tp->name, name))\n\t\t\treturn btp;\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "tp_name",
            "u64_to_user_ptr(attr->raw_tracepoint.name)",
            "sizeof(tp_name) - 1"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->raw_tracepoint.name"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct file_operations bpf_raw_tp_fops = {\n\t.release\t= bpf_raw_tracepoint_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic int bpf_raw_tracepoint_open(const union bpf_attr *attr)\n{\n\tstruct bpf_raw_tracepoint *raw_tp;\n\tstruct bpf_raw_event_map *btp;\n\tstruct bpf_prog *prog;\n\tchar tp_name[128];\n\tint tp_fd, err;\n\n\tif (strncpy_from_user(tp_name, u64_to_user_ptr(attr->raw_tracepoint.name),\n\t\t\t      sizeof(tp_name) - 1) < 0)\n\t\treturn -EFAULT;\n\ttp_name[sizeof(tp_name) - 1] = 0;\n\n\tbtp = bpf_find_raw_tracepoint(tp_name);\n\tif (!btp)\n\t\treturn -ENOENT;\n\n\traw_tp = kzalloc(sizeof(*raw_tp), GFP_USER);\n\tif (!raw_tp)\n\t\treturn -ENOMEM;\n\traw_tp->btp = btp;\n\n\tprog = bpf_prog_get_type(attr->raw_tracepoint.prog_fd,\n\t\t\t\t BPF_PROG_TYPE_RAW_TRACEPOINT);\n\tif (IS_ERR(prog)) {\n\t\terr = PTR_ERR(prog);\n\t\tgoto out_free_tp;\n\t}\n\n\terr = bpf_probe_register(raw_tp->btp, prog);\n\tif (err)\n\t\tgoto out_put_prog;\n\n\traw_tp->prog = prog;\n\ttp_fd = anon_inode_getfd(\"bpf-raw-tracepoint\", &bpf_raw_tp_fops, raw_tp,\n\t\t\t\t O_CLOEXEC);\n\tif (tp_fd < 0) {\n\t\tbpf_probe_unregister(raw_tp->btp, prog);\n\t\terr = tp_fd;\n\t\tgoto out_put_prog;\n\t}\n\treturn tp_fd;\n\nout_put_prog:\n\tbpf_prog_put(prog);\nout_free_tp:\n\tkfree(raw_tp);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_raw_tracepoint_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1592-1602",
    "snippet": "static int bpf_raw_tracepoint_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_raw_tracepoint *raw_tp = filp->private_data;\n\n\tif (raw_tp->prog) {\n\t\tbpf_probe_unregister(raw_tp->btp, raw_tp->prog);\n\t\tbpf_prog_put(raw_tp->prog);\n\t}\n\tkfree(raw_tp);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "raw_tp"
          ],
          "line": 1600
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "raw_tp->prog"
          ],
          "line": 1598
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_probe_unregister",
          "args": [
            "raw_tp->btp",
            "raw_tp->prog"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_probe_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/bpf_trace.c",
          "lines": "1167-1175",
          "snippet": "int bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_perf_event.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(bpf_event_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"trace_probe.h\"\n#include <linux/error-injection.h>\n#include <linux/syscalls.h>\n#include <linux/kprobes.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/filter.h>\n#include <linux/bpf_perf_event.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_MUTEX(bpf_event_mutex);\n\nint bpf_probe_unregister(struct bpf_raw_event_map *btp, struct bpf_prog *prog)\n{\n\tint err;\n\n\tmutex_lock(&bpf_event_mutex);\n\terr = tracepoint_probe_unregister(btp->tp, (void *)btp->bpf_func, prog);\n\tmutex_unlock(&bpf_event_mutex);\n\treturn err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_raw_tracepoint_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_raw_tracepoint *raw_tp = filp->private_data;\n\n\tif (raw_tp->prog) {\n\t\tbpf_probe_unregister(raw_tp->btp, raw_tp->prog);\n\t\tbpf_prog_put(raw_tp->prog);\n\t}\n\tkfree(raw_tp);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_obj_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1577-1585",
    "snippet": "static int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_obj_get_user",
          "args": [
            "u64_to_user_ptr(attr->pathname)",
            "attr->file_flags"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->pathname"
          ],
          "line": 1583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_OBJ_FLAG_MASK   (BPF_F_RDONLY | BPF_F_WRONLY)\n\nstatic int bpf_obj_get(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->bpf_fd != 0 ||\n\t    attr->file_flags & ~BPF_OBJ_FLAG_MASK)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_get_user(u64_to_user_ptr(attr->pathname),\n\t\t\t\tattr->file_flags);\n}"
  },
  {
    "function_name": "bpf_obj_pin",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1569-1575",
    "snippet": "static int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_obj_pin_user",
          "args": [
            "attr->bpf_fd",
            "u64_to_user_ptr(attr->pathname)"
          ],
          "line": 1574
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_pin_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "425-448",
          "snippet": "int bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tstruct filename *pname;\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tret = bpf_obj_do_pin(pname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_pin_user(u32 ufd, const char __user *pathname)\n{\n\tstruct filename *pname;\n\tenum bpf_type type;\n\tvoid *raw;\n\tint ret;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_fd_probe_obj(ufd, &type);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tret = bpf_obj_do_pin(pname, raw, type);\n\tif (ret != 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->pathname"
          ],
          "line": 1574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_OBJ"
          ],
          "line": 1571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_pin(const union bpf_attr *attr)\n{\n\tif (CHECK_ATTR(BPF_OBJ) || attr->file_flags != 0)\n\t\treturn -EINVAL;\n\n\treturn bpf_obj_pin_user(attr->bpf_fd, u64_to_user_ptr(attr->pathname));\n}"
  },
  {
    "function_name": "bpf_prog_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1442-1565",
    "snippet": "static int bpf_prog_load(union bpf_attr *attr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~BPF_F_STRICT_ALIGNMENT)\n\t\treturn -EINVAL;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_user(license, u64_to_user_ptr(attr->license),\n\t\t\t      sizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 || attr->insn_cnt > BPF_MAXINSNS)\n\t\treturn -E2BIG;\n\n\tif (type == BPF_PROG_TYPE_KPROBE &&\n\t    attr->kern_version != LINUX_VERSION_CODE)\n\t\treturn -EINVAL;\n\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach_type(type, attr->expected_attach_type))\n\t\treturn -EINVAL;\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog)\n\t\treturn -ENOMEM;\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog_nouncharge;\n\n\terr = bpf_prog_charge_memlock(prog);\n\tif (err)\n\t\tgoto free_prog_sec;\n\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_user(prog->insns, u64_to_user_ptr(attr->insns),\n\t\t\t   bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog;\n\n\tprog->aux->load_time = ktime_get_boot_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name);\n\tif (err)\n\t\tgoto free_prog;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_prog_put() is needed because the above\n\t\t * bpf_prog_alloc_id() has published the prog\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_PROG_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_prog_put(prog);\n\t\treturn err;\n\t}\n\n\tbpf_prog_kallsyms_add(prog);\n\treturn err;\n\nfree_used_maps:\n\tbpf_prog_kallsyms_del_subprogs(prog);\n\tfree_used_maps(prog->aux);\nfree_prog:\n\tbpf_prog_uncharge_memlock(prog);\nfree_prog_sec:\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog_nouncharge:\n\tbpf_prog_free(prog);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_free",
          "args": [
            "prog"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1790-1796",
          "snippet": "void bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_free",
          "args": [
            "prog->aux"
          ],
          "line": 1561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_uncharge_memlock",
          "args": [
            "prog"
          ],
          "line": 1559
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1149-1155",
          "snippet": "static void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_used_maps",
          "args": [
            "prog->aux"
          ],
          "line": 1557
        },
        "resolved": true,
        "details": {
          "function_name": "free_used_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1094-1110",
          "snippet": "static void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del_subprogs",
          "args": [
            "prog"
          ],
          "line": 1556
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del_subprogs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "353-359",
          "snippet": "void bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del_subprogs(struct bpf_prog *fp)\n{\n\tint i;\n\n\tfor (i = 0; i < fp->aux->func_cnt; i++)\n\t\tbpf_prog_kallsyms_del(fp->aux->func[i]);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_add",
          "args": [
            "prog"
          ],
          "line": 1552
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "484-493",
          "snippet": "void bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_add(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_add(struct bpf_prog *fp)\n{\n\tif (!bpf_prog_kallsyms_candidate(fp) ||\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn;\n\n\tspin_lock_bh(&bpf_lock);\n\tbpf_prog_ksym_node_add(fp->aux);\n\tspin_unlock_bh(&bpf_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1548
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_new_fd",
          "args": [
            "prog"
          ],
          "line": 1540
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1265-1275",
          "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_alloc_id",
          "args": [
            "prog"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_alloc_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1157-1174",
          "snippet": "static int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_select_runtime",
          "args": [
            "prog",
            "&err"
          ],
          "line": 1532
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_select_runtime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1513-1554",
          "snippet": "struct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\tfp = bpf_int_jit_compile(fp);\n#ifdef CONFIG_BPF_JIT_ALWAYS_ON\n\t\tif (!fp->jited) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n#endif\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_select_runtime(struct bpf_prog *fp, int *err)\n{\n\t/* In case of BPF to BPF calls, verifier did all the prep\n\t * work with regards to JITing, etc.\n\t */\n\tif (fp->bpf_func)\n\t\tgoto finalize;\n\n\tbpf_prog_select_func(fp);\n\n\t/* eBPF JITs can rewrite the program in case constant\n\t * blinding is active. However, in case of error during\n\t * blinding, bpf_int_jit_compile() must always return a\n\t * valid program, which in this case would simply not\n\t * be JITed, but falls back to the interpreter.\n\t */\n\tif (!bpf_prog_is_dev_bound(fp->aux)) {\n\t\tfp = bpf_int_jit_compile(fp);\n#ifdef CONFIG_BPF_JIT_ALWAYS_ON\n\t\tif (!fp->jited) {\n\t\t\t*err = -ENOTSUPP;\n\t\t\treturn fp;\n\t\t}\n#endif\n\t} else {\n\t\t*err = bpf_prog_offload_compile(fp);\n\t\tif (*err)\n\t\t\treturn fp;\n\t}\n\nfinalize:\n\tbpf_prog_lock_ro(fp);\n\n\t/* The tail call compatibility check can only be done at\n\t * this late stage as we need to determine, if we deal\n\t * with JITed or non JITed program concatenations and not\n\t * all eBPF JITs might immediately support all features.\n\t */\n\t*err = bpf_check_tail_call(fp);\n\n\treturn fp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_check",
          "args": [
            "&prog",
            "attr"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/verifier.c",
          "lines": "6305-6447",
          "snippet": "int bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tstruct bpf_verifier_env *env;\n\tstruct bpf_verifier_log *log;\n\tint ret = -EINVAL;\n\n\t/* no program is valid */\n\tif (ARRAY_SIZE(bpf_verifier_ops) == 0)\n\t\treturn -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\tlog = &env->log;\n\n\tenv->insn_aux_data =\n\t\tvzalloc(array_size(sizeof(struct bpf_insn_aux_data),\n\t\t\t\t   (*prog)->len));\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\tenv->ops = bpf_verifier_ops[env->prog->type];\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = attr->log_level;\n\t\tlog->ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog->len_total = attr->log_size;\n\n\t\tret = -EINVAL;\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf)\n\t\t\tgoto err_unlock;\n\t}\n\n\tenv->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\tenv->strict_alignment = true;\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\tret = bpf_prog_offload_verifier_prep(env);\n\t\tif (ret)\n\t\t\tgoto skip_full_check;\n\t}\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = do_check(env);\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\n\tif (ret == 0 && bpf_prog_is_dev_bound(env->prog->aux))\n\t\tret = bpf_prog_offload_finalize(env);\n\nskip_full_check:\n\twhile (!pop_stack(env, NULL, NULL));\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\tsanitize_dead_code(env);\n\n\tif (ret == 0)\n\t\tret = check_max_stack_depth(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (ret == 0)\n\t\tret = fixup_call_args(env);\n\n\tif (log->level && bpf_verifier_log_full(log))\n\t\tret = -ENOSPC;\n\tif (log->level && !log->ubuf) {\n\t\tret = -EFAULT;\n\t\tgoto err_release_maps;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nerr_release_maps:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_used_maps() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}",
          "includes": [
            "#include \"disasm.h\"",
            "#include <linux/perf_event.h>",
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/stringify.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/file.h>",
            "#include <net/netlink.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>",
            "#include <linux/slab.h>",
            "#include <linux/types.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_verifier_ops * const bpf_verifier_ops[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _verifier_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};",
            "static DEFINE_MUTEX(bpf_verifier_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"disasm.h\"\n#include <linux/perf_event.h>\n#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/stringify.h>\n#include <linux/vmalloc.h>\n#include <linux/file.h>\n#include <net/netlink.h>\n#include <linux/filter.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n#include <linux/slab.h>\n#include <linux/types.h>\n#include <linux/kernel.h>\n\nstatic const struct bpf_verifier_ops * const bpf_verifier_ops[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _verifier_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};\nstatic DEFINE_MUTEX(bpf_verifier_lock);\n\nint bpf_check(struct bpf_prog **prog, union bpf_attr *attr)\n{\n\tstruct bpf_verifier_env *env;\n\tstruct bpf_verifier_log *log;\n\tint ret = -EINVAL;\n\n\t/* no program is valid */\n\tif (ARRAY_SIZE(bpf_verifier_ops) == 0)\n\t\treturn -EINVAL;\n\n\t/* 'struct bpf_verifier_env' can be global, but since it's not small,\n\t * allocate/free it every time bpf_check() is called\n\t */\n\tenv = kzalloc(sizeof(struct bpf_verifier_env), GFP_KERNEL);\n\tif (!env)\n\t\treturn -ENOMEM;\n\tlog = &env->log;\n\n\tenv->insn_aux_data =\n\t\tvzalloc(array_size(sizeof(struct bpf_insn_aux_data),\n\t\t\t\t   (*prog)->len));\n\tret = -ENOMEM;\n\tif (!env->insn_aux_data)\n\t\tgoto err_free_env;\n\tenv->prog = *prog;\n\tenv->ops = bpf_verifier_ops[env->prog->type];\n\n\t/* grab the mutex to protect few globals used by verifier */\n\tmutex_lock(&bpf_verifier_lock);\n\n\tif (attr->log_level || attr->log_buf || attr->log_size) {\n\t\t/* user requested verbose verifier output\n\t\t * and supplied buffer to store the verification trace\n\t\t */\n\t\tlog->level = attr->log_level;\n\t\tlog->ubuf = (char __user *) (unsigned long) attr->log_buf;\n\t\tlog->len_total = attr->log_size;\n\n\t\tret = -EINVAL;\n\t\t/* log attributes have to be sane */\n\t\tif (log->len_total < 128 || log->len_total > UINT_MAX >> 8 ||\n\t\t    !log->level || !log->ubuf)\n\t\t\tgoto err_unlock;\n\t}\n\n\tenv->strict_alignment = !!(attr->prog_flags & BPF_F_STRICT_ALIGNMENT);\n\tif (!IS_ENABLED(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS))\n\t\tenv->strict_alignment = true;\n\n\tret = replace_map_fd_with_map_ptr(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tif (bpf_prog_is_dev_bound(env->prog->aux)) {\n\t\tret = bpf_prog_offload_verifier_prep(env);\n\t\tif (ret)\n\t\t\tgoto skip_full_check;\n\t}\n\n\tenv->explored_states = kcalloc(env->prog->len,\n\t\t\t\t       sizeof(struct bpf_verifier_state_list *),\n\t\t\t\t       GFP_USER);\n\tret = -ENOMEM;\n\tif (!env->explored_states)\n\t\tgoto skip_full_check;\n\n\tenv->allow_ptr_leaks = capable(CAP_SYS_ADMIN);\n\n\tret = check_cfg(env);\n\tif (ret < 0)\n\t\tgoto skip_full_check;\n\n\tret = do_check(env);\n\tif (env->cur_state) {\n\t\tfree_verifier_state(env->cur_state, true);\n\t\tenv->cur_state = NULL;\n\t}\n\n\tif (ret == 0 && bpf_prog_is_dev_bound(env->prog->aux))\n\t\tret = bpf_prog_offload_finalize(env);\n\nskip_full_check:\n\twhile (!pop_stack(env, NULL, NULL));\n\tfree_states(env);\n\n\tif (ret == 0)\n\t\tsanitize_dead_code(env);\n\n\tif (ret == 0)\n\t\tret = check_max_stack_depth(env);\n\n\tif (ret == 0)\n\t\t/* program is valid, convert *(u32*)(ctx + off) accesses */\n\t\tret = convert_ctx_accesses(env);\n\n\tif (ret == 0)\n\t\tret = fixup_bpf_calls(env);\n\n\tif (ret == 0)\n\t\tret = fixup_call_args(env);\n\n\tif (log->level && bpf_verifier_log_full(log))\n\t\tret = -ENOSPC;\n\tif (log->level && !log->ubuf) {\n\t\tret = -EFAULT;\n\t\tgoto err_release_maps;\n\t}\n\n\tif (ret == 0 && env->used_map_cnt) {\n\t\t/* if program passed verifier, update used_maps in bpf_prog_info */\n\t\tenv->prog->aux->used_maps = kmalloc_array(env->used_map_cnt,\n\t\t\t\t\t\t\t  sizeof(env->used_maps[0]),\n\t\t\t\t\t\t\t  GFP_KERNEL);\n\n\t\tif (!env->prog->aux->used_maps) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto err_release_maps;\n\t\t}\n\n\t\tmemcpy(env->prog->aux->used_maps, env->used_maps,\n\t\t       sizeof(env->used_maps[0]) * env->used_map_cnt);\n\t\tenv->prog->aux->used_map_cnt = env->used_map_cnt;\n\n\t\t/* program is valid. Convert pseudo bpf_ld_imm64 into generic\n\t\t * bpf_ld_imm64 instructions\n\t\t */\n\t\tconvert_pseudo_ld_imm64(env);\n\t}\n\nerr_release_maps:\n\tif (!env->prog->aux->used_maps)\n\t\t/* if we didn't copy map pointers into bpf_prog_info, release\n\t\t * them now. Otherwise free_used_maps() will release them.\n\t\t */\n\t\trelease_maps(env);\n\t*prog = env->prog;\nerr_unlock:\n\tmutex_unlock(&bpf_verifier_lock);\n\tvfree(env->insn_aux_data);\nerr_free_env:\n\tkfree(env);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_obj_name_cpy",
          "args": [
            "prog->aux->name",
            "attr->prog_name"
          ],
          "line": 1523
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_name_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "438-456",
          "snippet": "static int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_boot_ns",
          "args": [],
          "line": 1522
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_prog_type",
          "args": [
            "type",
            "prog"
          ],
          "line": 1518
        },
        "resolved": true,
        "details": {
          "function_name": "find_prog_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1074-1091",
          "snippet": "static int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};\n\nstatic int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_offload_init",
          "args": [
            "prog",
            "attr"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_offload_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "78-122",
          "snippet": "int bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr)\n{\n\tstruct bpf_offload_netdev *ondev;\n\tstruct bpf_prog_offload *offload;\n\tint err;\n\n\tif (attr->prog_type != BPF_PROG_TYPE_SCHED_CLS &&\n\t    attr->prog_type != BPF_PROG_TYPE_XDP)\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags)\n\t\treturn -EINVAL;\n\n\toffload = kzalloc(sizeof(*offload), GFP_USER);\n\tif (!offload)\n\t\treturn -ENOMEM;\n\n\toffload->prog = prog;\n\n\toffload->netdev = dev_get_by_index(current->nsproxy->net_ns,\n\t\t\t\t\t   attr->prog_ifindex);\n\terr = bpf_dev_offload_check(offload->netdev);\n\tif (err)\n\t\tgoto err_maybe_put;\n\n\tdown_write(&bpf_devs_lock);\n\tondev = bpf_offload_find_netdev(offload->netdev);\n\tif (!ondev) {\n\t\terr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\tprog->aux->offload = offload;\n\tlist_add_tail(&offload->offloads, &ondev->progs);\n\tdev_put(offload->netdev);\n\tup_write(&bpf_devs_lock);\n\n\treturn 0;\nerr_unlock:\n\tup_write(&bpf_devs_lock);\nerr_maybe_put:\n\tif (offload->netdev)\n\t\tdev_put(offload->netdev);\n\tkfree(offload);\n\treturn err;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_prog_offload_init(struct bpf_prog *prog, union bpf_attr *attr)\n{\n\tstruct bpf_offload_netdev *ondev;\n\tstruct bpf_prog_offload *offload;\n\tint err;\n\n\tif (attr->prog_type != BPF_PROG_TYPE_SCHED_CLS &&\n\t    attr->prog_type != BPF_PROG_TYPE_XDP)\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags)\n\t\treturn -EINVAL;\n\n\toffload = kzalloc(sizeof(*offload), GFP_USER);\n\tif (!offload)\n\t\treturn -ENOMEM;\n\n\toffload->prog = prog;\n\n\toffload->netdev = dev_get_by_index(current->nsproxy->net_ns,\n\t\t\t\t\t   attr->prog_ifindex);\n\terr = bpf_dev_offload_check(offload->netdev);\n\tif (err)\n\t\tgoto err_maybe_put;\n\n\tdown_write(&bpf_devs_lock);\n\tondev = bpf_offload_find_netdev(offload->netdev);\n\tif (!ondev) {\n\t\terr = -EINVAL;\n\t\tgoto err_unlock;\n\t}\n\tprog->aux->offload = offload;\n\tlist_add_tail(&offload->offloads, &ondev->progs);\n\tdev_put(offload->netdev);\n\tup_write(&bpf_devs_lock);\n\n\treturn 0;\nerr_unlock:\n\tup_write(&bpf_devs_lock);\nerr_maybe_put:\n\tif (offload->netdev)\n\t\tdev_put(offload->netdev);\n\tkfree(offload);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 1511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&prog->aux->refcnt",
            "1"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "prog->insns",
            "u64_to_user_ptr(attr->insns)",
            "bpf_prog_insn_size(prog)"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_insn_size",
          "args": [
            "prog"
          ],
          "line": 1502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->insns"
          ],
          "line": 1501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_charge_memlock",
          "args": [
            "prog"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_charge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1134-1147",
          "snippet": "static int bpf_prog_charge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = __bpf_prog_charge(user, prog->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\n\tprog->aux->user = user;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_charge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = __bpf_prog_charge(user, prog->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\n\tprog->aux->user = user;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_alloc",
          "args": [
            "prog->aux"
          ],
          "line": 1490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_alloc",
          "args": [
            "bpf_prog_size(attr->insn_cnt)",
            "GFP_USER"
          ],
          "line": 1482
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "78-103",
          "snippet": "struct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, PAGE_SIZE);\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL | gfp_extra_flags);\n\tif (aux == NULL) {\n\t\tvfree(fp);\n\t\treturn NULL;\n\t}\n\n\tfp->pages = size / PAGE_SIZE;\n\tfp->aux = aux;\n\tfp->aux->prog = fp;\n\tfp->jit_requested = ebpf_jit_enabled();\n\n\tINIT_LIST_HEAD_RCU(&fp->aux->ksym_lnode);\n\n\treturn fp;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nstruct bpf_prog *bpf_prog_alloc(unsigned int size, gfp_t gfp_extra_flags)\n{\n\tgfp_t gfp_flags = GFP_KERNEL | __GFP_ZERO | gfp_extra_flags;\n\tstruct bpf_prog_aux *aux;\n\tstruct bpf_prog *fp;\n\n\tsize = round_up(size, PAGE_SIZE);\n\tfp = __vmalloc(size, gfp_flags, PAGE_KERNEL);\n\tif (fp == NULL)\n\t\treturn NULL;\n\n\taux = kzalloc(sizeof(*aux), GFP_KERNEL | gfp_extra_flags);\n\tif (aux == NULL) {\n\t\tvfree(fp);\n\t\treturn NULL;\n\t}\n\n\tfp->pages = size / PAGE_SIZE;\n\tfp->aux = aux;\n\tfp->aux->prog = fp;\n\tfp->jit_requested = ebpf_jit_enabled();\n\n\tINIT_LIST_HEAD_RCU(&fp->aux->ksym_lnode);\n\n\treturn fp;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_size",
          "args": [
            "attr->insn_cnt"
          ],
          "line": 1482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_load_check_attach_type",
          "args": [
            "type",
            "attr->expected_attach_type"
          ],
          "line": 1478
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_load_check_attach_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1408-1437",
          "snippet": "static int\nbpf_prog_load_check_attach_type(enum bpf_prog_type prog_type,\n\t\t\t\tenum bpf_attach_type expected_attach_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int\nbpf_prog_load_check_attach_type(enum bpf_prog_type prog_type,\n\t\t\t\tenum bpf_attach_type expected_attach_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_load_fixup_attach_type",
          "args": [
            "attr"
          ],
          "line": 1477
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_load_fixup_attach_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1394-1406",
          "snippet": "static void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 1474
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "license_is_gpl_compatible",
          "args": [
            "license"
          ],
          "line": 1463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "license",
            "u64_to_user_ptr(attr->license)",
            "sizeof(license) - 1"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->license"
          ],
          "line": 1457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_PROG_LOAD"
          ],
          "line": 1450
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_load(union bpf_attr *attr)\n{\n\tenum bpf_prog_type type = attr->prog_type;\n\tstruct bpf_prog *prog;\n\tint err;\n\tchar license[128];\n\tbool is_gpl;\n\n\tif (CHECK_ATTR(BPF_PROG_LOAD))\n\t\treturn -EINVAL;\n\n\tif (attr->prog_flags & ~BPF_F_STRICT_ALIGNMENT)\n\t\treturn -EINVAL;\n\n\t/* copy eBPF program license from user space */\n\tif (strncpy_from_user(license, u64_to_user_ptr(attr->license),\n\t\t\t      sizeof(license) - 1) < 0)\n\t\treturn -EFAULT;\n\tlicense[sizeof(license) - 1] = 0;\n\n\t/* eBPF programs must be GPL compatible to use GPL-ed functions */\n\tis_gpl = license_is_gpl_compatible(license);\n\n\tif (attr->insn_cnt == 0 || attr->insn_cnt > BPF_MAXINSNS)\n\t\treturn -E2BIG;\n\n\tif (type == BPF_PROG_TYPE_KPROBE &&\n\t    attr->kern_version != LINUX_VERSION_CODE)\n\t\treturn -EINVAL;\n\n\tif (type != BPF_PROG_TYPE_SOCKET_FILTER &&\n\t    type != BPF_PROG_TYPE_CGROUP_SKB &&\n\t    !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\tbpf_prog_load_fixup_attach_type(attr);\n\tif (bpf_prog_load_check_attach_type(type, attr->expected_attach_type))\n\t\treturn -EINVAL;\n\n\t/* plain bpf_prog allocation */\n\tprog = bpf_prog_alloc(bpf_prog_size(attr->insn_cnt), GFP_USER);\n\tif (!prog)\n\t\treturn -ENOMEM;\n\n\tprog->expected_attach_type = attr->expected_attach_type;\n\n\tprog->aux->offload_requested = !!attr->prog_ifindex;\n\n\terr = security_bpf_prog_alloc(prog->aux);\n\tif (err)\n\t\tgoto free_prog_nouncharge;\n\n\terr = bpf_prog_charge_memlock(prog);\n\tif (err)\n\t\tgoto free_prog_sec;\n\n\tprog->len = attr->insn_cnt;\n\n\terr = -EFAULT;\n\tif (copy_from_user(prog->insns, u64_to_user_ptr(attr->insns),\n\t\t\t   bpf_prog_insn_size(prog)) != 0)\n\t\tgoto free_prog;\n\n\tprog->orig_prog = NULL;\n\tprog->jited = 0;\n\n\tatomic_set(&prog->aux->refcnt, 1);\n\tprog->gpl_compatible = is_gpl ? 1 : 0;\n\n\tif (bpf_prog_is_dev_bound(prog->aux)) {\n\t\terr = bpf_prog_offload_init(prog, attr);\n\t\tif (err)\n\t\t\tgoto free_prog;\n\t}\n\n\t/* find program type: socket_filter vs tracing_filter */\n\terr = find_prog_type(type, prog);\n\tif (err < 0)\n\t\tgoto free_prog;\n\n\tprog->aux->load_time = ktime_get_boot_ns();\n\terr = bpf_obj_name_cpy(prog->aux->name, attr->prog_name);\n\tif (err)\n\t\tgoto free_prog;\n\n\t/* run eBPF verifier */\n\terr = bpf_check(&prog, attr);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\tprog = bpf_prog_select_runtime(prog, &err);\n\tif (err < 0)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_alloc_id(prog);\n\tif (err)\n\t\tgoto free_used_maps;\n\n\terr = bpf_prog_new_fd(prog);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_prog_put() is needed because the above\n\t\t * bpf_prog_alloc_id() has published the prog\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_PROG_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_prog_put(prog);\n\t\treturn err;\n\t}\n\n\tbpf_prog_kallsyms_add(prog);\n\treturn err;\n\nfree_used_maps:\n\tbpf_prog_kallsyms_del_subprogs(prog);\n\tfree_used_maps(prog->aux);\nfree_prog:\n\tbpf_prog_uncharge_memlock(prog);\nfree_prog_sec:\n\tsecurity_bpf_prog_free(prog->aux);\nfree_prog_nouncharge:\n\tbpf_prog_free(prog);\n\treturn err;\n}"
  },
  {
    "function_name": "bpf_prog_load_check_attach_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1408-1437",
    "snippet": "static int\nbpf_prog_load_check_attach_type(enum bpf_prog_type prog_type,\n\t\t\t\tenum bpf_attach_type expected_attach_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int\nbpf_prog_load_check_attach_type(enum bpf_prog_type prog_type,\n\t\t\t\tenum bpf_attach_type expected_attach_type)\n{\n\tswitch (prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET_SOCK_CREATE:\n\t\tcase BPF_CGROUP_INET4_POST_BIND:\n\t\tcase BPF_CGROUP_INET6_POST_BIND:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tcase BPF_PROG_TYPE_CGROUP_SOCK_ADDR:\n\t\tswitch (expected_attach_type) {\n\t\tcase BPF_CGROUP_INET4_BIND:\n\t\tcase BPF_CGROUP_INET6_BIND:\n\t\tcase BPF_CGROUP_INET4_CONNECT:\n\t\tcase BPF_CGROUP_INET6_CONNECT:\n\t\tcase BPF_CGROUP_UDP4_SENDMSG:\n\t\tcase BPF_CGROUP_UDP6_SENDMSG:\n\t\t\treturn 0;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_load_fixup_attach_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1394-1406",
    "snippet": "static void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_load_fixup_attach_type(union bpf_attr *attr)\n{\n\tswitch (attr->prog_type) {\n\tcase BPF_PROG_TYPE_CGROUP_SOCK:\n\t\t/* Unfortunately BPF_ATTACH_TYPE_UNSPEC enumeration doesn't\n\t\t * exist so checking for non-zero is the way to go here.\n\t\t */\n\t\tif (!attr->expected_attach_type)\n\t\t\tattr->expected_attach_type =\n\t\t\t\tBPF_CGROUP_INET_SOCK_CREATE;\n\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "bpf_prog_get_type_dev",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1375-1379",
    "snippet": "struct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_get",
          "args": [
            "ufd",
            "&type",
            "attach_drv"
          ],
          "line": 1378
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1350-1368",
          "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_get_type_dev(u32 ufd, enum bpf_prog_type type,\n\t\t\t\t       bool attach_drv)\n{\n\treturn __bpf_prog_get(ufd, &type, attach_drv);\n}"
  },
  {
    "function_name": "bpf_prog_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1370-1373",
    "snippet": "struct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\treturn __bpf_prog_get(ufd, NULL, false);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_get",
          "args": [
            "ufd",
            "NULL",
            "false"
          ],
          "line": 1372
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1350-1368",
          "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_get(u32 ufd)\n{\n\treturn __bpf_prog_get(ufd, NULL, false);\n}"
  },
  {
    "function_name": "__bpf_prog_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1350-1368",
    "snippet": "static struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_inc",
          "args": [
            "prog"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_inc_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1317-1332",
          "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_get_ok",
          "args": [
            "prog",
            "attach_type",
            "attach_drv"
          ],
          "line": 1359
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_get_ok",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1335-1348",
          "snippet": "bool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nbool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "prog"
          ],
          "line": 1357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "____bpf_prog_get",
          "args": [
            "f"
          ],
          "line": 1356
        },
        "resolved": true,
        "details": {
          "function_name": "____bpf_prog_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1277-1287",
          "snippet": "static struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic struct bpf_prog *__bpf_prog_get(u32 ufd, enum bpf_prog_type *attach_type,\n\t\t\t\t       bool attach_drv)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_prog *prog;\n\n\tprog = ____bpf_prog_get(f);\n\tif (IS_ERR(prog))\n\t\treturn prog;\n\tif (!bpf_prog_get_ok(prog, attach_type, attach_drv)) {\n\t\tprog = ERR_PTR(-EINVAL);\n\t\tgoto out;\n\t}\n\n\tprog = bpf_prog_inc(prog);\nout:\n\tfdput(f);\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_prog_get_ok",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1335-1348",
    "snippet": "bool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 1344
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nbool bpf_prog_get_ok(struct bpf_prog *prog,\n\t\t\t    enum bpf_prog_type *attach_type, bool attach_drv)\n{\n\t/* not an attachment, just a refcount inc, always allow */\n\tif (!attach_type)\n\t\treturn true;\n\n\tif (prog->type != *attach_type)\n\t\treturn false;\n\tif (bpf_prog_is_dev_bound(prog->aux) && !attach_drv)\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "bpf_prog_inc_not_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1317-1332",
    "snippet": "struct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_MAX_REFCNT 32768"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_prog_put",
          "args": [
            "prog",
            "false"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1210-1219",
          "snippet": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_unless",
          "args": [
            "&prog->aux->refcnt",
            "1",
            "0"
          ],
          "line": 1321
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_prog *bpf_prog_inc_not_zero(struct bpf_prog *prog)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&prog->aux->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_prog_put(prog, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\treturn prog;\n}"
  },
  {
    "function_name": "bpf_prog_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1310-1313",
    "snippet": "struct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\treturn bpf_prog_add(prog, 1);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_add",
          "args": [
            "prog",
            "1"
          ],
          "line": 1312
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1289-1296",
          "snippet": "struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tif (atomic_add_return(i, &prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_sub(i, &prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tif (atomic_add_return(i, &prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_sub(i, &prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstruct bpf_prog *bpf_prog_inc(struct bpf_prog *prog)\n{\n\treturn bpf_prog_add(prog, 1);\n}"
  },
  {
    "function_name": "bpf_prog_sub",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1299-1307",
    "snippet": "void bpf_prog_sub(struct bpf_prog *prog, int i)\n{\n\t/* Only to be used for undoing previous bpf_prog_add() in some\n\t * error path. We still know that another entity in our call\n\t * path holds a reference to the program, thus atomic_sub() can\n\t * be safely used in such cases!\n\t */\n\tWARN_ON(atomic_sub_return(i, &prog->aux->refcnt) == 0);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "atomic_sub_return(i, &prog->aux->refcnt) == 0"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub_return",
          "args": [
            "i",
            "&prog->aux->refcnt"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_sub(struct bpf_prog *prog, int i)\n{\n\t/* Only to be used for undoing previous bpf_prog_add() in some\n\t * error path. We still know that another entity in our call\n\t * path holds a reference to the program, thus atomic_sub() can\n\t * be safely used in such cases!\n\t */\n\tWARN_ON(atomic_sub_return(i, &prog->aux->refcnt) == 0);\n}"
  },
  {
    "function_name": "bpf_prog_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1289-1296",
    "snippet": "struct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tif (atomic_add_return(i, &prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_sub(i, &prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_MAX_REFCNT 32768"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 1293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_sub",
          "args": [
            "i",
            "&prog->aux->refcnt"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_return",
          "args": [
            "i",
            "&prog->aux->refcnt"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_prog *bpf_prog_add(struct bpf_prog *prog, int i)\n{\n\tif (atomic_add_return(i, &prog->aux->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_sub(i, &prog->aux->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\treturn prog;\n}"
  },
  {
    "function_name": "____bpf_prog_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1277-1287",
    "snippet": "static struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 1280
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstatic struct bpf_prog *____bpf_prog_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_prog_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
  },
  {
    "function_name": "bpf_prog_new_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1265-1275",
    "snippet": "int bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-prog\"",
            "&bpf_prog_fops",
            "prog",
            "O_RDWR | O_CLOEXEC"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_prog",
          "args": [
            "prog"
          ],
          "line": 1269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_prog_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_prog_show_fdinfo,\n#endif\n\t.release\t= bpf_prog_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_prog_new_fd(struct bpf_prog *prog)\n{\n\tint ret;\n\n\tret = security_bpf_prog(prog);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-prog\", &bpf_prog_fops, prog,\n\t\t\t\tO_RDWR | O_CLOEXEC);\n}"
  },
  {
    "function_name": "bpf_prog_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1236-1253",
    "snippet": "static void bpf_prog_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_prog *prog = filp->private_data;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\",\n\t\t   prog->type,\n\t\t   prog->jited,\n\t\t   prog_tag,\n\t\t   prog->pages * 1ULL << PAGE_SHIFT,\n\t\t   prog->aux->id);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\"",
            "prog->type",
            "prog->jited",
            "prog_tag",
            "prog->pages * 1ULL << PAGE_SHIFT",
            "prog->aux->id"
          ],
          "line": 1242
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bin2hex",
          "args": [
            "prog_tag",
            "prog->tag",
            "sizeof(prog->tag)"
          ],
          "line": 1241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_prog *prog = filp->private_data;\n\tchar prog_tag[sizeof(prog->tag) * 2 + 1] = { };\n\n\tbin2hex(prog_tag, prog->tag, sizeof(prog->tag));\n\tseq_printf(m,\n\t\t   \"prog_type:\\t%u\\n\"\n\t\t   \"prog_jited:\\t%u\\n\"\n\t\t   \"prog_tag:\\t%s\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"prog_id:\\t%u\\n\",\n\t\t   prog->type,\n\t\t   prog->jited,\n\t\t   prog_tag,\n\t\t   prog->pages * 1ULL << PAGE_SHIFT,\n\t\t   prog->aux->id);\n}"
  },
  {
    "function_name": "bpf_prog_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1227-1233",
    "snippet": "static int bpf_prog_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_prog *prog = filp->private_data;\n\n\tbpf_prog_put(prog);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_put",
          "args": [
            "prog"
          ],
          "line": 1231
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1221-1224",
          "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_prog *prog = filp->private_data;\n\n\tbpf_prog_put(prog);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_prog_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1221-1224",
    "snippet": "void bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_prog_put",
          "args": [
            "prog",
            "true"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1210-1219",
          "snippet": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_prog_put(struct bpf_prog *prog)\n{\n\t__bpf_prog_put(prog, true);\n}"
  },
  {
    "function_name": "__bpf_prog_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1210-1219",
    "snippet": "static void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&prog->aux->rcu",
            "__bpf_prog_put_rcu"
          ],
          "line": 1217
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_kallsyms_del_all",
          "args": [
            "prog"
          ],
          "line": 1215
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_kallsyms_del_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "361-365",
          "snippet": "void bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_kallsyms_del_all(struct bpf_prog *fp)\n{\n\tbpf_prog_kallsyms_del_subprogs(fp);\n\tbpf_prog_kallsyms_del(fp);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_prog_free_id",
          "args": [
            "prog",
            "do_idr_lock"
          ],
          "line": 1214
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1176-1198",
          "snippet": "void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_bh(&prog_idr_lock);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_bh(&prog_idr_lock);\n\telse\n\t\t__release(&prog_idr_lock);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(prog_idr);",
            "static DEFINE_SPINLOCK(prog_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nvoid bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_bh(&prog_idr_lock);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_bh(&prog_idr_lock);\n\telse\n\t\t__release(&prog_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&prog->aux->refcnt"
          ],
          "line": 1212
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put(struct bpf_prog *prog, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&prog->aux->refcnt)) {\n\t\t/* bpf_prog_free_id() must be called first */\n\t\tbpf_prog_free_id(prog, do_idr_lock);\n\t\tbpf_prog_kallsyms_del_all(prog);\n\n\t\tcall_rcu(&prog->aux->rcu, __bpf_prog_put_rcu);\n\t}\n}"
  },
  {
    "function_name": "__bpf_prog_put_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1200-1208",
    "snippet": "static void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tfree_used_maps(aux);\n\tbpf_prog_uncharge_memlock(aux->prog);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_free",
          "args": [
            "aux->prog"
          ],
          "line": 1207
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1790-1796",
          "snippet": "void bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nvoid bpf_prog_free(struct bpf_prog *fp)\n{\n\tstruct bpf_prog_aux *aux = fp->aux;\n\n\tINIT_WORK(&aux->work, bpf_prog_free_deferred);\n\tschedule_work(&aux->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_prog_free",
          "args": [
            "aux"
          ],
          "line": 1206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_prog_uncharge_memlock",
          "args": [
            "aux->prog"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1149-1155",
          "snippet": "static void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_used_maps",
          "args": [
            "aux"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "free_used_maps",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1094-1110",
          "snippet": "static void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structbpf_prog_aux",
            "rcu"
          ],
          "line": 1202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_prog_put_rcu(struct rcu_head *rcu)\n{\n\tstruct bpf_prog_aux *aux = container_of(rcu, struct bpf_prog_aux, rcu);\n\n\tfree_used_maps(aux);\n\tbpf_prog_uncharge_memlock(aux->prog);\n\tsecurity_bpf_prog_free(aux);\n\tbpf_prog_free(aux->prog);\n}"
  },
  {
    "function_name": "bpf_prog_free_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1176-1198",
    "snippet": "void bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_bh(&prog_idr_lock);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_bh(&prog_idr_lock);\n\telse\n\t\t__release(&prog_idr_lock);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1197
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1195
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&prog_idr",
            "prog->aux->id"
          ],
          "line": 1191
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquire",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1187
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nvoid bpf_prog_free_id(struct bpf_prog *prog, bool do_idr_lock)\n{\n\t/* cBPF to eBPF migrations are currently not in the idr store.\n\t * Offloaded programs are removed from the store when their device\n\t * disappears - even if someone grabs an fd to them they are unusable,\n\t * simply waiting for refcnt to drop to be freed.\n\t */\n\tif (!prog->aux->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_bh(&prog_idr_lock);\n\telse\n\t\t__acquire(&prog_idr_lock);\n\n\tidr_remove(&prog_idr, prog->aux->id);\n\tprog->aux->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_bh(&prog_idr_lock);\n\telse\n\t\t__release(&prog_idr_lock);\n}"
  },
  {
    "function_name": "bpf_prog_alloc_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1157-1174",
    "snippet": "static int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 1167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1166
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&prog_idr",
            "prog",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 1163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&prog_idr_lock"
          ],
          "line": 1162
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 1161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\n\nstatic int bpf_prog_alloc_id(struct bpf_prog *prog)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&prog_idr_lock);\n\tid = idr_alloc_cyclic(&prog_idr, prog, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tprog->aux->id = id;\n\tspin_unlock_bh(&prog_idr_lock);\n\tidr_preload_end();\n\n\t/* id is in [1, INT_MAX) */\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "bpf_prog_uncharge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1149-1155",
    "snippet": "static void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 1154
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_prog_uncharge",
          "args": [
            "user",
            "prog->pages"
          ],
          "line": 1153
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_uncharge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1128-1132",
          "snippet": "void __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_prog_uncharge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = prog->aux->user;\n\n\t__bpf_prog_uncharge(user, prog->pages);\n\tfree_uid(user);\n}"
  },
  {
    "function_name": "bpf_prog_charge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1134-1147",
    "snippet": "static int bpf_prog_charge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = __bpf_prog_charge(user, prog->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\n\tprog->aux->user = user;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 1141
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__bpf_prog_charge",
          "args": [
            "user",
            "prog->pages"
          ],
          "line": 1139
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_prog_charge",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "1112-1126",
          "snippet": "int __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_prog_charge_memlock(struct bpf_prog *prog)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = __bpf_prog_charge(user, prog->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\n\tprog->aux->user = user;\n\treturn 0;\n}"
  },
  {
    "function_name": "__bpf_prog_uncharge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1128-1132",
    "snippet": "void __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid __bpf_prog_uncharge(struct user_struct *user, u32 pages)\n{\n\tif (user)\n\t\tatomic_long_sub(pages, &user->locked_vm);\n}"
  },
  {
    "function_name": "__bpf_prog_charge",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1112-1126",
    "snippet": "int __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 1120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 1118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 1114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint __bpf_prog_charge(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tunsigned long user_bufs;\n\n\tif (user) {\n\t\tuser_bufs = atomic_long_add_return(pages, &user->locked_vm);\n\t\tif (user_bufs > memlock_limit) {\n\t\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "free_used_maps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1094-1110",
    "snippet": "static void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux->used_maps"
          ],
          "line": 1109
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "aux->used_maps[i]"
          ],
          "line": 1107
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_cgroup_storage_release",
          "args": [
            "aux->prog",
            "aux->cgroup_storage[stype]"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_cgroup_storage_release",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "344-356",
          "snippet": "void bpf_cgroup_storage_release(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tspin_lock_bh(&map->lock);\n\tif (map->prog == prog) {\n\t\tWARN_ON(prog->aux->cgroup_storage[stype] != _map);\n\t\tmap->prog = NULL;\n\t\tprog->aux->cgroup_storage[stype] = NULL;\n\t}\n\tspin_unlock_bh(&map->lock);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nvoid bpf_cgroup_storage_release(struct bpf_prog *prog, struct bpf_map *_map)\n{\n\tenum bpf_cgroup_storage_type stype = cgroup_storage_type(_map);\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\n\tspin_lock_bh(&map->lock);\n\tif (map->prog == prog) {\n\t\tWARN_ON(prog->aux->cgroup_storage[stype] != _map);\n\t\tmap->prog = NULL;\n\t\tprog->aux->cgroup_storage[stype] = NULL;\n\t}\n\tspin_unlock_bh(&map->lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void free_used_maps(struct bpf_prog_aux *aux)\n{\n\tenum bpf_cgroup_storage_type stype;\n\tint i;\n\n\tfor_each_cgroup_storage_type(stype) {\n\t\tif (!aux->cgroup_storage[stype])\n\t\t\tcontinue;\n\t\tbpf_cgroup_storage_release(aux->prog,\n\t\t\t\t\t   aux->cgroup_storage[stype]);\n\t}\n\n\tfor (i = 0; i < aux->used_map_cnt; i++)\n\t\tbpf_map_put(aux->used_maps[i]);\n\n\tkfree(aux->used_maps);\n}"
  },
  {
    "function_name": "find_prog_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1074-1091",
    "snippet": "static int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_prog_is_dev_bound",
          "args": [
            "prog->aux"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "type",
            "ARRAY_SIZE(bpf_prog_types)"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_prog_types"
          ],
          "line": 1080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_prog_types"
          ],
          "line": 1078
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_prog_ops * const bpf_prog_types[] = {\n#define BPF_PROG_TYPE(_id, _name) \\\n\t[_id] = & _name ## _prog_ops,\n#define BPF_MAP_TYPE(_id, _ops)\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};\n\nstatic int find_prog_type(enum bpf_prog_type type, struct bpf_prog *prog)\n{\n\tconst struct bpf_prog_ops *ops;\n\n\tif (type >= ARRAY_SIZE(bpf_prog_types))\n\t\treturn -EINVAL;\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_prog_types));\n\tops = bpf_prog_types[type];\n\tif (!ops)\n\t\treturn -EINVAL;\n\n\tif (!bpf_prog_is_dev_bound(prog->aux))\n\t\tprog->aux->ops = ops;\n\telse\n\t\tprog->aux->ops = &bpf_offload_prog_ops;\n\tprog->type = type;\n\treturn 0;\n}"
  },
  {
    "function_name": "map_lookup_and_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "1004-1063",
    "snippet": "static int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else {\n\t\terr = -ENOTSUPP;\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 1061
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uvalue",
            "value",
            "value_size"
          ],
          "line": 1051
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_pop_elem",
          "args": [
            "map",
            "value"
          ],
          "line": 1043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 1030
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 1029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 1028
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "654-663",
          "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 1021
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 1020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 1019
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_LOOKUP_AND_DELETE_ELEM"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->value"
          ],
          "line": 1007
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 1006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_and_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_AND_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t    map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_pop_elem(map, value);\n\t} else {\n\t\terr = -ENOTSUPP;\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_get_next_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "937-1000",
    "snippet": "static int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkfree(next_key);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 998
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "unext_key",
            "next_key",
            "map->key_size"
          ],
          "line": 988
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 982
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_get_next_key",
          "args": [
            "map",
            "key",
            "next_key"
          ],
          "line": 981
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 980
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_get_next_key",
          "args": [
            "map",
            "key",
            "next_key"
          ],
          "line": 976
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_get_next_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "464-475",
          "snippet": "int bpf_map_offload_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_get_next_key(offmap, key, next_key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_get_next_key(struct bpf_map *map, void *key, void *next_key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_get_next_key(offmap, key, next_key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 975
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "map->key_size",
            "GFP_USER"
          ],
          "line": 971
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 963
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 961
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "654-663",
          "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 952
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 951
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_GET_NEXT_KEY"
          ],
          "line": 947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->next_key"
          ],
          "line": 940
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_get_next_key(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *unext_key = u64_to_user_ptr(attr->next_key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *next_key;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_GET_NEXT_KEY))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tif (ukey) {\n\t\tkey = __bpf_copy_key(ukey, map->key_size);\n\t\tif (IS_ERR(key)) {\n\t\t\terr = PTR_ERR(key);\n\t\t\tgoto err_put;\n\t\t}\n\t} else {\n\t\tkey = NULL;\n\t}\n\n\terr = -ENOMEM;\n\tnext_key = kmalloc(map->key_size, GFP_USER);\n\tif (!next_key)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_get_next_key(map, key, next_key);\n\t\tgoto out;\n\t}\n\n\trcu_read_lock();\n\terr = map->ops->map_get_next_key(map, key, next_key);\n\trcu_read_unlock();\nout:\n\tif (err)\n\t\tgoto free_next_key;\n\n\terr = -EFAULT;\n\tif (copy_to_user(unext_key, next_key, map->key_size) != 0)\n\t\tgoto free_next_key;\n\n\terr = 0;\n\nfree_next_key:\n\tkfree(next_key);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_delete_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "886-932",
    "snippet": "static int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 926
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "765-774",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_prog_active"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 923
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 922
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 921
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bpf_prog_active"
          ],
          "line": 920
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 919
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_delete_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 915
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_delete_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "451-462",
          "snippet": "int bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_delete_elem(struct bpf_map *map, void *key)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_delete_elem(offmap, key);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 909
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 908
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "654-663",
          "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 901
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 900
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 899
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_DELETE_ELEM"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_delete_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tstruct fd f;\n\tvoid *key;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_DELETE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_delete_elem(map, key);\n\t\tgoto out;\n\t}\n\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\trcu_read_lock();\n\terr = map->ops->map_delete_elem(map, key);\n\trcu_read_unlock();\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tmaybe_wait_bpf_programs(map);\nout:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "map_update_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "778-882",
    "snippet": "static int map_update_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();\n\telse\n\t\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_user(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_update_elem(map, key, value, attr->flags);\n\t\tgoto out;\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\terr = map->ops->map_update_elem(map, key, value, attr->flags);\n\t\tgoto out;\n\t}\n\n\t/* must increment bpf_prog_active to avoid kprobe+bpf triggering from\n\t * inside bpf map update or delete otherwise deadlocks are possible\n\t */\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       attr->flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   attr->flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  attr->flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_push_elem(map, value, attr->flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, attr->flags);\n\t\trcu_read_unlock();\n\t}\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tmaybe_wait_bpf_programs(map);\nout:\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 878
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "maybe_wait_bpf_programs",
          "args": [
            "map"
          ],
          "line": 873
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_wait_bpf_programs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "765-774",
          "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 872
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__this_cpu_dec",
          "args": [
            "bpf_prog_active"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 867
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_push_elem",
          "args": [
            "map",
            "value",
            "attr->flags"
          ],
          "line": 865
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_reuseport_array_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 861
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_reuseport_array_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/reuseport_array.c",
          "lines": "251-334",
          "snippet": "int bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\t/* Ensure reuse->reuseport_id is set */\n\terr = reuseport_get_id(reuse);\n\tif (err < 0)\n\t\tgoto put_file_unlock;\n\n\tWRITE_ONCE(nsk->sk_user_data, &array->ptrs[index]);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_update_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value, u64 map_flags)\n{\n\tstruct reuseport_array *array = reuseport_array(map);\n\tstruct sock *free_osk = NULL, *osk, *nsk;\n\tstruct sock_reuseport *reuse;\n\tu32 index = *(u32 *)key;\n\tstruct socket *socket;\n\tint err, fd;\n\n\tif (map_flags > BPF_EXIST)\n\t\treturn -EINVAL;\n\n\tif (index >= map->max_entries)\n\t\treturn -E2BIG;\n\n\tif (map->value_size == sizeof(u64)) {\n\t\tu64 fd64 = *(u64 *)value;\n\n\t\tif (fd64 > S32_MAX)\n\t\t\treturn -EINVAL;\n\t\tfd = fd64;\n\t} else {\n\t\tfd = *(int *)value;\n\t}\n\n\tsocket = sockfd_lookup(fd, &err);\n\tif (!socket)\n\t\treturn err;\n\n\tnsk = socket->sk;\n\tif (!nsk) {\n\t\terr = -EINVAL;\n\t\tgoto put_file;\n\t}\n\n\t/* Quick checks before taking reuseport_lock */\n\terr = reuseport_array_update_check(array, nsk,\n\t\t\t\t\t   rcu_access_pointer(array->ptrs[index]),\n\t\t\t\t\t   rcu_access_pointer(nsk->sk_reuseport_cb),\n\t\t\t\t\t   map_flags);\n\tif (err)\n\t\tgoto put_file;\n\n\tspin_lock_bh(&reuseport_lock);\n\t/*\n\t * Some of the checks only need reuseport_lock\n\t * but it is done under sk_callback_lock also\n\t * for simplicity reason.\n\t */\n\twrite_lock_bh(&nsk->sk_callback_lock);\n\n\tosk = rcu_dereference_protected(array->ptrs[index],\n\t\t\t\t\tlockdep_is_held(&reuseport_lock));\n\treuse = rcu_dereference_protected(nsk->sk_reuseport_cb,\n\t\t\t\t\t  lockdep_is_held(&reuseport_lock));\n\terr = reuseport_array_update_check(array, nsk, osk, reuse, map_flags);\n\tif (err)\n\t\tgoto put_file_unlock;\n\n\t/* Ensure reuse->reuseport_id is set */\n\terr = reuseport_get_id(reuse);\n\tif (err < 0)\n\t\tgoto put_file_unlock;\n\n\tWRITE_ONCE(nsk->sk_user_data, &array->ptrs[index]);\n\trcu_assign_pointer(array->ptrs[index], nsk);\n\tfree_osk = osk;\n\terr = 0;\n\nput_file_unlock:\n\twrite_unlock_bh(&nsk->sk_callback_lock);\n\n\tif (free_osk) {\n\t\twrite_lock_bh(&free_osk->sk_callback_lock);\n\t\tWRITE_ONCE(free_osk->sk_user_data, NULL);\n\t\twrite_unlock_bh(&free_osk->sk_callback_lock);\n\t}\n\n\tspin_unlock_bh(&reuseport_lock);\nput_file:\n\tfput(socket->file);\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_htab_map_update_elem",
          "args": [
            "map",
            "f.file",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 856
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_htab_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1388-1404",
          "snippet": "int bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\tvoid *key, void *value, u64 map_flags)\n{\n\tvoid *ptr;\n\tint ret;\n\tu32 ufd = *(u32 *)value;\n\n\tptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(ptr))\n\t\treturn PTR_ERR(ptr);\n\n\tret = htab_map_update_elem(map, key, &ptr, map_flags);\n\tif (ret)\n\t\tmap->ops->map_fd_put_ptr(ptr);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_update_elem",
          "args": [
            "map",
            "f.file",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 851
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "476-499",
          "snippet": "int bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\told_ptr = xchg(array->ptrs + index, new_ptr);\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_update_elem(struct bpf_map *map, struct file *map_file,\n\t\t\t\t void *key, void *value, u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tvoid *new_ptr, *old_ptr;\n\tu32 index = *(u32 *)key, ufd;\n\n\tif (map_flags != BPF_ANY)\n\t\treturn -EINVAL;\n\n\tif (index >= array->map.max_entries)\n\t\treturn -E2BIG;\n\n\tufd = *(u32 *)value;\n\tnew_ptr = map->ops->map_fd_get_ptr(map, map_file, ufd);\n\tif (IS_ERR(new_ptr))\n\t\treturn PTR_ERR(new_ptr);\n\n\told_ptr = xchg(array->ptrs + index, new_ptr);\n\tif (old_ptr)\n\t\tmap->ops->map_fd_put_ptr(old_ptr);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_ARRAY",
          "args": [
            "map"
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_percpu_cgroup_storage_update",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 847
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_cgroup_storage_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "185-218",
          "snippet": "int bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *_key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_update(struct bpf_map *_map, void *_key,\n\t\t\t\t     void *value, u64 map_flags)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (map_flags != BPF_ANY && map_flags != BPF_EXIST)\n\t\treturn -EINVAL;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(storage->percpu_buf, cpu),\n\t\t\t\tvalue + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_array_update",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_array_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "279-315",
          "snippet": "int bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_update(struct bpf_map *map, void *key, void *value,\n\t\t\t    u64 map_flags)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(map_flags > BPF_EXIST))\n\t\t/* unknown flags */\n\t\treturn -EINVAL;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\t/* all elements were pre-allocated, cannot insert a new one */\n\t\treturn -E2BIG;\n\n\tif (unlikely(map_flags == BPF_NOEXIST))\n\t\t/* all elements already exist */\n\t\treturn -EEXIST;\n\n\t/* the user space will provide round_up(value_size, 8) bytes that\n\t * will be copied into per-cpu area. bpf programs can only access\n\t * value_size of it. During lookup the same extra bytes will be\n\t * returned or zeros which were zero-filled by percpu_alloc,\n\t * so no kernel data leaks possible\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(per_cpu_ptr(pptr, cpu), value + off, size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_hash_update",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 843
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_hash_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1270-1286",
          "snippet": "int bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_update(struct bpf_map *map, void *key, void *value,\n\t\t\t   u64 map_flags)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tint ret;\n\n\trcu_read_lock();\n\tif (htab_is_lru(htab))\n\t\tret = __htab_lru_percpu_map_update_elem(map, key, value,\n\t\t\t\t\t\t\tmap_flags, true);\n\telse\n\t\tret = __htab_percpu_map_update_elem(map, key, value, map_flags,\n\t\t\t\t\t\t    true);\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__this_cpu_inc",
          "args": [
            "bpf_prog_active"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 839
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_update_elem",
          "args": [
            "map",
            "key",
            "value",
            "attr->flags"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_update_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "433-449",
          "snippet": "int bpf_map_offload_update_elem(struct bpf_map *map,\n\t\t\t\tvoid *key, void *value, u64 flags)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_update_elem(offmap, key, value,\n\t\t\t\t\t\t       flags);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_update_elem(struct bpf_map *map,\n\t\t\t\tvoid *key, void *value, u64 flags)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tif (unlikely(flags > BPF_EXIST))\n\t\treturn -EINVAL;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_update_elem(offmap, key, value,\n\t\t\t\t\t\t       flags);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 826
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "value",
            "uvalue",
            "value_size"
          ],
          "line": 822
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 817
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 804
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "654-663",
          "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 794
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_UPDATE_ELEM"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->value"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_update_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_UPDATE_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_WRITE)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();\n\telse\n\t\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\terr = -EFAULT;\n\tif (copy_from_user(value, uvalue, value_size) != 0)\n\t\tgoto free_value;\n\n\t/* Need to create a kthread, thus must support schedule */\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_update_elem(map, key, value, attr->flags);\n\t\tgoto out;\n\t} else if (map->map_type == BPF_MAP_TYPE_CPUMAP ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKHASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_SOCKMAP) {\n\t\terr = map->ops->map_update_elem(map, key, value, attr->flags);\n\t\tgoto out;\n\t}\n\n\t/* must increment bpf_prog_active to avoid kprobe+bpf triggering from\n\t * inside bpf map update or delete otherwise deadlocks are possible\n\t */\n\tpreempt_disable();\n\t__this_cpu_inc(bpf_prog_active);\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_update(map, key, value, attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_update(map, key, value, attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_update(map, key, value,\n\t\t\t\t\t\t       attr->flags);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_array_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t   attr->flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS) {\n\t\trcu_read_lock();\n\t\terr = bpf_fd_htab_map_update_elem(map, f.file, key, value,\n\t\t\t\t\t\t  attr->flags);\n\t\trcu_read_unlock();\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\t/* rcu_read_lock() is not needed */\n\t\terr = bpf_fd_reuseport_array_update_elem(map, key, value,\n\t\t\t\t\t\t\t attr->flags);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_push_elem(map, value, attr->flags);\n\t} else {\n\t\trcu_read_lock();\n\t\terr = map->ops->map_update_elem(map, key, value, attr->flags);\n\t\trcu_read_unlock();\n\t}\n\t__this_cpu_dec(bpf_prog_active);\n\tpreempt_enable();\n\tmaybe_wait_bpf_programs(map);\nout:\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "maybe_wait_bpf_programs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "765-774",
    "snippet": "static void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "synchronize_rcu",
          "args": [],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "603-611",
          "snippet": "void synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid synchronize_rcu_tasks(void)\n{\n\t/* Complain if the scheduler has not started.  */\n\tRCU_LOCKDEP_WARN(rcu_scheduler_active == RCU_SCHEDULER_INACTIVE,\n\t\t\t \"synchronize_rcu_tasks called too soon\");\n\n\t/* Wait for the grace period. */\n\twait_rcu_gp(call_rcu_tasks);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void maybe_wait_bpf_programs(struct bpf_map *map)\n{\n\t/* Wait for any running BPF programs to complete so that\n\t * userspace, when we return to it, knows that all programs\n\t * that could be running use the new map value.\n\t */\n\tif (map->map_type == BPF_MAP_TYPE_HASH_OF_MAPS ||\n\t    map->map_type == BPF_MAP_TYPE_ARRAY_OF_MAPS)\n\t\tsynchronize_rcu();\n}"
  },
  {
    "function_name": "map_lookup_elem",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "668-763",
    "snippet": "static int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value, *ptr;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\tvalue_size = sizeof(u32);\n\telse\n\t\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tmemcpy(value, ptr, value_size);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 759
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uvalue",
            "value",
            "value_size"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "value",
            "ptr",
            "value_size"
          ],
          "line": 742
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "ptr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "ptr"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map->ops->map_lookup_elem",
          "args": [
            "map",
            "key"
          ],
          "line": 735
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 734
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_peek_elem",
          "args": [
            "map",
            "value"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_reuseport_array_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_reuseport_array_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/reuseport_array.c",
          "lines": "184-204",
          "snippet": "int bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}",
          "includes": [
            "#include <net/sock_reuseport.h>",
            "#include <linux/sock_diag.h>",
            "#include <linux/err.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <net/sock_reuseport.h>\n#include <linux/sock_diag.h>\n#include <linux/err.h>\n#include <linux/bpf.h>\n\nint bpf_fd_reuseport_array_lookup_elem(struct bpf_map *map, void *key,\n\t\t\t\t       void *value)\n{\n\tstruct sock *sk;\n\tint err;\n\n\tif (map->value_size != sizeof(u64))\n\t\treturn -ENOSPC;\n\n\trcu_read_lock();\n\tsk = reuseport_array_lookup_elem(map, key);\n\tif (sk) {\n\t\t*(u64 *)value = sock_gen_cookie(sk);\n\t\terr = 0;\n\t} else {\n\t\terr = -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\treturn err;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_fd_htab_map_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 727
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_htab_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1368-1385",
          "snippet": "int bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_htab_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **ptr;\n\tint ret = 0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\tptr = htab_map_lookup_elem(map, key);\n\tif (ptr)\n\t\t*value = map->ops->map_fd_sys_lookup_elem(READ_ONCE(*ptr));\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_HASH",
          "args": [
            "map"
          ],
          "line": 726
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_fd_array_map_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_fd_array_map_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "456-473",
          "snippet": "int bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_fd_array_map_lookup_elem(struct bpf_map *map, void *key, u32 *value)\n{\n\tvoid **elem, *ptr;\n\tint ret =  0;\n\n\tif (!map->ops->map_fd_sys_lookup_elem)\n\t\treturn -ENOTSUPP;\n\n\trcu_read_lock();\n\telem = array_map_lookup_elem(map, key);\n\tif (elem && (ptr = READ_ONCE(*elem)))\n\t\t*value = map->ops->map_fd_sys_lookup_elem(ptr);\n\telse\n\t\tret = -ENOENT;\n\trcu_read_unlock();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_ARRAY",
          "args": [
            "map"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_stackmap_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 723
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_stackmap_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "649-652",
          "snippet": "int __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_cgroup_storage_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_cgroup_storage_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/local_storage.c",
          "lines": "155-183",
          "snippet": "int bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *_key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/mm.h>",
            "#include <linux/filter.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf.h>",
            "#include <linux/bpf-cgroup.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/mm.h>\n#include <linux/filter.h>\n#include <linux/bug.h>\n#include <linux/bpf.h>\n#include <linux/bpf-cgroup.h>\n\nint bpf_percpu_cgroup_storage_copy(struct bpf_map *_map, void *_key,\n\t\t\t\t   void *value)\n{\n\tstruct bpf_cgroup_storage_map *map = map_to_storage(_map);\n\tstruct bpf_cgroup_storage_key *key = _key;\n\tstruct bpf_cgroup_storage *storage;\n\tint cpu, off = 0;\n\tu32 size;\n\n\trcu_read_lock();\n\tstorage = cgroup_storage_lookup(map, key, false);\n\tif (!storage) {\n\t\trcu_read_unlock();\n\t\treturn -ENOENT;\n\t}\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(_map->value_size, 8);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(storage->percpu_buf, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_array_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_array_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "205-229",
          "snippet": "int bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_array_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_array *array = container_of(map, struct bpf_array, map);\n\tu32 index = *(u32 *)key;\n\tvoid __percpu *pptr;\n\tint cpu, off = 0;\n\tu32 size;\n\n\tif (unlikely(index >= array->map.max_entries))\n\t\treturn -ENOENT;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tpptr = array->pptrs[index & array->index_mask];\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off, per_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_percpu_hash_copy",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 717
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_percpu_hash_copy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/hashtab.c",
          "lines": "1238-1268",
          "snippet": "int bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include \"bpf_lru_list.h\"",
            "#include \"percpu_freelist.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/random.h>",
            "#include <linux/rculist_nulls.h>",
            "#include <linux/filter.h>",
            "#include <linux/jhash.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include \"bpf_lru_list.h\"\n#include \"percpu_freelist.h\"\n#include <uapi/linux/btf.h>\n#include <linux/random.h>\n#include <linux/rculist_nulls.h>\n#include <linux/filter.h>\n#include <linux/jhash.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nint bpf_percpu_hash_copy(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_htab *htab = container_of(map, struct bpf_htab, map);\n\tstruct htab_elem *l;\n\tvoid __percpu *pptr;\n\tint ret = -ENOENT;\n\tint cpu, off = 0;\n\tu32 size;\n\n\t/* per_cpu areas are zero-filled and bpf programs can only\n\t * access 'value_size' of them, so copying rounded areas\n\t * will not leak any kernel data\n\t */\n\tsize = round_up(map->value_size, 8);\n\trcu_read_lock();\n\tl = __htab_map_lookup_elem(map, key);\n\tif (!l)\n\t\tgoto out;\n\tif (htab_is_lru(htab))\n\t\tbpf_lru_node_set_ref(&l->lru_node);\n\tpptr = htab_elem_get_ptr(l, map->key_size);\n\tfor_each_possible_cpu(cpu) {\n\t\tbpf_long_memcpy(value + off,\n\t\t\t\tper_cpu_ptr(pptr, cpu), size);\n\t\toff += size;\n\t}\n\tret = 0;\nout:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_offload_lookup_elem",
          "args": [
            "map",
            "key",
            "value"
          ],
          "line": 714
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_offload_lookup_elem",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/offload.c",
          "lines": "420-431",
          "snippet": "int bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_lookup_elem(offmap, key, value);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/rtnetlink.h>",
            "#include <linux/rhashtable.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/printk.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/list.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/bug.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(bpf_devs_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/rtnetlink.h>\n#include <linux/rhashtable.h>\n#include <linux/proc_ns.h>\n#include <linux/printk.h>\n#include <linux/netdevice.h>\n#include <linux/lockdep.h>\n#include <linux/list.h>\n#include <linux/kdev_t.h>\n#include <linux/bug.h>\n#include <linux/bpf_verifier.h>\n#include <linux/bpf.h>\n\nstatic DECLARE_RWSEM(bpf_devs_lock);\n\nint bpf_map_offload_lookup_elem(struct bpf_map *map, void *key, void *value)\n{\n\tstruct bpf_offloaded_map *offmap = map_to_offmap(map);\n\tint ret = -ENODEV;\n\n\tdown_read(&bpf_devs_lock);\n\tif (offmap->netdev)\n\t\tret = offmap->dev_ops->map_lookup_elem(offmap, key, value);\n\tup_read(&bpf_devs_lock);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_is_dev_bound",
          "args": [
            "map"
          ],
          "line": 713
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "value_size",
            "GFP_USER | __GFP_NOWARN"
          ],
          "line": 709
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_FD_MAP",
          "args": [
            "map"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_possible_cpus",
          "args": [],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "round_up",
          "args": [
            "map->value_size",
            "8"
          ],
          "line": 702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "key"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "key"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_copy_key",
          "args": [
            "ukey",
            "map->key_size"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_copy_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "654-663",
          "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_LOOKUP_ELEM"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->value"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "attr->key"
          ],
          "line": 670
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_lookup_elem(union bpf_attr *attr)\n{\n\tvoid __user *ukey = u64_to_user_ptr(attr->key);\n\tvoid __user *uvalue = u64_to_user_ptr(attr->value);\n\tint ufd = attr->map_fd;\n\tstruct bpf_map *map;\n\tvoid *key, *value, *ptr;\n\tu32 value_size;\n\tstruct fd f;\n\tint err;\n\n\tif (CHECK_ATTR(BPF_MAP_LOOKUP_ELEM))\n\t\treturn -EINVAL;\n\n\tf = fdget(ufd);\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\tif (!(f.file->f_mode & FMODE_CAN_READ)) {\n\t\terr = -EPERM;\n\t\tgoto err_put;\n\t}\n\n\tkey = __bpf_copy_key(ukey, map->key_size);\n\tif (IS_ERR(key)) {\n\t\terr = PTR_ERR(key);\n\t\tgoto err_put;\n\t}\n\n\tif (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY ||\n\t    map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE)\n\t\tvalue_size = round_up(map->value_size, 8) * num_possible_cpus();\n\telse if (IS_FD_MAP(map))\n\t\tvalue_size = sizeof(u32);\n\telse\n\t\tvalue_size = map->value_size;\n\n\terr = -ENOMEM;\n\tvalue = kmalloc(value_size, GFP_USER | __GFP_NOWARN);\n\tif (!value)\n\t\tgoto free_key;\n\n\tif (bpf_map_is_dev_bound(map)) {\n\t\terr = bpf_map_offload_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_HASH ||\n\t\t   map->map_type == BPF_MAP_TYPE_LRU_PERCPU_HASH) {\n\t\terr = bpf_percpu_hash_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_ARRAY) {\n\t\terr = bpf_percpu_array_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_PERCPU_CGROUP_STORAGE) {\n\t\terr = bpf_percpu_cgroup_storage_copy(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_STACK_TRACE) {\n\t\terr = bpf_stackmap_copy(map, key, value);\n\t} else if (IS_FD_ARRAY(map)) {\n\t\terr = bpf_fd_array_map_lookup_elem(map, key, value);\n\t} else if (IS_FD_HASH(map)) {\n\t\terr = bpf_fd_htab_map_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_REUSEPORT_SOCKARRAY) {\n\t\terr = bpf_fd_reuseport_array_lookup_elem(map, key, value);\n\t} else if (map->map_type == BPF_MAP_TYPE_QUEUE ||\n\t\t   map->map_type == BPF_MAP_TYPE_STACK) {\n\t\terr = map->ops->map_peek_elem(map, value);\n\t} else {\n\t\trcu_read_lock();\n\t\tptr = map->ops->map_lookup_elem(map, key);\n\t\tif (IS_ERR(ptr)) {\n\t\t\terr = PTR_ERR(ptr);\n\t\t} else if (!ptr) {\n\t\t\terr = -ENOENT;\n\t\t} else {\n\t\t\terr = 0;\n\t\t\tmemcpy(value, ptr, value_size);\n\t\t}\n\t\trcu_read_unlock();\n\t}\n\n\tif (err)\n\t\tgoto free_value;\n\n\terr = -EFAULT;\n\tif (copy_to_user(uvalue, value, value_size) != 0)\n\t\tgoto free_value;\n\n\terr = 0;\n\nfree_value:\n\tkfree(value);\nfree_key:\n\tkfree(key);\nerr_put:\n\tfdput(f);\n\treturn err;\n}"
  },
  {
    "function_name": "__bpf_copy_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "654-663",
    "snippet": "static void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memdup_user",
          "args": [
            "ukey",
            "key_size"
          ],
          "line": 657
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void *__bpf_copy_key(void __user *ukey, u64 key_size)\n{\n\tif (key_size)\n\t\treturn memdup_user(ukey, key_size);\n\n\tif (ukey)\n\t\treturn ERR_PTR(-EINVAL);\n\n\treturn NULL;\n}"
  },
  {
    "function_name": "bpf_stackmap_copy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "649-652",
    "snippet": "int __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint __weak bpf_stackmap_copy(struct bpf_map *map, void *key, void *value)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_map_inc_not_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "628-647",
    "snippet": "static struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_MAX_REFCNT 32768"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&map->usercnt"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_put",
          "args": [
            "map",
            "false"
          ],
          "line": 636
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "304-313",
          "snippet": "static void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_fetch_add_unless",
          "args": [
            "&map->refcnt",
            "1",
            "0"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstatic struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_get_with_uref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "612-625",
    "snippet": "struct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tmap = bpf_map_inc(map, true);\n\tfdput(f);\n\n\treturn map;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_inc",
          "args": [
            "map",
            "true"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_inc_not_zero",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "628-647",
          "snippet": "static struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [
            "#define BPF_MAX_REFCNT 32768"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstatic struct bpf_map *bpf_map_inc_not_zero(struct bpf_map *map,\n\t\t\t\t\t    bool uref)\n{\n\tint refold;\n\n\trefold = atomic_fetch_add_unless(&map->refcnt, 1, 0);\n\n\tif (refold >= BPF_MAX_REFCNT) {\n\t\t__bpf_map_put(map, false);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\n\tif (!refold)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__bpf_map_get",
          "args": [
            "f"
          ],
          "line": 617
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "585-595",
          "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "ufd"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstruct bpf_map *bpf_map_get_with_uref(u32 ufd)\n{\n\tstruct fd f = fdget(ufd);\n\tstruct bpf_map *map;\n\n\tmap = __bpf_map_get(f);\n\tif (IS_ERR(map))\n\t\treturn map;\n\n\tmap = bpf_map_inc(map, true);\n\tfdput(f);\n\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_map_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "600-609",
    "snippet": "struct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&map->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\treturn map;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [
      "#define BPF_MAX_REFCNT 32768"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&map->usercnt"
          ],
          "line": 607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBUSY"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&map->refcnt"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&map->refcnt"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\n#define BPF_MAX_REFCNT 32768\n\nstruct bpf_map *bpf_map_inc(struct bpf_map *map, bool uref)\n{\n\tif (atomic_inc_return(&map->refcnt) > BPF_MAX_REFCNT) {\n\t\tatomic_dec(&map->refcnt);\n\t\treturn ERR_PTR(-EBUSY);\n\t}\n\tif (uref)\n\t\tatomic_inc(&map->usercnt);\n\treturn map;\n}"
  },
  {
    "function_name": "__bpf_map_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "585-595",
    "snippet": "struct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 591
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EBADF"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nstruct bpf_map *__bpf_map_get(struct fd f)\n{\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\tif (f.file->f_op != &bpf_map_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\treturn f.file->private_data;\n}"
  },
  {
    "function_name": "map_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "488-580",
    "snippet": "static int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name);\n\tif (err)\n\t\tgoto free_map_nouncharge;\n\n\tatomic_set(&map->refcnt, 1);\n\tatomic_set(&map->usercnt, 1);\n\n\tif (attr->btf_key_type_id || attr->btf_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tif (!attr->btf_key_type_id || !attr->btf_value_type_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t    attr->btf_value_type_id);\n\t\tif (err) {\n\t\t\tbtf_put(btf);\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\tmap->btf = btf;\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map_nouncharge;\n\n\terr = bpf_map_init_memlock(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map:\n\tbpf_map_release_memlock(map);\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map_nouncharge:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_free",
          "args": [
            "map"
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "map->btf"
          ],
          "line": 577
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "684-690",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_map_free",
          "args": [
            "map"
          ],
          "line": 575
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_release_memlock",
          "args": [
            "map"
          ],
          "line": 573
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_release_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "214-219",
          "snippet": "static void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_new_fd",
          "args": [
            "map",
            "f_flags"
          ],
          "line": 558
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_new_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "404-414",
          "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_alloc_id",
          "args": [
            "map"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_alloc_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "238-254",
          "snippet": "static int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_init_memlock",
          "args": [
            "map"
          ],
          "line": 550
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_init_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "200-212",
          "snippet": "static int bpf_map_init_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = bpf_charge_memlock(user, map->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\tmap->user = user;\n\treturn ret;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_init_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = bpf_charge_memlock(user, map->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\tmap->user = user;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_bpf_map_alloc",
          "args": [
            "map"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "map_check_btf",
          "args": [
            "map",
            "btf",
            "attr->btf_key_type_id",
            "attr->btf_value_type_id"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "map_check_btf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "465-484",
          "snippet": "static int map_check_btf(const struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\tif (!key_type || key_size != map->key_size)\n\t\treturn -EINVAL;\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, key_type, value_type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_check_btf(const struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\tif (!key_type || key_size != map->key_size)\n\t\treturn -EINVAL;\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, key_type, value_type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "btf"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "btf"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_get_by_fd",
          "args": [
            "attr->btf_fd"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "btf_get_by_fd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "2278-2298",
          "snippet": "struct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct file_operations btf_fops = {\n\t.release\t= btf_release,\n};\n\nstruct btf *btf_get_by_fd(int fd)\n{\n\tstruct btf *btf;\n\tstruct fd f;\n\n\tf = fdget(fd);\n\n\tif (!f.file)\n\t\treturn ERR_PTR(-EBADF);\n\n\tif (f.file->f_op != &btf_fops) {\n\t\tfdput(f);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\tbtf = f.file->private_data;\n\trefcount_inc(&btf->refcnt);\n\tfdput(f);\n\n\treturn btf;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->usercnt",
            "1"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&map->refcnt",
            "1"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_obj_name_cpy",
          "args": [
            "map->name",
            "attr->map_name"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_name_cpy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "438-456",
          "snippet": "static int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "map"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_and_alloc_map",
          "args": [
            "attr"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "find_and_alloc_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "108-135",
          "snippet": "static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _ops)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};",
            "const struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _ops)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};\nconst struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}"
        }
      },
      {
        "call_info": {
          "callee": "node_online",
          "args": [
            "numa_node"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_get_file_flag",
          "args": [
            "attr->map_flags"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_get_file_flag",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "416-425",
          "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
        }
      },
      {
        "call_info": {
          "callee": "CHECK_ATTR",
          "args": [
            "BPF_MAP_CREATE"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_create(union bpf_attr *attr)\n{\n\tint numa_node = bpf_map_attr_numa_node(attr);\n\tstruct bpf_map *map;\n\tint f_flags;\n\tint err;\n\n\terr = CHECK_ATTR(BPF_MAP_CREATE);\n\tif (err)\n\t\treturn -EINVAL;\n\n\tf_flags = bpf_get_file_flag(attr->map_flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tif (numa_node != NUMA_NO_NODE &&\n\t    ((unsigned int)numa_node >= nr_node_ids ||\n\t     !node_online(numa_node)))\n\t\treturn -EINVAL;\n\n\t/* find map type and init map: hashtable vs rbtree vs bloom vs ... */\n\tmap = find_and_alloc_map(attr);\n\tif (IS_ERR(map))\n\t\treturn PTR_ERR(map);\n\n\terr = bpf_obj_name_cpy(map->name, attr->map_name);\n\tif (err)\n\t\tgoto free_map_nouncharge;\n\n\tatomic_set(&map->refcnt, 1);\n\tatomic_set(&map->usercnt, 1);\n\n\tif (attr->btf_key_type_id || attr->btf_value_type_id) {\n\t\tstruct btf *btf;\n\n\t\tif (!attr->btf_key_type_id || !attr->btf_value_type_id) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\tbtf = btf_get_by_fd(attr->btf_fd);\n\t\tif (IS_ERR(btf)) {\n\t\t\terr = PTR_ERR(btf);\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\terr = map_check_btf(map, btf, attr->btf_key_type_id,\n\t\t\t\t    attr->btf_value_type_id);\n\t\tif (err) {\n\t\t\tbtf_put(btf);\n\t\t\tgoto free_map_nouncharge;\n\t\t}\n\n\t\tmap->btf = btf;\n\t\tmap->btf_key_type_id = attr->btf_key_type_id;\n\t\tmap->btf_value_type_id = attr->btf_value_type_id;\n\t}\n\n\terr = security_bpf_map_alloc(map);\n\tif (err)\n\t\tgoto free_map_nouncharge;\n\n\terr = bpf_map_init_memlock(map);\n\tif (err)\n\t\tgoto free_map_sec;\n\n\terr = bpf_map_alloc_id(map);\n\tif (err)\n\t\tgoto free_map;\n\n\terr = bpf_map_new_fd(map, f_flags);\n\tif (err < 0) {\n\t\t/* failed to allocate fd.\n\t\t * bpf_map_put() is needed because the above\n\t\t * bpf_map_alloc_id() has published the map\n\t\t * to the userspace and the userspace may\n\t\t * have refcnt-ed it through BPF_MAP_GET_FD_BY_ID.\n\t\t */\n\t\tbpf_map_put(map);\n\t\treturn err;\n\t}\n\n\treturn err;\n\nfree_map:\n\tbpf_map_release_memlock(map);\nfree_map_sec:\n\tsecurity_bpf_map_free(map);\nfree_map_nouncharge:\n\tbtf_put(map->btf);\n\tmap->ops->map_free(map);\n\treturn err;\n}"
  },
  {
    "function_name": "map_check_btf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "465-484",
    "snippet": "static int map_check_btf(const struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\tif (!key_type || key_size != map->key_size)\n\t\treturn -EINVAL;\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, key_type, value_type);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_check_btf",
          "args": [
            "map",
            "key_type",
            "value_type"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_type_id_size",
          "args": [
            "btf",
            "&btf_value_id",
            "&value_size"
          ],
          "line": 476
        },
        "resolved": true,
        "details": {
          "function_name": "btf_type_id_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "821-854",
          "snippet": "const struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nconst struct btf_type *btf_type_id_size(const struct btf *btf,\n\t\t\t\t\tu32 *type_id, u32 *ret_size)\n{\n\tconst struct btf_type *size_type;\n\tu32 size_type_id = *type_id;\n\tu32 size = 0;\n\n\tsize_type = btf_type_by_id(btf, size_type_id);\n\tif (btf_type_is_void_or_null(size_type))\n\t\treturn NULL;\n\n\tif (btf_type_has_size(size_type)) {\n\t\tsize = size_type->size;\n\t} else if (btf_type_is_array(size_type)) {\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t} else if (btf_type_is_ptr(size_type)) {\n\t\tsize = sizeof(void *);\n\t} else {\n\t\tif (WARN_ON_ONCE(!btf_type_is_modifier(size_type)))\n\t\t\treturn NULL;\n\n\t\tsize = btf->resolved_sizes[size_type_id];\n\t\tsize_type_id = btf->resolved_ids[size_type_id];\n\t\tsize_type = btf_type_by_id(btf, size_type_id);\n\t\tif (btf_type_is_void(size_type))\n\t\t\treturn NULL;\n\t}\n\n\t*type_id = size_type_id;\n\tif (ret_size)\n\t\t*ret_size = size;\n\n\treturn size_type;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int map_check_btf(const struct bpf_map *map, const struct btf *btf,\n\t\t\t u32 btf_key_id, u32 btf_value_id)\n{\n\tconst struct btf_type *key_type, *value_type;\n\tu32 key_size, value_size;\n\tint ret = 0;\n\n\tkey_type = btf_type_id_size(btf, &btf_key_id, &key_size);\n\tif (!key_type || key_size != map->key_size)\n\t\treturn -EINVAL;\n\n\tvalue_type = btf_type_id_size(btf, &btf_value_id, &value_size);\n\tif (!value_type || value_size != map->value_size)\n\t\treturn -EINVAL;\n\n\tif (map->ops->map_check_btf)\n\t\tret = map->ops->map_check_btf(map, key_type, value_type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "map_check_no_btf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "458-463",
    "snippet": "int map_check_no_btf(const struct bpf_map *map,\n\t\t     const struct btf_type *key_type,\n\t\t     const struct btf_type *value_type)\n{\n\treturn -ENOTSUPP;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint map_check_no_btf(const struct bpf_map *map,\n\t\t     const struct btf_type *key_type,\n\t\t     const struct btf_type *value_type)\n{\n\treturn -ENOTSUPP;\n}"
  },
  {
    "function_name": "bpf_obj_name_cpy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "438-456",
    "snippet": "static int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "*src"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "dst",
            "0",
            "BPF_OBJ_NAME_LEN"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_obj_name_cpy(char *dst, const char *src)\n{\n\tconst char *end = src + BPF_OBJ_NAME_LEN;\n\n\tmemset(dst, 0, BPF_OBJ_NAME_LEN);\n\n\t/* Copy all isalnum() and '_' char */\n\twhile (src < end && *src) {\n\t\tif (!isalnum(*src) && *src != '_')\n\t\t\treturn -EINVAL;\n\t\t*dst++ = *src++;\n\t}\n\n\t/* No '\\0' found in BPF_OBJ_NAME_LEN number of bytes */\n\tif (src == end)\n\t\treturn -EINVAL;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_get_file_flag",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "416-425",
    "snippet": "int bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_get_file_flag(int flags)\n{\n\tif ((flags & BPF_F_RDONLY) && (flags & BPF_F_WRONLY))\n\t\treturn -EINVAL;\n\tif (flags & BPF_F_RDONLY)\n\t\treturn O_RDONLY;\n\tif (flags & BPF_F_WRONLY)\n\t\treturn O_WRONLY;\n\treturn O_RDWR;\n}"
  },
  {
    "function_name": "bpf_map_new_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "404-414",
    "snippet": "int bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "const struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "anon_inode_getfd",
          "args": [
            "\"bpf-map\"",
            "&bpf_map_fops",
            "map",
            "flags | O_CLOEXEC"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_map",
          "args": [
            "map",
            "OPEN_FMODE(flags)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "OPEN_FMODE",
          "args": [
            "flags"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nconst struct file_operations bpf_map_fops = {\n#ifdef CONFIG_PROC_FS\n\t.show_fdinfo\t= bpf_map_show_fdinfo,\n#endif\n\t.release\t= bpf_map_release,\n\t.read\t\t= bpf_dummy_read,\n\t.write\t\t= bpf_dummy_write,\n};\n\nint bpf_map_new_fd(struct bpf_map *map, int flags)\n{\n\tint ret;\n\n\tret = security_bpf_map(map, OPEN_FMODE(flags));\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn anon_inode_getfd(\"bpf-map\", &bpf_map_fops, map,\n\t\t\t\tflags | O_CLOEXEC);\n}"
  },
  {
    "function_name": "bpf_dummy_write",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "386-393",
    "snippet": "static ssize_t bpf_dummy_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t siz, loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_WRITE.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic ssize_t bpf_dummy_write(struct file *filp, const char __user *buf,\n\t\t\t       size_t siz, loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_WRITE.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_dummy_read",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "377-384",
    "snippet": "static ssize_t bpf_dummy_read(struct file *filp, char __user *buf, size_t siz,\n\t\t\t      loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_READ.\n\t */\n\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic ssize_t bpf_dummy_read(struct file *filp, char __user *buf, size_t siz,\n\t\t\t      loff_t *ppos)\n{\n\t/* We need this handler such that alloc_file() enables\n\t * f_mode with FMODE_CAN_READ.\n\t */\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "bpf_map_show_fdinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "339-374",
    "snippet": "static void bpf_map_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_map *map = filp->private_data;\n\tconst struct bpf_array *array;\n\tu32 owner_prog_type = 0;\n\tu32 owner_jited = 0;\n\n\tif (map->map_type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\towner_prog_type = array->owner_prog_type;\n\t\towner_jited = array->owner_jited;\n\t}\n\n\tseq_printf(m,\n\t\t   \"map_type:\\t%u\\n\"\n\t\t   \"key_size:\\t%u\\n\"\n\t\t   \"value_size:\\t%u\\n\"\n\t\t   \"max_entries:\\t%u\\n\"\n\t\t   \"map_flags:\\t%#x\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"map_id:\\t%u\\n\",\n\t\t   map->map_type,\n\t\t   map->key_size,\n\t\t   map->value_size,\n\t\t   map->max_entries,\n\t\t   map->map_flags,\n\t\t   map->pages * 1ULL << PAGE_SHIFT,\n\t\t   map->id);\n\n\tif (owner_prog_type) {\n\t\tseq_printf(m, \"owner_prog_type:\\t%u\\n\",\n\t\t\t   owner_prog_type);\n\t\tseq_printf(m, \"owner_jited:\\t%u\\n\",\n\t\t\t   owner_jited);\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "m",
            "\"owner_jited:\\t%u\\n\"",
            "owner_jited"
          ],
          "line": 371
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "map",
            "structbpf_array",
            "map"
          ],
          "line": 347
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_show_fdinfo(struct seq_file *m, struct file *filp)\n{\n\tconst struct bpf_map *map = filp->private_data;\n\tconst struct bpf_array *array;\n\tu32 owner_prog_type = 0;\n\tu32 owner_jited = 0;\n\n\tif (map->map_type == BPF_MAP_TYPE_PROG_ARRAY) {\n\t\tarray = container_of(map, struct bpf_array, map);\n\t\towner_prog_type = array->owner_prog_type;\n\t\towner_jited = array->owner_jited;\n\t}\n\n\tseq_printf(m,\n\t\t   \"map_type:\\t%u\\n\"\n\t\t   \"key_size:\\t%u\\n\"\n\t\t   \"value_size:\\t%u\\n\"\n\t\t   \"max_entries:\\t%u\\n\"\n\t\t   \"map_flags:\\t%#x\\n\"\n\t\t   \"memlock:\\t%llu\\n\"\n\t\t   \"map_id:\\t%u\\n\",\n\t\t   map->map_type,\n\t\t   map->key_size,\n\t\t   map->value_size,\n\t\t   map->max_entries,\n\t\t   map->map_flags,\n\t\t   map->pages * 1ULL << PAGE_SHIFT,\n\t\t   map->id);\n\n\tif (owner_prog_type) {\n\t\tseq_printf(m, \"owner_prog_type:\\t%u\\n\",\n\t\t\t   owner_prog_type);\n\t\tseq_printf(m, \"owner_jited:\\t%u\\n\",\n\t\t\t   owner_jited);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_release",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "327-336",
    "snippet": "static int bpf_map_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_release)\n\t\tmap->ops->map_release(map, filp);\n\n\tbpf_map_put_with_uref(map);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put_with_uref",
          "args": [
            "map"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
        }
      },
      {
        "call_info": {
          "callee": "map->ops->map_release",
          "args": [
            "map",
            "filp"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_release(struct inode *inode, struct file *filp)\n{\n\tstruct bpf_map *map = filp->private_data;\n\n\tif (map->ops->map_release)\n\t\tmap->ops->map_release(map, filp);\n\n\tbpf_map_put_with_uref(map);\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_map_put_with_uref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "321-325",
    "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_put",
          "args": [
            "map"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_with_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "321-325",
          "snippet": "void bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_put_uref",
          "args": [
            "map"
          ],
          "line": 323
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_put_uref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "293-299",
          "snippet": "static void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put_with_uref(struct bpf_map *map)\n{\n\tbpf_map_put_uref(map);\n\tbpf_map_put(map);\n}"
  },
  {
    "function_name": "bpf_map_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "315-318",
    "snippet": "void bpf_map_put(struct bpf_map *map)\n{\n\t__bpf_map_put(map, true);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__bpf_map_put",
          "args": [
            "map",
            "true"
          ],
          "line": 317
        },
        "resolved": true,
        "details": {
          "function_name": "__bpf_map_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "304-313",
          "snippet": "static void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_put(struct bpf_map *map)\n{\n\t__bpf_map_put(map, true);\n}"
  },
  {
    "function_name": "__bpf_map_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "304-313",
    "snippet": "static void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&map->work"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&map->work",
            "bpf_map_free_deferred"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "btf_put",
          "args": [
            "map->btf"
          ],
          "line": 309
        },
        "resolved": true,
        "details": {
          "function_name": "btf_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/btf.c",
          "lines": "684-690",
          "snippet": "void btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}",
          "includes": [
            "#include <linux/btf.h>",
            "#include <linux/bpf_verifier.h>",
            "#include <linux/sort.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/file.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/slab.h>",
            "#include <linux/errno.h>",
            "#include <linux/compiler.h>",
            "#include <linux/seq_file.h>",
            "#include <uapi/linux/types.h>",
            "#include <uapi/linux/btf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/btf.h>\n#include <linux/bpf_verifier.h>\n#include <linux/sort.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/uaccess.h>\n#include <linux/file.h>\n#include <linux/anon_inodes.h>\n#include <linux/slab.h>\n#include <linux/errno.h>\n#include <linux/compiler.h>\n#include <linux/seq_file.h>\n#include <uapi/linux/types.h>\n#include <uapi/linux/btf.h>\n\nvoid btf_put(struct btf *btf)\n{\n\tif (btf && refcount_dec_and_test(&btf->refcnt)) {\n\t\tbtf_free_id(btf);\n\t\tcall_rcu(&btf->rcu, btf_free_rcu);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_map_free_id",
          "args": [
            "map",
            "do_idr_lock"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_free_id",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "256-280",
          "snippet": "void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_IDR(map_idr);",
            "static DEFINE_SPINLOCK(map_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nvoid bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&map->refcnt"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void __bpf_map_put(struct bpf_map *map, bool do_idr_lock)\n{\n\tif (atomic_dec_and_test(&map->refcnt)) {\n\t\t/* bpf_map_free_id() must be called first */\n\t\tbpf_map_free_id(map, do_idr_lock);\n\t\tbtf_put(map->btf);\n\t\tINIT_WORK(&map->work, bpf_map_free_deferred);\n\t\tschedule_work(&map->work);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_put_uref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "293-299",
    "snippet": "static void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_release_uref",
          "args": [
            "map"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_test",
          "args": [
            "&map->usercnt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_put_uref(struct bpf_map *map)\n{\n\tif (atomic_dec_and_test(&map->usercnt)) {\n\t\tif (map->ops->map_release_uref)\n\t\t\tmap->ops->map_release_uref(map);\n\t}\n}"
  },
  {
    "function_name": "bpf_map_free_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "283-291",
    "snippet": "static void bpf_map_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_map, work);\n\n\tbpf_map_release_memlock(map);\n\tsecurity_bpf_map_free(map);\n\t/* implementation dependent freeing */\n\tmap->ops->map_free(map);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "map->ops->map_free",
          "args": [
            "map"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_bpf_map_free",
          "args": [
            "map"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bpf_map_release_memlock",
          "args": [
            "map"
          ],
          "line": 287
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_map_release_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "214-219",
          "snippet": "static void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structbpf_map",
            "work"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_free_deferred(struct work_struct *work)\n{\n\tstruct bpf_map *map = container_of(work, struct bpf_map, work);\n\n\tbpf_map_release_memlock(map);\n\tsecurity_bpf_map_free(map);\n\t/* implementation dependent freeing */\n\tmap->ops->map_free(map);\n}"
  },
  {
    "function_name": "bpf_map_free_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "256-280",
    "snippet": "void bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__release",
          "args": [
            "&map_idr_lock"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "__release_child_resources",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/resource.c",
          "lines": "241-262",
          "snippet": "static void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}",
          "includes": [
            "#include <asm/io.h>",
            "#include <linux/resource_ext.h>",
            "#include <linux/mm.h>",
            "#include <linux/pfn.h>",
            "#include <linux/device.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/sched.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/fs.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/init.h>",
            "#include <linux/ioport.h>",
            "#include <linux/errno.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/io.h>\n#include <linux/resource_ext.h>\n#include <linux/mm.h>\n#include <linux/pfn.h>\n#include <linux/device.h>\n#include <linux/seq_file.h>\n#include <linux/sched.h>\n#include <linux/proc_fs.h>\n#include <linux/fs.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/init.h>\n#include <linux/ioport.h>\n#include <linux/errno.h>\n#include <linux/export.h>\n\nstatic void __release_child_resources(struct resource *r)\n{\n\tstruct resource *tmp, *p;\n\tresource_size_t size;\n\n\tp = r->child;\n\tr->child = NULL;\n\twhile (p) {\n\t\ttmp = p;\n\t\tp = p->sibling;\n\n\t\ttmp->parent = NULL;\n\t\ttmp->sibling = NULL;\n\t\t__release_child_resources(tmp);\n\n\t\tprintk(KERN_DEBUG \"release child resource %pR\\n\", tmp);\n\t\t/* need to restore size, and keep flags */\n\t\tsize = resource_size(tmp);\n\t\ttmp->start = 0;\n\t\ttmp->end = size - 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&map_idr_lock",
            "flags"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_remove",
          "args": [
            "&map_idr",
            "map->id"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "cgroup_idr_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup.c",
          "lines": "324-329",
          "snippet": "static void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}",
          "includes": [
            "#include <linux/cgroup_subsys.h>",
            "#include <linux/cgroup_subsys.h>",
            "#include <trace/events/cgroup.h>",
            "#include <net/sock.h>",
            "#include <linux/psi.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/file.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/atomic.h>",
            "#include <linux/kthread.h>",
            "#include <linux/idr.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/string.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/mount.h>",
            "#include <linux/mutex.h>",
            "#include <linux/magic.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init_task.h>",
            "#include <linux/errno.h>",
            "#include <linux/cred.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(cgroup_idr_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cgroup_subsys.h>\n#include <linux/cgroup_subsys.h>\n#include <trace/events/cgroup.h>\n#include <net/sock.h>\n#include <linux/psi.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/nsproxy.h>\n#include <linux/proc_ns.h>\n#include <linux/cpuset.h>\n#include <linux/atomic.h>\n#include <linux/kthread.h>\n#include <linux/idr.h>\n#include <linux/hashtable.h>\n#include <linux/string.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/spinlock.h>\n#include <linux/slab.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/proc_fs.h>\n#include <linux/pagemap.h>\n#include <linux/mount.h>\n#include <linux/mutex.h>\n#include <linux/magic.h>\n#include <linux/kernel.h>\n#include <linux/init_task.h>\n#include <linux/errno.h>\n#include <linux/cred.h>\n#include \"cgroup-internal.h\"\n\nstatic DEFINE_SPINLOCK(cgroup_idr_lock);\n\nstatic void cgroup_idr_remove(struct idr *idr, int id)\n{\n\tspin_lock_bh(&cgroup_idr_lock);\n\tidr_remove(idr, id);\n\tspin_unlock_bh(&cgroup_idr_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__acquire",
          "args": [
            "&map_idr_lock"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&map_idr_lock",
            "flags"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nvoid bpf_map_free_id(struct bpf_map *map, bool do_idr_lock)\n{\n\tunsigned long flags;\n\n\t/* Offloaded maps are removed from the IDR store when their device\n\t * disappears - even if someone holds an fd to them they are unusable,\n\t * the memory is gone, all ops will fail; they are simply waiting for\n\t * refcnt to drop to be freed.\n\t */\n\tif (!map->id)\n\t\treturn;\n\n\tif (do_idr_lock)\n\t\tspin_lock_irqsave(&map_idr_lock, flags);\n\telse\n\t\t__acquire(&map_idr_lock);\n\n\tidr_remove(&map_idr, map->id);\n\tmap->id = 0;\n\n\tif (do_idr_lock)\n\t\tspin_unlock_irqrestore(&map_idr_lock, flags);\n\telse\n\t\t__release(&map_idr_lock);\n}"
  },
  {
    "function_name": "bpf_map_alloc_id",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "238-254",
    "snippet": "static int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!id"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_preload_end",
          "args": [],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_alloc_cyclic",
          "args": [
            "&map_idr",
            "map",
            "1",
            "INT_MAX",
            "GFP_ATOMIC"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_bh",
          "args": [
            "&map_idr_lock"
          ],
          "line": 243
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_preload",
          "args": [
            "GFP_KERNEL"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\n\nstatic int bpf_map_alloc_id(struct bpf_map *map)\n{\n\tint id;\n\n\tidr_preload(GFP_KERNEL);\n\tspin_lock_bh(&map_idr_lock);\n\tid = idr_alloc_cyclic(&map_idr, map, 1, INT_MAX, GFP_ATOMIC);\n\tif (id > 0)\n\t\tmap->id = id;\n\tspin_unlock_bh(&map_idr_lock);\n\tidr_preload_end();\n\n\tif (WARN_ON_ONCE(!id))\n\t\treturn -ENOSPC;\n\n\treturn id > 0 ? 0 : id;\n}"
  },
  {
    "function_name": "bpf_map_uncharge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "232-236",
    "snippet": "void bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_uncharge_memlock",
          "args": [
            "map->user",
            "pages"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "195-198",
          "snippet": "static void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_uncharge_memlock(struct bpf_map *map, u32 pages)\n{\n\tbpf_uncharge_memlock(map->user, pages);\n\tmap->pages -= pages;\n}"
  },
  {
    "function_name": "bpf_map_charge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "221-230",
    "snippet": "int bpf_map_charge_memlock(struct bpf_map *map, u32 pages)\n{\n\tint ret;\n\n\tret = bpf_charge_memlock(map->user, pages);\n\tif (ret)\n\t\treturn ret;\n\tmap->pages += pages;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_charge_memlock",
          "args": [
            "map->user",
            "pages"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_charge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "184-193",
          "snippet": "static int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_charge_memlock(struct bpf_map *map, u32 pages)\n{\n\tint ret;\n\n\tret = bpf_charge_memlock(map->user, pages);\n\tif (ret)\n\t\treturn ret;\n\tmap->pages += pages;\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_map_release_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "214-219",
    "snippet": "static void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_uncharge_memlock",
          "args": [
            "user",
            "map->pages"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_uncharge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "195-198",
          "snippet": "static void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_map_release_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = map->user;\n\tbpf_uncharge_memlock(user, map->pages);\n\tfree_uid(user);\n}"
  },
  {
    "function_name": "bpf_map_init_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "200-212",
    "snippet": "static int bpf_map_init_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = bpf_charge_memlock(user, map->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\tmap->user = user;\n\treturn ret;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 207
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bpf_charge_memlock",
          "args": [
            "user",
            "map->pages"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_charge_memlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
          "lines": "184-193",
          "snippet": "static int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/nospec.h>",
            "#include <linux/ctype.h>",
            "#include <linux/timekeeping.h>",
            "#include <linux/cred.h>",
            "#include <linux/idr.h>",
            "#include <linux/kernel.h>",
            "#include <linux/version.h>",
            "#include <linux/filter.h>",
            "#include <linux/license.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/mmzone.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf_lirc.h>",
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_map_init_memlock(struct bpf_map *map)\n{\n\tstruct user_struct *user = get_current_user();\n\tint ret;\n\n\tret = bpf_charge_memlock(user, map->pages);\n\tif (ret) {\n\t\tfree_uid(user);\n\t\treturn ret;\n\t}\n\tmap->user = user;\n\treturn ret;\n}"
  },
  {
    "function_name": "bpf_uncharge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "195-198",
    "snippet": "static void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic void bpf_uncharge_memlock(struct user_struct *user, u32 pages)\n{\n\tatomic_long_sub(pages, &user->locked_vm);\n}"
  },
  {
    "function_name": "bpf_charge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "184-193",
    "snippet": "static int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_long_sub",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 189
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_long_add_return",
          "args": [
            "pages",
            "&user->locked_vm"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 186
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic int bpf_charge_memlock(struct user_struct *user, u32 pages)\n{\n\tunsigned long memlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\n\tif (atomic_long_add_return(pages, &user->locked_vm) > memlock_limit) {\n\t\tatomic_long_sub(pages, &user->locked_vm);\n\t\treturn -EPERM;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_map_precharge_memlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "171-182",
    "snippet": "int bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_long_read",
          "args": [
            "&user->locked_vm"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rlimit",
          "args": [
            "RLIMIT_MEMLOCK"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_current_user",
          "args": [],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_map_precharge_memlock(u32 pages)\n{\n\tstruct user_struct *user = get_current_user();\n\tunsigned long memlock_limit, cur;\n\n\tmemlock_limit = rlimit(RLIMIT_MEMLOCK) >> PAGE_SHIFT;\n\tcur = atomic_long_read(&user->locked_vm);\n\tfree_uid(user);\n\tif (cur + pages > memlock_limit)\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf_map_init_from_attr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "161-169",
    "snippet": "void bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "bpf_map_attr_numa_node",
          "args": [
            "attr"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_init_from_attr(struct bpf_map *map, union bpf_attr *attr)\n{\n\tmap->map_type = attr->map_type;\n\tmap->key_size = attr->key_size;\n\tmap->value_size = attr->value_size;\n\tmap->max_entries = attr->max_entries;\n\tmap->map_flags = attr->map_flags;\n\tmap->numa_node = bpf_map_attr_numa_node(attr);\n}"
  },
  {
    "function_name": "bpf_map_area_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "156-159",
    "snippet": "void bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kvfree",
          "args": [
            "area"
          ],
          "line": 158
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid bpf_map_area_free(void *area)\n{\n\tkvfree(area);\n}"
  },
  {
    "function_name": "bpf_map_area_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "137-154",
    "snippet": "void *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__vmalloc_node_flags_caller",
          "args": [
            "size",
            "numa_node",
            "GFP_KERNEL | flags",
            "__builtin_return_address(0)"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "size",
            "GFP_USER | flags",
            "numa_node"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nvoid *bpf_map_area_alloc(size_t size, int numa_node)\n{\n\t/* We definitely need __GFP_NORETRY, so OOM killer doesn't\n\t * trigger under memory pressure as we really just want to\n\t * fail instead.\n\t */\n\tconst gfp_t flags = __GFP_NOWARN | __GFP_NORETRY | __GFP_ZERO;\n\tvoid *area;\n\n\tif (size <= (PAGE_SIZE << PAGE_ALLOC_COSTLY_ORDER)) {\n\t\tarea = kmalloc_node(size, GFP_USER | flags, numa_node);\n\t\tif (area != NULL)\n\t\t\treturn area;\n\t}\n\n\treturn __vmalloc_node_flags_caller(size, numa_node, GFP_KERNEL | flags,\n\t\t\t\t\t   __builtin_return_address(0));\n}"
  },
  {
    "function_name": "find_and_alloc_map",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "108-135",
    "snippet": "static struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _ops)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};",
      "const struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "map"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->map_alloc",
          "args": [
            "attr"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ops->map_alloc_check",
          "args": [
            "attr"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "array_index_nospec",
          "args": [
            "type",
            "ARRAY_SIZE(bpf_map_types)"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_map_types"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "bpf_map_types"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic const struct bpf_map_ops * const bpf_map_types[] = {\n#define BPF_PROG_TYPE(_id, _ops)\n#define BPF_MAP_TYPE(_id, _ops) \\\n\t[_id] = &_ops,\n#include <linux/bpf_types.h>\n#undef BPF_PROG_TYPE\n#undef BPF_MAP_TYPE\n};\nconst struct bpf_map_ops bpf_map_offload_ops = {\n\t.map_alloc = bpf_map_offload_map_alloc,\n\t.map_free = bpf_map_offload_map_free,\n\t.map_check_btf = map_check_no_btf,\n};\n\nstatic struct bpf_map *find_and_alloc_map(union bpf_attr *attr)\n{\n\tconst struct bpf_map_ops *ops;\n\tu32 type = attr->map_type;\n\tstruct bpf_map *map;\n\tint err;\n\n\tif (type >= ARRAY_SIZE(bpf_map_types))\n\t\treturn ERR_PTR(-EINVAL);\n\ttype = array_index_nospec(type, ARRAY_SIZE(bpf_map_types));\n\tops = bpf_map_types[type];\n\tif (!ops)\n\t\treturn ERR_PTR(-EINVAL);\n\n\tif (ops->map_alloc_check) {\n\t\terr = ops->map_alloc_check(attr);\n\t\tif (err)\n\t\t\treturn ERR_PTR(err);\n\t}\n\tif (attr->map_ifindex)\n\t\tops = &bpf_map_offload_ops;\n\tmap = ops->map_alloc(attr);\n\tif (IS_ERR(map))\n\t\treturn map;\n\tmap->ops = ops;\n\tmap->map_type = type;\n\treturn map;\n}"
  },
  {
    "function_name": "bpf_check_uarg_tail_zero",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "70-100",
    "snippet": "int bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "val",
            "addr"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_READ, uaddr, actual_size)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "uaddr",
            "actual_size"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "actual_size > PAGE_SIZE"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nint bpf_check_uarg_tail_zero(void __user *uaddr,\n\t\t\t     size_t expected_size,\n\t\t\t     size_t actual_size)\n{\n\tunsigned char __user *addr;\n\tunsigned char __user *end;\n\tunsigned char val;\n\tint err;\n\n\tif (unlikely(actual_size > PAGE_SIZE))\t/* silly large */\n\t\treturn -E2BIG;\n\n\tif (unlikely(!access_ok(VERIFY_READ, uaddr, actual_size)))\n\t\treturn -EFAULT;\n\n\tif (actual_size <= expected_size)\n\t\treturn 0;\n\n\taddr = uaddr + expected_size;\n\tend  = uaddr + actual_size;\n\n\tfor (; addr < end; addr++) {\n\t\terr = get_user(val, addr);\n\t\tif (err)\n\t\t\treturn err;\n\t\tif (val)\n\t\t\treturn -E2BIG;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "bpf",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/syscall.c",
    "lines": "2451-2547",
    "snippet": "SYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)\n{\n\tunion bpf_attr attr = {};\n\tint err;\n\n\tif (sysctl_unprivileged_bpf_disabled && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);\n\tif (err)\n\t\treturn err;\n\tsize = min_t(u32, size, sizeof(attr));\n\n\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */\n\tif (copy_from_user(&attr, uattr, size) != 0)\n\t\treturn -EFAULT;\n\n\terr = security_bpf(cmd, &attr, size);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_ELEM:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_ELEM:\n\t\terr = map_update_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_ELEM:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_KEY:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\terr = bpf_prog_load(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_PIN:\n\t\terr = bpf_obj_pin(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET:\n\t\terr = bpf_obj_get(&attr);\n\t\tbreak;\n\tcase BPF_PROG_ATTACH:\n\t\terr = bpf_prog_attach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_DETACH:\n\t\terr = bpf_prog_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_QUERY:\n\t\terr = bpf_prog_query(&attr, uattr);\n\t\tbreak;\n\tcase BPF_PROG_TEST_RUN:\n\t\terr = bpf_prog_test_run(&attr, uattr);\n\t\tbreak;\n\tcase BPF_PROG_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr,\n\t\t\t\t\t  &prog_idr, &prog_idr_lock);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr,\n\t\t\t\t\t  &map_idr, &map_idr_lock);\n\t\tbreak;\n\tcase BPF_PROG_GET_FD_BY_ID:\n\t\terr = bpf_prog_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_FD_BY_ID:\n\t\terr = bpf_map_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET_INFO_BY_FD:\n\t\terr = bpf_obj_get_info_by_fd(&attr, uattr);\n\t\tbreak;\n\tcase BPF_RAW_TRACEPOINT_OPEN:\n\t\terr = bpf_raw_tracepoint_open(&attr);\n\t\tbreak;\n\tcase BPF_BTF_LOAD:\n\t\terr = bpf_btf_load(&attr);\n\t\tbreak;\n\tcase BPF_BTF_GET_FD_BY_ID:\n\t\terr = bpf_btf_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_TASK_FD_QUERY:\n\t\terr = bpf_task_fd_query(&attr, uattr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:\n\t\terr = map_lookup_and_delete_elem(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}",
    "includes": [
      "#include <linux/nospec.h>",
      "#include <linux/ctype.h>",
      "#include <linux/timekeeping.h>",
      "#include <linux/cred.h>",
      "#include <linux/idr.h>",
      "#include <linux/kernel.h>",
      "#include <linux/version.h>",
      "#include <linux/filter.h>",
      "#include <linux/license.h>",
      "#include <linux/fs.h>",
      "#include <linux/file.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/anon_inodes.h>",
      "#include <linux/mmzone.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/btf.h>",
      "#include <linux/bpf_lirc.h>",
      "#include <linux/bpf_trace.h>",
      "#include <linux/bpf.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_IDR(prog_idr);",
      "static DEFINE_SPINLOCK(prog_idr_lock);",
      "static DEFINE_IDR(map_idr);",
      "static DEFINE_SPINLOCK(map_idr_lock);",
      "int sysctl_unprivileged_bpf_disabled"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/nospec.h>\n#include <linux/ctype.h>\n#include <linux/timekeeping.h>\n#include <linux/cred.h>\n#include <linux/idr.h>\n#include <linux/kernel.h>\n#include <linux/version.h>\n#include <linux/filter.h>\n#include <linux/license.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/fdtable.h>\n#include <linux/anon_inodes.h>\n#include <linux/mmzone.h>\n#include <linux/vmalloc.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/syscalls.h>\n#include <linux/btf.h>\n#include <linux/bpf_lirc.h>\n#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n\nstatic DEFINE_IDR(prog_idr);\nstatic DEFINE_SPINLOCK(prog_idr_lock);\nstatic DEFINE_IDR(map_idr);\nstatic DEFINE_SPINLOCK(map_idr_lock);\nint sysctl_unprivileged_bpf_disabled;\n\nSYSCALL_DEFINE3(bpf, int, cmd, union bpf_attr __user *, uattr, unsigned int, size)\n{\n\tunion bpf_attr attr = {};\n\tint err;\n\n\tif (sysctl_unprivileged_bpf_disabled && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\terr = bpf_check_uarg_tail_zero(uattr, sizeof(attr), size);\n\tif (err)\n\t\treturn err;\n\tsize = min_t(u32, size, sizeof(attr));\n\n\t/* copy attributes from user space, may be less than sizeof(bpf_attr) */\n\tif (copy_from_user(&attr, uattr, size) != 0)\n\t\treturn -EFAULT;\n\n\terr = security_bpf(cmd, &attr, size);\n\tif (err < 0)\n\t\treturn err;\n\n\tswitch (cmd) {\n\tcase BPF_MAP_CREATE:\n\t\terr = map_create(&attr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_ELEM:\n\t\terr = map_lookup_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_UPDATE_ELEM:\n\t\terr = map_update_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_DELETE_ELEM:\n\t\terr = map_delete_elem(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_KEY:\n\t\terr = map_get_next_key(&attr);\n\t\tbreak;\n\tcase BPF_PROG_LOAD:\n\t\terr = bpf_prog_load(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_PIN:\n\t\terr = bpf_obj_pin(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET:\n\t\terr = bpf_obj_get(&attr);\n\t\tbreak;\n\tcase BPF_PROG_ATTACH:\n\t\terr = bpf_prog_attach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_DETACH:\n\t\terr = bpf_prog_detach(&attr);\n\t\tbreak;\n\tcase BPF_PROG_QUERY:\n\t\terr = bpf_prog_query(&attr, uattr);\n\t\tbreak;\n\tcase BPF_PROG_TEST_RUN:\n\t\terr = bpf_prog_test_run(&attr, uattr);\n\t\tbreak;\n\tcase BPF_PROG_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr,\n\t\t\t\t\t  &prog_idr, &prog_idr_lock);\n\t\tbreak;\n\tcase BPF_MAP_GET_NEXT_ID:\n\t\terr = bpf_obj_get_next_id(&attr, uattr,\n\t\t\t\t\t  &map_idr, &map_idr_lock);\n\t\tbreak;\n\tcase BPF_PROG_GET_FD_BY_ID:\n\t\terr = bpf_prog_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_MAP_GET_FD_BY_ID:\n\t\terr = bpf_map_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_OBJ_GET_INFO_BY_FD:\n\t\terr = bpf_obj_get_info_by_fd(&attr, uattr);\n\t\tbreak;\n\tcase BPF_RAW_TRACEPOINT_OPEN:\n\t\terr = bpf_raw_tracepoint_open(&attr);\n\t\tbreak;\n\tcase BPF_BTF_LOAD:\n\t\terr = bpf_btf_load(&attr);\n\t\tbreak;\n\tcase BPF_BTF_GET_FD_BY_ID:\n\t\terr = bpf_btf_get_fd_by_id(&attr);\n\t\tbreak;\n\tcase BPF_TASK_FD_QUERY:\n\t\terr = bpf_task_fd_query(&attr, uattr);\n\t\tbreak;\n\tcase BPF_MAP_LOOKUP_AND_DELETE_ELEM:\n\t\terr = map_lookup_and_delete_elem(&attr);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\n\treturn err;\n}"
  }
]