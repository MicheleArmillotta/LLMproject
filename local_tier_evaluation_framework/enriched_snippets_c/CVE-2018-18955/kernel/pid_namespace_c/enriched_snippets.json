[
  {
    "function_name": "pid_namespaces_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "458-466",
    "snippet": "static __init int pid_namespaces_init(void)\n{\n\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC);\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tregister_sysctl_paths(kern_path, pid_ns_ctl_table);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pid_ns_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_paths",
          "args": [
            "kern_path",
            "pid_ns_ctl_table"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "pid_namespace",
            "SLAB_PANIC"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct kmem_cache *pid_ns_cachep;\n\nstatic __init int pid_namespaces_init(void)\n{\n\tpid_ns_cachep = KMEM_CACHE(pid_namespace, SLAB_PANIC);\n\n#ifdef CONFIG_CHECKPOINT_RESTORE\n\tregister_sysctl_paths(kern_path, pid_ns_ctl_table);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "pidns_owner",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "432-435",
    "snippet": "static struct user_namespace *pidns_owner(struct ns_common *ns)\n{\n\treturn to_pid_ns(ns)->user_ns;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "to_pid_ns",
          "args": [
            "ns"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "to_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "337-340",
          "snippet": "static inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct user_namespace *pidns_owner(struct ns_common *ns)\n{\n\treturn to_pid_ns(ns)->user_ns;\n}"
  },
  {
    "function_name": "pidns_get_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "414-430",
    "snippet": "static struct ns_common *pidns_get_parent(struct ns_common *ns)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *pid_ns, *p;\n\n\t/* See if the parent is in the current namespace */\n\tpid_ns = p = to_pid_ns(ns)->parent;\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn &get_pid_ns(pid_ns)->ns;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "pid_ns"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EPERM"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pid_ns",
          "args": [
            "ns"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "to_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "337-340",
          "snippet": "static inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 416
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct ns_common *pidns_get_parent(struct ns_common *ns)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *pid_ns, *p;\n\n\t/* See if the parent is in the current namespace */\n\tpid_ns = p = to_pid_ns(ns)->parent;\n\tfor (;;) {\n\t\tif (!p)\n\t\t\treturn ERR_PTR(-EPERM);\n\t\tif (p == active)\n\t\t\tbreak;\n\t\tp = p->parent;\n\t}\n\n\treturn &get_pid_ns(pid_ns)->ns;\n}"
  },
  {
    "function_name": "pidns_install",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "383-412",
    "snippet": "static int pidns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);\n\n\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Only allow entering the current active pid namespace\n\t * or a child of the current active pid namespace.\n\t *\n\t * This is required for fork to return a usable pid value and\n\t * this maintains the property that processes and their\n\t * children can not escape their current pid namespace.\n\t */\n\tif (new->level < active->level)\n\t\treturn -EINVAL;\n\n\tancestor = new;\n\twhile (ancestor->level > active->level)\n\t\tancestor = ancestor->parent;\n\tif (ancestor != active)\n\t\treturn -EINVAL;\n\n\tput_pid_ns(nsproxy->pid_ns_for_children);\n\tnsproxy->pid_ns_for_children = get_pid_ns(new);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "new"
          ],
          "line": 410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "nsproxy->pid_ns_for_children"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "167-177",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "current_user_ns()",
            "CAP_SYS_ADMIN"
          ],
          "line": 389
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_pid_ns",
          "args": [
            "ns"
          ],
          "line": 386
        },
        "resolved": true,
        "details": {
          "function_name": "to_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "337-340",
          "snippet": "static inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic int pidns_install(struct nsproxy *nsproxy, struct ns_common *ns)\n{\n\tstruct pid_namespace *active = task_active_pid_ns(current);\n\tstruct pid_namespace *ancestor, *new = to_pid_ns(ns);\n\n\tif (!ns_capable(new->user_ns, CAP_SYS_ADMIN) ||\n\t    !ns_capable(current_user_ns(), CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Only allow entering the current active pid namespace\n\t * or a child of the current active pid namespace.\n\t *\n\t * This is required for fork to return a usable pid value and\n\t * this maintains the property that processes and their\n\t * children can not escape their current pid namespace.\n\t */\n\tif (new->level < active->level)\n\t\treturn -EINVAL;\n\n\tancestor = new;\n\twhile (ancestor->level > active->level)\n\t\tancestor = ancestor->parent;\n\tif (ancestor != active)\n\t\treturn -EINVAL;\n\n\tput_pid_ns(nsproxy->pid_ns_for_children);\n\tnsproxy->pid_ns_for_children = get_pid_ns(new);\n\treturn 0;\n}"
  },
  {
    "function_name": "pidns_put",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "378-381",
    "snippet": "static void pidns_put(struct ns_common *ns)\n{\n\tput_pid_ns(to_pid_ns(ns));\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "to_pid_ns(ns)"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "167-177",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "to_pid_ns",
          "args": [
            "ns"
          ],
          "line": 380
        },
        "resolved": true,
        "details": {
          "function_name": "to_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "337-340",
          "snippet": "static inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void pidns_put(struct ns_common *ns)\n{\n\tput_pid_ns(to_pid_ns(ns));\n}"
  },
  {
    "function_name": "pidns_for_children_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "355-376",
    "snippet": "static struct ns_common *pidns_for_children_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns = NULL;\n\n\ttask_lock(task);\n\tif (task->nsproxy) {\n\t\tns = task->nsproxy->pid_ns_for_children;\n\t\tget_pid_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\tif (ns) {\n\t\tread_lock(&tasklist_lock);\n\t\tif (!ns->child_reaper) {\n\t\t\tput_pid_ns(ns);\n\t\t\tns = NULL;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\treturn ns ? &ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 372
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_pid_ns",
          "args": [
            "ns"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "put_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "167-177",
          "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_unlock",
          "args": [
            "task"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "ns"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_lock",
          "args": [
            "task"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct ns_common *pidns_for_children_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns = NULL;\n\n\ttask_lock(task);\n\tif (task->nsproxy) {\n\t\tns = task->nsproxy->pid_ns_for_children;\n\t\tget_pid_ns(ns);\n\t}\n\ttask_unlock(task);\n\n\tif (ns) {\n\t\tread_lock(&tasklist_lock);\n\t\tif (!ns->child_reaper) {\n\t\t\tput_pid_ns(ns);\n\t\t\tns = NULL;\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\treturn ns ? &ns->ns : NULL;\n}"
  },
  {
    "function_name": "pidns_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "342-353",
    "snippet": "static struct ns_common *pidns_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns;\n\n\trcu_read_lock();\n\tns = task_active_pid_ns(task);\n\tif (ns)\n\t\tget_pid_ns(ns);\n\trcu_read_unlock();\n\n\treturn ns ? &ns->ns : NULL;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 350
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "ns"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "task"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 346
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct ns_common *pidns_get(struct task_struct *task)\n{\n\tstruct pid_namespace *ns;\n\n\trcu_read_lock();\n\tns = task_active_pid_ns(task);\n\tif (ns)\n\t\tget_pid_ns(ns);\n\trcu_read_unlock();\n\n\treturn ns ? &ns->ns : NULL;\n}"
  },
  {
    "function_name": "to_pid_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "337-340",
    "snippet": "static inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ns",
            "structpid_namespace",
            "ns"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic inline struct pid_namespace *to_pid_ns(struct ns_common *ns)\n{\n\treturn container_of(ns, struct pid_namespace, ns);\n}"
  },
  {
    "function_name": "reboot_pid_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "308-335",
    "snippet": "int reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)\n{\n\tif (pid_ns == &init_pid_ns)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tpid_ns->reboot = SIGHUP;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tpid_ns->reboot = SIGINT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tforce_sig(SIGKILL, pid_ns->child_reaper);\n\tread_unlock(&tasklist_lock);\n\n\tdo_exit(0);\n\n\t/* Not reached */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_exit",
          "args": [
            "0"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "765-925",
          "snippet": "void __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __noreturn do_exit(long code)\n{\n\tstruct task_struct *tsk = current;\n\tint group_dead;\n\n\tprofile_task_exit(tsk);\n\tkcov_task_exit(tsk);\n\n\tWARN_ON(blk_needs_flush_plug(tsk));\n\n\tif (unlikely(in_interrupt()))\n\t\tpanic(\"Aiee, killing interrupt handler!\");\n\tif (unlikely(!tsk->pid))\n\t\tpanic(\"Attempted to kill the idle task!\");\n\n\t/*\n\t * If do_exit is called because this processes oopsed, it's possible\n\t * that get_fs() was left as KERNEL_DS, so reset it to USER_DS before\n\t * continuing. Amongst other possible reasons, this is to prevent\n\t * mm_release()->clear_child_tid() from writing to a user-controlled\n\t * kernel address.\n\t */\n\tset_fs(USER_DS);\n\n\tptrace_event(PTRACE_EVENT_EXIT, code);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\t/*\n\t * We're taking recursive faults here in do_exit. Safest is to just\n\t * leave this task alone and wait for reboot.\n\t */\n\tif (unlikely(tsk->flags & PF_EXITING)) {\n\t\tpr_alert(\"Fixing recursive fault but reboot is needed!\\n\");\n\t\t/*\n\t\t * We can do this unlocked here. The futex code uses\n\t\t * this flag just to verify whether the pi state\n\t\t * cleanup has been done or not. In the worst case it\n\t\t * loops once more. We pretend that the cleanup was\n\t\t * done as there is no way to return. Either the\n\t\t * OWNER_DIED bit is set by now or we push the blocked\n\t\t * task into the wait for ever nirwana as well.\n\t\t */\n\t\ttsk->flags |= PF_EXITPIDONE;\n\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\tschedule();\n\t}\n\n\texit_signals(tsk);  /* sets PF_EXITING */\n\t/*\n\t * Ensure that all new tsk->pi_lock acquisitions must observe\n\t * PF_EXITING. Serializes against futex.c:attach_to_pi_owner().\n\t */\n\tsmp_mb();\n\t/*\n\t * Ensure that we must observe the pi_state in exit_mm() ->\n\t * mm_release() -> exit_pi_state_list().\n\t */\n\traw_spin_lock_irq(&tsk->pi_lock);\n\traw_spin_unlock_irq(&tsk->pi_lock);\n\n\tif (unlikely(in_atomic())) {\n\t\tpr_info(\"note: %s[%d] exited with preempt_count %d\\n\",\n\t\t\tcurrent->comm, task_pid_nr(current),\n\t\t\tpreempt_count());\n\t\tpreempt_count_set(PREEMPT_ENABLED);\n\t}\n\n\t/* sync mm's RSS info before statistics gathering */\n\tif (tsk->mm)\n\t\tsync_mm_rss(tsk->mm);\n\tacct_update_integrals(tsk);\n\tgroup_dead = atomic_dec_and_test(&tsk->signal->live);\n\tif (group_dead) {\n#ifdef CONFIG_POSIX_TIMERS\n\t\thrtimer_cancel(&tsk->signal->real_timer);\n\t\texit_itimers(tsk->signal);\n#endif\n\t\tif (tsk->mm)\n\t\t\tsetmax_mm_hiwater_rss(&tsk->signal->maxrss, tsk->mm);\n\t}\n\tacct_collect(code, group_dead);\n\tif (group_dead)\n\t\ttty_audit_exit();\n\taudit_free(tsk);\n\n\ttsk->exit_code = code;\n\ttaskstats_exit(tsk, group_dead);\n\n\texit_mm();\n\n\tif (group_dead)\n\t\tacct_process();\n\ttrace_sched_process_exit(tsk);\n\n\texit_sem(tsk);\n\texit_shm(tsk);\n\texit_files(tsk);\n\texit_fs(tsk);\n\tif (group_dead)\n\t\tdisassociate_ctty(1);\n\texit_task_namespaces(tsk);\n\texit_task_work(tsk);\n\texit_thread(tsk);\n\n\t/*\n\t * Flush inherited counters to the parent - before the parent\n\t * gets woken up by child-exit notifications.\n\t *\n\t * because of cgroup mode, must be called before cgroup_exit()\n\t */\n\tperf_event_exit_task(tsk);\n\n\tsched_autogroup_exit_task(tsk);\n\tcgroup_exit(tsk);\n\n\t/*\n\t * FIXME: do that only when needed, using sched_exit tracepoint\n\t */\n\tflush_ptrace_hw_breakpoint(tsk);\n\n\texit_tasks_rcu_start();\n\texit_notify(tsk, group_dead);\n\tproc_exit_connector(tsk);\n\tmpol_put_task_policy(tsk);\n#ifdef CONFIG_FUTEX\n\tif (unlikely(current->pi_state_cache))\n\t\tkfree(current->pi_state_cache);\n#endif\n\t/*\n\t * Make sure we are holding no locks:\n\t */\n\tdebug_check_no_locks_held();\n\t/*\n\t * We can do this unlocked here. The futex code uses this flag\n\t * just to verify whether the pi state cleanup has been done\n\t * or not. In the worst case it loops once more.\n\t */\n\ttsk->flags |= PF_EXITPIDONE;\n\n\tif (tsk->io_context)\n\t\texit_io_context(tsk);\n\n\tif (tsk->splice_pipe)\n\t\tfree_pipe_info(tsk->splice_pipe);\n\n\tif (tsk->task_frag.page)\n\t\tput_page(tsk->task_frag.page);\n\n\tvalidate_creds_for_do_exit(tsk);\n\n\tcheck_stack_usage();\n\tpreempt_disable();\n\tif (tsk->nr_dirtied)\n\t\t__this_cpu_add(dirty_throttle_leaks, tsk->nr_dirtied);\n\texit_rcu();\n\texit_tasks_rcu_finish();\n\n\tlockdep_free_task(tsk);\n\tdo_task_dead();\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGKILL",
            "pid_ns->child_reaper"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_ptrace_errno_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1638-1648",
          "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nint reboot_pid_ns(struct pid_namespace *pid_ns, int cmd)\n{\n\tif (pid_ns == &init_pid_ns)\n\t\treturn 0;\n\n\tswitch (cmd) {\n\tcase LINUX_REBOOT_CMD_RESTART2:\n\tcase LINUX_REBOOT_CMD_RESTART:\n\t\tpid_ns->reboot = SIGHUP;\n\t\tbreak;\n\n\tcase LINUX_REBOOT_CMD_POWER_OFF:\n\tcase LINUX_REBOOT_CMD_HALT:\n\t\tpid_ns->reboot = SIGINT;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\tread_lock(&tasklist_lock);\n\tforce_sig(SIGKILL, pid_ns->child_reaper);\n\tread_unlock(&tasklist_lock);\n\n\tdo_exit(0);\n\n\t/* Not reached */\n\treturn 0;\n}"
  },
  {
    "function_name": "pid_ns_ctl_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "266-290",
    "snippet": "static int pid_ns_ctl_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tstruct ctl_table tmp = *table;\n\tint ret, next;\n\n\tif (write && !ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Writing directly to ns' last_pid field is OK, since this field\n\t * is volatile in a living namespace anyway and a code writing to\n\t * it should synchronize its usage with external means.\n\t */\n\n\tnext = idr_get_cursor(&pid_ns->idr) - 1;\n\n\ttmp.data = &next;\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tif (!ret && write)\n\t\tidr_set_cursor(&pid_ns->idr, next + 1);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "idr_set_cursor",
          "args": [
            "&pid_ns->idr",
            "next + 1"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "&tmp",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_get_cursor",
          "args": [
            "&pid_ns->idr"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "pid_ns->user_ns",
            "CAP_SYS_ADMIN"
          ],
          "line": 273
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic int pid_ns_ctl_handler(struct ctl_table *table, int write,\n\t\tvoid __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct pid_namespace *pid_ns = task_active_pid_ns(current);\n\tstruct ctl_table tmp = *table;\n\tint ret, next;\n\n\tif (write && !ns_capable(pid_ns->user_ns, CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\t/*\n\t * Writing directly to ns' last_pid field is OK, since this field\n\t * is volatile in a living namespace anyway and a code writing to\n\t * it should synchronize its usage with external means.\n\t */\n\n\tnext = idr_get_cursor(&pid_ns->idr) - 1;\n\n\ttmp.data = &next;\n\tret = proc_dointvec_minmax(&tmp, write, buffer, lenp, ppos);\n\tif (!ret && write)\n\t\tidr_set_cursor(&pid_ns->idr, next + 1);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "zap_pid_ns_processes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "180-263",
    "snippet": "void zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() above can't reap the EXIT_DEAD children but we do not\n\t * really care, we could reparent them to the global init. We could\n\t * exit and reap ->child_reaper even if it is not the last thread in\n\t * this pid_ns, free_pid(pid_allocated == 0) calls proc_cleanup_work(),\n\t * pid_ns can not go away until proc_kill_sb() drops the reference.\n\t *\n\t * But this ns can also have other tasks injected by setns()+fork().\n\t * Again, ignoring the user visible semantics we do not really need\n\t * to wait until they are all reaped, but they can be reparented to\n\t * us and thus we need to ensure that pid->child_reaper stays valid\n\t * until they all go away. See free_pid()->wake_up_process().\n\t *\n\t * We rely on ignored SIGCHLD, an injected zombie must be autoreaped\n\t * if reparented.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "acct_exit_ns",
          "args": [
            "pid_ns"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "acct_exit_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/acct.c",
          "lines": "297-301",
          "snippet": "void acct_exit_ns(struct pid_namespace *ns)\n{\n\trcu_read_lock();\n\tpin_kill(ns->bacct);\n}",
          "includes": [
            "#include <linux/fs_pin.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/blkdev.h> /* sector_div */",
            "#include <asm/div64.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/times.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/vfs.h>",
            "#include <linux/security.h>",
            "#include <linux/tty.h>",
            "#include <linux/file.h>",
            "#include <linux/capability.h>",
            "#include <linux/acct.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/fs_pin.h>\n#include <linux/pid_namespace.h>\n#include <linux/blkdev.h> /* sector_div */\n#include <asm/div64.h>\n#include <linux/sched/cputime.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/syscalls.h>\n#include <linux/times.h>\n#include <linux/jiffies.h>\n#include <linux/vfs.h>\n#include <linux/security.h>\n#include <linux/tty.h>\n#include <linux/file.h>\n#include <linux/capability.h>\n#include <linux/acct.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid acct_exit_ns(struct pid_namespace *ns)\n{\n\trcu_read_lock();\n\tpin_kill(ns->bacct);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kernel_wait4",
          "args": [
            "-1",
            "NULL",
            "__WALL",
            "NULL"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "SIGKILL",
            "SEND_SIG_PRIV",
            "task",
            "PIDTYPE_MAX"
          ],
          "line": 219
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1319-1332",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_for_each_entry_continue",
          "args": [
            "&pid_ns->idr",
            "pid",
            "nr"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 214
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 213
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&me->sighand->siglock"
          ],
          "line": 198
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&me->sighand->siglock"
          ],
          "line": 196
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "disable_pid_allocation",
          "args": [
            "pid_ns"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "disable_pid_allocation",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "249-254",
          "snippet": "void disable_pid_allocation(struct pid_namespace *ns)\n{\n\tspin_lock_irq(&pidmap_lock);\n\tns->pid_allocated &= ~PIDNS_ADDING;\n\tspin_unlock_irq(&pidmap_lock);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstatic  __cacheline_aligned_in_smp DEFINE_SPINLOCK(pidmap_lock);\n\nvoid disable_pid_allocation(struct pid_namespace *ns)\n{\n\tspin_lock_irq(&pidmap_lock);\n\tns->pid_allocated &= ~PIDNS_ADDING;\n\tspin_unlock_irq(&pidmap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_leader",
          "args": [
            "me"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid zap_pid_ns_processes(struct pid_namespace *pid_ns)\n{\n\tint nr;\n\tint rc;\n\tstruct task_struct *task, *me = current;\n\tint init_pids = thread_group_leader(me) ? 1 : 2;\n\tstruct pid *pid;\n\n\t/* Don't allow any more processes into the pid namespace */\n\tdisable_pid_allocation(pid_ns);\n\n\t/*\n\t * Ignore SIGCHLD causing any terminated children to autoreap.\n\t * This speeds up the namespace shutdown, plus see the comment\n\t * below.\n\t */\n\tspin_lock_irq(&me->sighand->siglock);\n\tme->sighand->action[SIGCHLD - 1].sa.sa_handler = SIG_IGN;\n\tspin_unlock_irq(&me->sighand->siglock);\n\n\t/*\n\t * The last thread in the cgroup-init thread group is terminating.\n\t * Find remaining pid_ts in the namespace, signal and wait for them\n\t * to exit.\n\t *\n\t * Note:  This signals each threads in the namespace - even those that\n\t * \t  belong to the same thread group, To avoid this, we would have\n\t * \t  to walk the entire tasklist looking a processes in this\n\t * \t  namespace, but that could be unnecessarily expensive if the\n\t * \t  pid namespace has just a few processes. Or we need to\n\t * \t  maintain a tasklist for each pid namespace.\n\t *\n\t */\n\trcu_read_lock();\n\tread_lock(&tasklist_lock);\n\tnr = 2;\n\tidr_for_each_entry_continue(&pid_ns->idr, pid, nr) {\n\t\ttask = pid_task(pid, PIDTYPE_PID);\n\t\tif (task && !__fatal_signal_pending(task))\n\t\t\tgroup_send_sig_info(SIGKILL, SEND_SIG_PRIV, task, PIDTYPE_MAX);\n\t}\n\tread_unlock(&tasklist_lock);\n\trcu_read_unlock();\n\n\t/*\n\t * Reap the EXIT_ZOMBIE children we had before we ignored SIGCHLD.\n\t * kernel_wait4() will also block until our children traced from the\n\t * parent namespace are detached and become EXIT_DEAD.\n\t */\n\tdo {\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\t\trc = kernel_wait4(-1, NULL, __WALL, NULL);\n\t} while (rc != -ECHILD);\n\n\t/*\n\t * kernel_wait4() above can't reap the EXIT_DEAD children but we do not\n\t * really care, we could reparent them to the global init. We could\n\t * exit and reap ->child_reaper even if it is not the last thread in\n\t * this pid_ns, free_pid(pid_allocated == 0) calls proc_cleanup_work(),\n\t * pid_ns can not go away until proc_kill_sb() drops the reference.\n\t *\n\t * But this ns can also have other tasks injected by setns()+fork().\n\t * Again, ignoring the user visible semantics we do not really need\n\t * to wait until they are all reaped, but they can be reparented to\n\t * us and thus we need to ensure that pid->child_reaper stays valid\n\t * until they all go away. See free_pid()->wake_up_process().\n\t *\n\t * We rely on ignored SIGCHLD, an injected zombie must be autoreaped\n\t * if reparented.\n\t */\n\tfor (;;) {\n\t\tset_current_state(TASK_INTERRUPTIBLE);\n\t\tif (pid_ns->pid_allocated == init_pids)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t__set_current_state(TASK_RUNNING);\n\n\tif (pid_ns->reboot)\n\t\tcurrent->signal->group_exit_code = pid_ns->reboot;\n\n\tacct_exit_ns(pid_ns);\n\treturn;\n}"
  },
  {
    "function_name": "put_pid_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "167-177",
    "snippet": "void put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kref_put",
          "args": [
            "&ns->kref",
            "free_pid_ns"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nvoid put_pid_ns(struct pid_namespace *ns)\n{\n\tstruct pid_namespace *parent;\n\n\twhile (ns != &init_pid_ns) {\n\t\tparent = ns->parent;\n\t\tif (!kref_put(&ns->kref, free_pid_ns))\n\t\t\tbreak;\n\t\tns = parent;\n\t}\n}"
  },
  {
    "function_name": "free_pid_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "159-165",
    "snippet": "static void free_pid_ns(struct kref *kref)\n{\n\tstruct pid_namespace *ns;\n\n\tns = container_of(kref, struct pid_namespace, kref);\n\tdestroy_pid_namespace(ns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_pid_namespace",
          "args": [
            "ns"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_pid_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "141-147",
          "snippet": "static void destroy_pid_namespace(struct pid_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\n\tidr_destroy(&ns->idr);\n\tcall_rcu(&ns->rcu, delayed_free_pidns);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void destroy_pid_namespace(struct pid_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\n\tidr_destroy(&ns->idr);\n\tcall_rcu(&ns->rcu, delayed_free_pidns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "kref",
            "structpid_namespace",
            "kref"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void free_pid_ns(struct kref *kref)\n{\n\tstruct pid_namespace *ns;\n\n\tns = container_of(kref, struct pid_namespace, kref);\n\tdestroy_pid_namespace(ns);\n}"
  },
  {
    "function_name": "copy_pid_ns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "149-157",
    "snippet": "struct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "create_pid_namespace",
          "args": [
            "user_ns",
            "old_ns"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "create_pid_namespace",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "77-129",
          "snippet": "static struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\n\tstruct pid_namespace *parent_pid_ns)\n{\n\tstruct pid_namespace *ns;\n\tunsigned int level = parent_pid_ns->level + 1;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!in_userns(parent_pid_ns->user_ns, user_ns))\n\t\tgoto out;\n\n\terr = -ENOSPC;\n\tif (level > MAX_PID_NS_LEVEL)\n\t\tgoto out;\n\tucounts = inc_pid_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\n\tif (ns == NULL)\n\t\tgoto out_dec;\n\n\tidr_init(&ns->idr);\n\n\tns->pid_cachep = create_pid_cachep(level);\n\tif (ns->pid_cachep == NULL)\n\t\tgoto out_free_idr;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto out_free_idr;\n\tns->ns.ops = &pidns_operations;\n\n\tkref_init(&ns->kref);\n\tns->level = level;\n\tns->parent = get_pid_ns(parent_pid_ns);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\tns->pid_allocated = PIDNS_ADDING;\n\tINIT_WORK(&ns->proc_work, proc_cleanup_work);\n\n\treturn ns;\n\nout_free_idr:\n\tidr_destroy(&ns->idr);\n\tkmem_cache_free(pid_ns_cachep, ns);\nout_dec:\n\tdec_pid_namespaces(ucounts);\nout:\n\treturn ERR_PTR(err);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [
            "#define MAX_PID_NS_LEVEL 32"
          ],
          "globals_used": [
            "static struct kmem_cache *pid_ns_cachep;",
            "const struct proc_ns_operations pidns_operations = {\n\t.name\t\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\n#define MAX_PID_NS_LEVEL 32\n\nstatic struct kmem_cache *pid_ns_cachep;\nconst struct proc_ns_operations pidns_operations = {\n\t.name\t\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};\n\nstatic struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\n\tstruct pid_namespace *parent_pid_ns)\n{\n\tstruct pid_namespace *ns;\n\tunsigned int level = parent_pid_ns->level + 1;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!in_userns(parent_pid_ns->user_ns, user_ns))\n\t\tgoto out;\n\n\terr = -ENOSPC;\n\tif (level > MAX_PID_NS_LEVEL)\n\t\tgoto out;\n\tucounts = inc_pid_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\n\tif (ns == NULL)\n\t\tgoto out_dec;\n\n\tidr_init(&ns->idr);\n\n\tns->pid_cachep = create_pid_cachep(level);\n\tif (ns->pid_cachep == NULL)\n\t\tgoto out_free_idr;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto out_free_idr;\n\tns->ns.ops = &pidns_operations;\n\n\tkref_init(&ns->kref);\n\tns->level = level;\n\tns->parent = get_pid_ns(parent_pid_ns);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\tns->pid_allocated = PIDNS_ADDING;\n\tINIT_WORK(&ns->proc_work, proc_cleanup_work);\n\n\treturn ns;\n\nout_free_idr:\n\tidr_destroy(&ns->idr);\n\tkmem_cache_free(pid_ns_cachep, ns);\nout_dec:\n\tdec_pid_namespaces(ucounts);\nout:\n\treturn ERR_PTR(err);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "old_ns"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstruct pid_namespace *copy_pid_ns(unsigned long flags,\n\tstruct user_namespace *user_ns, struct pid_namespace *old_ns)\n{\n\tif (!(flags & CLONE_NEWPID))\n\t\treturn get_pid_ns(old_ns);\n\tif (task_active_pid_ns(current) != old_ns)\n\t\treturn ERR_PTR(-EINVAL);\n\treturn create_pid_namespace(user_ns, old_ns);\n}"
  },
  {
    "function_name": "destroy_pid_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "141-147",
    "snippet": "static void destroy_pid_namespace(struct pid_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\n\tidr_destroy(&ns->idr);\n\tcall_rcu(&ns->rcu, delayed_free_pidns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&ns->rcu",
            "delayed_free_pidns"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&ns->idr"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_free_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void destroy_pid_namespace(struct pid_namespace *ns)\n{\n\tns_free_inum(&ns->ns);\n\n\tidr_destroy(&ns->idr);\n\tcall_rcu(&ns->rcu, delayed_free_pidns);\n}"
  },
  {
    "function_name": "delayed_free_pidns",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "131-139",
    "snippet": "static void delayed_free_pidns(struct rcu_head *p)\n{\n\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);\n\n\tdec_pid_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\n\tkmem_cache_free(pid_ns_cachep, ns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *pid_ns_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pid_ns_cachep",
            "ns"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "ns->user_ns"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "209-212",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dec_pid_namespaces",
          "args": [
            "ns->ucounts"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "dec_pid_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "72-75",
          "snippet": "static void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "p",
            "structpid_namespace",
            "rcu"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct kmem_cache *pid_ns_cachep;\n\nstatic void delayed_free_pidns(struct rcu_head *p)\n{\n\tstruct pid_namespace *ns = container_of(p, struct pid_namespace, rcu);\n\n\tdec_pid_namespaces(ns->ucounts);\n\tput_user_ns(ns->user_ns);\n\n\tkmem_cache_free(pid_ns_cachep, ns);\n}"
  },
  {
    "function_name": "create_pid_namespace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "77-129",
    "snippet": "static struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\n\tstruct pid_namespace *parent_pid_ns)\n{\n\tstruct pid_namespace *ns;\n\tunsigned int level = parent_pid_ns->level + 1;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!in_userns(parent_pid_ns->user_ns, user_ns))\n\t\tgoto out;\n\n\terr = -ENOSPC;\n\tif (level > MAX_PID_NS_LEVEL)\n\t\tgoto out;\n\tucounts = inc_pid_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\n\tif (ns == NULL)\n\t\tgoto out_dec;\n\n\tidr_init(&ns->idr);\n\n\tns->pid_cachep = create_pid_cachep(level);\n\tif (ns->pid_cachep == NULL)\n\t\tgoto out_free_idr;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto out_free_idr;\n\tns->ns.ops = &pidns_operations;\n\n\tkref_init(&ns->kref);\n\tns->level = level;\n\tns->parent = get_pid_ns(parent_pid_ns);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\tns->pid_allocated = PIDNS_ADDING;\n\tINIT_WORK(&ns->proc_work, proc_cleanup_work);\n\n\treturn ns;\n\nout_free_idr:\n\tidr_destroy(&ns->idr);\n\tkmem_cache_free(pid_ns_cachep, ns);\nout_dec:\n\tdec_pid_namespaces(ucounts);\nout:\n\treturn ERR_PTR(err);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [
      "#define MAX_PID_NS_LEVEL 32"
    ],
    "globals_used": [
      "static struct kmem_cache *pid_ns_cachep;",
      "const struct proc_ns_operations pidns_operations = {\n\t.name\t\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "err"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dec_pid_namespaces",
          "args": [
            "ucounts"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "dec_pid_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "72-75",
          "snippet": "static void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "pid_ns_cachep",
            "ns"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "idr_destroy",
          "args": [
            "&ns->idr"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&ns->proc_work",
            "proc_cleanup_work"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "user_ns"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_pid_ns",
          "args": [
            "parent_pid_ns"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kref_init",
          "args": [
            "&ns->kref"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ns_alloc_inum",
          "args": [
            "&ns->ns"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_pid_cachep",
          "args": [
            "level"
          ],
          "line": 103
        },
        "resolved": true,
        "details": {
          "function_name": "create_pid_cachep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "38-59",
          "snippet": "static struct kmem_cache *create_pid_cachep(unsigned int level)\n{\n\t/* Level 0 is init_pid_ns.pid_cachep */\n\tstruct kmem_cache **pkc = &pid_cache[level - 1];\n\tstruct kmem_cache *kc;\n\tchar name[4 + 10 + 1];\n\tunsigned int len;\n\n\tkc = READ_ONCE(*pkc);\n\tif (kc)\n\t\treturn kc;\n\n\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);\n\tlen = sizeof(struct pid) + level * sizeof(struct upid);\n\tmutex_lock(&pid_caches_mutex);\n\t/* Name collision forces to do allocation under mutex. */\n\tif (!*pkc)\n\t\t*pkc = kmem_cache_create(name, len, 0, SLAB_HWCACHE_ALIGN, 0);\n\tmutex_unlock(&pid_caches_mutex);\n\t/* current can fail, but someone else can succeed. */\n\treturn READ_ONCE(*pkc);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(pid_caches_mutex);",
            "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic DEFINE_MUTEX(pid_caches_mutex);\nstatic struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];\n\nstatic struct kmem_cache *create_pid_cachep(unsigned int level)\n{\n\t/* Level 0 is init_pid_ns.pid_cachep */\n\tstruct kmem_cache **pkc = &pid_cache[level - 1];\n\tstruct kmem_cache *kc;\n\tchar name[4 + 10 + 1];\n\tunsigned int len;\n\n\tkc = READ_ONCE(*pkc);\n\tif (kc)\n\t\treturn kc;\n\n\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);\n\tlen = sizeof(struct pid) + level * sizeof(struct upid);\n\tmutex_lock(&pid_caches_mutex);\n\t/* Name collision forces to do allocation under mutex. */\n\tif (!*pkc)\n\t\t*pkc = kmem_cache_create(name, len, 0, SLAB_HWCACHE_ALIGN, 0);\n\tmutex_unlock(&pid_caches_mutex);\n\t/* current can fail, but someone else can succeed. */\n\treturn READ_ONCE(*pkc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "idr_init",
          "args": [
            "&ns->idr"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "pid_ns_cachep",
            "GFP_KERNEL"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "inc_pid_namespaces",
          "args": [
            "user_ns"
          ],
          "line": 92
        },
        "resolved": true,
        "details": {
          "function_name": "inc_pid_namespaces",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
          "lines": "67-70",
          "snippet": "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/export.h>",
            "#include <linux/reboot.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/slab.h>",
            "#include <linux/acct.h>",
            "#include <linux/err.h>",
            "#include <linux/cred.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/pid.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct ucounts *inc_pid_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_userns",
          "args": [
            "parent_pid_ns->user_ns",
            "user_ns"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "in_userns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "1222-1229",
          "snippet": "bool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nbool in_userns(const struct user_namespace *ancestor,\n\t       const struct user_namespace *child)\n{\n\tconst struct user_namespace *ns;\n\tfor (ns = child; ns->level > ancestor->level; ns = ns->parent)\n\t\t;\n\treturn (ns == ancestor);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\n#define MAX_PID_NS_LEVEL 32\n\nstatic struct kmem_cache *pid_ns_cachep;\nconst struct proc_ns_operations pidns_operations = {\n\t.name\t\t= \"pid\",\n\t.type\t\t= CLONE_NEWPID,\n\t.get\t\t= pidns_get,\n\t.put\t\t= pidns_put,\n\t.install\t= pidns_install,\n\t.owner\t\t= pidns_owner,\n\t.get_parent\t= pidns_get_parent,\n};\n\nstatic struct pid_namespace *create_pid_namespace(struct user_namespace *user_ns,\n\tstruct pid_namespace *parent_pid_ns)\n{\n\tstruct pid_namespace *ns;\n\tunsigned int level = parent_pid_ns->level + 1;\n\tstruct ucounts *ucounts;\n\tint err;\n\n\terr = -EINVAL;\n\tif (!in_userns(parent_pid_ns->user_ns, user_ns))\n\t\tgoto out;\n\n\terr = -ENOSPC;\n\tif (level > MAX_PID_NS_LEVEL)\n\t\tgoto out;\n\tucounts = inc_pid_namespaces(user_ns);\n\tif (!ucounts)\n\t\tgoto out;\n\n\terr = -ENOMEM;\n\tns = kmem_cache_zalloc(pid_ns_cachep, GFP_KERNEL);\n\tif (ns == NULL)\n\t\tgoto out_dec;\n\n\tidr_init(&ns->idr);\n\n\tns->pid_cachep = create_pid_cachep(level);\n\tif (ns->pid_cachep == NULL)\n\t\tgoto out_free_idr;\n\n\terr = ns_alloc_inum(&ns->ns);\n\tif (err)\n\t\tgoto out_free_idr;\n\tns->ns.ops = &pidns_operations;\n\n\tkref_init(&ns->kref);\n\tns->level = level;\n\tns->parent = get_pid_ns(parent_pid_ns);\n\tns->user_ns = get_user_ns(user_ns);\n\tns->ucounts = ucounts;\n\tns->pid_allocated = PIDNS_ADDING;\n\tINIT_WORK(&ns->proc_work, proc_cleanup_work);\n\n\treturn ns;\n\nout_free_idr:\n\tidr_destroy(&ns->idr);\n\tkmem_cache_free(pid_ns_cachep, ns);\nout_dec:\n\tdec_pid_namespaces(ucounts);\nout:\n\treturn ERR_PTR(err);\n}"
  },
  {
    "function_name": "dec_pid_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "72-75",
    "snippet": "static void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "dec_ucount",
          "args": [
            "ucounts",
            "UCOUNT_PID_NAMESPACES"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "dec_ucount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "219-227",
          "snippet": "void dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nvoid dec_ucount(struct ucounts *ucounts, enum ucount_type type)\n{\n\tstruct ucounts *iter;\n\tfor (iter = ucounts; iter; iter = iter->ns->ucounts) {\n\t\tint dec = atomic_dec_if_positive(&iter->ucount[type]);\n\t\tWARN_ON_ONCE(dec < 0);\n\t}\n\tput_ucounts(ucounts);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void dec_pid_namespaces(struct ucounts *ucounts)\n{\n\tdec_ucount(ucounts, UCOUNT_PID_NAMESPACES);\n}"
  },
  {
    "function_name": "inc_pid_namespaces",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "67-70",
    "snippet": "static struct ucounts *inc_pid_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "inc_ucount",
          "args": [
            "ns",
            "current_euid()",
            "UCOUNT_PID_NAMESPACES"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "inc_ucount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/ucount.c",
          "lines": "196-217",
          "snippet": "struct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/user_namespace.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/hash.h>",
            "#include <linux/cred.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/user_namespace.h>\n#include <linux/kmemleak.h>\n#include <linux/hash.h>\n#include <linux/cred.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/stat.h>\n\nstruct ucounts *inc_ucount(struct user_namespace *ns, kuid_t uid,\n\t\t\t   enum ucount_type type)\n{\n\tstruct ucounts *ucounts, *iter, *bad;\n\tstruct user_namespace *tns;\n\tucounts = get_ucounts(ns, uid);\n\tfor (iter = ucounts; iter; iter = tns->ucounts) {\n\t\tint max;\n\t\ttns = iter->ns;\n\t\tmax = READ_ONCE(tns->ucount_max[type]);\n\t\tif (!atomic_inc_below(&iter->ucount[type], max))\n\t\t\tgoto fail;\n\t}\n\treturn ucounts;\nfail:\n\tbad = iter;\n\tfor (iter = ucounts; iter != bad; iter = iter->ns->ucounts)\n\t\tatomic_dec(&iter->ucount[type]);\n\n\tput_ucounts(ucounts);\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_euid",
          "args": [],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic struct ucounts *inc_pid_namespaces(struct user_namespace *ns)\n{\n\treturn inc_ucount(ns, current_euid(), UCOUNT_PID_NAMESPACES);\n}"
  },
  {
    "function_name": "proc_cleanup_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "61-65",
    "snippet": "static void proc_cleanup_work(struct work_struct *work)\n{\n\tstruct pid_namespace *ns = container_of(work, struct pid_namespace, proc_work);\n\tpid_ns_release_proc(ns);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pid_ns_release_proc",
          "args": [
            "ns"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structpid_namespace",
            "proc_work"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic void proc_cleanup_work(struct work_struct *work)\n{\n\tstruct pid_namespace *ns = container_of(work, struct pid_namespace, proc_work);\n\tpid_ns_release_proc(ns);\n}"
  },
  {
    "function_name": "create_pid_cachep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid_namespace.c",
    "lines": "38-59",
    "snippet": "static struct kmem_cache *create_pid_cachep(unsigned int level)\n{\n\t/* Level 0 is init_pid_ns.pid_cachep */\n\tstruct kmem_cache **pkc = &pid_cache[level - 1];\n\tstruct kmem_cache *kc;\n\tchar name[4 + 10 + 1];\n\tunsigned int len;\n\n\tkc = READ_ONCE(*pkc);\n\tif (kc)\n\t\treturn kc;\n\n\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);\n\tlen = sizeof(struct pid) + level * sizeof(struct upid);\n\tmutex_lock(&pid_caches_mutex);\n\t/* Name collision forces to do allocation under mutex. */\n\tif (!*pkc)\n\t\t*pkc = kmem_cache_create(name, len, 0, SLAB_HWCACHE_ALIGN, 0);\n\tmutex_unlock(&pid_caches_mutex);\n\t/* current can fail, but someone else can succeed. */\n\treturn READ_ONCE(*pkc);\n}",
    "includes": [
      "#include <linux/idr.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/export.h>",
      "#include <linux/reboot.h>",
      "#include <linux/proc_ns.h>",
      "#include <linux/slab.h>",
      "#include <linux/acct.h>",
      "#include <linux/err.h>",
      "#include <linux/cred.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/pid.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(pid_caches_mutex);",
      "static struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pkc"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&pid_caches_mutex"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "name",
            "len",
            "0",
            "SLAB_HWCACHE_ALIGN",
            "0"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&pid_caches_mutex"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "name",
            "sizeof(name)",
            "\"pid_%u\"",
            "level + 1"
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "*pkc"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/task.h>\n#include <linux/export.h>\n#include <linux/reboot.h>\n#include <linux/proc_ns.h>\n#include <linux/slab.h>\n#include <linux/acct.h>\n#include <linux/err.h>\n#include <linux/cred.h>\n#include <linux/syscalls.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/pid.h>\n\nstatic DEFINE_MUTEX(pid_caches_mutex);\nstatic struct kmem_cache *pid_cache[MAX_PID_NS_LEVEL];\n\nstatic struct kmem_cache *create_pid_cachep(unsigned int level)\n{\n\t/* Level 0 is init_pid_ns.pid_cachep */\n\tstruct kmem_cache **pkc = &pid_cache[level - 1];\n\tstruct kmem_cache *kc;\n\tchar name[4 + 10 + 1];\n\tunsigned int len;\n\n\tkc = READ_ONCE(*pkc);\n\tif (kc)\n\t\treturn kc;\n\n\tsnprintf(name, sizeof(name), \"pid_%u\", level + 1);\n\tlen = sizeof(struct pid) + level * sizeof(struct upid);\n\tmutex_lock(&pid_caches_mutex);\n\t/* Name collision forces to do allocation under mutex. */\n\tif (!*pkc)\n\t\t*pkc = kmem_cache_create(name, len, 0, SLAB_HWCACHE_ALIGN, 0);\n\tmutex_unlock(&pid_caches_mutex);\n\t/* current can fail, but someone else can succeed. */\n\treturn READ_ONCE(*pkc);\n}"
  }
]