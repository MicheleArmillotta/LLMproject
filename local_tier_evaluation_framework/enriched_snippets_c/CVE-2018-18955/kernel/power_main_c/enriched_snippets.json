[
  {
    "function_name": "pm_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "806-822",
    "snippet": "static int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpm_states_init();\n\tpower_kobj = kobject_create_and_add(\"power\", NULL);\n\tif (!power_kobj)\n\t\treturn -ENOMEM;\n\terror = sysfs_create_group(power_kobj, &attr_group);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kobject *power_kobj;",
      "static const struct attribute_group attr_group = {\n\t.attrs = g,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_init",
          "args": [],
          "line": 821
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "301-301",
          "snippet": "static inline int pm_autosleep_init(void) { return 0; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_init(void) { return 0; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_print_times_init",
          "args": [],
          "line": 820
        },
        "resolved": true,
        "details": {
          "function_name": "pm_print_times_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "449-449",
          "snippet": "static inline void pm_print_times_init(void) {}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "sysfs_create_group",
          "args": [
            "power_kobj",
            "&attr_group"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kobject_create_and_add",
          "args": [
            "\"power\"",
            "NULL"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_states_init",
          "args": [],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "pm_states_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/suspend.c",
          "lines": "185-195",
          "snippet": "void __init pm_states_init(void)\n{\n\t/* \"mem\" and \"freeze\" are always present in /sys/power/state. */\n\tpm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];\n\tpm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];\n\t/*\n\t * Suspend-to-idle should be supported even without any suspend_ops,\n\t * initialize mem_sleep_states[] accordingly here.\n\t */\n\tmem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "const char * const pm_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"freeze\",\n\t[PM_SUSPEND_STANDBY] = \"standby\",\n\t[PM_SUSPEND_MEM] = \"mem\",\n};",
            "const char *pm_states[PM_SUSPEND_MAX];",
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};",
            "const char *mem_sleep_states[PM_SUSPEND_MAX];",
            "static const struct platform_suspend_ops *suspend_ops;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/syscalls.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nconst char * const pm_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"freeze\",\n\t[PM_SUSPEND_STANDBY] = \"standby\",\n\t[PM_SUSPEND_MEM] = \"mem\",\n};\nconst char *pm_states[PM_SUSPEND_MAX];\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\nconst char *mem_sleep_states[PM_SUSPEND_MAX];\nstatic const struct platform_suspend_ops *suspend_ops;\n\nvoid __init pm_states_init(void)\n{\n\t/* \"mem\" and \"freeze\" are always present in /sys/power/state. */\n\tpm_states[PM_SUSPEND_MEM] = pm_labels[PM_SUSPEND_MEM];\n\tpm_states[PM_SUSPEND_TO_IDLE] = pm_labels[PM_SUSPEND_TO_IDLE];\n\t/*\n\t * Suspend-to-idle should be supported even without any suspend_ops,\n\t * initialize mem_sleep_states[] accordingly here.\n\t */\n\tmem_sleep_states[PM_SUSPEND_TO_IDLE] = mem_sleep_labels[PM_SUSPEND_TO_IDLE];\n}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_reserved_size_init",
          "args": [],
          "line": 812
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_reserved_size_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "74-74",
          "snippet": "static inline void hibernate_reserved_size_init(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void hibernate_reserved_size_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate_image_size_init",
          "args": [],
          "line": 811
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate_image_size_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "75-75",
          "snippet": "static inline void hibernate_image_size_init(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void hibernate_image_size_init(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "pm_start_workqueue",
          "args": [],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "pm_start_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "799-804",
          "snippet": "static int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct workqueue_struct *pm_wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct workqueue_struct *pm_wq;\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct kobject *power_kobj;\nstatic const struct attribute_group attr_group = {\n\t.attrs = g,\n};\n\nstatic int __init pm_init(void)\n{\n\tint error = pm_start_workqueue();\n\tif (error)\n\t\treturn error;\n\thibernate_image_size_init();\n\thibernate_reserved_size_init();\n\tpm_states_init();\n\tpower_kobj = kobject_create_and_add(\"power\", NULL);\n\tif (!power_kobj)\n\t\treturn -ENOMEM;\n\terror = sysfs_create_group(power_kobj, &attr_group);\n\tif (error)\n\t\treturn error;\n\tpm_print_times_init();\n\treturn pm_autosleep_init();\n}"
  },
  {
    "function_name": "pm_start_workqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "799-804",
    "snippet": "static int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *pm_wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"pm\"",
            "WQ_FREEZABLE",
            "0"
          ],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstruct workqueue_struct *pm_wq;\n\nstatic int __init pm_start_workqueue(void)\n{\n\tpm_wq = alloc_workqueue(\"pm\", WQ_FREEZABLE, 0);\n\n\treturn pm_wq ? 0 : -ENOMEM;\n}"
  },
  {
    "function_name": "pm_freeze_timeout_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "743-754",
    "snippet": "static ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_freeze_timeout_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tfreeze_timeout_msecs = val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_freeze_timeout_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "737-741",
    "snippet": "static ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "freeze_timeout_msecs"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_freeze_timeout_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%u\\n\", freeze_timeout_msecs);\n}"
  },
  {
    "function_name": "pm_trace_dev_match_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "725-730",
    "snippet": "static ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, PAGE_SIZE);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_trace_dev_match",
          "args": [
            "buf",
            "PAGE_SIZE"
          ],
          "line": 729
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_trace_dev_match_show(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       char *buf)\n{\n\treturn show_trace_dev_match(buf, PAGE_SIZE);\n}"
  },
  {
    "function_name": "pm_trace_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "706-721",
    "snippet": "static ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\""
          ],
          "line": 715
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%d\"",
            "&val"
          ],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t\npm_trace_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t       const char *buf, size_t n)\n{\n\tint val;\n\n\tif (sscanf(buf, \"%d\", &val) == 1) {\n\t\tpm_trace_enabled = !!val;\n\t\tif (pm_trace_enabled) {\n\t\t\tpr_warn(\"PM: Enabling pm_trace changes system date and time during resume.\\n\"\n\t\t\t\t\"PM: Correct system time has to be restored manually after resume.\\n\");\n\t\t}\n\t\treturn n;\n\t}\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "pm_trace_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "700-704",
    "snippet": "static ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_trace_enabled"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_trace_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_trace_enabled);\n}"
  },
  {
    "function_name": "wake_unlock_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "684-690",
    "snippet": "static ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_wake_unlock",
          "args": [
            "buf"
          ],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "pm_wake_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "248-282",
          "snippet": "int pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(&wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_unlock(const char *buf)\n{\n\tstruct wakelock *wl;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\tlen = strlen(buf);\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (buf[len-1] == '\\n')\n\t\tlen--;\n\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, false);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\t__pm_relax(&wl->ws);\n\n\twakelocks_lru_most_recent(wl);\n\twakelocks_gc();\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_unlock_store(struct kobject *kobj,\n\t\t\t\t struct kobj_attribute *attr,\n\t\t\t\t const char *buf, size_t n)\n{\n\tint error = pm_wake_unlock(buf);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "wake_unlock_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "677-682",
    "snippet": "static ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_show_wakelocks",
          "args": [
            "buf",
            "false"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "pm_show_wakelocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "38-59",
          "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);",
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_unlock_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\treturn pm_show_wakelocks(buf, false);\n}"
  },
  {
    "function_name": "wake_lock_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "667-673",
    "snippet": "static ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_wake_lock",
          "args": [
            "buf"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "pm_wake_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "200-246",
          "snippet": "int pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(&wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(&wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\n\nint pm_wake_lock(const char *buf)\n{\n\tconst char *str = buf;\n\tstruct wakelock *wl;\n\tu64 timeout_ns = 0;\n\tsize_t len;\n\tint ret = 0;\n\n\tif (!capable(CAP_BLOCK_SUSPEND))\n\t\treturn -EPERM;\n\n\twhile (*str && !isspace(*str))\n\t\tstr++;\n\n\tlen = str - buf;\n\tif (!len)\n\t\treturn -EINVAL;\n\n\tif (*str && *str != '\\n') {\n\t\t/* Find out if there's a valid timeout string appended. */\n\t\tret = kstrtou64(skip_spaces(str), 10, &timeout_ns);\n\t\tif (ret)\n\t\t\treturn -EINVAL;\n\t}\n\n\tmutex_lock(&wakelocks_lock);\n\n\twl = wakelock_lookup_add(buf, len, true);\n\tif (IS_ERR(wl)) {\n\t\tret = PTR_ERR(wl);\n\t\tgoto out;\n\t}\n\tif (timeout_ns) {\n\t\tu64 timeout_ms = timeout_ns + NSEC_PER_MSEC - 1;\n\n\t\tdo_div(timeout_ms, NSEC_PER_MSEC);\n\t\t__pm_wakeup_event(&wl->ws, timeout_ms);\n\t} else {\n\t\t__pm_stay_awake(&wl->ws);\n\t}\n\n\twakelocks_lru_most_recent(wl);\n\n out:\n\tmutex_unlock(&wakelocks_lock);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_lock_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tint error = pm_wake_lock(buf);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "wake_lock_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "660-665",
    "snippet": "static ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_show_wakelocks",
          "args": [
            "buf",
            "true"
          ],
          "line": 664
        },
        "resolved": true,
        "details": {
          "function_name": "pm_show_wakelocks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/wakelock.c",
          "lines": "38-59",
          "snippet": "ssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/rbtree.h>",
            "#include <linux/list.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/ctype.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(wakelocks_lock);",
            "static struct rb_root wakelocks_tree = RB_ROOT;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/rbtree.h>\n#include <linux/list.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/ctype.h>\n#include <linux/capability.h>\n\nstatic DEFINE_MUTEX(wakelocks_lock);\nstatic struct rb_root wakelocks_tree = RB_ROOT;\n\nssize_t pm_show_wakelocks(char *buf, bool show_active)\n{\n\tstruct rb_node *node;\n\tstruct wakelock *wl;\n\tchar *str = buf;\n\tchar *end = buf + PAGE_SIZE;\n\n\tmutex_lock(&wakelocks_lock);\n\n\tfor (node = rb_first(&wakelocks_tree); node; node = rb_next(node)) {\n\t\twl = rb_entry(node, struct wakelock, node);\n\t\tif (wl->ws.active == show_active)\n\t\t\tstr += scnprintf(str, end - str, \"%s \", wl->name);\n\t}\n\tif (str > buf)\n\t\tstr--;\n\n\tstr += scnprintf(str, end - str, \"\\n\");\n\n\tmutex_unlock(&wakelocks_lock);\n\treturn (str - buf);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wake_lock_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\treturn pm_show_wakelocks(buf, true);\n}"
  },
  {
    "function_name": "autosleep_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "638-654",
    "snippet": "static ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == PM_SUSPEND_ON\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -EINVAL;\n\n\tif (state == PM_SUSPEND_MEM)\n\t\tstate = mem_sleep_current;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_set_state",
          "args": [
            "state"
          ],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_set_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/autosleep.c",
          "lines": "90-115",
          "snippet": "int pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/pm_wakeup.h>",
            "#include <linux/mutex.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static suspend_state_t autosleep_state;",
            "static DEFINE_MUTEX(autosleep_lock);",
            "static struct wakeup_source *autosleep_ws;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/pm_wakeup.h>\n#include <linux/mutex.h>\n#include <linux/device.h>\n\nstatic suspend_state_t autosleep_state;\nstatic DEFINE_MUTEX(autosleep_lock);\nstatic struct wakeup_source *autosleep_ws;\n\nint pm_autosleep_set_state(suspend_state_t state)\n{\n\n#ifndef CONFIG_HIBERNATION\n\tif (state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n#endif\n\n\t__pm_stay_awake(autosleep_ws);\n\n\tmutex_lock(&autosleep_lock);\n\n\tautosleep_state = state;\n\n\t__pm_relax(autosleep_ws);\n\n\tif (state > PM_SUSPEND_ON) {\n\t\tpm_wakep_autosleep_enabled(true);\n\t\tqueue_up_suspend_work();\n\t} else {\n\t\tpm_wakep_autosleep_enabled(false);\n\t}\n\n\tmutex_unlock(&autosleep_lock);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"off\\n\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "buf",
            "\"off\""
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "decode_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 642
        },
        "resolved": true,
        "details": {
          "function_name": "decode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "485-510",
          "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t autosleep_store(struct kobject *kobj,\n\t\t\t       struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state = decode_state(buf, n);\n\tint error;\n\n\tif (state == PM_SUSPEND_ON\n\t    && strcmp(buf, \"off\") && strcmp(buf, \"off\\n\"))\n\t\treturn -EINVAL;\n\n\tif (state == PM_SUSPEND_MEM)\n\t\tstate = mem_sleep_current;\n\n\terror = pm_autosleep_set_state(state);\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "autosleep_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "617-636",
    "snippet": "static ssize_t autosleep_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tsuspend_state_t state = pm_autosleep_state();\n\n\tif (state == PM_SUSPEND_ON)\n\t\treturn sprintf(buf, \"off\\n\");\n\n#ifdef CONFIG_SUSPEND\n\tif (state < PM_SUSPEND_MAX)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef CONFIG_HIBERNATION\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"error\""
          ],
          "line": 634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"disk\\n\""
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%s\\n\"",
            "pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\""
          ],
          "line": 628
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"off\\n\""
          ],
          "line": 624
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t autosleep_show(struct kobject *kobj,\n\t\t\t      struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tsuspend_state_t state = pm_autosleep_state();\n\n\tif (state == PM_SUSPEND_ON)\n\t\treturn sprintf(buf, \"off\\n\");\n\n#ifdef CONFIG_SUSPEND\n\tif (state < PM_SUSPEND_MAX)\n\t\treturn sprintf(buf, \"%s\\n\", pm_states[state] ?\n\t\t\t\t\tpm_states[state] : \"error\");\n#endif\n#ifdef CONFIG_HIBERNATION\n\treturn sprintf(buf, \"disk\\n\");\n#else\n\treturn sprintf(buf, \"error\");\n#endif\n}"
  },
  {
    "function_name": "wakeup_count_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "585-612",
    "snippet": "static ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terror = -EINVAL;\n\tif (sscanf(buf, \"%u\", &val) == 1) {\n\t\tif (pm_save_wakeup_count(val))\n\t\t\terror = n;\n\t\telse\n\t\t\tpm_print_active_wakeup_sources();\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 610
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "pm_print_active_wakeup_sources",
          "args": [],
          "line": 606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_save_wakeup_count",
          "args": [
            "val"
          ],
          "line": 603
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sscanf",
          "args": [
            "buf",
            "\"%u\"",
            "&val"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 596
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wakeup_count_store(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tunsigned int val;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\terror = -EINVAL;\n\tif (sscanf(buf, \"%u\", &val) == 1) {\n\t\tif (pm_save_wakeup_count(val))\n\t\t\terror = n;\n\t\telse\n\t\t\tpm_print_active_wakeup_sources();\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "wakeup_count_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "575-583",
    "snippet": "static ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -EINTR;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "val"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pm_get_wakeup_count",
          "args": [
            "&val",
            "true"
          ],
          "line": 581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t wakeup_count_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tunsigned int val;\n\n\treturn pm_get_wakeup_count(&val, true) ?\n\t\tsprintf(buf, \"%u\\n\", val) : -EINTR;\n}"
  },
  {
    "function_name": "state_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "512-542",
    "snippet": "static ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_state(buf, n);\n\tif (state < PM_SUSPEND_MAX) {\n\t\tif (state == PM_SUSPEND_MEM)\n\t\t\tstate = mem_sleep_current;\n\n\t\terror = pm_suspend(state);\n\t} else if (state == PM_SUSPEND_MAX) {\n\t\terror = hibernate();\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "hibernate",
          "args": [],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "hibernate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "687-778",
          "snippet": "int hibernate(void)\n{\n\tint error, nr_calls = 0;\n\tbool snapshot_test = false;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Exit;\n\t}\n\n\tpr_info(\"Syncing filesystems ... \\n\");\n\tksys_sync();\n\tpr_info(\"done.\\n\");\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\t__pm_notifier_call_chain(PM_POST_HIBERNATION, nr_calls, NULL);\n\tpm_restore_console();\n\tatomic_inc(&snapshot_device_available);\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nocompress;",
            "static int hibernation_mode = HIBERNATION_SHUTDOWN;",
            "bool freezer_test_done;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nocompress;\nstatic int hibernation_mode = HIBERNATION_SHUTDOWN;\nbool freezer_test_done;\n\nint hibernate(void)\n{\n\tint error, nr_calls = 0;\n\tbool snapshot_test = false;\n\n\tif (!hibernation_available()) {\n\t\tpm_pr_dbg(\"Hibernation not available.\\n\");\n\t\treturn -EPERM;\n\t}\n\n\tlock_system_sleep();\n\t/* The snapshot device should not be opened while we're running */\n\tif (!atomic_add_unless(&snapshot_device_available, -1, 0)) {\n\t\terror = -EBUSY;\n\t\tgoto Unlock;\n\t}\n\n\tpr_info(\"hibernation entry\\n\");\n\tpm_prepare_console();\n\terror = __pm_notifier_call_chain(PM_HIBERNATION_PREPARE, -1, &nr_calls);\n\tif (error) {\n\t\tnr_calls--;\n\t\tgoto Exit;\n\t}\n\n\tpr_info(\"Syncing filesystems ... \\n\");\n\tksys_sync();\n\tpr_info(\"done.\\n\");\n\n\terror = freeze_processes();\n\tif (error)\n\t\tgoto Exit;\n\n\tlock_device_hotplug();\n\t/* Allocate memory management structures */\n\terror = create_basic_memory_bitmaps();\n\tif (error)\n\t\tgoto Thaw;\n\n\terror = hibernation_snapshot(hibernation_mode == HIBERNATION_PLATFORM);\n\tif (error || freezer_test_done)\n\t\tgoto Free_bitmaps;\n\n\tif (in_suspend) {\n\t\tunsigned int flags = 0;\n\n\t\tif (hibernation_mode == HIBERNATION_PLATFORM)\n\t\t\tflags |= SF_PLATFORM_MODE;\n\t\tif (nocompress)\n\t\t\tflags |= SF_NOCOMPRESS_MODE;\n\t\telse\n\t\t        flags |= SF_CRC32_MODE;\n\n\t\tpm_pr_dbg(\"Writing image.\\n\");\n\t\terror = swsusp_write(flags);\n\t\tswsusp_free();\n\t\tif (!error) {\n\t\t\tif (hibernation_mode == HIBERNATION_TEST_RESUME)\n\t\t\t\tsnapshot_test = true;\n\t\t\telse\n\t\t\t\tpower_down();\n\t\t}\n\t\tin_suspend = 0;\n\t\tpm_restore_gfp_mask();\n\t} else {\n\t\tpm_pr_dbg(\"Image restored successfully.\\n\");\n\t}\n\n Free_bitmaps:\n\tfree_basic_memory_bitmaps();\n Thaw:\n\tunlock_device_hotplug();\n\tif (snapshot_test) {\n\t\tpm_pr_dbg(\"Checking hibernation image\\n\");\n\t\terror = swsusp_check();\n\t\tif (!error)\n\t\t\terror = load_image_and_restore();\n\t}\n\tthaw_processes();\n\n\t/* Don't bother checking whether freezer_test_done is true */\n\tfreezer_test_done = false;\n Exit:\n\t__pm_notifier_call_chain(PM_POST_HIBERNATION, nr_calls, NULL);\n\tpm_restore_console();\n\tatomic_inc(&snapshot_device_available);\n Unlock:\n\tunlock_system_sleep();\n\tpr_info(\"hibernation exit\\n\");\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_suspend",
          "args": [
            "state"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "pm_suspend",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/suspend.c",
          "lines": "610-627",
          "snippet": "int pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/moduleparam.h>",
            "#include <linux/compiler.h>",
            "#include <trace/events/power.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/swait.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>",
            "#include <linux/list.h>",
            "#include <linux/kernel.h>",
            "#include <linux/io.h>",
            "#include <linux/gfp.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/init.h>",
            "#include <linux/errno.h>",
            "#include <linux/delay.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/moduleparam.h>\n#include <linux/compiler.h>\n#include <trace/events/power.h>\n#include <linux/ftrace.h>\n#include <linux/swait.h>\n#include <linux/syscore_ops.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n#include <linux/list.h>\n#include <linux/kernel.h>\n#include <linux/io.h>\n#include <linux/gfp.h>\n#include <linux/syscalls.h>\n#include <linux/cpuidle.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/init.h>\n#include <linux/errno.h>\n#include <linux/delay.h>\n#include <linux/string.h>\n\nstatic const char * const mem_sleep_labels[] = {\n\t[PM_SUSPEND_TO_IDLE] = \"s2idle\",\n\t[PM_SUSPEND_STANDBY] = \"shallow\",\n\t[PM_SUSPEND_MEM] = \"deep\",\n};\n\nint pm_suspend(suspend_state_t state)\n{\n\tint error;\n\n\tif (state <= PM_SUSPEND_ON || state >= PM_SUSPEND_MAX)\n\t\treturn -EINVAL;\n\n\tpr_info(\"suspend entry (%s)\\n\", mem_sleep_labels[state]);\n\terror = enter_state(state);\n\tif (error) {\n\t\tsuspend_stats.fail++;\n\t\tdpm_save_failed_errno(error);\n\t} else {\n\t\tsuspend_stats.success++;\n\t}\n\tpr_info(\"suspend exit\\n\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "decode_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "decode_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "485-510",
          "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 522
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t state_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t   const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_state(buf, n);\n\tif (state < PM_SUSPEND_MAX) {\n\t\tif (state == PM_SUSPEND_MEM)\n\t\t\tstate = mem_sleep_current;\n\n\t\terror = pm_suspend(state);\n\t} else if (state == PM_SUSPEND_MAX) {\n\t\terror = hibernate();\n\t} else {\n\t\terror = -EINVAL;\n\t}\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "decode_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "485-510",
    "snippet": "static suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "label",
            "len"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "label"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "\"disk\"",
            "len"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_state(const char *buf, size_t n)\n{\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t state;\n#endif\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\t/* Check hibernation first. */\n\tif (len == 4 && !strncmp(buf, \"disk\", len))\n\t\treturn PM_SUSPEND_MAX;\n\n#ifdef CONFIG_SUSPEND\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = pm_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n#endif\n\n\treturn PM_SUSPEND_ON;\n}"
  },
  {
    "function_name": "state_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "465-483",
    "snippet": "static ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar *s = buf;\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"disk \""
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hibernation_available",
          "args": [],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "hibernation_available",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/hibernate.c",
          "lines": "71-74",
          "snippet": "bool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <trace/events/power.h>",
            "#include <linux/ktime.h>",
            "#include <linux/genhd.h>",
            "#include <linux/ctype.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/gfp.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/pm.h>",
            "#include <linux/mount.h>",
            "#include <linux/fs.h>",
            "#include <linux/delay.h>",
            "#include <linux/async.h>",
            "#include <linux/device.h>",
            "#include <linux/string.h>",
            "#include <linux/reboot.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int nohibernate;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <trace/events/power.h>\n#include <linux/ktime.h>\n#include <linux/genhd.h>\n#include <linux/ctype.h>\n#include <linux/syscore_ops.h>\n#include <linux/gfp.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/pm.h>\n#include <linux/mount.h>\n#include <linux/fs.h>\n#include <linux/delay.h>\n#include <linux/async.h>\n#include <linux/device.h>\n#include <linux/string.h>\n#include <linux/reboot.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/export.h>\n\nstatic int nohibernate;\n\nbool hibernation_available(void)\n{\n\treturn (nohibernate == 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "pm_states[i]"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t state_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t  char *buf)\n{\n\tchar *s = buf;\n#ifdef CONFIG_SUSPEND\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (pm_states[i])\n\t\t\ts += sprintf(s,\"%s \", pm_states[i]);\n\n#endif\n\tif (hibernation_available())\n\t\ts += sprintf(s, \"disk \");\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "pm_print_times_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "449-449",
    "snippet": "static inline void pm_print_times_init(void) {}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void) {}"
  },
  {
    "function_name": "__pm_pr_dbg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "427-446",
    "snippet": "void __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"PM: %pV\"",
            "&vaf"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_DEBUG \"PM: %pV\"",
            "&vaf"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid __pm_pr_dbg(bool defer, const char *fmt, ...)\n{\n\tstruct va_format vaf;\n\tva_list args;\n\n\tif (!pm_debug_messages_on)\n\t\treturn;\n\n\tva_start(args, fmt);\n\n\tvaf.fmt = fmt;\n\tvaf.va = &args;\n\n\tif (defer)\n\t\tprintk_deferred(KERN_DEBUG \"PM: %pV\", &vaf);\n\telse\n\t\tprintk(KERN_DEBUG \"PM: %pV\", &vaf);\n\n\tva_end(args);\n}"
  },
  {
    "function_name": "pm_debug_messages_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "401-415",
    "snippet": "static ssize_t pm_debug_messages_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_debug_messages_on = !!val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_debug_messages_store(struct kobject *kobj,\n\t\t\t\t       struct kobj_attribute *attr,\n\t\t\t\t       const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_debug_messages_on = !!val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_debug_messages_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "395-399",
    "snippet": "static ssize_t pm_debug_messages_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_debug_messages_on);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_debug_messages_on"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_debug_messages_show(struct kobject *kobj,\n\t\t\t\t      struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_debug_messages_on);\n}"
  },
  {
    "function_name": "pm_wakeup_irq_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "384-389",
    "snippet": "static ssize_t pm_wakeup_irq_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn pm_wakeup_irq ? sprintf(buf, \"%u\\n\", pm_wakeup_irq) : -ENODATA;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "pm_wakeup_irq"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_wakeup_irq_show(struct kobject *kobj,\n\t\t\t\t\tstruct kobj_attribute *attr,\n\t\t\t\t\tchar *buf)\n{\n\treturn pm_wakeup_irq ? sprintf(buf, \"%u\\n\", pm_wakeup_irq) : -ENODATA;\n}"
  },
  {
    "function_name": "pm_print_times_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "379-382",
    "snippet": "static inline void pm_print_times_init(void)\n{\n\tpm_print_times_enabled = !!initcall_debug;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic inline void pm_print_times_init(void)\n{\n\tpm_print_times_enabled = !!initcall_debug;\n}"
  },
  {
    "function_name": "pm_print_times_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "361-375",
    "snippet": "static ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_print_times_enabled = !!val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_print_times_store(struct kobject *kobj,\n\t\t\t\t    struct kobj_attribute *attr,\n\t\t\t\t    const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_print_times_enabled = !!val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_print_times_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "355-359",
    "snippet": "static ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_print_times_enabled"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_print_times_show(struct kobject *kobj,\n\t\t\t\t   struct kobj_attribute *attr, char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_print_times_enabled);\n}"
  },
  {
    "function_name": "pm_debugfs_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "334-339",
    "snippet": "static int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", S_IFREG | S_IRUGO,\n\t\t\tNULL, NULL, &suspend_stats_operations);\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debugfs_create_file",
          "args": [
            "\"suspend_stats\"",
            "S_IFREG | S_IRUGO",
            "NULL",
            "NULL",
            "&suspend_stats_operations"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int __init pm_debugfs_init(void)\n{\n\tdebugfs_create_file(\"suspend_stats\", S_IFREG | S_IRUGO,\n\t\t\tNULL, NULL, &suspend_stats_operations);\n\treturn 0;\n}"
  },
  {
    "function_name": "suspend_stats_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "322-325",
    "snippet": "static int suspend_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, suspend_stats_show, NULL);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "single_open",
          "args": [
            "file",
            "suspend_stats_show",
            "NULL"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int suspend_stats_open(struct inode *inode, struct file *file)\n{\n\treturn single_open(file, suspend_stats_show, NULL);\n}"
  },
  {
    "function_name": "suspend_stats_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "266-320",
    "snippet": "static int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tlast_dev %= REC_FAILED_NUM;\n\tlast_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tlast_errno %= REC_FAILED_NUM;\n\tlast_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tlast_step %= REC_FAILED_NUM;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_dev + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_errno + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_step + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "seq_printf",
          "args": [
            "s",
            "\"\\t\\t\\t%-s\\n\"",
            "suspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index])"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "trace_seq_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_seq.c",
          "lines": "84-103",
          "snippet": "void trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}",
          "includes": [
            "#include <linux/trace_seq.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/uaccess.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/trace_seq.h>\n#include <linux/seq_file.h>\n#include <linux/uaccess.h>\n\nvoid trace_seq_printf(struct trace_seq *s, const char *fmt, ...)\n{\n\tunsigned int save_len = s->seq.len;\n\tva_list ap;\n\n\tif (s->full)\n\t\treturn;\n\n\t__trace_seq_init(s);\n\n\tva_start(ap, fmt);\n\tseq_buf_vprintf(&s->seq, fmt, ap);\n\tva_end(ap);\n\n\t/* If we can't write it all, don't bother writing anything */\n\tif (unlikely(seq_buf_has_overflowed(&s->seq))) {\n\t\ts->seq.len = save_len;\n\t\ts->full = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "suspend_step_name",
          "args": [
            "suspend_stats.failed_steps[index]"
          ],
          "line": 315
        },
        "resolved": true,
        "details": {
          "function_name": "suspend_step_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "246-264",
          "snippet": "static char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic int suspend_stats_show(struct seq_file *s, void *unused)\n{\n\tint i, index, last_dev, last_errno, last_step;\n\n\tlast_dev = suspend_stats.last_failed_dev + REC_FAILED_NUM - 1;\n\tlast_dev %= REC_FAILED_NUM;\n\tlast_errno = suspend_stats.last_failed_errno + REC_FAILED_NUM - 1;\n\tlast_errno %= REC_FAILED_NUM;\n\tlast_step = suspend_stats.last_failed_step + REC_FAILED_NUM - 1;\n\tlast_step %= REC_FAILED_NUM;\n\tseq_printf(s, \"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\"\n\t\t\t\"%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n%s: %d\\n\",\n\t\t\t\"success\", suspend_stats.success,\n\t\t\t\"fail\", suspend_stats.fail,\n\t\t\t\"failed_freeze\", suspend_stats.failed_freeze,\n\t\t\t\"failed_prepare\", suspend_stats.failed_prepare,\n\t\t\t\"failed_suspend\", suspend_stats.failed_suspend,\n\t\t\t\"failed_suspend_late\",\n\t\t\t\tsuspend_stats.failed_suspend_late,\n\t\t\t\"failed_suspend_noirq\",\n\t\t\t\tsuspend_stats.failed_suspend_noirq,\n\t\t\t\"failed_resume\", suspend_stats.failed_resume,\n\t\t\t\"failed_resume_early\",\n\t\t\t\tsuspend_stats.failed_resume_early,\n\t\t\t\"failed_resume_noirq\",\n\t\t\t\tsuspend_stats.failed_resume_noirq);\n\tseq_printf(s,\t\"failures:\\n  last_failed_dev:\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[last_dev]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_dev + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_stats.failed_devs[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_errno:\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[last_errno]);\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_errno + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-d\\n\",\n\t\t\tsuspend_stats.errno[index]);\n\t}\n\tseq_printf(s,\t\"  last_failed_step:\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[last_step]));\n\tfor (i = 1; i < REC_FAILED_NUM; i++) {\n\t\tindex = last_step + REC_FAILED_NUM - i;\n\t\tindex %= REC_FAILED_NUM;\n\t\tseq_printf(s, \"\\t\\t\\t%-s\\n\",\n\t\t\tsuspend_step_name(\n\t\t\t\tsuspend_stats.failed_steps[index]));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "suspend_step_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "246-264",
    "snippet": "static char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic char *suspend_step_name(enum suspend_stat_step step)\n{\n\tswitch (step) {\n\tcase SUSPEND_FREEZE:\n\t\treturn \"freeze\";\n\tcase SUSPEND_PREPARE:\n\t\treturn \"prepare\";\n\tcase SUSPEND_SUSPEND:\n\t\treturn \"suspend\";\n\tcase SUSPEND_SUSPEND_NOIRQ:\n\t\treturn \"suspend_noirq\";\n\tcase SUSPEND_RESUME_NOIRQ:\n\t\treturn \"resume_noirq\";\n\tcase SUSPEND_RESUME:\n\t\treturn \"resume\";\n\tdefault:\n\t\treturn \"\";\n\t}\n}"
  },
  {
    "function_name": "pm_test_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "215-240",
    "snippet": "static ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -EINVAL;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = TEST_FIRST;\n\tfor (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_system_sleep",
          "args": [],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "unlock_system_sleep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "31-51",
          "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "*s",
            "len"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "*s"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_test_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tconst char *buf, size_t n)\n{\n\tconst char * const *s;\n\tint level;\n\tchar *p;\n\tint len;\n\tint error = -EINVAL;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tlock_system_sleep();\n\n\tlevel = TEST_FIRST;\n\tfor (s = &pm_tests[level]; level <= TEST_MAX; s++, level++)\n\t\tif (*s && len == strlen(*s) && !strncmp(buf, *s, len)) {\n\t\t\tpm_test_level = level;\n\t\t\terror = 0;\n\t\t\tbreak;\n\t\t}\n\n\tunlock_system_sleep();\n\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "pm_test_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "194-213",
    "snippet": "static ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tchar *s = buf;\n\tint level;\n\n\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "pm_tests[level]"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"[%s] \"",
            "pm_tests[level]"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_test_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t\tchar *buf)\n{\n\tchar *s = buf;\n\tint level;\n\n\tfor (level = TEST_FIRST; level <= TEST_MAX; level++)\n\t\tif (pm_tests[level]) {\n\t\t\tif (level == pm_test_level)\n\t\t\t\ts += sprintf(s, \"[%s] \", pm_tests[level]);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", pm_tests[level]);\n\t\t}\n\n\tif (s != buf)\n\t\t/* convert the last space to a newline */\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "mem_sleep_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "153-177",
    "snippet": "static ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_suspend_state(buf, n);\n\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)\n\t\tmem_sleep_current = state;\n\telse\n\t\terror = -EINVAL;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pm_autosleep_unlock",
          "args": [],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "303-303",
          "snippet": "static inline void pm_autosleep_unlock(void) {}",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline void pm_autosleep_unlock(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "decode_suspend_state",
          "args": [
            "buf",
            "n"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "decode_suspend_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "134-151",
          "snippet": "static suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_state",
          "args": [],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "304-304",
          "snippet": "static inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline suspend_state_t pm_autosleep_state(void) { return PM_SUSPEND_ON; }"
        }
      },
      {
        "call_info": {
          "callee": "pm_autosleep_lock",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "pm_autosleep_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/power.h",
          "lines": "302-302",
          "snippet": "static inline int pm_autosleep_lock(void) { return 0; }",
          "includes": [
            "#include <linux/compiler.h>",
            "#include <linux/freezer.h>",
            "#include <linux/utsname.h>",
            "#include <linux/suspend_ioctls.h>",
            "#include <linux/suspend.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/compiler.h>\n#include <linux/freezer.h>\n#include <linux/utsname.h>\n#include <linux/suspend_ioctls.h>\n#include <linux/suspend.h>\n\nstatic inline int pm_autosleep_lock(void) { return 0; }"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t mem_sleep_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t       const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tint error;\n\n\terror = pm_autosleep_lock();\n\tif (error)\n\t\treturn error;\n\n\tif (pm_autosleep_state() > PM_SUSPEND_ON) {\n\t\terror = -EBUSY;\n\t\tgoto out;\n\t}\n\n\tstate = decode_suspend_state(buf, n);\n\tif (state < PM_SUSPEND_MAX && state > PM_SUSPEND_ON)\n\t\tmem_sleep_current = state;\n\telse\n\t\terror = -EINVAL;\n\n out:\n\tpm_autosleep_unlock();\n\treturn error ? error : n;\n}"
  },
  {
    "function_name": "decode_suspend_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "134-151",
    "snippet": "static suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "buf",
            "label",
            "len"
          ],
          "line": 146
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "label"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memchr",
          "args": [
            "buf",
            "'\\n'",
            "n"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic suspend_state_t decode_suspend_state(const char *buf, size_t n)\n{\n\tsuspend_state_t state;\n\tchar *p;\n\tint len;\n\n\tp = memchr(buf, '\\n', n);\n\tlen = p ? p - buf : n;\n\n\tfor (state = PM_SUSPEND_MIN; state < PM_SUSPEND_MAX; state++) {\n\t\tconst char *label = mem_sleep_states[state];\n\n\t\tif (label && len == strlen(label) && !strncmp(buf, label, len))\n\t\t\treturn state;\n\t}\n\n\treturn PM_SUSPEND_ON;\n}"
  },
  {
    "function_name": "mem_sleep_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "111-132",
    "snippet": "static ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *s = buf;\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (mem_sleep_states[i]) {\n\t\t\tconst char *label = mem_sleep_states[i];\n\n\t\t\tif (mem_sleep_current == i)\n\t\t\t\ts += sprintf(s, \"[%s] \", label);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", label);\n\t\t}\n\n\t/* Convert the last space to a newline if needed. */\n\tif (s != buf)\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"%s \"",
            "label"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "s",
            "\"[%s] \"",
            "label"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t mem_sleep_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      char *buf)\n{\n\tchar *s = buf;\n\tsuspend_state_t i;\n\n\tfor (i = PM_SUSPEND_MIN; i < PM_SUSPEND_MAX; i++)\n\t\tif (mem_sleep_states[i]) {\n\t\t\tconst char *label = mem_sleep_states[i];\n\n\t\t\tif (mem_sleep_current == i)\n\t\t\t\ts += sprintf(s, \"[%s] \", label);\n\t\t\telse\n\t\t\t\ts += sprintf(s, \"%s \", label);\n\t\t}\n\n\t/* Convert the last space to a newline if needed. */\n\tif (s != buf)\n\t\t*(s-1) = '\\n';\n\n\treturn (s - buf);\n}"
  },
  {
    "function_name": "pm_async_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "93-106",
    "snippet": "static ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_async_enabled = val;\n\treturn n;\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtoul",
          "args": [
            "buf",
            "10",
            "&val"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_async_store(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t      const char *buf, size_t n)\n{\n\tunsigned long val;\n\n\tif (kstrtoul(buf, 10, &val))\n\t\treturn -EINVAL;\n\n\tif (val > 1)\n\t\treturn -EINVAL;\n\n\tpm_async_enabled = val;\n\treturn n;\n}"
  },
  {
    "function_name": "pm_async_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "87-91",
    "snippet": "static ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_async_enabled);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%d\\n\"",
            "pm_async_enabled"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nstatic ssize_t pm_async_show(struct kobject *kobj, struct kobj_attribute *attr,\n\t\t\t     char *buf)\n{\n\treturn sprintf(buf, \"%d\\n\", pm_async_enabled);\n}"
  },
  {
    "function_name": "pm_notifier_call_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "79-82",
    "snippet": "int pm_notifier_call_chain(unsigned long val)\n{\n\treturn __pm_notifier_call_chain(val, -1, NULL);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__pm_notifier_call_chain",
          "args": [
            "val",
            "-1",
            "NULL"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "__pm_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
          "lines": "70-78",
          "snippet": "int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/pm-trace.h>",
            "#include <linux/string.h>",
            "#include <linux/kobject.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint pm_notifier_call_chain(unsigned long val)\n{\n\treturn __pm_notifier_call_chain(val, -1, NULL);\n}"
  },
  {
    "function_name": "__pm_notifier_call_chain",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "70-78",
    "snippet": "int __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_to_errno",
          "args": [
            "ret"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__blocking_notifier_call_chain",
          "args": [
            "&pm_chain_head",
            "val",
            "NULL",
            "nr_to_call",
            "nr_calls"
          ],
          "line": 74
        },
        "resolved": true,
        "details": {
          "function_name": "__blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "304-322",
          "snippet": "int __blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\t\t\t   unsigned long val, void *v,\n\t\t\t\t   int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, nr_to_call,\n\t\t\t\t\tnr_calls);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint __blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\t\t\t   unsigned long val, void *v,\n\t\t\t\t   int nr_to_call, int *nr_calls)\n{\n\tint ret = NOTIFY_DONE;\n\n\t/*\n\t * We check the head outside the lock, but if this access is\n\t * racy then it does not matter what the result of the test\n\t * is, we re-check the list after having taken the lock anyway:\n\t */\n\tif (rcu_access_pointer(nh->head)) {\n\t\tdown_read(&nh->rwsem);\n\t\tret = notifier_call_chain(&nh->head, val, v, nr_to_call,\n\t\t\t\t\tnr_calls);\n\t\tup_read(&nh->rwsem);\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint __pm_notifier_call_chain(unsigned long val, int nr_to_call, int *nr_calls)\n{\n\tint ret;\n\n\tret = __blocking_notifier_call_chain(&pm_chain_head, val, NULL,\n\t\t\t\t\t\tnr_to_call, nr_calls);\n\n\treturn notifier_to_errno(ret);\n}"
  },
  {
    "function_name": "unregister_pm_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "64-67",
    "snippet": "int unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&pm_chain_head",
            "nb"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "266-283",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint unregister_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&pm_chain_head, nb);\n}"
  },
  {
    "function_name": "register_pm_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "58-61",
    "snippet": "int register_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pm_chain_head, nb);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&pm_chain_head",
            "nb"
          ],
          "line": 60
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "213-230",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nint register_pm_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_register(&pm_chain_head, nb);\n}"
  },
  {
    "function_name": "unlock_system_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "31-51",
    "snippet": "void unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 50
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid unlock_system_sleep(void)\n{\n\t/*\n\t * Don't use freezer_count() because we don't want the call to\n\t * try_to_freeze() here.\n\t *\n\t * Reason:\n\t * Fundamentally, we just don't need it, because freezing condition\n\t * doesn't come into effect until we release the\n\t * system_transition_mutex lock, since the freezer always works with\n\t * system_transition_mutex held.\n\t *\n\t * More importantly, in the case of hibernation,\n\t * unlock_system_sleep() gets called in snapshot_read() and\n\t * snapshot_write() when the freezing condition is still in effect.\n\t * Which means, if we use try_to_freeze() here, it would make them\n\t * enter the refrigerator, thus causing hibernation to lockup.\n\t */\n\tcurrent->flags &= ~PF_FREEZER_SKIP;\n\tmutex_unlock(&system_transition_mutex);\n}"
  },
  {
    "function_name": "lock_system_sleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/main.c",
    "lines": "24-28",
    "snippet": "void lock_system_sleep(void)\n{\n\tcurrent->flags |= PF_FREEZER_SKIP;\n\tmutex_lock(&system_transition_mutex);\n}",
    "includes": [
      "#include \"power.h\"",
      "#include <linux/suspend.h>",
      "#include <linux/seq_file.h>",
      "#include <linux/debugfs.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/pm-trace.h>",
      "#include <linux/string.h>",
      "#include <linux/kobject.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&system_transition_mutex"
          ],
          "line": 27
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"power.h\"\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/debugfs.h>\n#include <linux/workqueue.h>\n#include <linux/pm-trace.h>\n#include <linux/string.h>\n#include <linux/kobject.h>\n#include <linux/export.h>\n\nvoid lock_system_sleep(void)\n{\n\tcurrent->flags |= PF_FREEZER_SKIP;\n\tmutex_lock(&system_transition_mutex);\n}"
  }
]