[
  {
    "function_name": "jump_label_test",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "762-791",
    "snippet": "static __init int jump_label_test(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tWARN_ON(static_key_enabled(&sk_true.key) != true);\n\t\tWARN_ON(static_key_enabled(&sk_false.key) != false);\n\n\t\tWARN_ON(!static_branch_likely(&sk_true));\n\t\tWARN_ON(!static_branch_unlikely(&sk_true));\n\t\tWARN_ON(static_branch_likely(&sk_false));\n\t\tWARN_ON(static_branch_unlikely(&sk_false));\n\n\t\tstatic_branch_disable(&sk_true);\n\t\tstatic_branch_enable(&sk_false);\n\n\t\tWARN_ON(static_key_enabled(&sk_true.key) == true);\n\t\tWARN_ON(static_key_enabled(&sk_false.key) == false);\n\n\t\tWARN_ON(static_branch_likely(&sk_true));\n\t\tWARN_ON(static_branch_unlikely(&sk_true));\n\t\tWARN_ON(!static_branch_likely(&sk_false));\n\t\tWARN_ON(!static_branch_unlikely(&sk_false));\n\n\t\tstatic_branch_enable(&sk_true);\n\t\tstatic_branch_disable(&sk_false);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&sk_false"
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&sk_true"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!static_branch_unlikely(&sk_false)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sk_false"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!static_branch_likely(&sk_false)"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sk_false"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_branch_unlikely(&sk_true)"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sk_true"
          ],
          "line": 782
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_branch_likely(&sk_true)"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sk_true"
          ],
          "line": 781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_key_enabled(&sk_false.key) == false"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&sk_false.key"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_key_enabled(&sk_true.key) == true"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&sk_true.key"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&sk_false"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&sk_true"
          ],
          "line": 775
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_branch_unlikely(&sk_false)"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sk_false"
          ],
          "line": 773
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_branch_likely(&sk_false)"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sk_false"
          ],
          "line": 772
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!static_branch_unlikely(&sk_true)"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sk_true"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!static_branch_likely(&sk_true)"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&sk_true"
          ],
          "line": 770
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_key_enabled(&sk_false.key) != false"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&sk_false.key"
          ],
          "line": 768
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "static_key_enabled(&sk_true.key) != true"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&sk_true.key"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic __init int jump_label_test(void)\n{\n\tint i;\n\n\tfor (i = 0; i < 2; i++) {\n\t\tWARN_ON(static_key_enabled(&sk_true.key) != true);\n\t\tWARN_ON(static_key_enabled(&sk_false.key) != false);\n\n\t\tWARN_ON(!static_branch_likely(&sk_true));\n\t\tWARN_ON(!static_branch_unlikely(&sk_true));\n\t\tWARN_ON(static_branch_likely(&sk_false));\n\t\tWARN_ON(static_branch_unlikely(&sk_false));\n\n\t\tstatic_branch_disable(&sk_true);\n\t\tstatic_branch_enable(&sk_false);\n\n\t\tWARN_ON(static_key_enabled(&sk_true.key) == true);\n\t\tWARN_ON(static_key_enabled(&sk_false.key) == false);\n\n\t\tWARN_ON(static_branch_likely(&sk_true));\n\t\tWARN_ON(static_branch_unlikely(&sk_true));\n\t\tWARN_ON(!static_branch_likely(&sk_false));\n\t\tWARN_ON(!static_branch_unlikely(&sk_false));\n\n\t\tstatic_branch_enable(&sk_true);\n\t\tstatic_branch_disable(&sk_false);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jump_label_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "733-756",
    "snippet": "static void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jump_label_update",
          "args": [
            "key",
            "entry",
            "stop",
            "system_state < SYSTEM_RUNNING"
          ],
          "line": 754
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "379-397",
          "snippet": "static void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_entries",
          "args": [
            "key"
          ],
          "line": 751
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "323-327",
          "snippet": "static inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_address",
          "args": [
            "(unsigned long)key"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "__module_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4318-4334",
          "snippet": "struct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define module_addr_max mod_tree.addr_max",
            "#define module_addr_min mod_tree.addr_min"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define module_addr_max mod_tree.addr_max\n#define module_addr_min mod_tree.addr_min\n\nstruct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 745
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jump_label_mod_update",
          "args": [
            "key"
          ],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_mod_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "503-526",
          "snippet": "static void __jump_label_mod_update(struct static_key *key)\n{\n\tstruct static_key_mod *mod;\n\n\tfor (mod = static_key_mod(key); mod; mod = mod->next) {\n\t\tstruct jump_entry *stop;\n\t\tstruct module *m;\n\n\t\t/*\n\t\t * NULL if the static_key is defined in a module\n\t\t * that does not use it\n\t\t */\n\t\tif (!mod->entries)\n\t\t\tcontinue;\n\n\t\tm = mod->mod;\n\t\tif (!m)\n\t\t\tstop = __stop___jump_table;\n\t\telse\n\t\t\tstop = m->jump_entries + m->num_jump_entries;\n\t\t__jump_label_update(key, mod->entries, stop,\n\t\t\t\t    m && m->state == MODULE_STATE_COMING);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_mod_update(struct static_key *key)\n{\n\tstruct static_key_mod *mod;\n\n\tfor (mod = static_key_mod(key); mod; mod = mod->next) {\n\t\tstruct jump_entry *stop;\n\t\tstruct module *m;\n\n\t\t/*\n\t\t * NULL if the static_key is defined in a module\n\t\t * that does not use it\n\t\t */\n\t\tif (!mod->entries)\n\t\t\tcontinue;\n\n\t\tm = mod->mod;\n\t\tif (!m)\n\t\t\tstop = __stop___jump_table;\n\t\telse\n\t\t\tstop = m->jump_entries + m->num_jump_entries;\n\t\t__jump_label_update(key, mod->entries, stop,\n\t\t\t\t    m && m->state == MODULE_STATE_COMING);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_linked",
          "args": [
            "key"
          ],
          "line": 740
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "334-337",
          "snippet": "static inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}"
  },
  {
    "function_name": "jump_label_text_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "719-731",
    "snippet": "int jump_label_text_reserved(void *start, void *end)\n{\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jump_label_mod_text_reserved",
          "args": [
            "start",
            "end"
          ],
          "line": 728
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_mod_text_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "485-501",
          "snippet": "static int __jump_label_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\n\treturn __jump_label_text_reserved(mod->jump_entries,\n\t\t\t\tmod->jump_entries + mod->num_jump_entries,\n\t\t\t\tstart, end);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int __jump_label_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\n\treturn __jump_label_text_reserved(mod->jump_entries,\n\t\t\t\tmod->jump_entries + mod->num_jump_entries,\n\t\t\t\tstart, end);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__jump_label_text_reserved",
          "args": [
            "__start___jump_table",
            "__stop___jump_table",
            "start",
            "end"
          ],
          "line": 721
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_text_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "296-309",
          "snippet": "static int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nint jump_label_text_reserved(void *start, void *end)\n{\n\tint ret = __jump_label_text_reserved(__start___jump_table,\n\t\t\t__stop___jump_table, start, end);\n\n\tif (ret)\n\t\treturn ret;\n\n#ifdef CONFIG_MODULES\n\tret = __jump_label_mod_text_reserved(start, end);\n#endif\n\treturn ret;\n}"
  },
  {
    "function_name": "jump_label_init_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "698-701",
    "snippet": "static __init int jump_label_init_module(void)\n{\n\treturn register_module_notifier(&jump_label_module_nb);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&jump_label_module_nb"
          ],
          "line": 700
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic __init int jump_label_init_module(void)\n{\n\treturn register_module_notifier(&jump_label_module_nb);\n}"
  },
  {
    "function_name": "jump_label_module_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "664-691",
    "snippet": "static int\njump_label_module_notify(struct notifier_block *self, unsigned long val,\n\t\t\t void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tjump_label_lock();\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = jump_label_add_module(mod);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Failed to allocate memory: jump_label may not work properly.\\n\");\n\t\t\tjump_label_del_module(mod);\n\t\t}\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tjump_label_del_module(mod);\n\t\tbreak;\n\t}\n\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\treturn notifier_from_errno(ret);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "notifier_from_errno",
          "args": [
            "ret"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 688
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_del_module",
          "args": [
            "mod"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_del_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "614-662",
          "snippet": "static void jump_label_del_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, **prev;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tif (jump_entry_key(iter) == key)\n\t\t\tcontinue;\n\n\t\tkey = jump_entry_key(iter);\n\n\t\tif (within_module((unsigned long)key, mod))\n\t\t\tcontinue;\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!static_key_linked(key)))\n\t\t\tcontinue;\n\n\t\tprev = &key->next;\n\t\tjlm = static_key_mod(key);\n\n\t\twhile (jlm && jlm->mod != mod) {\n\t\t\tprev = &jlm->next;\n\t\t\tjlm = jlm->next;\n\t\t}\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!jlm))\n\t\t\tcontinue;\n\n\t\tif (prev == &key->next)\n\t\t\tstatic_key_set_mod(key, jlm->next);\n\t\telse\n\t\t\t*prev = jlm->next;\n\n\t\tkfree(jlm);\n\n\t\tjlm = static_key_mod(key);\n\t\t/* if only one etry is left, fold it back into the static_key */\n\t\tif (jlm->next == NULL) {\n\t\t\tstatic_key_set_entries(key, jlm->entries);\n\t\t\tstatic_key_clear_linked(key);\n\t\t\tkfree(jlm);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_del_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, **prev;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tif (jump_entry_key(iter) == key)\n\t\t\tcontinue;\n\n\t\tkey = jump_entry_key(iter);\n\n\t\tif (within_module((unsigned long)key, mod))\n\t\t\tcontinue;\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!static_key_linked(key)))\n\t\t\tcontinue;\n\n\t\tprev = &key->next;\n\t\tjlm = static_key_mod(key);\n\n\t\twhile (jlm && jlm->mod != mod) {\n\t\t\tprev = &jlm->next;\n\t\t\tjlm = jlm->next;\n\t\t}\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!jlm))\n\t\t\tcontinue;\n\n\t\tif (prev == &key->next)\n\t\t\tstatic_key_set_mod(key, jlm->next);\n\t\telse\n\t\t\t*prev = jlm->next;\n\n\t\tkfree(jlm);\n\n\t\tjlm = static_key_mod(key);\n\t\t/* if only one etry is left, fold it back into the static_key */\n\t\tif (jlm->next == NULL) {\n\t\t\tstatic_key_set_entries(key, jlm->entries);\n\t\t\tstatic_key_clear_linked(key);\n\t\t\tkfree(jlm);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Failed to allocate memory: jump_label may not work properly.\\n\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_add_module",
          "args": [
            "mod"
          ],
          "line": 676
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_add_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "553-612",
          "snippet": "static int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, *jlm2;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn 0;\n\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\tif (within_module_init(jump_entry_code(iter), mod))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tif (within_module((unsigned long)key, mod)) {\n\t\t\tstatic_key_set_entries(key, iter);\n\t\t\tcontinue;\n\t\t}\n\t\tjlm = kzalloc(sizeof(struct static_key_mod), GFP_KERNEL);\n\t\tif (!jlm)\n\t\t\treturn -ENOMEM;\n\t\tif (!static_key_linked(key)) {\n\t\t\tjlm2 = kzalloc(sizeof(struct static_key_mod),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!jlm2) {\n\t\t\t\tkfree(jlm);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpreempt_disable();\n\t\t\tjlm2->mod = __module_address((unsigned long)key);\n\t\t\tpreempt_enable();\n\t\t\tjlm2->entries = static_key_entries(key);\n\t\t\tjlm2->next = NULL;\n\t\t\tstatic_key_set_mod(key, jlm2);\n\t\t\tstatic_key_set_linked(key);\n\t\t}\n\t\tjlm->mod = mod;\n\t\tjlm->entries = iter;\n\t\tjlm->next = static_key_mod(key);\n\t\tstatic_key_set_mod(key, jlm);\n\t\tstatic_key_set_linked(key);\n\n\t\t/* Only update if we've changed from our initial state */\n\t\tif (jump_label_type(iter) != jump_label_init_type(iter))\n\t\t\t__jump_label_update(key, iter, iter_stop, true);\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, *jlm2;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn 0;\n\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\tif (within_module_init(jump_entry_code(iter), mod))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tif (within_module((unsigned long)key, mod)) {\n\t\t\tstatic_key_set_entries(key, iter);\n\t\t\tcontinue;\n\t\t}\n\t\tjlm = kzalloc(sizeof(struct static_key_mod), GFP_KERNEL);\n\t\tif (!jlm)\n\t\t\treturn -ENOMEM;\n\t\tif (!static_key_linked(key)) {\n\t\t\tjlm2 = kzalloc(sizeof(struct static_key_mod),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!jlm2) {\n\t\t\t\tkfree(jlm);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpreempt_disable();\n\t\t\tjlm2->mod = __module_address((unsigned long)key);\n\t\t\tpreempt_enable();\n\t\t\tjlm2->entries = static_key_entries(key);\n\t\t\tjlm2->next = NULL;\n\t\t\tstatic_key_set_mod(key, jlm2);\n\t\t\tstatic_key_set_linked(key);\n\t\t}\n\t\tjlm->mod = mod;\n\t\tjlm->entries = iter;\n\t\tjlm->next = static_key_mod(key);\n\t\tstatic_key_set_mod(key, jlm);\n\t\tstatic_key_set_linked(key);\n\n\t\t/* Only update if we've changed from our initial state */\n\t\tif (jump_label_type(iter) != jump_label_init_type(iter))\n\t\t\t__jump_label_update(key, iter, iter_stop, true);\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 672
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int\njump_label_module_notify(struct notifier_block *self, unsigned long val,\n\t\t\t void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tcpus_read_lock();\n\tjump_label_lock();\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = jump_label_add_module(mod);\n\t\tif (ret) {\n\t\t\tWARN(1, \"Failed to allocate memory: jump_label may not work properly.\\n\");\n\t\t\tjump_label_del_module(mod);\n\t\t}\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\tjump_label_del_module(mod);\n\t\tbreak;\n\t}\n\n\tjump_label_unlock();\n\tcpus_read_unlock();\n\n\treturn notifier_from_errno(ret);\n}"
  },
  {
    "function_name": "jump_label_del_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "614-662",
    "snippet": "static void jump_label_del_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, **prev;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tif (jump_entry_key(iter) == key)\n\t\t\tcontinue;\n\n\t\tkey = jump_entry_key(iter);\n\n\t\tif (within_module((unsigned long)key, mod))\n\t\t\tcontinue;\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!static_key_linked(key)))\n\t\t\tcontinue;\n\n\t\tprev = &key->next;\n\t\tjlm = static_key_mod(key);\n\n\t\twhile (jlm && jlm->mod != mod) {\n\t\t\tprev = &jlm->next;\n\t\t\tjlm = jlm->next;\n\t\t}\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!jlm))\n\t\t\tcontinue;\n\n\t\tif (prev == &key->next)\n\t\t\tstatic_key_set_mod(key, jlm->next);\n\t\telse\n\t\t\t*prev = jlm->next;\n\n\t\tkfree(jlm);\n\n\t\tjlm = static_key_mod(key);\n\t\t/* if only one etry is left, fold it back into the static_key */\n\t\tif (jlm->next == NULL) {\n\t\t\tstatic_key_set_entries(key, jlm->entries);\n\t\t\tstatic_key_clear_linked(key);\n\t\t\tkfree(jlm);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jlm"
          ],
          "line": 659
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_clear_linked",
          "args": [
            "key"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_clear_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "339-342",
          "snippet": "static inline void static_key_clear_linked(struct static_key *key)\n{\n\tkey->type &= ~JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline void static_key_clear_linked(struct static_key *key)\n{\n\tkey->type &= ~JUMP_TYPE_LINKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_set_entries",
          "args": [
            "key",
            "jlm->entries"
          ],
          "line": 657
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "358-367",
          "snippet": "static void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_mod",
          "args": [
            "key"
          ],
          "line": 654
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "462-466",
          "snippet": "static inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_set_mod",
          "args": [
            "key",
            "jlm->next"
          ],
          "line": 648
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "474-483",
          "snippet": "static void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!jlm"
          ],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!static_key_linked(key)"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_linked",
          "args": [
            "key"
          ],
          "line": 632
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "334-337",
          "snippet": "static inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module",
          "args": [
            "(unsigned long)key",
            "mod"
          ],
          "line": 628
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_within_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "57-63",
          "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "iter"
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "iter"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_del_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, **prev;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tif (jump_entry_key(iter) == key)\n\t\t\tcontinue;\n\n\t\tkey = jump_entry_key(iter);\n\n\t\tif (within_module((unsigned long)key, mod))\n\t\t\tcontinue;\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!static_key_linked(key)))\n\t\t\tcontinue;\n\n\t\tprev = &key->next;\n\t\tjlm = static_key_mod(key);\n\n\t\twhile (jlm && jlm->mod != mod) {\n\t\t\tprev = &jlm->next;\n\t\t\tjlm = jlm->next;\n\t\t}\n\n\t\t/* No memory during module load */\n\t\tif (WARN_ON(!jlm))\n\t\t\tcontinue;\n\n\t\tif (prev == &key->next)\n\t\t\tstatic_key_set_mod(key, jlm->next);\n\t\telse\n\t\t\t*prev = jlm->next;\n\n\t\tkfree(jlm);\n\n\t\tjlm = static_key_mod(key);\n\t\t/* if only one etry is left, fold it back into the static_key */\n\t\tif (jlm->next == NULL) {\n\t\t\tstatic_key_set_entries(key, jlm->entries);\n\t\t\tstatic_key_clear_linked(key);\n\t\t\tkfree(jlm);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jump_label_add_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "553-612",
    "snippet": "static int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, *jlm2;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn 0;\n\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\tif (within_module_init(jump_entry_code(iter), mod))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tif (within_module((unsigned long)key, mod)) {\n\t\t\tstatic_key_set_entries(key, iter);\n\t\t\tcontinue;\n\t\t}\n\t\tjlm = kzalloc(sizeof(struct static_key_mod), GFP_KERNEL);\n\t\tif (!jlm)\n\t\t\treturn -ENOMEM;\n\t\tif (!static_key_linked(key)) {\n\t\t\tjlm2 = kzalloc(sizeof(struct static_key_mod),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!jlm2) {\n\t\t\t\tkfree(jlm);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpreempt_disable();\n\t\t\tjlm2->mod = __module_address((unsigned long)key);\n\t\t\tpreempt_enable();\n\t\t\tjlm2->entries = static_key_entries(key);\n\t\t\tjlm2->next = NULL;\n\t\t\tstatic_key_set_mod(key, jlm2);\n\t\t\tstatic_key_set_linked(key);\n\t\t}\n\t\tjlm->mod = mod;\n\t\tjlm->entries = iter;\n\t\tjlm->next = static_key_mod(key);\n\t\tstatic_key_set_mod(key, jlm);\n\t\tstatic_key_set_linked(key);\n\n\t\t/* Only update if we've changed from our initial state */\n\t\tif (jump_label_type(iter) != jump_label_init_type(iter))\n\t\t\t__jump_label_update(key, iter, iter_stop, true);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jump_label_update",
          "args": [
            "key",
            "iter",
            "iter_stop",
            "true"
          ],
          "line": 608
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "379-397",
          "snippet": "static void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_init_type",
          "args": [
            "iter"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_init_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "446-454",
          "snippet": "static enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_type",
          "args": [
            "iter"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "369-377",
          "snippet": "static enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_set_linked",
          "args": [
            "key"
          ],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "344-347",
          "snippet": "static inline void static_key_set_linked(struct static_key *key)\n{\n\tkey->type |= JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline void static_key_set_linked(struct static_key *key)\n{\n\tkey->type |= JUMP_TYPE_LINKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_set_mod",
          "args": [
            "key",
            "jlm"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "474-483",
          "snippet": "static void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_mod",
          "args": [
            "key"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "462-466",
          "snippet": "static inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_entries",
          "args": [
            "key"
          ],
          "line": 595
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "323-327",
          "snippet": "static inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_address",
          "args": [
            "(unsigned long)key"
          ],
          "line": 593
        },
        "resolved": true,
        "details": {
          "function_name": "__module_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4318-4334",
          "snippet": "struct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define module_addr_max mod_tree.addr_max",
            "#define module_addr_min mod_tree.addr_min"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define module_addr_max mod_tree.addr_max\n#define module_addr_min mod_tree.addr_min\n\nstruct module *__module_address(unsigned long addr)\n{\n\tstruct module *mod;\n\n\tif (addr < module_addr_min || addr > module_addr_max)\n\t\treturn NULL;\n\n\tmodule_assert_mutex_or_preempt();\n\n\tmod = mod_find(addr);\n\tif (mod) {\n\t\tBUG_ON(!within_module(addr, mod));\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 592
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "jlm"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct static_key_mod)",
            "GFP_KERNEL"
          ],
          "line": 586
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_linked",
          "args": [
            "key"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "334-337",
          "snippet": "static inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct static_key_mod)",
            "GFP_KERNEL"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_set_entries",
          "args": [
            "key",
            "iter"
          ],
          "line": 579
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "358-367",
          "snippet": "static void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "within_module",
          "args": [
            "(unsigned long)key",
            "mod"
          ],
          "line": 578
        },
        "resolved": true,
        "details": {
          "function_name": "trace_kprobe_within_module",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "57-63",
          "snippet": "static nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "NOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nNOKPROBE_SYMBOL(process_fetch_insn)\n\n/* Kprobe handler */\nstatic nokprobe_inline;\n\nstatic nokprobe_inline bool trace_kprobe_within_module(struct trace_kprobe *tk,\n\t\t\t\t\t\t struct module *mod)\n{\n\tint len = strlen(mod->name);\n\tconst char *name = trace_kprobe_symbol(tk);\n\treturn strncmp(mod->name, name, len) == 0 && name[len] == ':';\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "iter"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_set_init",
          "args": [
            "iter"
          ],
          "line": 571
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "within_module_init",
          "args": [
            "jump_entry_code(iter)",
            "mod"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "iter"
          ],
          "line": 570
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_sort_entries",
          "args": [
            "iter_start",
            "iter_stop"
          ],
          "line": 565
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_sort_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "66-78",
          "snippet": "static void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int jump_label_add_module(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\tstruct static_key *key = NULL;\n\tstruct static_key_mod *jlm, *jlm2;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn 0;\n\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\tif (within_module_init(jump_entry_code(iter), mod))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tif (within_module((unsigned long)key, mod)) {\n\t\t\tstatic_key_set_entries(key, iter);\n\t\t\tcontinue;\n\t\t}\n\t\tjlm = kzalloc(sizeof(struct static_key_mod), GFP_KERNEL);\n\t\tif (!jlm)\n\t\t\treturn -ENOMEM;\n\t\tif (!static_key_linked(key)) {\n\t\t\tjlm2 = kzalloc(sizeof(struct static_key_mod),\n\t\t\t\t       GFP_KERNEL);\n\t\t\tif (!jlm2) {\n\t\t\t\tkfree(jlm);\n\t\t\t\treturn -ENOMEM;\n\t\t\t}\n\t\t\tpreempt_disable();\n\t\t\tjlm2->mod = __module_address((unsigned long)key);\n\t\t\tpreempt_enable();\n\t\t\tjlm2->entries = static_key_entries(key);\n\t\t\tjlm2->next = NULL;\n\t\t\tstatic_key_set_mod(key, jlm2);\n\t\t\tstatic_key_set_linked(key);\n\t\t}\n\t\tjlm->mod = mod;\n\t\tjlm->entries = iter;\n\t\tjlm->next = static_key_mod(key);\n\t\tstatic_key_set_mod(key, jlm);\n\t\tstatic_key_set_linked(key);\n\n\t\t/* Only update if we've changed from our initial state */\n\t\tif (jump_label_type(iter) != jump_label_init_type(iter))\n\t\t\t__jump_label_update(key, iter, iter_stop, true);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jump_label_apply_nops",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "536-551",
    "snippet": "void jump_label_apply_nops(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\t/* Only write NOPs for arch_branch_static(). */\n\t\tif (jump_label_init_type(iter) == JUMP_LABEL_NOP)\n\t\t\tarch_jump_label_transform_static(iter, JUMP_LABEL_NOP);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_jump_label_transform_static",
          "args": [
            "iter",
            "JUMP_LABEL_NOP"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "arch_jump_label_transform_static",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "317-321",
          "snippet": "__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\n__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_init_type",
          "args": [
            "iter"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_init_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "446-454",
          "snippet": "static enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_apply_nops(struct module *mod)\n{\n\tstruct jump_entry *iter_start = mod->jump_entries;\n\tstruct jump_entry *iter_stop = iter_start + mod->num_jump_entries;\n\tstruct jump_entry *iter;\n\n\t/* if the module doesn't have jump label entries, just return */\n\tif (iter_start == iter_stop)\n\t\treturn;\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\t/* Only write NOPs for arch_branch_static(). */\n\t\tif (jump_label_init_type(iter) == JUMP_LABEL_NOP)\n\t\t\tarch_jump_label_transform_static(iter, JUMP_LABEL_NOP);\n\t}\n}"
  },
  {
    "function_name": "__jump_label_mod_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "503-526",
    "snippet": "static void __jump_label_mod_update(struct static_key *key)\n{\n\tstruct static_key_mod *mod;\n\n\tfor (mod = static_key_mod(key); mod; mod = mod->next) {\n\t\tstruct jump_entry *stop;\n\t\tstruct module *m;\n\n\t\t/*\n\t\t * NULL if the static_key is defined in a module\n\t\t * that does not use it\n\t\t */\n\t\tif (!mod->entries)\n\t\t\tcontinue;\n\n\t\tm = mod->mod;\n\t\tif (!m)\n\t\t\tstop = __stop___jump_table;\n\t\telse\n\t\t\tstop = m->jump_entries + m->num_jump_entries;\n\t\t__jump_label_update(key, mod->entries, stop,\n\t\t\t\t    m && m->state == MODULE_STATE_COMING);\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jump_label_update",
          "args": [
            "key",
            "mod->entries",
            "stop",
            "m && m->state == MODULE_STATE_COMING"
          ],
          "line": 523
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "379-397",
          "snippet": "static void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_mod",
          "args": [
            "key"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_mod",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "462-466",
          "snippet": "static inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_mod_update(struct static_key *key)\n{\n\tstruct static_key_mod *mod;\n\n\tfor (mod = static_key_mod(key); mod; mod = mod->next) {\n\t\tstruct jump_entry *stop;\n\t\tstruct module *m;\n\n\t\t/*\n\t\t * NULL if the static_key is defined in a module\n\t\t * that does not use it\n\t\t */\n\t\tif (!mod->entries)\n\t\t\tcontinue;\n\n\t\tm = mod->mod;\n\t\tif (!m)\n\t\t\tstop = __stop___jump_table;\n\t\telse\n\t\t\tstop = m->jump_entries + m->num_jump_entries;\n\t\t__jump_label_update(key, mod->entries, stop,\n\t\t\t\t    m && m->state == MODULE_STATE_COMING);\n\t}\n}"
  },
  {
    "function_name": "__jump_label_mod_text_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "485-501",
    "snippet": "static int __jump_label_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\n\treturn __jump_label_text_reserved(mod->jump_entries,\n\t\t\t\tmod->jump_entries + mod->num_jump_entries,\n\t\t\t\tstart, end);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__jump_label_text_reserved",
          "args": [
            "mod->jump_entries",
            "mod->jump_entries + mod->num_jump_entries",
            "start",
            "end"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "__jump_label_text_reserved",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "296-309",
          "snippet": "static int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 492
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "__module_text_address((unsigned long)end) != mod"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__module_text_address",
          "args": [
            "(unsigned long)end"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "__module_text_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "4363-4373",
          "snippet": "struct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstruct module *__module_text_address(unsigned long addr)\n{\n\tstruct module *mod = __module_address(addr);\n\tif (mod) {\n\t\t/* Make sure it's within the text section. */\n\t\tif (!within(addr, mod->init_layout.base, mod->init_layout.text_size)\n\t\t    && !within(addr, mod->core_layout.base, mod->core_layout.text_size))\n\t\t\tmod = NULL;\n\t}\n\treturn mod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int __jump_label_mod_text_reserved(void *start, void *end)\n{\n\tstruct module *mod;\n\n\tpreempt_disable();\n\tmod = __module_text_address((unsigned long)start);\n\tWARN_ON_ONCE(__module_text_address((unsigned long)end) != mod);\n\tpreempt_enable();\n\n\tif (!mod)\n\t\treturn 0;\n\n\n\treturn __jump_label_text_reserved(mod->jump_entries,\n\t\t\t\tmod->jump_entries + mod->num_jump_entries,\n\t\t\t\tstart, end);\n}"
  },
  {
    "function_name": "static_key_set_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "474-483",
    "snippet": "static void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(unsigned long)mod & JUMP_TYPE_MASK"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_mod(struct static_key *key,\n\t\t\t       struct static_key_mod *mod)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)mod & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->next = mod;\n\tkey->type |= type;\n}"
  },
  {
    "function_name": "static_key_mod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "462-466",
    "snippet": "static inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!static_key_linked(key)"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_linked",
          "args": [
            "key"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_linked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "334-337",
          "snippet": "static inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct static_key_mod *static_key_mod(struct static_key *key)\n{\n\tWARN_ON_ONCE(!static_key_linked(key));\n\treturn (struct static_key_mod *)(key->type & ~JUMP_TYPE_MASK);\n}"
  },
  {
    "function_name": "jump_label_init_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "446-454",
    "snippet": "static enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_entry_is_branch",
          "args": [
            "entry"
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_type",
          "args": [
            "key"
          ],
          "line": 449
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "329-332",
          "snippet": "static inline bool static_key_type(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_TRUE;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_type(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_TRUE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "entry"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_init_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool type = static_key_type(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn type ^ branch;\n}"
  },
  {
    "function_name": "jump_label_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "399-442",
    "snippet": "void __init jump_label_init(void)\n{\n\tstruct jump_entry *iter_start = __start___jump_table;\n\tstruct jump_entry *iter_stop = __stop___jump_table;\n\tstruct static_key *key = NULL;\n\tstruct jump_entry *iter;\n\n\t/*\n\t * Since we are initializing the static_key.enabled field with\n\t * with the 'raw' int values (to avoid pulling in atomic.h) in\n\t * jump_label.h, let's make sure that is safe. There are only two\n\t * cases to check since we initialize to 0 or 1.\n\t */\n\tBUILD_BUG_ON((int)ATOMIC_INIT(0) != 0);\n\tBUILD_BUG_ON((int)ATOMIC_INIT(1) != 1);\n\n\tif (static_key_initialized)\n\t\treturn;\n\n\tcpus_read_lock();\n\tjump_label_lock();\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\t/* rewrite NOPs */\n\t\tif (jump_label_type(iter) == JUMP_LABEL_NOP)\n\t\t\tarch_jump_label_transform_static(iter, JUMP_LABEL_NOP);\n\n\t\tif (init_section_contains((void *)jump_entry_code(iter), 1))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tstatic_key_set_entries(key, iter);\n\t}\n\tstatic_key_initialized = true;\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 440
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_set_entries",
          "args": [
            "key",
            "iter"
          ],
          "line": 437
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_set_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "358-367",
          "snippet": "static void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "iter"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_set_init",
          "args": [
            "iter"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_section_contains",
          "args": [
            "(void *)jump_entry_code(iter)",
            "1"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "iter"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_jump_label_transform_static",
          "args": [
            "iter",
            "JUMP_LABEL_NOP"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "arch_jump_label_transform_static",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "317-321",
          "snippet": "__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\n__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_type",
          "args": [
            "iter"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "369-377",
          "snippet": "static enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_sort_entries",
          "args": [
            "iter_start",
            "iter_stop"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_sort_entries",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "66-78",
          "snippet": "static void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(int)ATOMIC_INIT(1) != 1"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "1"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "(int)ATOMIC_INIT(0) != 0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ATOMIC_INIT",
          "args": [
            "0"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid __init jump_label_init(void)\n{\n\tstruct jump_entry *iter_start = __start___jump_table;\n\tstruct jump_entry *iter_stop = __stop___jump_table;\n\tstruct static_key *key = NULL;\n\tstruct jump_entry *iter;\n\n\t/*\n\t * Since we are initializing the static_key.enabled field with\n\t * with the 'raw' int values (to avoid pulling in atomic.h) in\n\t * jump_label.h, let's make sure that is safe. There are only two\n\t * cases to check since we initialize to 0 or 1.\n\t */\n\tBUILD_BUG_ON((int)ATOMIC_INIT(0) != 0);\n\tBUILD_BUG_ON((int)ATOMIC_INIT(1) != 1);\n\n\tif (static_key_initialized)\n\t\treturn;\n\n\tcpus_read_lock();\n\tjump_label_lock();\n\tjump_label_sort_entries(iter_start, iter_stop);\n\n\tfor (iter = iter_start; iter < iter_stop; iter++) {\n\t\tstruct static_key *iterk;\n\n\t\t/* rewrite NOPs */\n\t\tif (jump_label_type(iter) == JUMP_LABEL_NOP)\n\t\t\tarch_jump_label_transform_static(iter, JUMP_LABEL_NOP);\n\n\t\tif (init_section_contains((void *)jump_entry_code(iter), 1))\n\t\t\tjump_entry_set_init(iter);\n\n\t\titerk = jump_entry_key(iter);\n\t\tif (iterk == key)\n\t\t\tcontinue;\n\n\t\tkey = iterk;\n\t\tstatic_key_set_entries(key, iter);\n\t}\n\tstatic_key_initialized = true;\n\tjump_label_unlock();\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "__jump_label_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "379-397",
    "snippet": "static void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"can't patch jump_label at %pS\"",
            "(void *)jump_entry_code(entry)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "entry"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_jump_label_transform",
          "args": [
            "entry",
            "jump_label_type(entry)"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "arch_jump_label_transform_static",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "317-321",
          "snippet": "__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\n__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_type",
          "args": [
            "entry"
          ],
          "line": 391
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_type",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "369-377",
          "snippet": "static enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kernel_text_address",
          "args": [
            "jump_entry_code(entry)"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "kernel_text_address",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/extable.c",
          "lines": "122-160",
          "snippet": "int kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <asm/sections.h>",
            "#include <linux/filter.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>",
            "#include <linux/extable.h>",
            "#include <linux/memory.h>",
            "#include <linux/ftrace.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <asm/sections.h>\n#include <linux/filter.h>\n#include <linux/kprobes.h>\n#include <linux/init.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n#include <linux/extable.h>\n#include <linux/memory.h>\n#include <linux/ftrace.h>\n\nint kernel_text_address(unsigned long addr)\n{\n\tbool no_rcu;\n\tint ret = 1;\n\n\tif (core_kernel_text(addr))\n\t\treturn 1;\n\n\t/*\n\t * If a stack dump happens while RCU is not watching, then\n\t * RCU needs to be notified that it requires to start\n\t * watching again. This can happen either by tracing that\n\t * triggers a stack trace, or a WARN() that happens during\n\t * coming back from idle, or cpu on or offlining.\n\t *\n\t * is_module_text_address() as well as the kprobe slots\n\t * and is_bpf_text_address() require RCU to be watching.\n\t */\n\tno_rcu = !rcu_is_watching();\n\n\t/* Treat this like an NMI as it can happen anywhere */\n\tif (no_rcu)\n\t\trcu_nmi_enter();\n\n\tif (is_module_text_address(addr))\n\t\tgoto out;\n\tif (is_ftrace_trampoline(addr))\n\t\tgoto out;\n\tif (is_kprobe_optinsn_slot(addr) || is_kprobe_insn_slot(addr))\n\t\tgoto out;\n\tif (is_bpf_text_address(addr))\n\t\tgoto out;\n\tret = 0;\nout:\n\tif (no_rcu)\n\t\trcu_nmi_exit();\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "entry"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_is_init",
          "args": [
            "entry"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "entry"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __jump_label_update(struct static_key *key,\n\t\t\t\tstruct jump_entry *entry,\n\t\t\t\tstruct jump_entry *stop,\n\t\t\t\tbool init)\n{\n\tfor (; (entry < stop) && (jump_entry_key(entry) == key); entry++) {\n\t\t/*\n\t\t * An entry->code of 0 indicates an entry which has been\n\t\t * disabled because it was in an init text area.\n\t\t */\n\t\tif (init || !jump_entry_is_init(entry)) {\n\t\t\tif (kernel_text_address(jump_entry_code(entry)))\n\t\t\t\tarch_jump_label_transform(entry, jump_label_type(entry));\n\t\t\telse\n\t\t\t\tWARN_ONCE(1, \"can't patch jump_label at %pS\",\n\t\t\t\t\t  (void *)jump_entry_code(entry));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "jump_label_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "369-377",
    "snippet": "static enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_entry_is_branch",
          "args": [
            "entry"
          ],
          "line": 373
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "key"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "entry"
          ],
          "line": 371
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic enum jump_label_type jump_label_type(struct jump_entry *entry)\n{\n\tstruct static_key *key = jump_entry_key(entry);\n\tbool enabled = static_key_enabled(key);\n\tbool branch = jump_entry_is_branch(entry);\n\n\t/* See the comment in linux/jump_label.h */\n\treturn enabled ^ branch;\n}"
  },
  {
    "function_name": "static_key_set_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "358-367",
    "snippet": "static void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "(unsigned long)entries & JUMP_TYPE_MASK"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void static_key_set_entries(struct static_key *key,\n\t\t\t\t   struct jump_entry *entries)\n{\n\tunsigned long type;\n\n\tWARN_ON_ONCE((unsigned long)entries & JUMP_TYPE_MASK);\n\ttype = key->type & JUMP_TYPE_MASK;\n\tkey->entries = entries;\n\tkey->type |= type;\n}"
  },
  {
    "function_name": "static_key_set_linked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "344-347",
    "snippet": "static inline void static_key_set_linked(struct static_key *key)\n{\n\tkey->type |= JUMP_TYPE_LINKED;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline void static_key_set_linked(struct static_key *key)\n{\n\tkey->type |= JUMP_TYPE_LINKED;\n}"
  },
  {
    "function_name": "static_key_clear_linked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "339-342",
    "snippet": "static inline void static_key_clear_linked(struct static_key *key)\n{\n\tkey->type &= ~JUMP_TYPE_LINKED;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline void static_key_clear_linked(struct static_key *key)\n{\n\tkey->type &= ~JUMP_TYPE_LINKED;\n}"
  },
  {
    "function_name": "static_key_linked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "334-337",
    "snippet": "static inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_linked(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_LINKED;\n}"
  },
  {
    "function_name": "static_key_type",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "329-332",
    "snippet": "static inline bool static_key_type(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_TRUE;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline bool static_key_type(struct static_key *key)\n{\n\treturn key->type & JUMP_TYPE_TRUE;\n}"
  },
  {
    "function_name": "static_key_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "323-327",
    "snippet": "static inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "key->type & JUMP_TYPE_LINKED"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic inline struct jump_entry *static_key_entries(struct static_key *key)\n{\n\tWARN_ON_ONCE(key->type & JUMP_TYPE_LINKED);\n\treturn (struct jump_entry *)(key->type & ~JUMP_TYPE_MASK);\n}"
  },
  {
    "function_name": "arch_jump_label_transform_static",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "317-321",
    "snippet": "__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_jump_label_transform",
          "args": [
            "entry",
            "type"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "arch_jump_label_transform_static",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "317-321",
          "snippet": "__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\n__init_or_module arch_jump_label_transform_static(struct jump_entry *entry,\n\t\t\t\t\t    enum jump_label_type type)\n{\n\tarch_jump_label_transform(entry, type);\n}"
  },
  {
    "function_name": "__jump_label_text_reserved",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "296-309",
    "snippet": "static int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "addr_conflict",
          "args": [
            "iter",
            "start",
            "end"
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "addr_conflict",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "287-294",
          "snippet": "static int addr_conflict(struct jump_entry *entry, void *start, void *end)\n{\n\tif (jump_entry_code(entry) <= (unsigned long)end &&\n\t    jump_entry_code(entry) + JUMP_LABEL_NOP_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int addr_conflict(struct jump_entry *entry, void *start, void *end)\n{\n\tif (jump_entry_code(entry) <= (unsigned long)end &&\n\t    jump_entry_code(entry) + JUMP_LABEL_NOP_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int __jump_label_text_reserved(struct jump_entry *iter_start,\n\t\tstruct jump_entry *iter_stop, void *start, void *end)\n{\n\tstruct jump_entry *iter;\n\n\titer = iter_start;\n\twhile (iter < iter_stop) {\n\t\tif (addr_conflict(iter, start, end))\n\t\t\treturn 1;\n\t\titer++;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "addr_conflict",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "287-294",
    "snippet": "static int addr_conflict(struct jump_entry *entry, void *start, void *end)\n{\n\tif (jump_entry_code(entry) <= (unsigned long)end &&\n\t    jump_entry_code(entry) + JUMP_LABEL_NOP_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "entry"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_code",
          "args": [
            "entry"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int addr_conflict(struct jump_entry *entry, void *start, void *end)\n{\n\tif (jump_entry_code(entry) <= (unsigned long)end &&\n\t    jump_entry_code(entry) + JUMP_LABEL_NOP_SIZE > (unsigned long)start)\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jump_label_rate_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "278-284",
    "snippet": "void jump_label_rate_limit(struct static_key_deferred *key,\n\t\tunsigned long rl)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tkey->timeout = rl;\n\tINIT_DELAYED_WORK(&key->work, jump_label_update_timeout);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_DELAYED_WORK",
          "args": [
            "&key->work",
            "jump_label_update_timeout"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_rate_limit(struct static_key_deferred *key,\n\t\tunsigned long rl)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tkey->timeout = rl;\n\tINIT_DELAYED_WORK(&key->work, jump_label_update_timeout);\n}"
  },
  {
    "function_name": "static_key_deferred_flush",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "271-275",
    "snippet": "void static_key_deferred_flush(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tflush_delayed_work(&key->work);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_delayed_work",
          "args": [
            "&key->work"
          ],
          "line": 274
        },
        "resolved": true,
        "details": {
          "function_name": "flush_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "3056-3063",
          "snippet": "bool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nbool flush_delayed_work(struct delayed_work *dwork)\n{\n\tlocal_irq_disable();\n\tif (del_timer_sync(&dwork->timer))\n\t\t__queue_work(dwork->cpu, dwork->wq, &dwork->work);\n\tlocal_irq_enable();\n\treturn flush_work(&dwork->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_deferred_flush(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tflush_delayed_work(&key->work);\n}"
  },
  {
    "function_name": "static_key_slow_dec_deferred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "264-268",
    "snippet": "void static_key_slow_dec_deferred(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(&key->key, key->timeout, &key->work);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_key_slow_dec",
          "args": [
            "&key->key",
            "key->timeout",
            "&key->work"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "__static_key_slow_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "235-242",
          "snippet": "static void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_dec_deferred(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(&key->key, key->timeout, &key->work);\n}"
  },
  {
    "function_name": "static_key_slow_dec_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "258-262",
    "snippet": "void static_key_slow_dec_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec_cpuslocked(key, 0, NULL);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_key_slow_dec_cpuslocked",
          "args": [
            "key",
            "0",
            "NULL"
          ],
          "line": 261
        },
        "resolved": true,
        "details": {
          "function_name": "__static_key_slow_dec_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "207-233",
          "snippet": "static void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_dec_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec_cpuslocked(key, 0, NULL);\n}"
  },
  {
    "function_name": "static_key_slow_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "251-255",
    "snippet": "void static_key_slow_dec(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(key, 0, NULL);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_key_slow_dec",
          "args": [
            "key",
            "0",
            "NULL"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "__static_key_slow_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "235-242",
          "snippet": "static void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_dec(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(key, 0, NULL);\n}"
  },
  {
    "function_name": "jump_label_update_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "244-249",
    "snippet": "static void jump_label_update_timeout(struct work_struct *work)\n{\n\tstruct static_key_deferred *key =\n\t\tcontainer_of(work, struct static_key_deferred, work.work);\n\t__static_key_slow_dec(&key->key, 0, NULL);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__static_key_slow_dec",
          "args": [
            "&key->key",
            "0",
            "NULL"
          ],
          "line": 248
        },
        "resolved": true,
        "details": {
          "function_name": "__static_key_slow_dec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "235-242",
          "snippet": "static void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structstatic_key_deferred",
            "work.work"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update_timeout(struct work_struct *work)\n{\n\tstruct static_key_deferred *key =\n\t\tcontainer_of(work, struct static_key_deferred, work.work);\n\t__static_key_slow_dec(&key->key, 0, NULL);\n}"
  },
  {
    "function_name": "__static_key_slow_dec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "235-242",
    "snippet": "static void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 241
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__static_key_slow_dec_cpuslocked",
          "args": [
            "key",
            "rate_limit",
            "work"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "__static_key_slow_dec_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "207-233",
          "snippet": "static void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec(struct static_key *key,\n\t\t\t\t  unsigned long rate_limit,\n\t\t\t\t  struct delayed_work *work)\n{\n\tcpus_read_lock();\n\t__static_key_slow_dec_cpuslocked(key, rate_limit, work);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "__static_key_slow_dec_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "207-233",
    "snippet": "static void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_update",
          "args": [
            "key"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "733-756",
          "snippet": "static void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_delayed_work",
          "args": [
            "work",
            "rate_limit"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&key->enabled"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "atomic_read(&key->enabled) < 0",
            "\"jump label: negative count!\\n\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_and_mutex_lock",
          "args": [
            "&key->enabled",
            "&jump_label_mutex"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "atomic_dec_and_mutex_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1430-1444",
          "snippet": "int atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)\n{\n\t/* dec if we can't possibly hit 0 */\n\tif (atomic_add_unless(cnt, -1, 1))\n\t\treturn 0;\n\t/* we might hit 0, so take the lock */\n\tmutex_lock(lock);\n\tif (!atomic_dec_and_test(cnt)) {\n\t\t/* when we actually did the dec, we didn't hit 0 */\n\t\tmutex_unlock(lock);\n\t\treturn 0;\n\t}\n\t/* we hit 0, and we hold the lock */\n\treturn 1;\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint atomic_dec_and_mutex_lock(atomic_t *cnt, struct mutex *lock)\n{\n\t/* dec if we can't possibly hit 0 */\n\tif (atomic_add_unless(cnt, -1, 1))\n\t\treturn 0;\n\t/* we might hit 0, so take the lock */\n\tmutex_lock(lock);\n\tif (!atomic_dec_and_test(cnt)) {\n\t\t/* when we actually did the dec, we didn't hit 0 */\n\t\tmutex_unlock(lock);\n\t\treturn 0;\n\t}\n\t/* we hit 0, and we hold the lock */\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 211
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void __static_key_slow_dec_cpuslocked(struct static_key *key,\n\t\t\t\t\t   unsigned long rate_limit,\n\t\t\t\t\t   struct delayed_work *work)\n{\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * The negative count check is valid even when a negative\n\t * key->enabled is in use by static_key_slow_inc(); a\n\t * __static_key_slow_dec() before the first static_key_slow_inc()\n\t * returns is unbalanced, because all other static_key_slow_inc()\n\t * instances block while the update is in progress.\n\t */\n\tif (!atomic_dec_and_mutex_lock(&key->enabled, &jump_label_mutex)) {\n\t\tWARN(atomic_read(&key->enabled) < 0,\n\t\t     \"jump label: negative count!\\n\");\n\t\treturn;\n\t}\n\n\tif (rate_limit) {\n\t\tatomic_inc(&key->enabled);\n\t\tschedule_delayed_work(work, rate_limit);\n\t} else {\n\t\tjump_label_update(key);\n\t}\n\tjump_label_unlock();\n}"
  },
  {
    "function_name": "static_key_disable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "199-204",
    "snippet": "void static_key_disable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_disable_cpuslocked(key);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_disable_cpuslocked",
          "args": [
            "key"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_disable_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "182-196",
          "snippet": "void static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_disable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_disable_cpuslocked(key);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "static_key_disable_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "182-196",
    "snippet": "void static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "jump_label_update",
          "args": [
            "key"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "733-756",
          "snippet": "static void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&key->enabled",
            "1",
            "0"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&key->enabled) != 0"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_disable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) != 1) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 0);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_cmpxchg(&key->enabled, 1, 0))\n\t\tjump_label_update(key);\n\tjump_label_unlock();\n}"
  },
  {
    "function_name": "static_key_enable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "174-179",
    "snippet": "void static_key_enable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_enable_cpuslocked(key);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 178
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_enable_cpuslocked",
          "args": [
            "key"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_enable_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "151-171",
          "snippet": "void static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 176
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_enable(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_enable_cpuslocked(key);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "static_key_enable_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "151-171",
    "snippet": "void static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&key->enabled",
            "1"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_update",
          "args": [
            "key"
          ],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "733-756",
          "snippet": "static void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&key->enabled",
            "-1"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "atomic_read(&key->enabled) != 1"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_enable_cpuslocked(struct static_key *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\tif (atomic_read(&key->enabled) > 0) {\n\t\tWARN_ON_ONCE(atomic_read(&key->enabled) != 1);\n\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * See static_key_slow_inc().\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t}\n\tjump_label_unlock();\n}"
  },
  {
    "function_name": "static_key_slow_inc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "143-148",
    "snippet": "void static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpus_read_unlock",
          "args": [],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "297-300",
          "snippet": "void cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_unlock(void)\n{\n\tpercpu_up_read(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc_cpuslocked",
          "args": [
            "key"
          ],
          "line": 146
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_slow_inc_cpuslocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "103-141",
          "snippet": "void static_key_slow_inc_cpuslocked(struct static_key *key)\n{\n\tint v, v1;\n\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * Careful if we get concurrent static_key_slow_inc() calls;\n\t * later calls must wait for the first one to _finish_ the\n\t * jump_label_update() process.  At the same time, however,\n\t * the jump_label_update() call below wants to see\n\t * static_key_enabled(&key) for jumps to be updated properly.\n\t *\n\t * So give a special meaning to negative key->enabled: it sends\n\t * static_key_slow_inc() down the slow path, and it is non-zero\n\t * so it counts as \"enabled\" in jump_label_update().  Note that\n\t * atomic_inc_unless_negative() checks >= 0, so roll our own.\n\t */\n\tfor (v = atomic_read(&key->enabled); v > 0; v = v1) {\n\t\tv1 = atomic_cmpxchg(&key->enabled, v, v + 1);\n\t\tif (likely(v1 == v))\n\t\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * Ensure that if the above cmpxchg loop observes our positive\n\t\t * value, it must also observe all the text changes.\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t} else {\n\t\tatomic_inc(&key->enabled);\n\t}\n\tjump_label_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_inc_cpuslocked(struct static_key *key)\n{\n\tint v, v1;\n\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * Careful if we get concurrent static_key_slow_inc() calls;\n\t * later calls must wait for the first one to _finish_ the\n\t * jump_label_update() process.  At the same time, however,\n\t * the jump_label_update() call below wants to see\n\t * static_key_enabled(&key) for jumps to be updated properly.\n\t *\n\t * So give a special meaning to negative key->enabled: it sends\n\t * static_key_slow_inc() down the slow path, and it is non-zero\n\t * so it counts as \"enabled\" in jump_label_update().  Note that\n\t * atomic_inc_unless_negative() checks >= 0, so roll our own.\n\t */\n\tfor (v = atomic_read(&key->enabled); v > 0; v = v1) {\n\t\tv1 = atomic_cmpxchg(&key->enabled, v, v + 1);\n\t\tif (likely(v1 == v))\n\t\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * Ensure that if the above cmpxchg loop observes our positive\n\t\t * value, it must also observe all the text changes.\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t} else {\n\t\tatomic_inc(&key->enabled);\n\t}\n\tjump_label_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpus_read_lock",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "cpus_read_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "285-288",
          "snippet": "void cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid cpus_read_lock(void)\n{\n\tpercpu_down_read(&cpu_hotplug_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}"
  },
  {
    "function_name": "static_key_slow_inc_cpuslocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "103-141",
    "snippet": "void static_key_slow_inc_cpuslocked(struct static_key *key)\n{\n\tint v, v1;\n\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * Careful if we get concurrent static_key_slow_inc() calls;\n\t * later calls must wait for the first one to _finish_ the\n\t * jump_label_update() process.  At the same time, however,\n\t * the jump_label_update() call below wants to see\n\t * static_key_enabled(&key) for jumps to be updated properly.\n\t *\n\t * So give a special meaning to negative key->enabled: it sends\n\t * static_key_slow_inc() down the slow path, and it is non-zero\n\t * so it counts as \"enabled\" in jump_label_update().  Note that\n\t * atomic_inc_unless_negative() checks >= 0, so roll our own.\n\t */\n\tfor (v = atomic_read(&key->enabled); v > 0; v = v1) {\n\t\tv1 = atomic_cmpxchg(&key->enabled, v, v + 1);\n\t\tif (likely(v1 == v))\n\t\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * Ensure that if the above cmpxchg loop observes our positive\n\t\t * value, it must also observe all the text changes.\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t} else {\n\t\tatomic_inc(&key->enabled);\n\t}\n\tjump_label_unlock();\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_label_unlock",
          "args": [],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "31-34",
          "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&key->enabled"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set_release",
          "args": [
            "&key->enabled",
            "1"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_update",
          "args": [
            "key"
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "733-756",
          "snippet": "static void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_update(struct static_key *key)\n{\n\tstruct jump_entry *stop = __stop___jump_table;\n\tstruct jump_entry *entry;\n#ifdef CONFIG_MODULES\n\tstruct module *mod;\n\n\tif (static_key_linked(key)) {\n\t\t__jump_label_mod_update(key);\n\t\treturn;\n\t}\n\n\tpreempt_disable();\n\tmod = __module_address((unsigned long)key);\n\tif (mod)\n\t\tstop = mod->jump_entries + mod->num_jump_entries;\n\tpreempt_enable();\n#endif\n\tentry = static_key_entries(key);\n\t/* if there are no users, entry can be NULL */\n\tif (entry)\n\t\t__jump_label_update(key, entry, stop,\n\t\t\t\t    system_state < SYSTEM_RUNNING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&key->enabled",
            "-1"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_label_lock",
          "args": [],
          "line": 128
        },
        "resolved": true,
        "details": {
          "function_name": "jump_label_lock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "26-29",
          "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "v1 == v"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_cmpxchg",
          "args": [
            "&key->enabled",
            "v",
            "v + 1"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_assert_cpus_held",
          "args": [],
          "line": 108
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_assert_cpus_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "313-316",
          "snippet": "void lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nvoid lockdep_assert_cpus_held(void)\n{\n\tpercpu_rwsem_assert_held(&cpu_hotplug_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "STATIC_KEY_CHECK_USE",
          "args": [
            "key"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_inc_cpuslocked(struct static_key *key)\n{\n\tint v, v1;\n\n\tSTATIC_KEY_CHECK_USE(key);\n\tlockdep_assert_cpus_held();\n\n\t/*\n\t * Careful if we get concurrent static_key_slow_inc() calls;\n\t * later calls must wait for the first one to _finish_ the\n\t * jump_label_update() process.  At the same time, however,\n\t * the jump_label_update() call below wants to see\n\t * static_key_enabled(&key) for jumps to be updated properly.\n\t *\n\t * So give a special meaning to negative key->enabled: it sends\n\t * static_key_slow_inc() down the slow path, and it is non-zero\n\t * so it counts as \"enabled\" in jump_label_update().  Note that\n\t * atomic_inc_unless_negative() checks >= 0, so roll our own.\n\t */\n\tfor (v = atomic_read(&key->enabled); v > 0; v = v1) {\n\t\tv1 = atomic_cmpxchg(&key->enabled, v, v + 1);\n\t\tif (likely(v1 == v))\n\t\t\treturn;\n\t}\n\n\tjump_label_lock();\n\tif (atomic_read(&key->enabled) == 0) {\n\t\tatomic_set(&key->enabled, -1);\n\t\tjump_label_update(key);\n\t\t/*\n\t\t * Ensure that if the above cmpxchg loop observes our positive\n\t\t * value, it must also observe all the text changes.\n\t\t */\n\t\tatomic_set_release(&key->enabled, 1);\n\t} else {\n\t\tatomic_inc(&key->enabled);\n\t}\n\tjump_label_unlock();\n}"
  },
  {
    "function_name": "static_key_count",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "91-100",
    "snippet": "int static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&key->enabled"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nint static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}"
  },
  {
    "function_name": "jump_label_sort_entries",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "66-78",
    "snippet": "static void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sort",
          "args": [
            "start",
            "size",
            "sizeof(struct jump_entry)",
            "jump_label_cmp",
            "swapfn"
          ],
          "line": 77
        },
        "resolved": true,
        "details": {
          "function_name": "sort_secondary",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/tracing_map.c",
          "lines": "986-1033",
          "snippet": "static void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}",
          "includes": [
            "#include \"trace.h\"",
            "#include \"tracing_map.h\"",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/jhash.h>",
            "#include <linux/vmalloc.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace.h\"\n#include \"tracing_map.h\"\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/jhash.h>\n#include <linux/vmalloc.h>\n\nstatic void sort_secondary(struct tracing_map *map,\n\t\t\t   const struct tracing_map_sort_entry **entries,\n\t\t\t   unsigned int n_entries,\n\t\t\t   struct tracing_map_sort_key *primary_key,\n\t\t\t   struct tracing_map_sort_key *secondary_key)\n{\n\tint (*primary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t  const struct tracing_map_sort_entry **);\n\tint (*secondary_fn)(const struct tracing_map_sort_entry **,\n\t\t\t    const struct tracing_map_sort_entry **);\n\tunsigned i, start = 0, n_sub = 1;\n\n\tif (is_key(map, primary_key->field_idx))\n\t\tprimary_fn = cmp_entries_key;\n\telse\n\t\tprimary_fn = cmp_entries_sum;\n\n\tif (is_key(map, secondary_key->field_idx))\n\t\tsecondary_fn = cmp_entries_key;\n\telse\n\t\tsecondary_fn = cmp_entries_sum;\n\n\tfor (i = 0; i < n_entries - 1; i++) {\n\t\tconst struct tracing_map_sort_entry **a = &entries[i];\n\t\tconst struct tracing_map_sort_entry **b = &entries[i + 1];\n\n\t\tif (primary_fn(a, b) == 0) {\n\t\t\tn_sub++;\n\t\t\tif (i < n_entries - 2)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tif (n_sub < 2) {\n\t\t\tstart = i + 1;\n\t\t\tn_sub = 1;\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_sort_key(map, secondary_key);\n\t\tsort(&entries[start], n_sub,\n\t\t     sizeof(struct tracing_map_sort_entry *),\n\t\t     (int (*)(const void *, const void *))secondary_fn, NULL);\n\t\tset_sort_key(map, primary_key);\n\n\t\tstart = i + 1;\n\t\tn_sub = 1;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void\njump_label_sort_entries(struct jump_entry *start, struct jump_entry *stop)\n{\n\tunsigned long size;\n\tvoid *swapfn = NULL;\n\n\tif (IS_ENABLED(CONFIG_HAVE_ARCH_JUMP_LABEL_RELATIVE))\n\t\tswapfn = jump_label_swap;\n\n\tsize = (((unsigned long)stop - (unsigned long)start)\n\t\t\t\t\t/ sizeof(struct jump_entry));\n\tsort(start, size, sizeof(struct jump_entry), jump_label_cmp, swapfn);\n}"
  },
  {
    "function_name": "jump_label_swap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "50-64",
    "snippet": "static void jump_label_swap(void *a, void *b, int size)\n{\n\tlong delta = (unsigned long)a - (unsigned long)b;\n\tstruct jump_entry *jea = a;\n\tstruct jump_entry *jeb = b;\n\tstruct jump_entry tmp = *jea;\n\n\tjea->code\t= jeb->code - delta;\n\tjea->target\t= jeb->target - delta;\n\tjea->key\t= jeb->key - delta;\n\n\tjeb->code\t= tmp.code + delta;\n\tjeb->target\t= tmp.target + delta;\n\tjeb->key\t= tmp.key + delta;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic void jump_label_swap(void *a, void *b, int size)\n{\n\tlong delta = (unsigned long)a - (unsigned long)b;\n\tstruct jump_entry *jea = a;\n\tstruct jump_entry *jeb = b;\n\tstruct jump_entry tmp = *jea;\n\n\tjea->code\t= jeb->code - delta;\n\tjea->target\t= jeb->target - delta;\n\tjea->key\t= jeb->key - delta;\n\n\tjeb->code\t= tmp.code + delta;\n\tjeb->target\t= tmp.target + delta;\n\tjeb->key\t= tmp.key + delta;\n}"
  },
  {
    "function_name": "jump_label_cmp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "36-48",
    "snippet": "static int jump_label_cmp(const void *a, const void *b)\n{\n\tconst struct jump_entry *jea = a;\n\tconst struct jump_entry *jeb = b;\n\n\tif (jump_entry_key(jea) < jump_entry_key(jeb))\n\t\treturn -1;\n\n\tif (jump_entry_key(jea) > jump_entry_key(jeb))\n\t\treturn 1;\n\n\treturn 0;\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "jeb"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "jea"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "jeb"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "jump_entry_key",
          "args": [
            "jea"
          ],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nstatic int jump_label_cmp(const void *a, const void *b)\n{\n\tconst struct jump_entry *jea = a;\n\tconst struct jump_entry *jeb = b;\n\n\tif (jump_entry_key(jea) < jump_entry_key(jeb))\n\t\treturn -1;\n\n\tif (jump_entry_key(jea) > jump_entry_key(jeb))\n\t\treturn 1;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "jump_label_unlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "31-34",
    "snippet": "void jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&jump_label_mutex"
          ],
          "line": 33
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_unlock(void)\n{\n\tmutex_unlock(&jump_label_mutex);\n}"
  },
  {
    "function_name": "jump_label_lock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
    "lines": "26-29",
    "snippet": "void jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}",
    "includes": [
      "#include <asm/sections.h>",
      "#include <linux/cpu.h>",
      "#include <linux/bug.h>",
      "#include <linux/jump_label_ratelimit.h>",
      "#include <linux/static_key.h>",
      "#include <linux/err.h>",
      "#include <linux/sort.h>",
      "#include <linux/slab.h>",
      "#include <linux/list.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/memory.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&jump_label_mutex"
          ],
          "line": 28
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid jump_label_lock(void)\n{\n\tmutex_lock(&jump_label_mutex);\n}"
  }
]