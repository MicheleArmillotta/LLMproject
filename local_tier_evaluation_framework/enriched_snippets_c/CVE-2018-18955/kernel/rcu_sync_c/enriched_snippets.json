[
  {
    "function_name": "rcu_sync_dtor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "224-240",
    "snippet": "void rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint cb_state;\n\n\tBUG_ON(rsp->gp_count);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->cb_state == CB_REPLAY)\n\t\trsp->cb_state = CB_PENDING;\n\tcb_state = rsp->cb_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (cb_state != CB_IDLE) {\n\t\tgp_ops[rsp->gp_type].wait();\n\t\tBUG_ON(rsp->cb_state != CB_IDLE);\n\t}\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [
      "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rsp->cb_state != CB_IDLE"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp_ops[rsp->gp_type].wait",
          "args": [],
          "line": 237
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 234
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rsp->gp_count"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nvoid rcu_sync_dtor(struct rcu_sync *rsp)\n{\n\tint cb_state;\n\n\tBUG_ON(rsp->gp_count);\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (rsp->cb_state == CB_REPLAY)\n\t\trsp->cb_state = CB_PENDING;\n\tcb_state = rsp->cb_state;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tif (cb_state != CB_IDLE) {\n\t\tgp_ops[rsp->gp_type].wait();\n\t\tBUG_ON(rsp->cb_state != CB_IDLE);\n\t}\n}"
  },
  {
    "function_name": "rcu_sync_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "206-218",
    "snippet": "void rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->cb_state == CB_IDLE) {\n\t\t\trsp->cb_state = CB_PENDING;\n\t\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t\t} else if (rsp->cb_state == CB_PENDING) {\n\t\t\trsp->cb_state = CB_REPLAY;\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [
      "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gp_ops[rsp->gp_type].call",
          "args": [
            "&rsp->cb_head",
            "rcu_sync_func"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nvoid rcu_sync_exit(struct rcu_sync *rsp)\n{\n\tspin_lock_irq(&rsp->rss_lock);\n\tif (!--rsp->gp_count) {\n\t\tif (rsp->cb_state == CB_IDLE) {\n\t\t\trsp->cb_state = CB_PENDING;\n\t\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t\t} else if (rsp->cb_state == CB_PENDING) {\n\t\t\trsp->cb_state = CB_REPLAY;\n\t\t}\n\t}\n\tspin_unlock_irq(&rsp->rss_lock);\n}"
  },
  {
    "function_name": "rcu_sync_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "164-194",
    "snippet": "static void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tBUG_ON(rsp->gp_state != GP_PASSED);\n\tBUG_ON(rsp->cb_state == CB_IDLE);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * A new rcu_sync_begin() has happened; drop the callback.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t} else if (rsp->cb_state == CB_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback\n\t\t * to catch a later GP.\n\t\t */\n\t\trsp->cb_state = CB_PENDING;\n\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after rcu_sync_exit(); eveybody will now\n\t\t * have observed the write side critical section. Let 'em rip!.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t\trsp->gp_state = GP_IDLE;\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [
      "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&rsp->rss_lock",
            "flags"
          ],
          "line": 193
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gp_ops[rsp->gp_type].call",
          "args": [
            "&rsp->cb_head",
            "rcu_sync_func"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&rsp->rss_lock",
            "flags"
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rsp->cb_state == CB_IDLE"
          ],
          "line": 170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rsp->gp_state != GP_PASSED"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rhp",
            "structrcu_sync",
            "cb_head"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nstatic void rcu_sync_func(struct rcu_head *rhp)\n{\n\tstruct rcu_sync *rsp = container_of(rhp, struct rcu_sync, cb_head);\n\tunsigned long flags;\n\n\tBUG_ON(rsp->gp_state != GP_PASSED);\n\tBUG_ON(rsp->cb_state == CB_IDLE);\n\n\tspin_lock_irqsave(&rsp->rss_lock, flags);\n\tif (rsp->gp_count) {\n\t\t/*\n\t\t * A new rcu_sync_begin() has happened; drop the callback.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t} else if (rsp->cb_state == CB_REPLAY) {\n\t\t/*\n\t\t * A new rcu_sync_exit() has happened; requeue the callback\n\t\t * to catch a later GP.\n\t\t */\n\t\trsp->cb_state = CB_PENDING;\n\t\tgp_ops[rsp->gp_type].call(&rsp->cb_head, rcu_sync_func);\n\t} else {\n\t\t/*\n\t\t * We're at least a GP after rcu_sync_exit(); eveybody will now\n\t\t * have observed the write side critical section. Let 'em rip!.\n\t\t */\n\t\trsp->cb_state = CB_IDLE;\n\t\trsp->gp_state = GP_IDLE;\n\t}\n\tspin_unlock_irqrestore(&rsp->rss_lock, flags);\n}"
  },
  {
    "function_name": "rcu_sync_enter",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "117-144",
    "snippet": "void rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tbool need_wait, need_sync;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tneed_wait = rsp->gp_count++;\n\tneed_sync = rsp->gp_state == GP_IDLE;\n\tif (need_sync)\n\t\trsp->gp_state = GP_PENDING;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tBUG_ON(need_wait && need_sync);\n\n\tif (need_sync) {\n\t\tgp_ops[rsp->gp_type].sync();\n\t\trsp->gp_state = GP_PASSED;\n\t\twake_up_all(&rsp->gp_wait);\n\t} else if (need_wait) {\n\t\twait_event(rsp->gp_wait, rsp->gp_state == GP_PASSED);\n\t} else {\n\t\t/*\n\t\t * Possible when there's a pending CB from a rcu_sync_exit().\n\t\t * Nobody has yet been allowed the 'fast' path and thus we can\n\t\t * avoid doing any sync(). The callback will get 'dropped'.\n\t\t */\n\t\tBUG_ON(rsp->gp_state != GP_PASSED);\n\t}\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [
      "#define\trss_lock\tgp_wait.lock"
    ],
    "globals_used": [
      "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "rsp->gp_state != GP_PASSED"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event",
          "args": [
            "rsp->gp_wait",
            "rsp->gp_state == GP_PASSED"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wake_up_all",
          "args": [
            "&rsp->gp_wait"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "swake_up_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/swait.c",
          "lines": "49-69",
          "snippet": "void swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid swake_up_all(struct swait_queue_head *q)\n{\n\tstruct swait_queue *curr;\n\tLIST_HEAD(tmp);\n\n\traw_spin_lock_irq(&q->lock);\n\tlist_splice_init(&q->task_list, &tmp);\n\twhile (!list_empty(&tmp)) {\n\t\tcurr = list_first_entry(&tmp, typeof(*curr), task_list);\n\n\t\twake_up_state(curr->task, TASK_NORMAL);\n\t\tlist_del_init(&curr->task_list);\n\n\t\tif (list_empty(&tmp))\n\t\t\tbreak;\n\n\t\traw_spin_unlock_irq(&q->lock);\n\t\traw_spin_lock_irq(&q->lock);\n\t}\n\traw_spin_unlock_irq(&q->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gp_ops[rsp->gp_type].sync",
          "args": [],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "need_wait && need_sync"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&rsp->rss_lock"
          ],
          "line": 121
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\n#define\trss_lock\tgp_wait.lock\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nvoid rcu_sync_enter(struct rcu_sync *rsp)\n{\n\tbool need_wait, need_sync;\n\n\tspin_lock_irq(&rsp->rss_lock);\n\tneed_wait = rsp->gp_count++;\n\tneed_sync = rsp->gp_state == GP_IDLE;\n\tif (need_sync)\n\t\trsp->gp_state = GP_PENDING;\n\tspin_unlock_irq(&rsp->rss_lock);\n\n\tBUG_ON(need_wait && need_sync);\n\n\tif (need_sync) {\n\t\tgp_ops[rsp->gp_type].sync();\n\t\trsp->gp_state = GP_PASSED;\n\t\twake_up_all(&rsp->gp_wait);\n\t} else if (need_wait) {\n\t\twait_event(rsp->gp_wait, rsp->gp_state == GP_PASSED);\n\t} else {\n\t\t/*\n\t\t * Possible when there's a pending CB from a rcu_sync_exit().\n\t\t * Nobody has yet been allowed the 'fast' path and thus we can\n\t\t * avoid doing any sync(). The callback will get 'dropped'.\n\t\t */\n\t\tBUG_ON(rsp->gp_state != GP_PASSED);\n\t}\n}"
  },
  {
    "function_name": "rcu_sync_enter_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "96-100",
    "snippet": "void rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_enter_start(struct rcu_sync *rsp)\n{\n\trsp->gp_count++;\n\trsp->gp_state = GP_PASSED;\n}"
  },
  {
    "function_name": "rcu_sync_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "80-85",
    "snippet": "void rcu_sync_init(struct rcu_sync *rsp, enum rcu_sync_type type)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n\trsp->gp_type = type;\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_waitqueue_head",
          "args": [
            "&rsp->gp_wait"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "rsp",
            "0",
            "sizeof(*rsp)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nvoid rcu_sync_init(struct rcu_sync *rsp, enum rcu_sync_type type)\n{\n\tmemset(rsp, 0, sizeof(*rsp));\n\tinit_waitqueue_head(&rsp->gp_wait);\n\trsp->gp_type = type;\n}"
  },
  {
    "function_name": "rcu_sync_lockdep_assert",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/sync.c",
    "lines": "66-70",
    "snippet": "void rcu_sync_lockdep_assert(struct rcu_sync *rsp)\n{\n\tRCU_LOCKDEP_WARN(!gp_ops[rsp->gp_type].held(),\n\t\t\t \"suspicious rcu_sync_is_idle() usage\");\n}",
    "includes": [
      "#include <linux/sched.h>",
      "#include <linux/rcu_sync.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "RCU_LOCKDEP_WARN",
          "args": [
            "!gp_ops[rsp->gp_type].held()",
            "\"suspicious rcu_sync_is_idle() usage\""
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gp_ops[rsp->gp_type].held",
          "args": [],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched.h>\n#include <linux/rcu_sync.h>\n\nstatic const struct {\n\tvoid (*sync)(void);\n\tvoid (*call)(struct rcu_head *, void (*)(struct rcu_head *));\n\tvoid (*wait)(void);\n#ifdef CONFIG_PROVE_RCU\n\tint  (*held)(void);\n#endif\n} gp_ops[] = {\n\t[RCU_SYNC] = {\n\t\t.sync = synchronize_rcu,\n\t\t.call = call_rcu,\n\t\t.wait = rcu_barrier,\n\t\t__INIT_HELD(rcu_read_lock_held)\n\t},\n\t[RCU_SCHED_SYNC] = {\n\t\t.sync = synchronize_sched,\n\t\t.call = call_rcu_sched,\n\t\t.wait = rcu_barrier_sched,\n\t\t__INIT_HELD(rcu_read_lock_sched_held)\n\t},\n\t[RCU_BH_SYNC] = {\n\t\t.sync = synchronize_rcu_bh,\n\t\t.call = call_rcu_bh,\n\t\t.wait = rcu_barrier_bh,\n\t\t__INIT_HELD(rcu_read_lock_bh_held)\n\t},\n};\n\nvoid rcu_sync_lockdep_assert(struct rcu_sync *rsp)\n{\n\tRCU_LOCKDEP_WARN(!gp_ops[rsp->gp_type].held(),\n\t\t\t \"suspicious rcu_sync_is_idle() usage\");\n}"
  }
]