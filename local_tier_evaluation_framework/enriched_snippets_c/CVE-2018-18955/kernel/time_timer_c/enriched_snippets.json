[
  {
    "function_name": "usleep_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1987-1998",
    "snippet": "void __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_hrtimeout_range",
          "args": [
            "&exp",
            "delta",
            "HRTIMER_MODE_ABS"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_hrtimeout_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1989-1994",
          "snippet": "int __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nint __sched schedule_hrtimeout_range(ktime_t *expires, u64 delta,\n\t\t\t\t     const enum hrtimer_mode mode)\n{\n\treturn schedule_hrtimeout_range_clock(expires, delta, mode,\n\t\t\t\t\t      CLOCK_MONOTONIC);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "max - min"
          ],
          "line": 1990
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_add_us",
          "args": [
            "ktime_get()",
            "min"
          ],
          "line": 1989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get",
          "args": [],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\n\nvoid __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "msleep_interruptible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1965-1972",
    "snippet": "unsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "jiffies_to_msecs",
          "args": [
            "timeout"
          ],
          "line": 1971
        },
        "resolved": true,
        "details": {
          "function_name": "jiffies_to_msecs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "311-325",
          "snippet": "unsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned int jiffies_to_msecs(const unsigned long j)\n{\n#if HZ <= MSEC_PER_SEC && !(MSEC_PER_SEC % HZ)\n\treturn (MSEC_PER_SEC / HZ) * j;\n#elif HZ > MSEC_PER_SEC && !(HZ % MSEC_PER_SEC)\n\treturn (j + (HZ / MSEC_PER_SEC) - 1)/(HZ / MSEC_PER_SEC);\n#else\n# if BITS_PER_LONG == 32\n\treturn (HZ_TO_MSEC_MUL32 * j + (1ULL << HZ_TO_MSEC_SHR32) - 1) >>\n\t       HZ_TO_MSEC_SHR32;\n# else\n\treturn DIV_ROUND_UP(j * HZ_TO_MSEC_NUM, HZ_TO_MSEC_DEN);\n# endif\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_timeout_interruptible",
          "args": [
            "timeout"
          ],
          "line": 1970
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1821-1825",
          "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 1969
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "msecs"
          ],
          "line": 1967
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long msleep_interruptible(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout && !signal_pending(current))\n\t\ttimeout = schedule_timeout_interruptible(timeout);\n\treturn jiffies_to_msecs(timeout);\n}"
  },
  {
    "function_name": "msleep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1951-1957",
    "snippet": "void msleep(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout)\n\t\ttimeout = schedule_timeout_uninterruptible(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout_uninterruptible",
          "args": [
            "timeout"
          ],
          "line": 1956
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_uninterruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1835-1839",
          "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "msecs_to_jiffies",
          "args": [
            "msecs"
          ],
          "line": 1953
        },
        "resolved": true,
        "details": {
          "function_name": "__msecs_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "565-573",
          "snippet": "unsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long __msecs_to_jiffies(const unsigned int m)\n{\n\t/*\n\t * Negative value, means infinite timeout:\n\t */\n\tif ((int)m < 0)\n\t\treturn MAX_JIFFY_OFFSET;\n\treturn _msecs_to_jiffies(m);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid msleep(unsigned int msecs)\n{\n\tunsigned long timeout = msecs_to_jiffies(msecs) + 1;\n\n\twhile (timeout)\n\t\ttimeout = schedule_timeout_uninterruptible(timeout);\n}"
  },
  {
    "function_name": "init_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1941-1945",
    "snippet": "void __init init_timers(void)\n{\n\tinit_timer_cpus();\n\topen_softirq(TIMER_SOFTIRQ, run_timer_softirq);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "open_softirq",
          "args": [
            "TIMER_SOFTIRQ",
            "run_timer_softirq"
          ],
          "line": 1944
        },
        "resolved": true,
        "details": {
          "function_name": "open_softirq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "455-458",
          "snippet": "void open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct softirq_action softirq_vec[NR_SOFTIRQS]"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic struct softirq_action softirq_vec[NR_SOFTIRQS];\n\nvoid open_softirq(int nr, void (*action)(struct softirq_action *))\n{\n\tsoftirq_vec[nr].action = action;\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_timer_cpus",
          "args": [],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "init_timer_cpus",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1933-1939",
          "snippet": "static void __init init_timer_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinit_timer_cpu(cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void __init init_timer_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinit_timer_cpu(cpu);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid __init init_timers(void)\n{\n\tinit_timer_cpus();\n\topen_softirq(TIMER_SOFTIRQ, run_timer_softirq);\n}"
  },
  {
    "function_name": "init_timer_cpus",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1933-1939",
    "snippet": "static void __init init_timer_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinit_timer_cpu(cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void __init init_timer_cpus(void)\n{\n\tint cpu;\n\n\tfor_each_possible_cpu(cpu)\n\t\tinit_timer_cpu(cpu);\n}"
  },
  {
    "function_name": "init_timer_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1920-1931",
    "snippet": "static void __init init_timer_cpu(int cpu)\n{\n\tstruct timer_base *base;\n\tint i;\n\n\tfor (i = 0; i < NR_BASES; i++) {\n\t\tbase = per_cpu_ptr(&timer_bases[i], cpu);\n\t\tbase->cpu = cpu;\n\t\traw_spin_lock_init(&base->lock);\n\t\tbase->clk = jiffies;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&base->lock"
          ],
          "line": 1928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&timer_bases[i]",
            "cpu"
          ],
          "line": 1926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic void __init init_timer_cpu(int cpu)\n{\n\tstruct timer_base *base;\n\tint i;\n\n\tfor (i = 0; i < NR_BASES; i++) {\n\t\tbase = per_cpu_ptr(&timer_bases[i], cpu);\n\t\tbase->cpu = cpu;\n\t\traw_spin_lock_init(&base->lock);\n\t\tbase->clk = jiffies;\n\t}\n}"
  },
  {
    "function_name": "timers_dead_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1882-1916",
    "snippet": "int timers_dead_cpu(unsigned int cpu)\n{\n\tstruct timer_base *old_base;\n\tstruct timer_base *new_base;\n\tint b, i;\n\n\tBUG_ON(cpu_online(cpu));\n\n\tfor (b = 0; b < NR_BASES; b++) {\n\t\told_base = per_cpu_ptr(&timer_bases[b], cpu);\n\t\tnew_base = get_cpu_ptr(&timer_bases[b]);\n\t\t/*\n\t\t * The caller is globally serialized and nobody else\n\t\t * takes two locks at once, deadlock is not possible.\n\t\t */\n\t\traw_spin_lock_irq(&new_base->lock);\n\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\t\t/*\n\t\t * The current CPUs base clock might be stale. Update it\n\t\t * before moving the timers over.\n\t\t */\n\t\tforward_timer_base(new_base);\n\n\t\tBUG_ON(old_base->running_timer);\n\n\t\tfor (i = 0; i < WHEEL_SIZE; i++)\n\t\t\tmigrate_timer_list(new_base, old_base->vectors + i);\n\n\t\traw_spin_unlock(&old_base->lock);\n\t\traw_spin_unlock_irq(&new_base->lock);\n\t\tput_cpu_ptr(&timer_bases);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define WHEEL_SIZE\t(LVL_SIZE * LVL_DEPTH)"
    ],
    "globals_used": [
      "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;",
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cpu_ptr",
          "args": [
            "&timer_bases"
          ],
          "line": 1913
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&new_base->lock"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&old_base->lock"
          ],
          "line": 1911
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "migrate_timer_list",
          "args": [
            "new_base",
            "old_base->vectors + i"
          ],
          "line": 1909
        },
        "resolved": true,
        "details": {
          "function_name": "migrate_timer_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1854-1865",
          "snippet": "static void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)\n{\n\tstruct timer_list *timer;\n\tint cpu = new_base->cpu;\n\n\twhile (!hlist_empty(head)) {\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\t\tdetach_timer(timer, false);\n\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)\n{\n\tstruct timer_list *timer;\n\tint cpu = new_base->cpu;\n\n\twhile (!hlist_empty(head)) {\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\t\tdetach_timer(timer, false);\n\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "old_base->running_timer"
          ],
          "line": 1906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "forward_timer_base",
          "args": [
            "new_base"
          ],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "forward_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "880-907",
          "snippet": "static inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_nested",
          "args": [
            "&old_base->lock",
            "SINGLE_DEPTH_NESTING"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "351-356",
          "snippet": "void __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_nested(raw_spinlock_t *lock, int subclass)\n{\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&new_base->lock"
          ],
          "line": 1897
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cpu_ptr",
          "args": [
            "&timer_bases[b]"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&timer_bases[b]",
            "cpu"
          ],
          "line": 1891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cpu_online(cpu)"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "cpu"
          ],
          "line": 1888
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define WHEEL_SIZE\t(LVL_SIZE * LVL_DEPTH)\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nint timers_dead_cpu(unsigned int cpu)\n{\n\tstruct timer_base *old_base;\n\tstruct timer_base *new_base;\n\tint b, i;\n\n\tBUG_ON(cpu_online(cpu));\n\n\tfor (b = 0; b < NR_BASES; b++) {\n\t\told_base = per_cpu_ptr(&timer_bases[b], cpu);\n\t\tnew_base = get_cpu_ptr(&timer_bases[b]);\n\t\t/*\n\t\t * The caller is globally serialized and nobody else\n\t\t * takes two locks at once, deadlock is not possible.\n\t\t */\n\t\traw_spin_lock_irq(&new_base->lock);\n\t\traw_spin_lock_nested(&old_base->lock, SINGLE_DEPTH_NESTING);\n\n\t\t/*\n\t\t * The current CPUs base clock might be stale. Update it\n\t\t * before moving the timers over.\n\t\t */\n\t\tforward_timer_base(new_base);\n\n\t\tBUG_ON(old_base->running_timer);\n\n\t\tfor (i = 0; i < WHEEL_SIZE; i++)\n\t\t\tmigrate_timer_list(new_base, old_base->vectors + i);\n\n\t\traw_spin_unlock(&old_base->lock);\n\t\traw_spin_unlock_irq(&new_base->lock);\n\t\tput_cpu_ptr(&timer_bases);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "timers_prepare_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1867-1880",
    "snippet": "int timers_prepare_cpu(unsigned int cpu)\n{\n\tstruct timer_base *base;\n\tint b;\n\n\tfor (b = 0; b < NR_BASES; b++) {\n\t\tbase = per_cpu_ptr(&timer_bases[b], cpu);\n\t\tbase->clk = jiffies;\n\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;\n\t\tbase->is_idle = false;\n\t\tbase->must_forward_clk = true;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&timer_bases[b]",
            "cpu"
          ],
          "line": 1873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nint timers_prepare_cpu(unsigned int cpu)\n{\n\tstruct timer_base *base;\n\tint b;\n\n\tfor (b = 0; b < NR_BASES; b++) {\n\t\tbase = per_cpu_ptr(&timer_bases[b], cpu);\n\t\tbase->clk = jiffies;\n\t\tbase->next_expiry = base->clk + NEXT_TIMER_MAX_DELTA;\n\t\tbase->is_idle = false;\n\t\tbase->must_forward_clk = true;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "migrate_timer_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1854-1865",
    "snippet": "static void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)\n{\n\tstruct timer_list *timer;\n\tint cpu = new_base->cpu;\n\n\twhile (!hlist_empty(head)) {\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\t\tdetach_timer(timer, false);\n\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "internal_add_timer",
          "args": [
            "new_base",
            "timer"
          ],
          "line": 1863
        },
        "resolved": true,
        "details": {
          "function_name": "internal_add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "587-592",
          "snippet": "static void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_timer",
          "args": [
            "timer",
            "false"
          ],
          "line": 1861
        },
        "resolved": true,
        "details": {
          "function_name": "detach_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "811-821",
          "snippet": "static inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "head->first",
            "structtimer_list",
            "entry"
          ],
          "line": 1860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1859
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void migrate_timer_list(struct timer_base *new_base, struct hlist_head *head)\n{\n\tstruct timer_list *timer;\n\tint cpu = new_base->cpu;\n\n\twhile (!hlist_empty(head)) {\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\t\tdetach_timer(timer, false);\n\t\ttimer->flags = (timer->flags & ~TIMER_BASEMASK) | cpu;\n\t\tinternal_add_timer(new_base, timer);\n\t}\n}"
  },
  {
    "function_name": "schedule_timeout_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1846-1850",
    "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1846-1850",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_IDLE"
          ],
          "line": 1848
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
  },
  {
    "function_name": "schedule_timeout_uninterruptible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1835-1839",
    "snippet": "signed long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 1838
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1846-1850",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_UNINTERRUPTIBLE"
          ],
          "line": 1837
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_uninterruptible(signed long timeout)\n{\n\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
  },
  {
    "function_name": "schedule_timeout_killable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1828-1832",
    "snippet": "signed long __sched schedule_timeout_killable(signed long timeout)\n{\n\t__set_current_state(TASK_KILLABLE);\n\treturn schedule_timeout(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 1831
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1846-1850",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_KILLABLE"
          ],
          "line": 1830
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_killable(signed long timeout)\n{\n\t__set_current_state(TASK_KILLABLE);\n\treturn schedule_timeout(timeout);\n}"
  },
  {
    "function_name": "schedule_timeout_interruptible",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1821-1825",
    "snippet": "signed long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_timeout",
          "args": [
            "timeout"
          ],
          "line": 1824
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_timeout_idle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1846-1850",
          "snippet": "signed long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_idle(signed long timeout)\n{\n\t__set_current_state(TASK_IDLE);\n\treturn schedule_timeout(timeout);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 1823
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout_interruptible(signed long timeout)\n{\n\t__set_current_state(TASK_INTERRUPTIBLE);\n\treturn schedule_timeout(timeout);\n}"
  },
  {
    "function_name": "schedule_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1765-1814",
    "snippet": "signed long __sched schedule_timeout(signed long timeout)\n{\n\tstruct process_timer timer;\n\tunsigned long expire;\n\n\tswitch (timeout)\n\t{\n\tcase MAX_SCHEDULE_TIMEOUT:\n\t\t/*\n\t\t * These two special cases are useful to be comfortable\n\t\t * in the caller. Nothing more. We could take\n\t\t * MAX_SCHEDULE_TIMEOUT from one of the negative value\n\t\t * but I' d like to return a valid offset (>=0) to allow\n\t\t * the caller to do everything it want with the retval.\n\t\t */\n\t\tschedule();\n\t\tgoto out;\n\tdefault:\n\t\t/*\n\t\t * Another bit of PARANOID. Note that the retval will be\n\t\t * 0 since no piece of kernel is supposed to do a check\n\t\t * for a negative retval of schedule_timeout() (since it\n\t\t * should never happens anyway). You just have the printk()\n\t\t * that will tell you if something is gone wrong and where.\n\t\t */\n\t\tif (timeout < 0) {\n\t\t\tprintk(KERN_ERR \"schedule_timeout: wrong timeout \"\n\t\t\t\t\"value %lx\\n\", timeout);\n\t\t\tdump_stack();\n\t\t\tcurrent->state = TASK_RUNNING;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\texpire = timeout + jiffies;\n\n\ttimer.task = current;\n\ttimer_setup_on_stack(&timer.timer, process_timeout, 0);\n\t__mod_timer(&timer.timer, expire, 0);\n\tschedule();\n\tdel_singleshot_timer_sync(&timer.timer);\n\n\t/* Remove the timer from the object tracker */\n\tdestroy_timer_on_stack(&timer.timer);\n\n\ttimeout = expire - jiffies;\n\n out:\n\treturn timeout < 0 ? 0 : timeout;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_timer_on_stack",
          "args": [
            "&timer.timer"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_timer_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "742-745",
          "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "del_singleshot_timer_sync",
          "args": [
            "&timer.timer"
          ],
          "line": 1805
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 1804
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__mod_timer",
          "args": [
            "&timer.timer",
            "expire",
            "0"
          ],
          "line": 1803
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "950-1062",
          "snippet": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02",
            "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nstatic inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_setup_on_stack",
          "args": [
            "&timer.timer",
            "process_timeout",
            "0"
          ],
          "line": 1802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_stack",
          "args": [],
          "line": 1793
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"schedule_timeout: wrong timeout \"\n\t\t\t\t\"value %lx\\n\"",
            "timeout"
          ],
          "line": 1791
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nsigned long __sched schedule_timeout(signed long timeout)\n{\n\tstruct process_timer timer;\n\tunsigned long expire;\n\n\tswitch (timeout)\n\t{\n\tcase MAX_SCHEDULE_TIMEOUT:\n\t\t/*\n\t\t * These two special cases are useful to be comfortable\n\t\t * in the caller. Nothing more. We could take\n\t\t * MAX_SCHEDULE_TIMEOUT from one of the negative value\n\t\t * but I' d like to return a valid offset (>=0) to allow\n\t\t * the caller to do everything it want with the retval.\n\t\t */\n\t\tschedule();\n\t\tgoto out;\n\tdefault:\n\t\t/*\n\t\t * Another bit of PARANOID. Note that the retval will be\n\t\t * 0 since no piece of kernel is supposed to do a check\n\t\t * for a negative retval of schedule_timeout() (since it\n\t\t * should never happens anyway). You just have the printk()\n\t\t * that will tell you if something is gone wrong and where.\n\t\t */\n\t\tif (timeout < 0) {\n\t\t\tprintk(KERN_ERR \"schedule_timeout: wrong timeout \"\n\t\t\t\t\"value %lx\\n\", timeout);\n\t\t\tdump_stack();\n\t\t\tcurrent->state = TASK_RUNNING;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\texpire = timeout + jiffies;\n\n\ttimer.task = current;\n\ttimer_setup_on_stack(&timer.timer, process_timeout, 0);\n\t__mod_timer(&timer.timer, expire, 0);\n\tschedule();\n\tdel_singleshot_timer_sync(&timer.timer);\n\n\t/* Remove the timer from the object tracker */\n\tdestroy_timer_on_stack(&timer.timer);\n\n\ttimeout = expire - jiffies;\n\n out:\n\treturn timeout < 0 ? 0 : timeout;\n}"
  },
  {
    "function_name": "process_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1729-1734",
    "snippet": "static void process_timeout(struct timer_list *t)\n{\n\tstruct process_timer *timeout = from_timer(timeout, t, timer);\n\n\twake_up_process(timeout->task);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "timeout->task"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_timer",
          "args": [
            "timeout",
            "t",
            "timer"
          ],
          "line": 1731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void process_timeout(struct timer_list *t)\n{\n\tstruct process_timer *timeout = from_timer(timeout, t, timer);\n\n\twake_up_process(timeout->task);\n}"
  },
  {
    "function_name": "run_local_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1703-1718",
    "snippet": "void run_local_timers(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\thrtimer_run_queues();\n\t/* Raise the softirq only if required. */\n\tif (time_before(jiffies, base->clk)) {\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t\treturn;\n\t\t/* CPU is awake, so check the deferrable base. */\n\t\tbase++;\n\t\tif (time_before(jiffies, base->clk))\n\t\t\treturn;\n\t}\n\traise_softirq(TIMER_SOFTIRQ);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raise_softirq",
          "args": [
            "TIMER_SOFTIRQ"
          ],
          "line": 1717
        },
        "resolved": true,
        "details": {
          "function_name": "__raise_softirq_irqoff",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "449-453",
          "snippet": "void __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nvoid __raise_softirq_irqoff(unsigned int nr)\n{\n\ttrace_softirq_raise(nr);\n\tor_softirq_pending(1UL << nr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "base->clk"
          ],
          "line": 1714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_COMMON"
          ],
          "line": 1710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "base->clk"
          ],
          "line": 1709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_run_queues",
          "args": [],
          "line": 1707
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_run_queues",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1601-1633",
          "snippet": "void hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_HARD\t((1U << MASK_SHIFT) - 1)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nvoid hrtimer_run_queues(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tunsigned long flags;\n\tktime_t now;\n\n\tif (__hrtimer_hres_active(cpu_base))\n\t\treturn;\n\n\t/*\n\t * This _is_ ugly: We have to check periodically, whether we\n\t * can switch to highres and / or nohz mode. The clocksource\n\t * switch happens with xtime_lock held. Notification from\n\t * there only sets the check bit in the tick_oneshot code,\n\t * otherwise we might deadlock vs. xtime_lock.\n\t */\n\tif (tick_check_oneshot_change(!hrtimer_is_hres_enabled())) {\n\t\thrtimer_switch_to_hres();\n\t\treturn;\n\t}\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\tnow = hrtimer_update_base(cpu_base);\n\n\tif (!ktime_before(now, cpu_base->softirq_expires_next)) {\n\t\tcpu_base->softirq_expires_next = KTIME_MAX;\n\t\tcpu_base->softirq_activated = 1;\n\t\traise_softirq_irqoff(HRTIMER_SOFTIRQ);\n\t}\n\n\t__hrtimer_run_queues(cpu_base, now, flags, HRTIMER_ACTIVE_HARD);\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]"
          ],
          "line": 1705
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid run_local_timers(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\thrtimer_run_queues();\n\t/* Raise the softirq only if required. */\n\tif (time_before(jiffies, base->clk)) {\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t\treturn;\n\t\t/* CPU is awake, so check the deferrable base. */\n\t\tbase++;\n\t\tif (time_before(jiffies, base->clk))\n\t\t\treturn;\n\t}\n\traise_softirq(TIMER_SOFTIRQ);\n}"
  },
  {
    "function_name": "run_timer_softirq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1691-1698",
    "snippet": "static __latent_entropy void run_timer_softirq(struct softirq_action *h)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t__run_timers(base);\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__run_timers",
          "args": [
            "this_cpu_ptr(&timer_bases[BASE_DEF])"
          ],
          "line": 1697
        },
        "resolved": true,
        "details": {
          "function_name": "__run_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1650-1686",
          "snippet": "static inline void __run_timers(struct timer_base *base)\n{\n\tstruct hlist_head heads[LVL_DEPTH];\n\tint levels;\n\n\tif (!time_after_eq(jiffies, base->clk))\n\t\treturn;\n\n\traw_spin_lock_irq(&base->lock);\n\n\t/*\n\t * timer_base::must_forward_clk must be cleared before running\n\t * timers so that any timer functions that call mod_timer() will\n\t * not try to forward the base. Idle tracking / clock forwarding\n\t * logic is only used with BASE_STD timers.\n\t *\n\t * The must_forward_clk flag is cleared unconditionally also for\n\t * the deferrable base. The deferrable base is not affected by idle\n\t * tracking and never forwarded, so clearing the flag is a NOOP.\n\t *\n\t * The fact that the deferrable base is never forwarded can cause\n\t * large variations in granularity for deferrable timers, but they\n\t * can be deferred for long periods due to idle anyway.\n\t */\n\tbase->must_forward_clk = false;\n\n\twhile (time_after_eq(jiffies, base->clk)) {\n\n\t\tlevels = collect_expired_timers(base, heads);\n\t\tbase->clk++;\n\n\t\twhile (levels--)\n\t\t\texpire_timers(base, heads + levels);\n\t}\n\tbase->running_timer = NULL;\n\traw_spin_unlock_irq(&base->lock);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void __run_timers(struct timer_base *base)\n{\n\tstruct hlist_head heads[LVL_DEPTH];\n\tint levels;\n\n\tif (!time_after_eq(jiffies, base->clk))\n\t\treturn;\n\n\traw_spin_lock_irq(&base->lock);\n\n\t/*\n\t * timer_base::must_forward_clk must be cleared before running\n\t * timers so that any timer functions that call mod_timer() will\n\t * not try to forward the base. Idle tracking / clock forwarding\n\t * logic is only used with BASE_STD timers.\n\t *\n\t * The must_forward_clk flag is cleared unconditionally also for\n\t * the deferrable base. The deferrable base is not affected by idle\n\t * tracking and never forwarded, so clearing the flag is a NOOP.\n\t *\n\t * The fact that the deferrable base is never forwarded can cause\n\t * large variations in granularity for deferrable timers, but they\n\t * can be deferred for long periods due to idle anyway.\n\t */\n\tbase->must_forward_clk = false;\n\n\twhile (time_after_eq(jiffies, base->clk)) {\n\n\t\tlevels = collect_expired_timers(base, heads);\n\t\tbase->clk++;\n\n\t\twhile (levels--)\n\t\t\texpire_timers(base, heads + levels);\n\t}\n\tbase->running_timer = NULL;\n\traw_spin_unlock_irq(&base->lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_DEF]"
          ],
          "line": 1697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_COMMON"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic __latent_entropy void run_timer_softirq(struct softirq_action *h)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t__run_timers(base);\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t__run_timers(this_cpu_ptr(&timer_bases[BASE_DEF]));\n}"
  },
  {
    "function_name": "__run_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1650-1686",
    "snippet": "static inline void __run_timers(struct timer_base *base)\n{\n\tstruct hlist_head heads[LVL_DEPTH];\n\tint levels;\n\n\tif (!time_after_eq(jiffies, base->clk))\n\t\treturn;\n\n\traw_spin_lock_irq(&base->lock);\n\n\t/*\n\t * timer_base::must_forward_clk must be cleared before running\n\t * timers so that any timer functions that call mod_timer() will\n\t * not try to forward the base. Idle tracking / clock forwarding\n\t * logic is only used with BASE_STD timers.\n\t *\n\t * The must_forward_clk flag is cleared unconditionally also for\n\t * the deferrable base. The deferrable base is not affected by idle\n\t * tracking and never forwarded, so clearing the flag is a NOOP.\n\t *\n\t * The fact that the deferrable base is never forwarded can cause\n\t * large variations in granularity for deferrable timers, but they\n\t * can be deferred for long periods due to idle anyway.\n\t */\n\tbase->must_forward_clk = false;\n\n\twhile (time_after_eq(jiffies, base->clk)) {\n\n\t\tlevels = collect_expired_timers(base, heads);\n\t\tbase->clk++;\n\n\t\twhile (levels--)\n\t\t\texpire_timers(base, heads + levels);\n\t}\n\tbase->running_timer = NULL;\n\traw_spin_unlock_irq(&base->lock);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&base->lock"
          ],
          "line": 1685
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "expire_timers",
          "args": [
            "base",
            "heads + levels"
          ],
          "line": 1682
        },
        "resolved": true,
        "details": {
          "function_name": "expire_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1344-1367",
          "snippet": "static void expire_timers(struct timer_base *base, struct hlist_head *head)\n{\n\twhile (!hlist_empty(head)) {\n\t\tstruct timer_list *timer;\n\t\tvoid (*fn)(struct timer_list *);\n\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\n\t\tbase->running_timer = timer;\n\t\tdetach_timer(timer, true);\n\n\t\tfn = timer->function;\n\n\t\tif (timer->flags & TIMER_IRQSAFE) {\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock(&base->lock);\n\t\t} else {\n\t\t\traw_spin_unlock_irq(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock_irq(&base->lock);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void expire_timers(struct timer_base *base, struct hlist_head *head)\n{\n\twhile (!hlist_empty(head)) {\n\t\tstruct timer_list *timer;\n\t\tvoid (*fn)(struct timer_list *);\n\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\n\t\tbase->running_timer = timer;\n\t\tdetach_timer(timer, true);\n\n\t\tfn = timer->function;\n\n\t\tif (timer->flags & TIMER_IRQSAFE) {\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock(&base->lock);\n\t\t} else {\n\t\t\traw_spin_unlock_irq(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock_irq(&base->lock);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "collect_expired_timers",
          "args": [
            "base",
            "heads"
          ],
          "line": 1678
        },
        "resolved": true,
        "details": {
          "function_name": "collect_expired_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1618-1622",
          "snippet": "static inline int collect_expired_timers(struct timer_base *base,\n\t\t\t\t\t struct hlist_head *heads)\n{\n\treturn __collect_expired_timers(base, heads);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int collect_expired_timers(struct timer_base *base,\n\t\t\t\t\t struct hlist_head *heads)\n{\n\treturn __collect_expired_timers(base, heads);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "base->clk"
          ],
          "line": 1676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&base->lock"
          ],
          "line": 1658
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "jiffies",
            "base->clk"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void __run_timers(struct timer_base *base)\n{\n\tstruct hlist_head heads[LVL_DEPTH];\n\tint levels;\n\n\tif (!time_after_eq(jiffies, base->clk))\n\t\treturn;\n\n\traw_spin_lock_irq(&base->lock);\n\n\t/*\n\t * timer_base::must_forward_clk must be cleared before running\n\t * timers so that any timer functions that call mod_timer() will\n\t * not try to forward the base. Idle tracking / clock forwarding\n\t * logic is only used with BASE_STD timers.\n\t *\n\t * The must_forward_clk flag is cleared unconditionally also for\n\t * the deferrable base. The deferrable base is not affected by idle\n\t * tracking and never forwarded, so clearing the flag is a NOOP.\n\t *\n\t * The fact that the deferrable base is never forwarded can cause\n\t * large variations in granularity for deferrable timers, but they\n\t * can be deferred for long periods due to idle anyway.\n\t */\n\tbase->must_forward_clk = false;\n\n\twhile (time_after_eq(jiffies, base->clk)) {\n\n\t\tlevels = collect_expired_timers(base, heads);\n\t\tbase->clk++;\n\n\t\twhile (levels--)\n\t\t\texpire_timers(base, heads + levels);\n\t}\n\tbase->running_timer = NULL;\n\traw_spin_unlock_irq(&base->lock);\n}"
  },
  {
    "function_name": "update_process_times",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1629-1644",
    "snippet": "void update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "run_posix_cpu_timers",
          "args": [
            "p"
          ],
          "line": 1643
        },
        "resolved": true,
        "details": {
          "function_name": "run_posix_cpu_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-cpu-timers.c",
          "lines": "1138-1196",
          "snippet": "void run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tLIST_HEAD(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t/*\n\t * Here we take off tsk->signal->cpu_timers[N] and\n\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t * put them on the firing list.\n\t */\n\tcheck_thread_timers(tsk, &firing);\n\n\tcheck_process_timers(tsk, &firing);\n\n\t/*\n\t * We must release these locks before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include <linux/sched/deadline.h>",
            "#include <linux/compat.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/tick.h>",
            "#include <trace/events/timer.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/math64.h>",
            "#include <linux/errno.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/signal.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void posix_cpu_timer_rearm(struct k_itimer *timer);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include <linux/sched/deadline.h>\n#include <linux/compat.h>\n#include <linux/workqueue.h>\n#include <linux/tick.h>\n#include <trace/events/timer.h>\n#include <linux/kernel_stat.h>\n#include <linux/uaccess.h>\n#include <linux/math64.h>\n#include <linux/errno.h>\n#include <linux/posix-timers.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/signal.h>\n\nstatic void posix_cpu_timer_rearm(struct k_itimer *timer);\n\nvoid run_posix_cpu_timers(struct task_struct *tsk)\n{\n\tLIST_HEAD(firing);\n\tstruct k_itimer *timer, *next;\n\tunsigned long flags;\n\n\tlockdep_assert_irqs_disabled();\n\n\t/*\n\t * The fast path checks that there are no expired thread or thread\n\t * group timers.  If that's so, just return.\n\t */\n\tif (!fastpath_timer_check(tsk))\n\t\treturn;\n\n\tif (!lock_task_sighand(tsk, &flags))\n\t\treturn;\n\t/*\n\t * Here we take off tsk->signal->cpu_timers[N] and\n\t * tsk->cpu_timers[N] all the timers that are firing, and\n\t * put them on the firing list.\n\t */\n\tcheck_thread_timers(tsk, &firing);\n\n\tcheck_process_timers(tsk, &firing);\n\n\t/*\n\t * We must release these locks before taking any timer's lock.\n\t * There is a potential race with timer deletion here, as the\n\t * siglock now protects our private firing list.  We have set\n\t * the firing flag in each timer, so that a deletion attempt\n\t * that gets the timer lock before we do will give it up and\n\t * spin until we've taken care of that timer below.\n\t */\n\tunlock_task_sighand(tsk, &flags);\n\n\t/*\n\t * Now that all the timers on our list have the firing flag,\n\t * no one will touch their list entries but us.  We'll take\n\t * each timer's lock before clearing its firing flag, so no\n\t * timer call will interfere.\n\t */\n\tlist_for_each_entry_safe(timer, next, &firing, it.cpu.entry) {\n\t\tint cpu_firing;\n\n\t\tspin_lock(&timer->it_lock);\n\t\tlist_del_init(&timer->it.cpu.entry);\n\t\tcpu_firing = timer->it.cpu.firing;\n\t\ttimer->it.cpu.firing = 0;\n\t\t/*\n\t\t * The firing flag is -1 if we collided with a reset\n\t\t * of the timer, which already reported this\n\t\t * almost-firing as an overrun.  So don't generate an event.\n\t\t */\n\t\tif (likely(cpu_firing >= 0))\n\t\t\tcpu_timer_fire(timer);\n\t\tspin_unlock(&timer->it_lock);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_POSIX_TIMERS"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "scheduler_tick",
          "args": [],
          "line": 1641
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_work_tick",
          "args": [],
          "line": 1639
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "175-182",
          "snippet": "void irq_work_tick(void)\n{\n\tstruct llist_head *raised = this_cpu_ptr(&raised_list);\n\n\tif (!llist_empty(raised) && !arch_irq_work_has_interrupt())\n\t\tirq_work_run_list(raised);\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nvoid irq_work_tick(void)\n{\n\tstruct llist_head *raised = this_cpu_ptr(&raised_list);\n\n\tif (!llist_empty(raised) && !arch_irq_work_has_interrupt())\n\t\tirq_work_run_list(raised);\n\tirq_work_run_list(this_cpu_ptr(&lazy_list));\n}"
        }
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 1638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_check_callbacks",
          "args": [
            "user_tick"
          ],
          "line": 1636
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_check_callbacks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree.c",
          "lines": "2492-2510",
          "snippet": "void rcu_check_callbacks(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_check_callbacks(user);\n\tif (rcu_pending())\n\t\tinvoke_rcu_core();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}",
          "includes": [
            "#include \"tree_plugin.h\"",
            "#include \"tree_exp.h\"",
            "#include \"rcu.h\"",
            "#include \"tree.h\"",
            "#include <linux/tick.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/suspend.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/random.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/delay.h>",
            "#include <linux/prefetch.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/kthread.h>",
            "#include <linux/wait.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/time.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/export.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/nmi.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};",
            "static void invoke_rcu_core(void);",
            "static int rcu_pending(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tree_plugin.h\"\n#include \"tree_exp.h\"\n#include \"rcu.h\"\n#include \"tree.h\"\n#include <linux/tick.h>\n#include <linux/ftrace.h>\n#include <linux/suspend.h>\n#include <linux/trace_events.h>\n#include <linux/random.h>\n#include <linux/stop_machine.h>\n#include <linux/delay.h>\n#include <linux/prefetch.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/kthread.h>\n#include <linux/wait.h>\n#include <linux/kernel_stat.h>\n#include <linux/time.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/export.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/nmi.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct rcu_data, rcu_data) = {\n\t.dynticks_nesting = 1,\n\t.dynticks_nmi_nesting = DYNTICK_IRQ_NONIDLE,\n\t.dynticks = ATOMIC_INIT(RCU_DYNTICK_CTRL_CTR),\n};\nstatic void invoke_rcu_core(void);\nstatic int rcu_pending(void);\n\nvoid rcu_check_callbacks(int user)\n{\n\ttrace_rcu_utilization(TPS(\"Start scheduler-tick\"));\n\traw_cpu_inc(rcu_data.ticks_this_gp);\n\t/* The load-acquire pairs with the store-release setting to true. */\n\tif (smp_load_acquire(this_cpu_ptr(&rcu_data.rcu_urgent_qs))) {\n\t\t/* Idle and userspace execution already are quiescent states. */\n\t\tif (!rcu_is_cpu_rrupt_from_idle() && !user) {\n\t\t\tset_tsk_need_resched(current);\n\t\t\tset_preempt_need_resched();\n\t\t}\n\t\t__this_cpu_write(rcu_data.rcu_urgent_qs, false);\n\t}\n\trcu_flavor_check_callbacks(user);\n\tif (rcu_pending())\n\t\tinvoke_rcu_core();\n\n\ttrace_rcu_utilization(TPS(\"End scheduler-tick\"));\n}"
        }
      },
      {
        "call_info": {
          "callee": "run_local_timers",
          "args": [],
          "line": 1635
        },
        "resolved": true,
        "details": {
          "function_name": "run_local_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1703-1718",
          "snippet": "void run_local_timers(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\thrtimer_run_queues();\n\t/* Raise the softirq only if required. */\n\tif (time_before(jiffies, base->clk)) {\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t\treturn;\n\t\t/* CPU is awake, so check the deferrable base. */\n\t\tbase++;\n\t\tif (time_before(jiffies, base->clk))\n\t\t\treturn;\n\t}\n\traise_softirq(TIMER_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid run_local_timers(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\thrtimer_run_queues();\n\t/* Raise the softirq only if required. */\n\tif (time_before(jiffies, base->clk)) {\n\t\tif (!IS_ENABLED(CONFIG_NO_HZ_COMMON))\n\t\t\treturn;\n\t\t/* CPU is awake, so check the deferrable base. */\n\t\tbase++;\n\t\tif (time_before(jiffies, base->clk))\n\t\t\treturn;\n\t}\n\traise_softirq(TIMER_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "account_process_tick",
          "args": [
            "p",
            "user_tick"
          ],
          "line": 1634
        },
        "resolved": true,
        "details": {
          "function_name": "account_process_tick",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "474-501",
          "snippet": "void account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [
            "#define sched_clock_irqtime\t(0)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\n#define sched_clock_irqtime\t(0)\n\nvoid account_process_tick(struct task_struct *p, int user_tick)\n{\n\tu64 cputime, steal;\n\tstruct rq *rq = this_rq();\n\n\tif (vtime_accounting_cpu_enabled())\n\t\treturn;\n\n\tif (sched_clock_irqtime) {\n\t\tirqtime_account_process_tick(p, user_tick, rq, 1);\n\t\treturn;\n\t}\n\n\tcputime = TICK_NSEC;\n\tsteal = steal_account_process_time(ULONG_MAX);\n\n\tif (steal >= cputime)\n\t\treturn;\n\n\tcputime -= steal;\n\n\tif (user_tick)\n\t\taccount_user_time(p, cputime);\n\telse if ((p != rq->idle) || (irq_count() != HARDIRQ_OFFSET))\n\t\taccount_system_time(p, HARDIRQ_OFFSET, cputime);\n\telse\n\t\taccount_idle_time(cputime);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid update_process_times(int user_tick)\n{\n\tstruct task_struct *p = current;\n\n\t/* Note: this timer irq context must be accounted for as well. */\n\taccount_process_tick(p, user_tick);\n\trun_local_timers();\n\trcu_check_callbacks(user_tick);\n#ifdef CONFIG_IRQ_WORK\n\tif (in_irq())\n\t\tirq_work_tick();\n#endif\n\tscheduler_tick();\n\tif (IS_ENABLED(CONFIG_POSIX_TIMERS))\n\t\trun_posix_cpu_timers(p);\n}"
  },
  {
    "function_name": "collect_expired_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1618-1622",
    "snippet": "static inline int collect_expired_timers(struct timer_base *base,\n\t\t\t\t\t struct hlist_head *heads)\n{\n\treturn __collect_expired_timers(base, heads);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__collect_expired_timers",
          "args": [
            "base",
            "heads"
          ],
          "line": 1621
        },
        "resolved": true,
        "details": {
          "function_name": "__collect_expired_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1369-1392",
          "snippet": "static int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_CLK_SHIFT\t3"
          ],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline int collect_expired_timers(struct timer_base *base,\n\t\t\t\t\t struct hlist_head *heads)\n{\n\treturn __collect_expired_timers(base, heads);\n}"
  },
  {
    "function_name": "collect_expired_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1590-1616",
    "snippet": "static int collect_expired_timers(struct timer_base *base,\n\t\t\t\t  struct hlist_head *heads)\n{\n\t/*\n\t * NOHZ optimization. After a long idle sleep we need to forward the\n\t * base to current jiffies. Avoid a loop by searching the bitfield for\n\t * the next expiring timer.\n\t */\n\tif ((long)(jiffies - base->clk) > 2) {\n\t\tunsigned long next = __next_timer_interrupt(base);\n\n\t\t/*\n\t\t * If the next timer is ahead of time forward to current\n\t\t * jiffies, otherwise forward to the next expiry time:\n\t\t */\n\t\tif (time_after(next, jiffies)) {\n\t\t\t/*\n\t\t\t * The call site will increment base->clk and then\n\t\t\t * terminate the expiry loop immediately.\n\t\t\t */\n\t\t\tbase->clk = jiffies;\n\t\t\treturn 0;\n\t\t}\n\t\tbase->clk = next;\n\t}\n\treturn __collect_expired_timers(base, heads);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__collect_expired_timers",
          "args": [
            "base",
            "heads"
          ],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "__collect_expired_timers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1369-1392",
          "snippet": "static int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_CLK_SHIFT\t3"
          ],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "next",
            "jiffies"
          ],
          "line": 1605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__next_timer_interrupt",
          "args": [
            "base"
          ],
          "line": 1599
        },
        "resolved": true,
        "details": {
          "function_name": "__next_timer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1418-1476",
          "snippet": "static unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_CLK_SHIFT\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstatic unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic int collect_expired_timers(struct timer_base *base,\n\t\t\t\t  struct hlist_head *heads)\n{\n\t/*\n\t * NOHZ optimization. After a long idle sleep we need to forward the\n\t * base to current jiffies. Avoid a loop by searching the bitfield for\n\t * the next expiring timer.\n\t */\n\tif ((long)(jiffies - base->clk) > 2) {\n\t\tunsigned long next = __next_timer_interrupt(base);\n\n\t\t/*\n\t\t * If the next timer is ahead of time forward to current\n\t\t * jiffies, otherwise forward to the next expiry time:\n\t\t */\n\t\tif (time_after(next, jiffies)) {\n\t\t\t/*\n\t\t\t * The call site will increment base->clk and then\n\t\t\t * terminate the expiry loop immediately.\n\t\t\t */\n\t\t\tbase->clk = jiffies;\n\t\t\treturn 0;\n\t\t}\n\t\tbase->clk = next;\n\t}\n\treturn __collect_expired_timers(base, heads);\n}"
  },
  {
    "function_name": "timer_clear_idle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1577-1588",
    "snippet": "void timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]"
          ],
          "line": 1579
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nvoid timer_clear_idle(void)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * We do this unlocked. The worst outcome is a remote enqueue sending\n\t * a pointless IPI, but taking the lock would just make the window for\n\t * sending the IPI a few instructions smaller for the cost of taking\n\t * the lock in the exit from idle path.\n\t */\n\tbase->is_idle = false;\n}"
  },
  {
    "function_name": "get_next_timer_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1519-1570",
    "snippet": "u64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\tbool is_max_delta;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tnextevt = __next_timer_interrupt(base);\n\tis_max_delta = (nextevt == base->clk + NEXT_TIMER_MAX_DELTA);\n\tbase->next_expiry = nextevt;\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (!is_max_delta)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC) {\n\t\t\tbase->must_forward_clk = true;\n\t\t\tbase->is_idle = true;\n\t\t}\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible u64",
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmp_next_hrtimer_event",
          "args": [
            "basem",
            "expires"
          ],
          "line": 1569
        },
        "resolved": true,
        "details": {
          "function_name": "cmp_next_hrtimer_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1482-1509",
          "snippet": "static u64 cmp_next_hrtimer_event(u64 basem, u64 expires)\n{\n\tu64 nextevt = hrtimer_get_next_event();\n\n\t/*\n\t * If high resolution timers are enabled\n\t * hrtimer_get_next_event() returns KTIME_MAX.\n\t */\n\tif (expires <= nextevt)\n\t\treturn expires;\n\n\t/*\n\t * If the next timer is already expired, return the tick base\n\t * time so the tick is fired immediately.\n\t */\n\tif (nextevt <= basem)\n\t\treturn basem;\n\n\t/*\n\t * Round up to the next jiffie. High resolution timers are\n\t * off, so the hrtimers are expired in the tick and we need to\n\t * make sure that this tick really expires the timer to avoid\n\t * a ping pong of the nohz stop code.\n\t *\n\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3\n\t */\n\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\n\nstatic u64 cmp_next_hrtimer_event(u64 basem, u64 expires)\n{\n\tu64 nextevt = hrtimer_get_next_event();\n\n\t/*\n\t * If high resolution timers are enabled\n\t * hrtimer_get_next_event() returns KTIME_MAX.\n\t */\n\tif (expires <= nextevt)\n\t\treturn expires;\n\n\t/*\n\t * If the next timer is already expired, return the tick base\n\t * time so the tick is fired immediately.\n\t */\n\tif (nextevt <= basem)\n\t\treturn basem;\n\n\t/*\n\t * Round up to the next jiffie. High resolution timers are\n\t * off, so the hrtimers are expired in the tick and we need to\n\t * make sure that this tick really expires the timer to avoid\n\t * a ping pong of the nohz stop code.\n\t *\n\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3\n\t */\n\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 1567
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "nextevt - basej"
          ],
          "line": 1554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_before_eq",
          "args": [
            "nextevt",
            "basej"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "nextevt",
            "base->clk"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "nextevt",
            "basej"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "basej",
            "base->clk"
          ],
          "line": 1542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__next_timer_interrupt",
          "args": [
            "base"
          ],
          "line": 1534
        },
        "resolved": true,
        "details": {
          "function_name": "__next_timer_interrupt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1418-1476",
          "snippet": "static unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_MASK\t(LVL_SIZE - 1)",
            "#define LVL_SIZE\t(1UL << LVL_BITS)",
            "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
            "#define LVL_CLK_SHIFT\t3"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstatic unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 1533
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_is_offline",
          "args": [
            "smp_processor_id()"
          ],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 1530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]"
          ],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nu64 get_next_timer_interrupt(unsigned long basej, u64 basem)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\tu64 expires = KTIME_MAX;\n\tunsigned long nextevt;\n\tbool is_max_delta;\n\n\t/*\n\t * Pretend that there is no timer pending if the cpu is offline.\n\t * Possible pending timers will be migrated later to an active cpu.\n\t */\n\tif (cpu_is_offline(smp_processor_id()))\n\t\treturn expires;\n\n\traw_spin_lock(&base->lock);\n\tnextevt = __next_timer_interrupt(base);\n\tis_max_delta = (nextevt == base->clk + NEXT_TIMER_MAX_DELTA);\n\tbase->next_expiry = nextevt;\n\t/*\n\t * We have a fresh next event. Check whether we can forward the\n\t * base. We can only do that when @basej is past base->clk\n\t * otherwise we might rewind base->clk.\n\t */\n\tif (time_after(basej, base->clk)) {\n\t\tif (time_after(nextevt, basej))\n\t\t\tbase->clk = basej;\n\t\telse if (time_after(nextevt, base->clk))\n\t\t\tbase->clk = nextevt;\n\t}\n\n\tif (time_before_eq(nextevt, basej)) {\n\t\texpires = basem;\n\t\tbase->is_idle = false;\n\t} else {\n\t\tif (!is_max_delta)\n\t\t\texpires = basem + (u64)(nextevt - basej) * TICK_NSEC;\n\t\t/*\n\t\t * If we expect to sleep more than a tick, mark the base idle.\n\t\t * Also the tick is stopped so any added timer must forward\n\t\t * the base clk itself to keep granularity small. This idle\n\t\t * logic is only maintained for the BASE_STD base, deferrable\n\t\t * timers may still see large granularity skew (by design).\n\t\t */\n\t\tif ((expires - basem) > TICK_NSEC) {\n\t\t\tbase->must_forward_clk = true;\n\t\t\tbase->is_idle = true;\n\t\t}\n\t}\n\traw_spin_unlock(&base->lock);\n\n\treturn cmp_next_hrtimer_event(basem, expires);\n}"
  },
  {
    "function_name": "cmp_next_hrtimer_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1482-1509",
    "snippet": "static u64 cmp_next_hrtimer_event(u64 basem, u64 expires)\n{\n\tu64 nextevt = hrtimer_get_next_event();\n\n\t/*\n\t * If high resolution timers are enabled\n\t * hrtimer_get_next_event() returns KTIME_MAX.\n\t */\n\tif (expires <= nextevt)\n\t\treturn expires;\n\n\t/*\n\t * If the next timer is already expired, return the tick base\n\t * time so the tick is fired immediately.\n\t */\n\tif (nextevt <= basem)\n\t\treturn basem;\n\n\t/*\n\t * Round up to the next jiffie. High resolution timers are\n\t * off, so the hrtimers are expired in the tick and we need to\n\t * make sure that this tick really expires the timer to avoid\n\t * a ping pong of the nohz stop code.\n\t *\n\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3\n\t */\n\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "__visible u64"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "DIV_ROUND_UP_ULL",
          "args": [
            "nextevt",
            "TICK_NSEC"
          ],
          "line": 1508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_get_next_event",
          "args": [],
          "line": 1484
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_get_next_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "1206-1220",
          "snippet": "u64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [
            "#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)"
          ],
          "globals_used": [
            "DEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\n#define HRTIMER_ACTIVE_ALL\t(HRTIMER_ACTIVE_SOFT | HRTIMER_ACTIVE_HARD)\n\nDEFINE_PER_CPU(struct hrtimer_cpu_base, hrtimer_bases) =\n{\n\t.lock = __RAW_SPIN_LOCK_UNLOCKED(hrtimer_bases.lock),\n\t.clock_base =\n\t{\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_MONOTONIC_SOFT,\n\t\t\t.clockid = CLOCK_MONOTONIC,\n\t\t\t.get_time = &ktime_get,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_REALTIME_SOFT,\n\t\t\t.clockid = CLOCK_REALTIME,\n\t\t\t.get_time = &ktime_get_real,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_BOOTTIME_SOFT,\n\t\t\t.clockid = CLOCK_BOOTTIME,\n\t\t\t.get_time = &ktime_get_boottime,\n\t\t},\n\t\t{\n\t\t\t.index = HRTIMER_BASE_TAI_SOFT,\n\t\t\t.clockid = CLOCK_TAI,\n\t\t\t.get_time = &ktime_get_clocktai,\n\t\t},\n\t}\n};\n\nu64 hrtimer_get_next_event(void)\n{\n\tstruct hrtimer_cpu_base *cpu_base = this_cpu_ptr(&hrtimer_bases);\n\tu64 expires = KTIME_MAX;\n\tunsigned long flags;\n\n\traw_spin_lock_irqsave(&cpu_base->lock, flags);\n\n\tif (!__hrtimer_hres_active(cpu_base))\n\t\texpires = __hrtimer_get_next_event(cpu_base, HRTIMER_ACTIVE_ALL);\n\n\traw_spin_unlock_irqrestore(&cpu_base->lock, flags);\n\n\treturn expires;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\n\nstatic u64 cmp_next_hrtimer_event(u64 basem, u64 expires)\n{\n\tu64 nextevt = hrtimer_get_next_event();\n\n\t/*\n\t * If high resolution timers are enabled\n\t * hrtimer_get_next_event() returns KTIME_MAX.\n\t */\n\tif (expires <= nextevt)\n\t\treturn expires;\n\n\t/*\n\t * If the next timer is already expired, return the tick base\n\t * time so the tick is fired immediately.\n\t */\n\tif (nextevt <= basem)\n\t\treturn basem;\n\n\t/*\n\t * Round up to the next jiffie. High resolution timers are\n\t * off, so the hrtimers are expired in the tick and we need to\n\t * make sure that this tick really expires the timer to avoid\n\t * a ping pong of the nohz stop code.\n\t *\n\t * Use DIV_ROUND_UP_ULL to prevent gcc calling __divdi3\n\t */\n\treturn DIV_ROUND_UP_ULL(nextevt, TICK_NSEC) * TICK_NSEC;\n}"
  },
  {
    "function_name": "__next_timer_interrupt",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1418-1476",
    "snippet": "static unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define LVL_MASK\t(LVL_SIZE - 1)",
      "#define LVL_SIZE\t(1UL << LVL_BITS)",
      "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
      "#define LVL_CLK_SHIFT\t3"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "tmp",
            "next"
          ],
          "line": 1432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_SHIFT",
          "args": [
            "lvl"
          ],
          "line": 1431
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_pending_bucket",
          "args": [
            "base",
            "offset",
            "clk & LVL_MASK"
          ],
          "line": 1426
        },
        "resolved": true,
        "details": {
          "function_name": "next_pending_bucket",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1400-1412",
          "snippet": "static int next_pending_bucket(struct timer_base *base, unsigned offset,\n\t\t\t       unsigned clk)\n{\n\tunsigned pos, start = offset + clk;\n\tunsigned end = offset + LVL_SIZE;\n\n\tpos = find_next_bit(base->pending_map, end, start);\n\tif (pos < end)\n\t\treturn pos - start;\n\n\tpos = find_next_bit(base->pending_map, start, offset);\n\treturn pos < start ? pos + LVL_SIZE - start : -1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_SIZE\t(1UL << LVL_BITS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_SIZE\t(1UL << LVL_BITS)\n\nstatic int next_pending_bucket(struct timer_base *base, unsigned offset,\n\t\t\t       unsigned clk)\n{\n\tunsigned pos, start = offset + clk;\n\tunsigned end = offset + LVL_SIZE;\n\n\tpos = find_next_bit(base->pending_map, end, start);\n\tif (pos < end)\n\t\treturn pos - start;\n\n\tpos = find_next_bit(base->pending_map, start, offset);\n\treturn pos < start ? pos + LVL_SIZE - start : -1;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstatic unsigned long __next_timer_interrupt(struct timer_base *base)\n{\n\tunsigned long clk, next, adj;\n\tunsigned lvl, offset = 0;\n\n\tnext = base->clk + NEXT_TIMER_MAX_DELTA;\n\tclk = base->clk;\n\tfor (lvl = 0; lvl < LVL_DEPTH; lvl++, offset += LVL_SIZE) {\n\t\tint pos = next_pending_bucket(base, offset, clk & LVL_MASK);\n\n\t\tif (pos >= 0) {\n\t\t\tunsigned long tmp = clk + (unsigned long) pos;\n\n\t\t\ttmp <<= LVL_SHIFT(lvl);\n\t\t\tif (time_before(tmp, next))\n\t\t\t\tnext = tmp;\n\t\t}\n\t\t/*\n\t\t * Clock for the next level. If the current level clock lower\n\t\t * bits are zero, we look at the next level as is. If not we\n\t\t * need to advance it by one because that's going to be the\n\t\t * next expiring bucket in that level. base->clk is the next\n\t\t * expiring jiffie. So in case of:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    0\n\t\t *\n\t\t * we have to look at all levels @index 0. With\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    0    2\n\t\t *\n\t\t * LVL0 has the next expiring bucket @index 2. The upper\n\t\t * levels have the next expiring bucket @index 1.\n\t\t *\n\t\t * In case that the propagation wraps the next level the same\n\t\t * rules apply:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1 LVL0\n\t\t *  0    0    0    0    F    2\n\t\t *\n\t\t * So after looking at LVL0 we get:\n\t\t *\n\t\t * LVL5 LVL4 LVL3 LVL2 LVL1\n\t\t *  0    0    0    1    0\n\t\t *\n\t\t * So no propagation from LVL1 to LVL2 because that happened\n\t\t * with the add already, but then we need to propagate further\n\t\t * from LVL2 to LVL3.\n\t\t *\n\t\t * So the simple check whether the lower bits of the current\n\t\t * level are 0 or not is sufficient for all cases.\n\t\t */\n\t\tadj = clk & LVL_CLK_MASK ? 1 : 0;\n\t\tclk >>= LVL_CLK_SHIFT;\n\t\tclk += adj;\n\t}\n\treturn next;\n}"
  },
  {
    "function_name": "next_pending_bucket",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1400-1412",
    "snippet": "static int next_pending_bucket(struct timer_base *base, unsigned offset,\n\t\t\t       unsigned clk)\n{\n\tunsigned pos, start = offset + clk;\n\tunsigned end = offset + LVL_SIZE;\n\n\tpos = find_next_bit(base->pending_map, end, start);\n\tif (pos < end)\n\t\treturn pos - start;\n\n\tpos = find_next_bit(base->pending_map, start, offset);\n\treturn pos < start ? pos + LVL_SIZE - start : -1;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define LVL_SIZE\t(1UL << LVL_BITS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "base->pending_map",
            "start",
            "offset"
          ],
          "line": 1410
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_next_bit",
          "args": [
            "base->pending_map",
            "end",
            "start"
          ],
          "line": 1406
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_SIZE\t(1UL << LVL_BITS)\n\nstatic int next_pending_bucket(struct timer_base *base, unsigned offset,\n\t\t\t       unsigned clk)\n{\n\tunsigned pos, start = offset + clk;\n\tunsigned end = offset + LVL_SIZE;\n\n\tpos = find_next_bit(base->pending_map, end, start);\n\tif (pos < end)\n\t\treturn pos - start;\n\n\tpos = find_next_bit(base->pending_map, start, offset);\n\treturn pos < start ? pos + LVL_SIZE - start : -1;\n}"
  },
  {
    "function_name": "__collect_expired_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1369-1392",
    "snippet": "static int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define LVL_MASK\t(LVL_SIZE - 1)",
      "#define LVL_SIZE\t(1UL << LVL_BITS)",
      "#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)",
      "#define LVL_CLK_SHIFT\t3"
    ],
    "globals_used": [
      "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_move_list",
          "args": [
            "vec",
            "heads++"
          ],
          "line": 1382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__test_and_clear_bit",
          "args": [
            "idx",
            "base->pending_map"
          ],
          "line": 1380
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n#define LVL_SIZE\t(1UL << LVL_BITS)\n#define LVL_CLK_MASK\t(LVL_CLK_DIV - 1)\n#define LVL_CLK_SHIFT\t3\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int __collect_expired_timers(struct timer_base *base,\n\t\t\t\t    struct hlist_head *heads)\n{\n\tunsigned long clk = base->clk;\n\tstruct hlist_head *vec;\n\tint i, levels = 0;\n\tunsigned int idx;\n\n\tfor (i = 0; i < LVL_DEPTH; i++) {\n\t\tidx = (clk & LVL_MASK) + i * LVL_SIZE;\n\n\t\tif (__test_and_clear_bit(idx, base->pending_map)) {\n\t\t\tvec = base->vectors + idx;\n\t\t\thlist_move_list(vec, heads++);\n\t\t\tlevels++;\n\t\t}\n\t\t/* Is it time to look at the next level? */\n\t\tif (clk & LVL_CLK_MASK)\n\t\t\tbreak;\n\t\t/* Shift clock for the next level granularity */\n\t\tclk >>= LVL_CLK_SHIFT;\n\t}\n\treturn levels;\n}"
  },
  {
    "function_name": "expire_timers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1344-1367",
    "snippet": "static void expire_timers(struct timer_base *base, struct hlist_head *head)\n{\n\twhile (!hlist_empty(head)) {\n\t\tstruct timer_list *timer;\n\t\tvoid (*fn)(struct timer_list *);\n\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\n\t\tbase->running_timer = timer;\n\t\tdetach_timer(timer, true);\n\n\t\tfn = timer->function;\n\n\t\tif (timer->flags & TIMER_IRQSAFE) {\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock(&base->lock);\n\t\t} else {\n\t\t\traw_spin_unlock_irq(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock_irq(&base->lock);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_irq",
          "args": [
            "&base->lock"
          ],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_timer_fn",
          "args": [
            "timer",
            "fn"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "call_timer_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1302-1342",
          "snippet": "static void call_timer_fn(struct timer_list *timer, void (*fn)(struct timer_list *))\n{\n\tint count = preempt_count();\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the timer from inside the\n\t * function that is called from it, this we need to take into\n\t * account for lockdep too. To avoid bogus \"held lock freed\"\n\t * warnings as well as problems when looking into\n\t * timer->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\n#endif\n\t/*\n\t * Couple the lock chain with the lock chain at\n\t * del_timer_sync() by acquiring the lock_map around the fn()\n\t * call here and in del_timer_sync().\n\t */\n\tlock_map_acquire(&lockdep_map);\n\n\ttrace_timer_expire_entry(timer);\n\tfn(timer);\n\ttrace_timer_expire_exit(timer);\n\n\tlock_map_release(&lockdep_map);\n\n\tif (count != preempt_count()) {\n\t\tWARN_ONCE(1, \"timer: %pF preempt leak: %08x -> %08x\\n\",\n\t\t\t  fn, count, preempt_count());\n\t\t/*\n\t\t * Restore the preempt count. That gives us a decent\n\t\t * chance to survive and extract information. If the\n\t\t * callback kept a lock held, bad luck, but not worse\n\t\t * than the BUG() we had.\n\t\t */\n\t\tpreempt_count_set(count);\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void call_timer_fn(struct timer_list *timer, void (*fn)(struct timer_list *))\n{\n\tint count = preempt_count();\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the timer from inside the\n\t * function that is called from it, this we need to take into\n\t * account for lockdep too. To avoid bogus \"held lock freed\"\n\t * warnings as well as problems when looking into\n\t * timer->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\n#endif\n\t/*\n\t * Couple the lock chain with the lock chain at\n\t * del_timer_sync() by acquiring the lock_map around the fn()\n\t * call here and in del_timer_sync().\n\t */\n\tlock_map_acquire(&lockdep_map);\n\n\ttrace_timer_expire_entry(timer);\n\tfn(timer);\n\ttrace_timer_expire_exit(timer);\n\n\tlock_map_release(&lockdep_map);\n\n\tif (count != preempt_count()) {\n\t\tWARN_ONCE(1, \"timer: %pF preempt leak: %08x -> %08x\\n\",\n\t\t\t  fn, count, preempt_count());\n\t\t/*\n\t\t * Restore the preempt count. That gives us a decent\n\t\t * chance to survive and extract information. If the\n\t\t * callback kept a lock held, bad luck, but not worse\n\t\t * than the BUG() we had.\n\t\t */\n\t\tpreempt_count_set(count);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irq",
          "args": [
            "&base->lock"
          ],
          "line": 1362
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 1358
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_timer",
          "args": [
            "timer",
            "true"
          ],
          "line": 1353
        },
        "resolved": true,
        "details": {
          "function_name": "detach_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "811-821",
          "snippet": "static inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hlist_entry",
          "args": [
            "head->first",
            "structtimer_list",
            "entry"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_empty",
          "args": [
            "head"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void expire_timers(struct timer_base *base, struct hlist_head *head)\n{\n\twhile (!hlist_empty(head)) {\n\t\tstruct timer_list *timer;\n\t\tvoid (*fn)(struct timer_list *);\n\n\t\ttimer = hlist_entry(head->first, struct timer_list, entry);\n\n\t\tbase->running_timer = timer;\n\t\tdetach_timer(timer, true);\n\n\t\tfn = timer->function;\n\n\t\tif (timer->flags & TIMER_IRQSAFE) {\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock(&base->lock);\n\t\t} else {\n\t\t\traw_spin_unlock_irq(&base->lock);\n\t\t\tcall_timer_fn(timer, fn);\n\t\t\traw_spin_lock_irq(&base->lock);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "call_timer_fn",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1302-1342",
    "snippet": "static void call_timer_fn(struct timer_list *timer, void (*fn)(struct timer_list *))\n{\n\tint count = preempt_count();\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the timer from inside the\n\t * function that is called from it, this we need to take into\n\t * account for lockdep too. To avoid bogus \"held lock freed\"\n\t * warnings as well as problems when looking into\n\t * timer->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\n#endif\n\t/*\n\t * Couple the lock chain with the lock chain at\n\t * del_timer_sync() by acquiring the lock_map around the fn()\n\t * call here and in del_timer_sync().\n\t */\n\tlock_map_acquire(&lockdep_map);\n\n\ttrace_timer_expire_entry(timer);\n\tfn(timer);\n\ttrace_timer_expire_exit(timer);\n\n\tlock_map_release(&lockdep_map);\n\n\tif (count != preempt_count()) {\n\t\tWARN_ONCE(1, \"timer: %pF preempt leak: %08x -> %08x\\n\",\n\t\t\t  fn, count, preempt_count());\n\t\t/*\n\t\t * Restore the preempt count. That gives us a decent\n\t\t * chance to survive and extract information. If the\n\t\t * callback kept a lock held, bad luck, but not worse\n\t\t * than the BUG() we had.\n\t\t */\n\t\tpreempt_count_set(count);\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_count_set",
          "args": [
            "count"
          ],
          "line": 1340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "1",
            "\"timer: %pF preempt leak: %08x -> %08x\\n\"",
            "fn",
            "count",
            "preempt_count()"
          ],
          "line": 1332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 1333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 1331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&lockdep_map"
          ],
          "line": 1329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_timer_expire_exit",
          "args": [
            "timer"
          ],
          "line": 1327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fn",
          "args": [
            "timer"
          ],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "posix_timer_fn",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "364-427",
          "snippet": "static enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nstatic enum hrtimer_restart posix_timer_fn(struct hrtimer *timer)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\tint si_private = 0;\n\tenum hrtimer_restart ret = HRTIMER_NORESTART;\n\n\ttimr = container_of(timer, struct k_itimer, it.real.timer);\n\tspin_lock_irqsave(&timr->it_lock, flags);\n\n\ttimr->it_active = 0;\n\tif (timr->it_interval != 0)\n\t\tsi_private = ++timr->it_requeue_pending;\n\n\tif (posix_timer_event(timr, si_private)) {\n\t\t/*\n\t\t * signal was not sent because of sig_ignor\n\t\t * we will not get a call back to restart it AND\n\t\t * it should be restarted.\n\t\t */\n\t\tif (timr->it_interval != 0) {\n\t\t\tktime_t now = hrtimer_cb_get_time(timer);\n\n\t\t\t/*\n\t\t\t * FIXME: What we really want, is to stop this\n\t\t\t * timer completely and restart it in case the\n\t\t\t * SIG_IGN is removed. This is a non trivial\n\t\t\t * change which involves sighand locking\n\t\t\t * (sigh !), which we don't want to do late in\n\t\t\t * the release cycle.\n\t\t\t *\n\t\t\t * For now we just let timers with an interval\n\t\t\t * less than a jiffie expire every jiffie to\n\t\t\t * avoid softirq starvation in case of SIG_IGN\n\t\t\t * and a very small interval, which would put\n\t\t\t * the timer right back on the softirq pending\n\t\t\t * list. By moving now ahead of time we trick\n\t\t\t * hrtimer_forward() to expire the timer\n\t\t\t * later, while we still maintain the overrun\n\t\t\t * accuracy, but have some inconsistency in\n\t\t\t * the timer_gettime() case. This is at least\n\t\t\t * better than a starved softirq. A more\n\t\t\t * complex fix which solves also another related\n\t\t\t * inconsistency is already in the pipeline.\n\t\t\t */\n#ifdef CONFIG_HIGH_RES_TIMERS\n\t\t\t{\n\t\t\t\tktime_t kj = NSEC_PER_SEC / HZ;\n\n\t\t\t\tif (timr->it_interval < kj)\n\t\t\t\t\tnow = ktime_add(now, kj);\n\t\t\t}\n#endif\n\t\t\ttimr->it_overrun += hrtimer_forward(timer, now,\n\t\t\t\t\t\t\t    timr->it_interval);\n\t\t\tret = HRTIMER_RESTART;\n\t\t\t++timr->it_requeue_pending;\n\t\t\ttimr->it_active = 1;\n\t\t}\n\t}\n\n\tunlock_timer(timr, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_timer_expire_entry",
          "args": [
            "timer"
          ],
          "line": 1325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&lockdep_map"
          ],
          "line": 1323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_copy_map",
          "args": [
            "&lockdep_map",
            "&timer->lockdep_map"
          ],
          "line": 1316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void call_timer_fn(struct timer_list *timer, void (*fn)(struct timer_list *))\n{\n\tint count = preempt_count();\n\n#ifdef CONFIG_LOCKDEP\n\t/*\n\t * It is permissible to free the timer from inside the\n\t * function that is called from it, this we need to take into\n\t * account for lockdep too. To avoid bogus \"held lock freed\"\n\t * warnings as well as problems when looking into\n\t * timer->lockdep_map, make a copy and use that here.\n\t */\n\tstruct lockdep_map lockdep_map;\n\n\tlockdep_copy_map(&lockdep_map, &timer->lockdep_map);\n#endif\n\t/*\n\t * Couple the lock chain with the lock chain at\n\t * del_timer_sync() by acquiring the lock_map around the fn()\n\t * call here and in del_timer_sync().\n\t */\n\tlock_map_acquire(&lockdep_map);\n\n\ttrace_timer_expire_entry(timer);\n\tfn(timer);\n\ttrace_timer_expire_exit(timer);\n\n\tlock_map_release(&lockdep_map);\n\n\tif (count != preempt_count()) {\n\t\tWARN_ONCE(1, \"timer: %pF preempt leak: %08x -> %08x\\n\",\n\t\t\t  fn, count, preempt_count());\n\t\t/*\n\t\t * Restore the preempt count. That gives us a decent\n\t\t * chance to survive and extract information. If the\n\t\t * callback kept a lock held, bad luck, but not worse\n\t\t * than the BUG() we had.\n\t\t */\n\t\tpreempt_count_set(count);\n\t}\n}"
  },
  {
    "function_name": "del_timer_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1273-1298",
    "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_del_timer_sync",
          "args": [
            "timer"
          ],
          "line": 1293
        },
        "resolved": true,
        "details": {
          "function_name": "try_to_del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1217-1233",
          "snippet": "int try_to_del_timer_sync(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tdebug_assert_init(timer);\n\n\tbase = lock_timer_base(timer, &flags);\n\n\tif (base->running_timer != timer)\n\t\tret = detach_if_pending(timer, base, true);\n\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint try_to_del_timer_sync(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tdebug_assert_init(timer);\n\n\tbase = lock_timer_base(timer, &flags);\n\n\tif (base->running_timer != timer)\n\t\tret = detach_if_pending(timer, base, true);\n\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "in_irq() && !(timer->flags & TIMER_IRQSAFE)"
          ],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_irq",
          "args": [],
          "line": 1291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 1285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_release",
          "args": [
            "&timer->lockdep_map"
          ],
          "line": 1284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_map_acquire",
          "args": [
            "&timer->lockdep_map"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 1282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "try_to_del_timer_sync",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1217-1233",
    "snippet": "int try_to_del_timer_sync(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tdebug_assert_init(timer);\n\n\tbase = lock_timer_base(timer, &flags);\n\n\tif (base->running_timer != timer)\n\t\tret = detach_if_pending(timer, base, true);\n\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 1230
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_if_pending",
          "args": [
            "timer",
            "base",
            "true"
          ],
          "line": 1228
        },
        "resolved": true,
        "details": {
          "function_name": "detach_if_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "823-836",
          "snippet": "static int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_timer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1225
        },
        "resolved": true,
        "details": {
          "function_name": "lock_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "921-945",
          "snippet": "static struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_assert_init",
          "args": [
            "timer"
          ],
          "line": 1223
        },
        "resolved": true,
        "details": {
          "function_name": "debug_assert_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "774-777",
          "snippet": "static inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint try_to_del_timer_sync(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = -1;\n\n\tdebug_assert_init(timer);\n\n\tbase = lock_timer_base(timer, &flags);\n\n\tif (base->running_timer != timer)\n\t\tret = detach_if_pending(timer, base, true);\n\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "del_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1192-1207",
    "snippet": "int del_timer(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdebug_assert_init(timer);\n\n\tif (timer_pending(timer)) {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tret = detach_if_pending(timer, base, true);\n\t\traw_spin_unlock_irqrestore(&base->lock, flags);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 1203
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_if_pending",
          "args": [
            "timer",
            "base",
            "true"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "detach_if_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "823-836",
          "snippet": "static int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_timer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1201
        },
        "resolved": true,
        "details": {
          "function_name": "lock_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "921-945",
          "snippet": "static struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 1200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_assert_init",
          "args": [
            "timer"
          ],
          "line": 1198
        },
        "resolved": true,
        "details": {
          "function_name": "debug_assert_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "774-777",
          "snippet": "static inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer(struct timer_list *timer)\n{\n\tstruct timer_base *base;\n\tunsigned long flags;\n\tint ret = 0;\n\n\tdebug_assert_init(timer);\n\n\tif (timer_pending(timer)) {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tret = detach_if_pending(timer, base, true);\n\t\traw_spin_unlock_irqrestore(&base->lock, flags);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "add_timer_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1149-1178",
    "snippet": "void add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 1177
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_add_timer",
          "args": [
            "base",
            "timer"
          ],
          "line": 1176
        },
        "resolved": true,
        "details": {
          "function_name": "internal_add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "587-592",
          "snippet": "static void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_activate",
          "args": [
            "timer",
            "timer->expires"
          ],
          "line": 1175
        },
        "resolved": true,
        "details": {
          "function_name": "debug_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "761-766",
          "snippet": "static inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "forward_timer_base",
          "args": [
            "base"
          ],
          "line": 1173
        },
        "resolved": true,
        "details": {
          "function_name": "forward_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "880-907",
          "snippet": "static inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->flags",
            "(timer->flags & ~TIMER_BASEMASK) | cpu"
          ],
          "line": 1170
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 1169
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 1167
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_timer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "lock_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "921-945",
          "snippet": "static struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_timer_cpu_base",
          "args": [
            "timer->flags",
            "cpu"
          ],
          "line": 1156
        },
        "resolved": true,
        "details": {
          "function_name": "get_timer_cpu_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "838-849",
          "snippet": "static inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "timer_pending(timer) || !timer->function"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 1154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer_on(struct timer_list *timer, int cpu)\n{\n\tstruct timer_base *new_base, *base;\n\tunsigned long flags;\n\n\tBUG_ON(timer_pending(timer) || !timer->function);\n\n\tnew_base = get_timer_cpu_base(timer->flags, cpu);\n\n\t/*\n\t * If @timer was on a different CPU, it should be migrated with the\n\t * old base locked to prevent other operations proceeding with the\n\t * wrong base locked.  See lock_timer_base().\n\t */\n\tbase = lock_timer_base(timer, &flags);\n\tif (base != new_base) {\n\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\traw_spin_unlock(&base->lock);\n\t\tbase = new_base;\n\t\traw_spin_lock(&base->lock);\n\t\tWRITE_ONCE(timer->flags,\n\t\t\t   (timer->flags & ~TIMER_BASEMASK) | cpu);\n\t}\n\tforward_timer_base(base);\n\n\tdebug_activate(timer, timer->expires);\n\tinternal_add_timer(base, timer);\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n}"
  },
  {
    "function_name": "add_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1135-1139",
    "snippet": "void add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\tmod_timer(timer, timer->expires);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mod_timer",
          "args": [
            "timer",
            "timer->expires"
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1100-1103",
          "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "timer_pending(timer)"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 1137
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid add_timer(struct timer_list *timer)\n{\n\tBUG_ON(timer_pending(timer));\n\tmod_timer(timer, timer->expires);\n}"
  },
  {
    "function_name": "timer_reduce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1115-1118",
    "snippet": "int timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define MOD_TIMER_REDUCE\t\t0x02"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_timer",
          "args": [
            "timer",
            "expires",
            "MOD_TIMER_REDUCE"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "950-1062",
          "snippet": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02",
            "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nstatic inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n\nint timer_reduce(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_REDUCE);\n}"
  },
  {
    "function_name": "mod_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1100-1103",
    "snippet": "int mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_timer",
          "args": [
            "timer",
            "expires",
            "0"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "950-1062",
          "snippet": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02",
            "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nstatic inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint mod_timer(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, 0);\n}"
  },
  {
    "function_name": "mod_timer_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "1074-1077",
    "snippet": "int mod_timer_pending(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_PENDING_ONLY);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__mod_timer",
          "args": [
            "timer",
            "expires",
            "MOD_TIMER_PENDING_ONLY"
          ],
          "line": 1076
        },
        "resolved": true,
        "details": {
          "function_name": "__mod_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "950-1062",
          "snippet": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define MOD_TIMER_REDUCE\t\t0x02",
            "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nstatic inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nint mod_timer_pending(struct timer_list *timer, unsigned long expires)\n{\n\treturn __mod_timer(timer, expires, MOD_TIMER_PENDING_ONLY);\n}"
  },
  {
    "function_name": "__mod_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "950-1062",
    "snippet": "static inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define MOD_TIMER_REDUCE\t\t0x02",
      "#define MOD_TIMER_PENDING_ONLY\t\t0x01"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "flags"
          ],
          "line": 1059
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "internal_add_timer",
          "args": [
            "base",
            "timer"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "internal_add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "587-592",
          "snippet": "static void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trigger_dyntick_cpu",
          "args": [
            "base",
            "timer"
          ],
          "line": 1053
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_dyntick_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "551-585",
          "snippet": "static void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "enqueue_timer",
          "args": [
            "base",
            "timer",
            "idx"
          ],
          "line": 1052
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "534-540",
          "snippet": "static void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_activate",
          "args": [
            "timer",
            "expires"
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "debug_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "761-766",
          "snippet": "static inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "forward_timer_base",
          "args": [
            "base"
          ],
          "line": 1037
        },
        "resolved": true,
        "details": {
          "function_name": "forward_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "880-907",
          "snippet": "static inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "WRITE_ONCE",
          "args": [
            "timer->flags",
            "(timer->flags & ~TIMER_BASEMASK) | base->cpu"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&base->lock"
          ],
          "line": 1034
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&base->lock"
          ],
          "line": 1032
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "base->running_timer != timer"
          ],
          "line": 1028
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_target_base",
          "args": [
            "base",
            "timer->flags"
          ],
          "line": 1018
        },
        "resolved": true,
        "details": {
          "function_name": "get_target_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "869-878",
          "snippet": "static inline struct timer_base *\nget_target_base(struct timer_base *base, unsigned tflags)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) &&\n\t    !(tflags & TIMER_PINNED))\n\t\treturn get_timer_cpu_base(tflags, get_nohz_timer_target());\n#endif\n\treturn get_timer_this_cpu_base(tflags);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline struct timer_base *\nget_target_base(struct timer_base *base, unsigned tflags)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) &&\n\t    !(tflags & TIMER_PINNED))\n\t\treturn get_timer_cpu_base(tflags, get_nohz_timer_target());\n#endif\n\treturn get_timer_this_cpu_base(tflags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "detach_if_pending",
          "args": [
            "timer",
            "base",
            "false"
          ],
          "line": 1014
        },
        "resolved": true,
        "details": {
          "function_name": "detach_if_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "823-836",
          "snippet": "static int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_timer_base",
          "args": [
            "timer",
            "&flags"
          ],
          "line": 1010
        },
        "resolved": true,
        "details": {
          "function_name": "lock_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "921-945",
          "snippet": "static struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "timer->expires",
            "expires"
          ],
          "line": 1004
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_get_idx",
          "args": [
            "timer"
          ],
          "line": 1001
        },
        "resolved": true,
        "details": {
          "function_name": "timer_get_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "473-476",
          "snippet": "static inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_wheel_index",
          "args": [
            "expires",
            "clk"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "calc_wheel_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "494-528",
          "snippet": "static int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))",
            "#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))",
            "#define LVL_MASK\t(LVL_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))\n#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))\n#define LVL_MASK\t(LVL_SIZE - 1)\n\nstatic int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before_eq",
          "args": [
            "timer->expires",
            "expires"
          ],
          "line": 988
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 987
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 965
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!timer->function"
          ],
          "line": 958
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define MOD_TIMER_REDUCE\t\t0x02\n#define MOD_TIMER_PENDING_ONLY\t\t0x01\n\nstatic inline int\n__mod_timer(struct timer_list *timer, unsigned long expires, unsigned int options)\n{\n\tstruct timer_base *base, *new_base;\n\tunsigned int idx = UINT_MAX;\n\tunsigned long clk = 0, flags;\n\tint ret = 0;\n\n\tBUG_ON(!timer->function);\n\n\t/*\n\t * This is a common optimization triggered by the networking code - if\n\t * the timer is re-modified to have the same timeout or ends up in the\n\t * same array bucket then just return:\n\t */\n\tif (timer_pending(timer)) {\n\t\t/*\n\t\t * The downside of this optimization is that it can result in\n\t\t * larger granularity than you would get from adding a new\n\t\t * timer with this expiry.\n\t\t */\n\t\tlong diff = timer->expires - expires;\n\n\t\tif (!diff)\n\t\t\treturn 1;\n\t\tif (options & MOD_TIMER_REDUCE && diff <= 0)\n\t\t\treturn 1;\n\n\t\t/*\n\t\t * We lock timer base and calculate the bucket index right\n\t\t * here. If the timer ends up in the same bucket, then we\n\t\t * just update the expiry time and avoid the whole\n\t\t * dequeue/enqueue dance.\n\t\t */\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\n\t\tif (timer_pending(timer) && (options & MOD_TIMER_REDUCE) &&\n\t\t    time_before_eq(timer->expires, expires)) {\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tclk = base->clk;\n\t\tidx = calc_wheel_index(expires, clk);\n\n\t\t/*\n\t\t * Retrieve and compare the array index of the pending\n\t\t * timer. If it matches set the expiry to the new value so a\n\t\t * subsequent call will exit in the expires check above.\n\t\t */\n\t\tif (idx == timer_get_idx(timer)) {\n\t\t\tif (!(options & MOD_TIMER_REDUCE))\n\t\t\t\ttimer->expires = expires;\n\t\t\telse if (time_after(timer->expires, expires))\n\t\t\t\ttimer->expires = expires;\n\t\t\tret = 1;\n\t\t\tgoto out_unlock;\n\t\t}\n\t} else {\n\t\tbase = lock_timer_base(timer, &flags);\n\t\tforward_timer_base(base);\n\t}\n\n\tret = detach_if_pending(timer, base, false);\n\tif (!ret && (options & MOD_TIMER_PENDING_ONLY))\n\t\tgoto out_unlock;\n\n\tnew_base = get_target_base(base, timer->flags);\n\n\tif (base != new_base) {\n\t\t/*\n\t\t * We are trying to schedule the timer on the new base.\n\t\t * However we can't change timer's base while it is running,\n\t\t * otherwise del_timer_sync() can't detect that the timer's\n\t\t * handler yet has not finished. This also guarantees that the\n\t\t * timer is serialized wrt itself.\n\t\t */\n\t\tif (likely(base->running_timer != timer)) {\n\t\t\t/* See the comment in lock_timer_base() */\n\t\t\ttimer->flags |= TIMER_MIGRATING;\n\n\t\t\traw_spin_unlock(&base->lock);\n\t\t\tbase = new_base;\n\t\t\traw_spin_lock(&base->lock);\n\t\t\tWRITE_ONCE(timer->flags,\n\t\t\t\t   (timer->flags & ~TIMER_BASEMASK) | base->cpu);\n\t\t\tforward_timer_base(base);\n\t\t}\n\t}\n\n\tdebug_activate(timer, expires);\n\n\ttimer->expires = expires;\n\t/*\n\t * If 'idx' was calculated above and the base time did not advance\n\t * between calculating 'idx' and possibly switching the base, only\n\t * enqueue_timer() and trigger_dyntick_cpu() is required. Otherwise\n\t * we need to (re)calculate the wheel index via\n\t * internal_add_timer().\n\t */\n\tif (idx != UINT_MAX && clk == base->clk) {\n\t\tenqueue_timer(base, timer, idx);\n\t\ttrigger_dyntick_cpu(base, timer);\n\t} else {\n\t\tinternal_add_timer(base, timer);\n\t}\n\nout_unlock:\n\traw_spin_unlock_irqrestore(&base->lock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "lock_timer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "921-945",
    "snippet": "static struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&base->lock",
            "*flags"
          ],
          "line": 941
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&base->lock",
            "*flags"
          ],
          "line": 938
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_timer_base",
          "args": [
            "tf"
          ],
          "line": 937
        },
        "resolved": true,
        "details": {
          "function_name": "get_timer_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "864-867",
          "snippet": "static inline struct timer_base *get_timer_base(u32 tflags)\n{\n\treturn get_timer_cpu_base(tflags, tflags & TIMER_CPUMASK);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline struct timer_base *get_timer_base(u32 tflags)\n{\n\treturn get_timer_cpu_base(tflags, tflags & TIMER_CPUMASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "timer->flags"
          ],
          "line": 934
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "timer->base->lock"
          ],
          "line": 923
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic struct timer_base *lock_timer_base(struct timer_list *timer,\n\t\t\t\t\t  unsigned long *flags)\n\t__acquires(timer->base->lock)\n{\n\tfor (;;) {\n\t\tstruct timer_base *base;\n\t\tu32 tf;\n\n\t\t/*\n\t\t * We need to use READ_ONCE() here, otherwise the compiler\n\t\t * might re-read @tf between the check for TIMER_MIGRATING\n\t\t * and spin_lock().\n\t\t */\n\t\ttf = READ_ONCE(timer->flags);\n\n\t\tif (!(tf & TIMER_MIGRATING)) {\n\t\t\tbase = get_timer_base(tf);\n\t\t\traw_spin_lock_irqsave(&base->lock, *flags);\n\t\t\tif (timer->flags == tf)\n\t\t\t\treturn base;\n\t\t\traw_spin_unlock_irqrestore(&base->lock, *flags);\n\t\t}\n\t\tcpu_relax();\n\t}\n}"
  },
  {
    "function_name": "forward_timer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "880-907",
    "snippet": "static inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "base->next_expiry",
            "jnow"
          ],
          "line": 902
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "READ_ONCE",
          "args": [
            "jiffies"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!base->must_forward_clk"
          ],
          "line": 890
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void forward_timer_base(struct timer_base *base)\n{\n#ifdef CONFIG_NO_HZ_COMMON\n\tunsigned long jnow;\n\n\t/*\n\t * We only forward the base when we are idle or have just come out of\n\t * idle (must_forward_clk logic), and have a delta between base clock\n\t * and jiffies. In the common case, run_timers will take care of it.\n\t */\n\tif (likely(!base->must_forward_clk))\n\t\treturn;\n\n\tjnow = READ_ONCE(jiffies);\n\tbase->must_forward_clk = base->is_idle;\n\tif ((long)(jnow - base->clk) < 2)\n\t\treturn;\n\n\t/*\n\t * If the next expiry value is > jiffies, then we fast forward to\n\t * jiffies otherwise we forward to the next expiry value.\n\t */\n\tif (time_after(base->next_expiry, jnow))\n\t\tbase->clk = jnow;\n\telse\n\t\tbase->clk = base->next_expiry;\n#endif\n}"
  },
  {
    "function_name": "get_target_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "869-878",
    "snippet": "static inline struct timer_base *\nget_target_base(struct timer_base *base, unsigned tflags)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) &&\n\t    !(tflags & TIMER_PINNED))\n\t\treturn get_timer_cpu_base(tflags, get_nohz_timer_target());\n#endif\n\treturn get_timer_this_cpu_base(tflags);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_timer_this_cpu_base",
          "args": [
            "tflags"
          ],
          "line": 877
        },
        "resolved": true,
        "details": {
          "function_name": "get_timer_this_cpu_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "851-862",
          "snippet": "static inline struct timer_base *get_timer_this_cpu_base(u32 tflags)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = this_cpu_ptr(&timer_bases[BASE_DEF]);\n\treturn base;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_this_cpu_base(u32 tflags)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = this_cpu_ptr(&timer_bases[BASE_DEF]);\n\treturn base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_timer_cpu_base",
          "args": [
            "tflags",
            "get_nohz_timer_target()"
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "get_timer_cpu_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "838-849",
          "snippet": "static inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_nohz_timer_target",
          "args": [],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "get_nohz_timer_target",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "497-523",
          "snippet": "int get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint get_nohz_timer_target(void)\n{\n\tint i, cpu = smp_processor_id();\n\tstruct sched_domain *sd;\n\n\tif (!idle_cpu(cpu) && housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\treturn cpu;\n\n\trcu_read_lock();\n\tfor_each_domain(cpu, sd) {\n\t\tfor_each_cpu(i, sched_domain_span(sd)) {\n\t\t\tif (cpu == i)\n\t\t\t\tcontinue;\n\n\t\t\tif (!idle_cpu(i) && housekeeping_cpu(i, HK_FLAG_TIMER)) {\n\t\t\t\tcpu = i;\n\t\t\t\tgoto unlock;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!housekeeping_cpu(cpu, HK_FLAG_TIMER))\n\t\tcpu = housekeeping_any_cpu(HK_FLAG_TIMER);\nunlock:\n\trcu_read_unlock();\n\treturn cpu;\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&timers_migration_enabled"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline struct timer_base *\nget_target_base(struct timer_base *base, unsigned tflags)\n{\n#if defined(CONFIG_SMP) && defined(CONFIG_NO_HZ_COMMON)\n\tif (static_branch_likely(&timers_migration_enabled) &&\n\t    !(tflags & TIMER_PINNED))\n\t\treturn get_timer_cpu_base(tflags, get_nohz_timer_target());\n#endif\n\treturn get_timer_this_cpu_base(tflags);\n}"
  },
  {
    "function_name": "get_timer_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "864-867",
    "snippet": "static inline struct timer_base *get_timer_base(u32 tflags)\n{\n\treturn get_timer_cpu_base(tflags, tflags & TIMER_CPUMASK);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_timer_cpu_base",
          "args": [
            "tflags",
            "tflags & TIMER_CPUMASK"
          ],
          "line": 866
        },
        "resolved": true,
        "details": {
          "function_name": "get_timer_cpu_base",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "838-849",
          "snippet": "static inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline struct timer_base *get_timer_base(u32 tflags)\n{\n\treturn get_timer_cpu_base(tflags, tflags & TIMER_CPUMASK);\n}"
  },
  {
    "function_name": "get_timer_this_cpu_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "851-862",
    "snippet": "static inline struct timer_base *get_timer_this_cpu_base(u32 tflags)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = this_cpu_ptr(&timer_bases[BASE_DEF]);\n\treturn base;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_DEF]"
          ],
          "line": 860
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_COMMON"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_this_cpu_base(u32 tflags)\n{\n\tstruct timer_base *base = this_cpu_ptr(&timer_bases[BASE_STD]);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = this_cpu_ptr(&timer_bases[BASE_DEF]);\n\treturn base;\n}"
  },
  {
    "function_name": "get_timer_cpu_base",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "838-849",
    "snippet": "static inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&timer_bases[BASE_DEF]",
            "cpu"
          ],
          "line": 847
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_NO_HZ_COMMON"
          ],
          "line": 846
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu_ptr",
          "args": [
            "&timer_bases[BASE_STD]",
            "cpu"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic DEFINE_PER_CPU(struct timer_base, timer_bases[NR_BASES]);\n\nstatic inline struct timer_base *get_timer_cpu_base(u32 tflags, u32 cpu)\n{\n\tstruct timer_base *base = per_cpu_ptr(&timer_bases[BASE_STD], cpu);\n\n\t/*\n\t * If the timer is deferrable and NO_HZ_COMMON is set then we need\n\t * to use the deferrable base.\n\t */\n\tif (IS_ENABLED(CONFIG_NO_HZ_COMMON) && (tflags & TIMER_DEFERRABLE))\n\t\tbase = per_cpu_ptr(&timer_bases[BASE_DEF], cpu);\n\treturn base;\n}"
  },
  {
    "function_name": "detach_if_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "823-836",
    "snippet": "static int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "detach_timer",
          "args": [
            "timer",
            "clear_pending"
          ],
          "line": 834
        },
        "resolved": true,
        "details": {
          "function_name": "detach_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "811-821",
          "snippet": "static inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__clear_bit",
          "args": [
            "idx",
            "base->pending_map"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_is_singular_node",
          "args": [
            "&timer->entry",
            "base->vectors + idx"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_pending",
          "args": [
            "timer"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_get_idx",
          "args": [
            "timer"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "timer_get_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "473-476",
          "snippet": "static inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic int detach_if_pending(struct timer_list *timer, struct timer_base *base,\n\t\t\t     bool clear_pending)\n{\n\tunsigned idx = timer_get_idx(timer);\n\n\tif (!timer_pending(timer))\n\t\treturn 0;\n\n\tif (hlist_is_singular_node(&timer->entry, base->vectors + idx))\n\t\t__clear_bit(idx, base->pending_map);\n\n\tdetach_timer(timer, clear_pending);\n\treturn 1;\n}"
  },
  {
    "function_name": "detach_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "811-821",
    "snippet": "static inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__hlist_del",
          "args": [
            "entry"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_deactivate",
          "args": [
            "timer"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "debug_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "768-772",
          "snippet": "static inline void debug_deactivate(struct timer_list *timer)\n{\n\tdebug_timer_deactivate(timer);\n\ttrace_timer_cancel(timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_deactivate(struct timer_list *timer)\n{\n\tdebug_timer_deactivate(timer);\n\ttrace_timer_cancel(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void detach_timer(struct timer_list *timer, bool clear_pending)\n{\n\tstruct hlist_node *entry = &timer->entry;\n\n\tdebug_deactivate(timer);\n\n\t__hlist_del(entry);\n\tif (clear_pending)\n\t\tentry->pprev = NULL;\n\tentry->next = LIST_POISON2;\n}"
  },
  {
    "function_name": "init_timer_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "802-808",
    "snippet": "void init_timer_key(struct timer_list *timer,\n\t\t    void (*func)(struct timer_list *), unsigned int flags,\n\t\t    const char *name, struct lock_class_key *key)\n{\n\tdebug_init(timer);\n\tdo_init_timer(timer, func, flags, name, key);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_init_timer",
          "args": [
            "timer",
            "func",
            "flags",
            "name",
            "key"
          ],
          "line": 807
        },
        "resolved": true,
        "details": {
          "function_name": "do_init_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "779-788",
          "snippet": "static void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_init",
          "args": [
            "timer"
          ],
          "line": 806
        },
        "resolved": true,
        "details": {
          "function_name": "debug_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "755-759",
          "snippet": "static inline void debug_init(struct timer_list *timer)\n{\n\tdebug_timer_init(timer);\n\ttrace_timer_init(timer);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_init(struct timer_list *timer)\n{\n\tdebug_timer_init(timer);\n\ttrace_timer_init(timer);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid init_timer_key(struct timer_list *timer,\n\t\t    void (*func)(struct timer_list *), unsigned int flags,\n\t\t    const char *name, struct lock_class_key *key)\n{\n\tdebug_init(timer);\n\tdo_init_timer(timer, func, flags, name, key);\n}"
  },
  {
    "function_name": "do_init_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "779-788",
    "snippet": "static void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_init_map",
          "args": [
            "&timer->lockdep_map",
            "name",
            "key",
            "0"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_init_map",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "3148-3152",
          "snippet": "void lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_init_map(struct lockdep_map *lock, const char *name,\n\t\t      struct lock_class_key *key, int subclass)\n{\n\t__lockdep_init_map(lock, name, key, subclass);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}"
  },
  {
    "function_name": "debug_assert_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "774-777",
    "snippet": "static inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_timer_assert_init",
          "args": [
            "timer"
          ],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "debug_timer_assert_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "752-752",
          "snippet": "static inline void debug_timer_assert_init(struct timer_list *timer) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_assert_init(struct timer_list *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_assert_init(struct timer_list *timer)\n{\n\tdebug_timer_assert_init(timer);\n}"
  },
  {
    "function_name": "debug_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "768-772",
    "snippet": "static inline void debug_deactivate(struct timer_list *timer)\n{\n\tdebug_timer_deactivate(timer);\n\ttrace_timer_cancel(timer);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_timer_cancel",
          "args": [
            "timer"
          ],
          "line": 771
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_timer_deactivate",
          "args": [
            "timer"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "debug_timer_deactivate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "751-751",
          "snippet": "static inline void debug_timer_deactivate(struct timer_list *timer) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_deactivate(struct timer_list *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_deactivate(struct timer_list *timer)\n{\n\tdebug_timer_deactivate(timer);\n\ttrace_timer_cancel(timer);\n}"
  },
  {
    "function_name": "debug_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "761-766",
    "snippet": "static inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_timer_start",
          "args": [
            "timer",
            "expires",
            "timer->flags"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_timer_activate",
          "args": [
            "timer"
          ],
          "line": 764
        },
        "resolved": true,
        "details": {
          "function_name": "debug_timer_activate",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "750-750",
          "snippet": "static inline void debug_timer_activate(struct timer_list *timer) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_activate(struct timer_list *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void\ndebug_activate(struct timer_list *timer, unsigned long expires)\n{\n\tdebug_timer_activate(timer);\n\ttrace_timer_start(timer, expires, timer->flags);\n}"
  },
  {
    "function_name": "debug_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "755-759",
    "snippet": "static inline void debug_init(struct timer_list *timer)\n{\n\tdebug_timer_init(timer);\n\ttrace_timer_init(timer);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_timer_init",
          "args": [
            "timer"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "debug_timer_init",
          "args": [
            "timer"
          ],
          "line": 757
        },
        "resolved": true,
        "details": {
          "function_name": "debug_timer_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "749-749",
          "snippet": "static inline void debug_timer_init(struct timer_list *timer) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_init(struct timer_list *timer) { }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_init(struct timer_list *timer)\n{\n\tdebug_timer_init(timer);\n\ttrace_timer_init(timer);\n}"
  },
  {
    "function_name": "debug_timer_assert_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "752-752",
    "snippet": "static inline void debug_timer_assert_init(struct timer_list *timer) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_assert_init(struct timer_list *timer) { }"
  },
  {
    "function_name": "debug_timer_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "751-751",
    "snippet": "static inline void debug_timer_deactivate(struct timer_list *timer) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_deactivate(struct timer_list *timer) { }"
  },
  {
    "function_name": "debug_timer_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "750-750",
    "snippet": "static inline void debug_timer_activate(struct timer_list *timer) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_activate(struct timer_list *timer) { }"
  },
  {
    "function_name": "debug_timer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "749-749",
    "snippet": "static inline void debug_timer_init(struct timer_list *timer) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_init(struct timer_list *timer) { }"
  },
  {
    "function_name": "destroy_timer_on_stack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "742-745",
    "snippet": "void destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid destroy_timer_on_stack(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "init_timer_on_stack_key",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "732-739",
    "snippet": "void init_timer_on_stack_key(struct timer_list *timer,\n\t\t\t     void (*func)(struct timer_list *),\n\t\t\t     unsigned int flags,\n\t\t\t     const char *name, struct lock_class_key *key)\n{\n\tdebug_object_init_on_stack(timer, &timer_debug_descr);\n\tdo_init_timer(timer, func, flags, name, key);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_init_timer",
          "args": [
            "timer",
            "func",
            "flags",
            "name",
            "key"
          ],
          "line": 738
        },
        "resolved": true,
        "details": {
          "function_name": "do_init_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "779-788",
          "snippet": "static void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void do_init_timer(struct timer_list *timer,\n\t\t\t  void (*func)(struct timer_list *),\n\t\t\t  unsigned int flags,\n\t\t\t  const char *name, struct lock_class_key *key)\n{\n\ttimer->entry.pprev = NULL;\n\ttimer->function = func;\n\ttimer->flags = flags | raw_smp_processor_id();\n\tlockdep_init_map(&timer->lockdep_map, name, key, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "debug_object_init_on_stack",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid init_timer_on_stack_key(struct timer_list *timer,\n\t\t\t     void (*func)(struct timer_list *),\n\t\t\t     unsigned int flags,\n\t\t\t     const char *name, struct lock_class_key *key)\n{\n\tdebug_object_init_on_stack(timer, &timer_debug_descr);\n\tdo_init_timer(timer, func, flags, name, key);\n}"
  },
  {
    "function_name": "debug_timer_assert_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "722-725",
    "snippet": "static inline void debug_timer_assert_init(struct timer_list *timer)\n{\n\tdebug_object_assert_init(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_assert_init",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_assert_init(struct timer_list *timer)\n{\n\tdebug_object_assert_init(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "debug_timer_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "717-720",
    "snippet": "static inline void debug_timer_free(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 719
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_free(struct timer_list *timer)\n{\n\tdebug_object_free(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "debug_timer_deactivate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "712-715",
    "snippet": "static inline void debug_timer_deactivate(struct timer_list *timer)\n{\n\tdebug_object_deactivate(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_deactivate",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_deactivate(struct timer_list *timer)\n{\n\tdebug_object_deactivate(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "debug_timer_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "707-710",
    "snippet": "static inline void debug_timer_activate(struct timer_list *timer)\n{\n\tdebug_object_activate(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_activate",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_activate(struct timer_list *timer)\n{\n\tdebug_object_activate(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "debug_timer_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "702-705",
    "snippet": "static inline void debug_timer_init(struct timer_list *timer)\n{\n\tdebug_object_init(timer, &timer_debug_descr);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void debug_timer_init(struct timer_list *timer)\n{\n\tdebug_object_init(timer, &timer_debug_descr);\n}"
  },
  {
    "function_name": "timer_fixup_assert_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "679-690",
    "snippet": "static bool timer_fixup_assert_init(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_NOTAVAILABLE:\n\t\ttimer_setup(timer, stub_timer, 0);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "timer",
            "stub_timer",
            "0"
          ],
          "line": 685
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic bool timer_fixup_assert_init(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_NOTAVAILABLE:\n\t\ttimer_setup(timer, stub_timer, 0);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "timer_fixup_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "661-673",
    "snippet": "static bool timer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tdel_timer_sync(timer);\n\t\tdebug_object_free(timer, &timer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_free",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "timer"
          ],
          "line": 667
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic bool timer_fixup_free(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tdel_timer_sync(timer);\n\t\tdebug_object_free(timer, &timer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "timer_fixup_activate",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "640-655",
    "snippet": "static bool timer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_NOTAVAILABLE:\n\t\ttimer_setup(timer, stub_timer, 0);\n\t\treturn true;\n\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timer_setup",
          "args": [
            "timer",
            "stub_timer",
            "0"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic bool timer_fixup_activate(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_NOTAVAILABLE:\n\t\ttimer_setup(timer, stub_timer, 0);\n\t\treturn true;\n\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tWARN_ON(1);\n\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "stub_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "630-633",
    "snippet": "static void stub_timer(struct timer_list *unused)\n{\n\tWARN_ON(1);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "1"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void stub_timer(struct timer_list *unused)\n{\n\tWARN_ON(1);\n}"
  },
  {
    "function_name": "timer_fixup_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "615-627",
    "snippet": "static bool timer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tdel_timer_sync(timer);\n\t\tdebug_object_init(timer, &timer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_object_init",
          "args": [
            "timer",
            "&timer_debug_descr"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "del_timer_sync",
          "args": [
            "timer"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "del_timer_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1273-1298",
          "snippet": "int del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint del_timer_sync(struct timer_list *timer)\n{\n#ifdef CONFIG_LOCKDEP\n\tunsigned long flags;\n\n\t/*\n\t * If lockdep gives a backtrace here, please reference\n\t * the synchronization rules above.\n\t */\n\tlocal_irq_save(flags);\n\tlock_map_acquire(&timer->lockdep_map);\n\tlock_map_release(&timer->lockdep_map);\n\tlocal_irq_restore(flags);\n#endif\n\t/*\n\t * don't use it in hardirq context, because it\n\t * could lead to deadlock.\n\t */\n\tWARN_ON(in_irq() && !(timer->flags & TIMER_IRQSAFE));\n\tfor (;;) {\n\t\tint ret = try_to_del_timer_sync(timer);\n\t\tif (ret >= 0)\n\t\t\treturn ret;\n\t\tcpu_relax();\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic bool timer_fixup_init(void *addr, enum debug_obj_state state)\n{\n\tstruct timer_list *timer = addr;\n\n\tswitch (state) {\n\tcase ODEBUG_STATE_ACTIVE:\n\t\tdel_timer_sync(timer);\n\t\tdebug_object_init(timer, &timer_debug_descr);\n\t\treturn true;\n\tdefault:\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "timer_is_static_object",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "603-609",
    "snippet": "static bool timer_is_static_object(void *addr)\n{\n\tstruct timer_list *timer = addr;\n\n\treturn (timer->entry.pprev == NULL &&\n\t\ttimer->entry.next == TIMER_ENTRY_STATIC);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic bool timer_is_static_object(void *addr)\n{\n\tstruct timer_list *timer = addr;\n\n\treturn (timer->entry.pprev == NULL &&\n\t\ttimer->entry.next == TIMER_ENTRY_STATIC);\n}"
  },
  {
    "function_name": "timer_debug_hint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "598-601",
    "snippet": "static void *timer_debug_hint(void *addr)\n{\n\treturn ((struct timer_list *) addr)->function;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void *timer_debug_hint(void *addr)\n{\n\treturn ((struct timer_list *) addr)->function;\n}"
  },
  {
    "function_name": "internal_add_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "587-592",
    "snippet": "static void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trigger_dyntick_cpu",
          "args": [
            "base",
            "timer"
          ],
          "line": 591
        },
        "resolved": true,
        "details": {
          "function_name": "trigger_dyntick_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "551-585",
          "snippet": "static void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__internal_add_timer",
          "args": [
            "base",
            "timer"
          ],
          "line": 590
        },
        "resolved": true,
        "details": {
          "function_name": "__internal_add_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "542-549",
          "snippet": "static void\n__internal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\tunsigned int idx;\n\n\tidx = calc_wheel_index(timer->expires, base->clk);\n\tenqueue_timer(base, timer, idx);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\n__internal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\tunsigned int idx;\n\n\tidx = calc_wheel_index(timer->expires, base->clk);\n\tenqueue_timer(base, timer, idx);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ninternal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\t__internal_add_timer(base, timer);\n\ttrigger_dyntick_cpu(base, timer);\n}"
  },
  {
    "function_name": "trigger_dyntick_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "551-585",
    "snippet": "static void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_nohz_cpu",
          "args": [
            "base->cpu"
          ],
          "line": 584
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_nohz_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "573-577",
          "snippet": "void wake_up_nohz_cpu(int cpu)\n{\n\tif (!wake_up_full_nohz_cpu(cpu))\n\t\twake_up_idle_cpu(cpu);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nvoid wake_up_nohz_cpu(int cpu)\n{\n\tif (!wake_up_full_nohz_cpu(cpu))\n\t\twake_up_idle_cpu(cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after_eq",
          "args": [
            "timer->expires",
            "base->next_expiry"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_nohz_full_cpu",
          "args": [
            "base->cpu"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_timers_nohz_active",
          "args": [],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "is_timers_nohz_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "267-267",
          "snippet": "static inline bool is_timers_nohz_active(void) { return false; }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool is_timers_nohz_active(void) { return false; }"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\ntrigger_dyntick_cpu(struct timer_base *base, struct timer_list *timer)\n{\n\tif (!is_timers_nohz_active())\n\t\treturn;\n\n\t/*\n\t * TODO: This wants some optimizing similar to the code below, but we\n\t * will do that when we switch from push to pull for deferrable timers.\n\t */\n\tif (timer->flags & TIMER_DEFERRABLE) {\n\t\tif (tick_nohz_full_cpu(base->cpu))\n\t\t\twake_up_nohz_cpu(base->cpu);\n\t\treturn;\n\t}\n\n\t/*\n\t * We might have to IPI the remote CPU if the base is idle and the\n\t * timer is not deferrable. If the other CPU is on the way to idle\n\t * then it can't set base->is_idle as we hold the base lock:\n\t */\n\tif (!base->is_idle)\n\t\treturn;\n\n\t/* Check whether this is the new first expiring timer: */\n\tif (time_after_eq(timer->expires, base->next_expiry))\n\t\treturn;\n\n\t/*\n\t * Set the next expiry time and kick the CPU so it can reevaluate the\n\t * wheel:\n\t */\n\tbase->next_expiry = timer->expires;\n\twake_up_nohz_cpu(base->cpu);\n}"
  },
  {
    "function_name": "__internal_add_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "542-549",
    "snippet": "static void\n__internal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\tunsigned int idx;\n\n\tidx = calc_wheel_index(timer->expires, base->clk);\n\tenqueue_timer(base, timer, idx);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enqueue_timer",
          "args": [
            "base",
            "timer",
            "idx"
          ],
          "line": 548
        },
        "resolved": true,
        "details": {
          "function_name": "enqueue_timer",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "534-540",
          "snippet": "static void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "calc_wheel_index",
          "args": [
            "timer->expires",
            "base->clk"
          ],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "calc_wheel_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "494-528",
          "snippet": "static int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))",
            "#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))",
            "#define LVL_MASK\t(LVL_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))\n#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))\n#define LVL_MASK\t(LVL_SIZE - 1)\n\nstatic int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void\n__internal_add_timer(struct timer_base *base, struct timer_list *timer)\n{\n\tunsigned int idx;\n\n\tidx = calc_wheel_index(timer->expires, base->clk);\n\tenqueue_timer(base, timer, idx);\n}"
  },
  {
    "function_name": "enqueue_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "534-540",
    "snippet": "static void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "timer_set_idx",
          "args": [
            "timer",
            "idx"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "timer_set_idx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "478-482",
          "snippet": "static inline void timer_set_idx(struct timer_list *timer, unsigned int idx)\n{\n\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |\n\t\t\tidx << TIMER_ARRAYSHIFT;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void timer_set_idx(struct timer_list *timer, unsigned int idx)\n{\n\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |\n\t\t\tidx << TIMER_ARRAYSHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_bit",
          "args": [
            "idx",
            "base->pending_map"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_add_head",
          "args": [
            "&timer->entry",
            "base->vectors + idx"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstruct timer_base {\n\traw_spinlock_t\t\tlock;\n\tstruct timer_list\t*running_timer;\n\tunsigned long\t\tclk;\n\tunsigned long\t\tnext_expiry;\n\tunsigned int\t\tcpu;\n\tbool\t\t\tis_idle;\n\tbool\t\t\tmust_forward_clk;\n\tDECLARE_BITMAP(pending_map, WHEEL_SIZE);\n\tstruct hlist_head\tvectors[WHEEL_SIZE];\n} ____cacheline_aligned;\n\nstatic void enqueue_timer(struct timer_base *base, struct timer_list *timer,\n\t\t\t  unsigned int idx)\n{\n\thlist_add_head(&timer->entry, base->vectors + idx);\n\t__set_bit(idx, base->pending_map);\n\ttimer_set_idx(timer, idx);\n}"
  },
  {
    "function_name": "calc_wheel_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "494-528",
    "snippet": "static int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))",
      "#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))",
      "#define LVL_MASK\t(LVL_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "calc_index",
          "args": [
            "expires",
            "LVL_DEPTH - 1"
          ],
          "line": 525
        },
        "resolved": true,
        "details": {
          "function_name": "calc_index",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "488-492",
          "snippet": "static inline unsigned calc_index(unsigned expires, unsigned lvl)\n{\n\texpires = (expires + LVL_GRAN(lvl)) >> LVL_SHIFT(lvl);\n\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [
            "#define LVL_MASK\t(LVL_SIZE - 1)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n\nstatic inline unsigned calc_index(unsigned expires, unsigned lvl)\n{\n\texpires = (expires + LVL_GRAN(lvl)) >> LVL_SHIFT(lvl);\n\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);\n}"
        }
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "8"
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "7"
          ],
          "line": 511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "6"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "5"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "4"
          ],
          "line": 505
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "3"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "2"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_START",
          "args": [
            "1"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define WHEEL_TIMEOUT_MAX\t(WHEEL_TIMEOUT_CUTOFF - LVL_GRAN(LVL_DEPTH - 1))\n#define WHEEL_TIMEOUT_CUTOFF\t(LVL_START(LVL_DEPTH))\n#define LVL_MASK\t(LVL_SIZE - 1)\n\nstatic int calc_wheel_index(unsigned long expires, unsigned long clk)\n{\n\tunsigned long delta = expires - clk;\n\tunsigned int idx;\n\n\tif (delta < LVL_START(1)) {\n\t\tidx = calc_index(expires, 0);\n\t} else if (delta < LVL_START(2)) {\n\t\tidx = calc_index(expires, 1);\n\t} else if (delta < LVL_START(3)) {\n\t\tidx = calc_index(expires, 2);\n\t} else if (delta < LVL_START(4)) {\n\t\tidx = calc_index(expires, 3);\n\t} else if (delta < LVL_START(5)) {\n\t\tidx = calc_index(expires, 4);\n\t} else if (delta < LVL_START(6)) {\n\t\tidx = calc_index(expires, 5);\n\t} else if (delta < LVL_START(7)) {\n\t\tidx = calc_index(expires, 6);\n\t} else if (LVL_DEPTH > 8 && delta < LVL_START(8)) {\n\t\tidx = calc_index(expires, 7);\n\t} else if ((long) delta < 0) {\n\t\tidx = clk & LVL_MASK;\n\t} else {\n\t\t/*\n\t\t * Force expire obscene large timeouts to expire at the\n\t\t * capacity limit of the wheel.\n\t\t */\n\t\tif (expires >= WHEEL_TIMEOUT_CUTOFF)\n\t\t\texpires = WHEEL_TIMEOUT_MAX;\n\n\t\tidx = calc_index(expires, LVL_DEPTH - 1);\n\t}\n\treturn idx;\n}"
  },
  {
    "function_name": "calc_index",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "488-492",
    "snippet": "static inline unsigned calc_index(unsigned expires, unsigned lvl)\n{\n\texpires = (expires + LVL_GRAN(lvl)) >> LVL_SHIFT(lvl);\n\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [
      "#define LVL_MASK\t(LVL_SIZE - 1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "LVL_OFFS",
          "args": [
            "lvl"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_SHIFT",
          "args": [
            "lvl"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LVL_GRAN",
          "args": [
            "lvl"
          ],
          "line": 490
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n#define LVL_MASK\t(LVL_SIZE - 1)\n\nstatic inline unsigned calc_index(unsigned expires, unsigned lvl)\n{\n\texpires = (expires + LVL_GRAN(lvl)) >> LVL_SHIFT(lvl);\n\treturn LVL_OFFS(lvl) + (expires & LVL_MASK);\n}"
  },
  {
    "function_name": "timer_set_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "478-482",
    "snippet": "static inline void timer_set_idx(struct timer_list *timer, unsigned int idx)\n{\n\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |\n\t\t\tidx << TIMER_ARRAYSHIFT;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void timer_set_idx(struct timer_list *timer, unsigned int idx)\n{\n\ttimer->flags = (timer->flags & ~TIMER_ARRAYMASK) |\n\t\t\tidx << TIMER_ARRAYSHIFT;\n}"
  },
  {
    "function_name": "timer_get_idx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "473-476",
    "snippet": "static inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline unsigned int timer_get_idx(struct timer_list *timer)\n{\n\treturn (timer->flags & TIMER_ARRAYMASK) >> TIMER_ARRAYSHIFT;\n}"
  },
  {
    "function_name": "round_jiffies_up_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "466-469",
    "snippet": "unsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__round_jiffies_up_relative",
          "args": [
            "j",
            "raw_smp_processor_id()"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "__round_jiffies_up_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "433-439",
          "snippet": "unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_up_relative(unsigned long j)\n{\n\treturn __round_jiffies_up_relative(j, raw_smp_processor_id());\n}"
  },
  {
    "function_name": "round_jiffies_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "451-454",
    "snippet": "unsigned long round_jiffies_up(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), true);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j",
            "raw_smp_processor_id()",
            "true"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_up(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), true);\n}"
  },
  {
    "function_name": "__round_jiffies_up_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "433-439",
    "snippet": "unsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j + j0",
            "cpu",
            "true"
          ],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies_up_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, true) - j0;\n}"
  },
  {
    "function_name": "__round_jiffies_up",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "417-420",
    "snippet": "unsigned long __round_jiffies_up(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, true);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j",
            "cpu",
            "true"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies_up(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, true);\n}"
  },
  {
    "function_name": "round_jiffies_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "401-404",
    "snippet": "unsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__round_jiffies_relative",
          "args": [
            "j",
            "raw_smp_processor_id()"
          ],
          "line": 403
        },
        "resolved": true,
        "details": {
          "function_name": "__round_jiffies_relative",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "356-362",
          "snippet": "unsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies_relative(unsigned long j)\n{\n\treturn __round_jiffies_relative(j, raw_smp_processor_id());\n}"
  },
  {
    "function_name": "round_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "380-383",
    "snippet": "unsigned long round_jiffies(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), false);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j",
            "raw_smp_processor_id()",
            "false"
          ],
          "line": 382
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long round_jiffies(unsigned long j)\n{\n\treturn round_jiffies_common(j, raw_smp_processor_id(), false);\n}"
  },
  {
    "function_name": "__round_jiffies_relative",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "356-362",
    "snippet": "unsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j + j0",
            "cpu",
            "false"
          ],
          "line": 361
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies_relative(unsigned long j, int cpu)\n{\n\tunsigned long j0 = jiffies;\n\n\t/* Use j0 because jiffies might change while we run */\n\treturn round_jiffies_common(j + j0, cpu, false) - j0;\n}"
  },
  {
    "function_name": "__round_jiffies",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "330-333",
    "snippet": "unsigned long __round_jiffies(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, false);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "round_jiffies_common",
          "args": [
            "j",
            "cpu",
            "false"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "round_jiffies_common",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "270-308",
          "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nunsigned long __round_jiffies(unsigned long j, int cpu)\n{\n\treturn round_jiffies_common(j, cpu, false);\n}"
  },
  {
    "function_name": "round_jiffies_common",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "270-308",
    "snippet": "static unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "time_is_after_jiffies",
          "args": [
            "j"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic unsigned long round_jiffies_common(unsigned long j, int cpu,\n\t\tbool force_up)\n{\n\tint rem;\n\tunsigned long original = j;\n\n\t/*\n\t * We don't want all cpus firing their timers at once hitting the\n\t * same lock or cachelines, so we skew each extra cpu with an extra\n\t * 3 jiffies. This 3 jiffies came originally from the mm/ code which\n\t * already did this.\n\t * The skew is done by adding 3*cpunr, then round, then subtract this\n\t * extra offset again.\n\t */\n\tj += cpu * 3;\n\n\trem = j % HZ;\n\n\t/*\n\t * If the target jiffie is just after a whole second (which can happen\n\t * due to delays of the timer irq, long irq off times etc etc) then\n\t * we should round down to the whole second, not up. Use 1/4th second\n\t * as cutoff for this rounding as an extreme upper bound for this.\n\t * But never round down if @force_up is set.\n\t */\n\tif (rem < HZ/4 && !force_up) /* round down */\n\t\tj = j - rem;\n\telse /* round up */\n\t\tj = j - rem + HZ;\n\n\t/* now that we have rounded, subtract the extra skew again */\n\tj -= cpu * 3;\n\n\t/*\n\t * Make sure j is still in the future. Otherwise return the\n\t * unmodified value.\n\t */\n\treturn time_is_after_jiffies(j) ? j : original;\n}"
  },
  {
    "function_name": "is_timers_nohz_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "267-267",
    "snippet": "static inline bool is_timers_nohz_active(void) { return false; }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool is_timers_nohz_active(void) { return false; }"
  },
  {
    "function_name": "is_timers_nohz_active",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "262-265",
    "snippet": "static inline bool is_timers_nohz_active(void)\n{\n\treturn static_branch_unlikely(&timers_nohz_active);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&timers_nohz_active"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline bool is_timers_nohz_active(void)\n{\n\treturn static_branch_unlikely(&timers_nohz_active);\n}"
  },
  {
    "function_name": "timer_migration_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "248-260",
    "snippet": "int timer_migration_handler(struct ctl_table *table, int write,\n\t\t\t    void __user *buffer, size_t *lenp,\n\t\t\t    loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&timer_keys_mutex);\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (!ret && write)\n\t\ttimers_update_migration();\n\tmutex_unlock(&timer_keys_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&timer_keys_mutex"
          ],
          "line": 258
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "timers_update_migration",
          "args": [],
          "line": 257
        },
        "resolved": true,
        "details": {
          "function_name": "timers_update_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "232-232",
          "snippet": "static inline void timers_update_migration(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void timers_update_migration(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "proc_dointvec_minmax",
          "args": [
            "table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 255
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dointvec_minmax",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3200-3204",
          "snippet": "int proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dointvec_minmax(struct ctl_table *table, int write,\n\t\t    void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&timer_keys_mutex"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nint timer_migration_handler(struct ctl_table *table, int write,\n\t\t\t    void __user *buffer, size_t *lenp,\n\t\t\t    loff_t *ppos)\n{\n\tint ret;\n\n\tmutex_lock(&timer_keys_mutex);\n\tret = proc_dointvec_minmax(table, write, buffer, lenp, ppos);\n\tif (!ret && write)\n\t\ttimers_update_migration();\n\tmutex_unlock(&timer_keys_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "timers_update_nohz",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "243-246",
    "snippet": "void timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&timer_update_work"
          ],
          "line": 245
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nvoid timers_update_nohz(void)\n{\n\tschedule_work(&timer_update_work);\n}"
  },
  {
    "function_name": "timer_update_keys",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "235-241",
    "snippet": "static void timer_update_keys(struct work_struct *work)\n{\n\tmutex_lock(&timer_keys_mutex);\n\ttimers_update_migration();\n\tstatic_branch_enable(&timers_nohz_active);\n\tmutex_unlock(&timer_keys_mutex);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&timer_keys_mutex"
          ],
          "line": 240
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&timers_nohz_active"
          ],
          "line": 239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timers_update_migration",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "timers_update_migration",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "232-232",
          "snippet": "static inline void timers_update_migration(void) { }",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void timers_update_migration(void) { }"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&timer_keys_mutex"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void timer_update_keys(struct work_struct *work)\n{\n\tmutex_lock(&timer_keys_mutex);\n\ttimers_update_migration();\n\tstatic_branch_enable(&timers_nohz_active);\n\tmutex_unlock(&timer_keys_mutex);\n}"
  },
  {
    "function_name": "timers_update_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "232-232",
    "snippet": "static inline void timers_update_migration(void) { }",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic inline void timers_update_migration(void) { }"
  },
  {
    "function_name": "timers_update_migration",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
    "lines": "224-230",
    "snippet": "static void timers_update_migration(void)\n{\n\tif (sysctl_timer_migration && tick_nohz_active)\n\t\tstatic_branch_enable(&timers_migration_enabled);\n\telse\n\t\tstatic_branch_disable(&timers_migration_enabled);\n}",
    "includes": [
      "#include <trace/events/timer.h>",
      "#include \"tick-internal.h\"",
      "#include <asm/io.h>",
      "#include <asm/timex.h>",
      "#include <asm/div64.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/compat.h>",
      "#include <linux/slab.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/nohz.h>",
      "#include <linux/sched/sysctl.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/irq_work.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/tick.h>",
      "#include <linux/delay.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/cpu.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/time.h>",
      "#include <linux/thread_info.h>",
      "#include <linux/notifier.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/swap.h>",
      "#include <linux/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/percpu.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/export.h>",
      "#include <linux/kernel_stat.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&timers_migration_enabled"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&timers_migration_enabled"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\nstatic void timers_update_migration(void)\n{\n\tif (sysctl_timer_migration && tick_nohz_active)\n\t\tstatic_branch_enable(&timers_migration_enabled);\n\telse\n\t\tstatic_branch_disable(&timers_migration_enabled);\n}"
  }
]