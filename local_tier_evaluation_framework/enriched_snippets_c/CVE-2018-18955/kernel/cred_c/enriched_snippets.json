[
  {
    "function_name": "validate_creds_for_do_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "808-816",
    "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__validate_process_creds",
          "args": [
            "tsk",
            "__FILE__",
            "__LINE__"
          ],
          "line": 815
        },
        "resolved": true,
        "details": {
          "function_name": "__validate_process_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "776-802",
          "snippet": "void __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"validate_creds_for_do_exit(%p,%p{%d,%d})\"",
            "tsk->real_cred",
            "tsk->cred",
            "atomic_read(&tsk->cred->usage)",
            "read_cred_subscribers(tsk->cred)"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 813
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tsk->cred->usage"
          ],
          "line": 812
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
  },
  {
    "function_name": "__validate_process_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "776-802",
    "snippet": "void __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 801
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: Effective creds == Real creds\\n\""
          ],
          "line": 800
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dump_invalid_creds",
          "args": [
            "tsk->cred",
            "\"Effective\"",
            "tsk"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "dump_invalid_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "727-759",
          "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: At %s:%u\\n\"",
            "file",
            "line"
          ],
          "line": 794
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "creds_are_invalid",
          "args": [
            "tsk->cred"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "creds_are_invalid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "703-721",
          "snippet": "bool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 785
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)"
          ],
          "line": 780
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __validate_process_creds(struct task_struct *tsk,\n\t\t\t      const char *file, unsigned line)\n{\n\tif (tsk->cred == tsk->real_cred) {\n\t\tif (unlikely(read_cred_subscribers(tsk->cred) < 2 ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t} else {\n\t\tif (unlikely(read_cred_subscribers(tsk->real_cred) < 1 ||\n\t\t\t     read_cred_subscribers(tsk->cred) < 1 ||\n\t\t\t     creds_are_invalid(tsk->real_cred) ||\n\t\t\t     creds_are_invalid(tsk->cred)))\n\t\t\tgoto invalid_creds;\n\t}\n\treturn;\n\ninvalid_creds:\n\tprintk(KERN_ERR \"CRED: Invalid process credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\n\tdump_invalid_creds(tsk->real_cred, \"Real\", tsk);\n\tif (tsk->cred != tsk->real_cred)\n\t\tdump_invalid_creds(tsk->cred, \"Effective\", tsk);\n\telse\n\t\tprintk(KERN_ERR \"CRED: Effective creds == Real creds\\n\");\n\tBUG();\n}"
  },
  {
    "function_name": "__invalid_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "764-770",
    "snippet": "void __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dump_invalid_creds",
          "args": [
            "cred",
            "\"Specified\"",
            "current"
          ],
          "line": 768
        },
        "resolved": true,
        "details": {
          "function_name": "dump_invalid_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "727-759",
          "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: At %s:%u\\n\"",
            "file",
            "line"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: Invalid credentials\\n\""
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __invalid_creds(const struct cred *cred, const char *file, unsigned line)\n{\n\tprintk(KERN_ERR \"CRED: Invalid credentials\\n\");\n\tprintk(KERN_ERR \"CRED: At %s:%u\\n\", file, line);\n\tdump_invalid_creds(cred, \"Specified\", current);\n\tBUG();\n}"
  },
  {
    "function_name": "dump_invalid_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "727-759",
    "snippet": "static void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_ERR \"CRED: ->security {%x, %x}\\n\"",
            "((u32*)cred->security)[0]",
            "((u32*)cred->security)[1]"
          ],
          "line": 755
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid_munged",
          "args": [
            "&init_user_ns",
            "cred->fsgid"
          ],
          "line": 749
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "&init_user_ns",
            "cred->fsuid"
          ],
          "line": 744
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 739
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};\n\nstatic void dump_invalid_creds(const struct cred *cred, const char *label,\n\t\t\t       const struct task_struct *tsk)\n{\n\tprintk(KERN_ERR \"CRED: %s credentials: %p %s%s%s\\n\",\n\t       label, cred,\n\t       cred == &init_cred ? \"[init]\" : \"\",\n\t       cred == tsk->real_cred ? \"[real]\" : \"\",\n\t       cred == tsk->cred ? \"[eff]\" : \"\");\n\tprintk(KERN_ERR \"CRED: ->magic=%x, put_addr=%p\\n\",\n\t       cred->magic, cred->put_addr);\n\tprintk(KERN_ERR \"CRED: ->usage=%d, subscr=%d\\n\",\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\tprintk(KERN_ERR \"CRED: ->*uid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kuid_munged(&init_user_ns, cred->uid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->euid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->suid),\n\t\tfrom_kuid_munged(&init_user_ns, cred->fsuid));\n\tprintk(KERN_ERR \"CRED: ->*gid = { %d,%d,%d,%d }\\n\",\n\t\tfrom_kgid_munged(&init_user_ns, cred->gid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->egid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->sgid),\n\t\tfrom_kgid_munged(&init_user_ns, cred->fsgid));\n#ifdef CONFIG_SECURITY\n\tprintk(KERN_ERR \"CRED: ->security is %p\\n\", cred->security);\n\tif ((unsigned long) cred->security >= PAGE_SIZE &&\n\t    (((unsigned long) cred->security & 0xffffff00) !=\n\t     (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8)))\n\t\tprintk(KERN_ERR \"CRED: ->security {%x, %x}\\n\",\n\t\t       ((u32*)cred->security)[0],\n\t\t       ((u32*)cred->security)[1]);\n#endif\n}"
  },
  {
    "function_name": "creds_are_invalid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "703-721",
    "snippet": "bool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "selinux_is_enabled",
          "args": [],
          "line": 712
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nbool creds_are_invalid(const struct cred *cred)\n{\n\tif (cred->magic != CRED_MAGIC)\n\t\treturn true;\n#ifdef CONFIG_SECURITY_SELINUX\n\t/*\n\t * cred->security == NULL if security_cred_alloc_blank() or\n\t * security_prepare_creds() returned an error.\n\t */\n\tif (selinux_is_enabled() && cred->security) {\n\t\tif ((unsigned long) cred->security < PAGE_SIZE)\n\t\t\treturn true;\n\t\tif ((*(u32 *)cred->security & 0xffffff00) ==\n\t\t    (POISON_FREE << 24 | POISON_FREE << 16 | POISON_FREE << 8))\n\t\t\treturn true;\n\t}\n#endif\n\treturn false;\n}"
  },
  {
    "function_name": "set_create_files_as",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "691-698",
    "snippet": "int set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EINVAL;\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_kernel_create_files_as",
          "args": [
            "new",
            "inode"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_valid",
          "args": [
            "inode->i_gid"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "inode->i_uid"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_create_files_as(struct cred *new, struct inode *inode)\n{\n\tif (!uid_valid(inode->i_uid) || !gid_valid(inode->i_gid))\n\t\treturn -EINVAL;\n\tnew->fsuid = inode->i_uid;\n\tnew->fsgid = inode->i_gid;\n\treturn security_kernel_create_files_as(new, inode);\n}"
  },
  {
    "function_name": "set_security_override_from_ctx",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "669-679",
    "snippet": "int set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_security_override",
          "args": [
            "new",
            "secid"
          ],
          "line": 678
        },
        "resolved": true,
        "details": {
          "function_name": "set_security_override_from_ctx",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "669-679",
          "snippet": "int set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "security_secctx_to_secid",
          "args": [
            "secctx",
            "strlen(secctx)",
            "&secid"
          ],
          "line": 674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "secctx"
          ],
          "line": 674
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_security_override_from_ctx(struct cred *new, const char *secctx)\n{\n\tu32 secid;\n\tint ret;\n\n\tret = security_secctx_to_secid(secctx, strlen(secctx), &secid);\n\tif (ret < 0)\n\t\treturn ret;\n\n\treturn set_security_override(new, secid);\n}"
  },
  {
    "function_name": "set_security_override",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "653-656",
    "snippet": "int set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_kernel_act_as",
          "args": [
            "new",
            "secid"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint set_security_override(struct cred *new, u32 secid)\n{\n\treturn security_kernel_act_as(new, secid);\n}"
  },
  {
    "function_name": "prepare_kernel_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "595-642",
    "snippet": "struct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;",
      "struct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "old"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_prepare_creds",
          "args": [
            "new",
            "old",
            "GFP_KERNEL"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "new->user_ns"
          ],
          "line": 617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "new->user"
          ],
          "line": 616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cred_subscribers",
          "args": [
            "new",
            "0"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "68-73",
          "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "&init_cred"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_task_cred",
          "args": [
            "daemon"
          ],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "get_task_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "188-201",
          "snippet": "const struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"prepare_kernel_cred() alloc %p\"",
            "new"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\nstruct cred init_cred = {\n\t.usage\t\t\t= ATOMIC_INIT(4),\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\t.subscribers\t\t= ATOMIC_INIT(2),\n\t.magic\t\t\t= CRED_MAGIC,\n#endif\n\t.uid\t\t\t= GLOBAL_ROOT_UID,\n\t.gid\t\t\t= GLOBAL_ROOT_GID,\n\t.suid\t\t\t= GLOBAL_ROOT_UID,\n\t.sgid\t\t\t= GLOBAL_ROOT_GID,\n\t.euid\t\t\t= GLOBAL_ROOT_UID,\n\t.egid\t\t\t= GLOBAL_ROOT_GID,\n\t.fsuid\t\t\t= GLOBAL_ROOT_UID,\n\t.fsgid\t\t\t= GLOBAL_ROOT_GID,\n\t.securebits\t\t= SECUREBITS_DEFAULT,\n\t.cap_inheritable\t= CAP_EMPTY_SET,\n\t.cap_permitted\t\t= CAP_FULL_SET,\n\t.cap_effective\t\t= CAP_FULL_SET,\n\t.cap_bset\t\t= CAP_FULL_SET,\n\t.user\t\t\t= INIT_USER,\n\t.user_ns\t\t= &init_user_ns,\n\t.group_info\t\t= &init_groups,\n};\n\nstruct cred *prepare_kernel_cred(struct task_struct *daemon)\n{\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_kernel_cred() alloc %p\", new);\n\n\tif (daemon)\n\t\told = get_task_cred(daemon);\n\telse\n\t\told = get_cred(&init_cred);\n\n\tvalidate_creds(old);\n\n\t*new = *old;\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\tget_group_info(new->group_info);\n\n#ifdef CONFIG_KEYS\n\tnew->session_keyring = NULL;\n\tnew->process_keyring = NULL;\n\tnew->thread_keyring = NULL;\n\tnew->request_key_auth = NULL;\n\tnew->jit_keyring = KEY_REQKEY_DEFL_THREAD_KEYRING;\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\tput_cred(old);\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tput_cred(new);\n\tput_cred(old);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cred_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "570-575",
    "snippet": "void __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_create",
          "args": [
            "\"cred_jar\"",
            "sizeof(struct cred)",
            "0",
            "SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT",
            "NULL"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nvoid __init cred_init(void)\n{\n\t/* allocate a slab in which we can store credentials */\n\tcred_jar = kmem_cache_create(\"cred_jar\", sizeof(struct cred), 0,\n\t\t\tSLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_ACCOUNT, NULL);\n}"
  },
  {
    "function_name": "revert_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "550-564",
    "snippet": "void revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "override"
          ],
          "line": 563
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "override",
            "-1"
          ],
          "line": 562
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "84-91",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "current->cred",
            "old"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "override"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"revert_creds(%p{%d,%d})\"",
            "old",
            "atomic_read(&old->usage)",
            "read_cred_subscribers(old)"
          ],
          "line": 554
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 556
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&old->usage"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid revert_creds(const struct cred *old)\n{\n\tconst struct cred *override = current->cred;\n\n\tkdebug(\"revert_creds(%p{%d,%d})\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\n\tvalidate_creds(old);\n\tvalidate_creds(override);\n\talter_cred_subscribers(old, 1);\n\trcu_assign_pointer(current->cred, old);\n\talter_cred_subscribers(override, -1);\n\tput_cred(override);\n}"
  },
  {
    "function_name": "override_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "521-540",
    "snippet": "const struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"override_creds() = %p{%d,%d}\"",
            "old",
            "atomic_read(&old->usage)",
            "read_cred_subscribers(old)"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 538
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&old->usage"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "old",
            "-1"
          ],
          "line": 534
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "84-91",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "current->cred",
            "new"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "new"
          ],
          "line": 531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 530
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"override_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 526
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *override_creds(const struct cred *new)\n{\n\tconst struct cred *old = current->cred;\n\n\tkdebug(\"override_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n\tget_cred(new);\n\talter_cred_subscribers(new, 1);\n\trcu_assign_pointer(current->cred, new);\n\talter_cred_subscribers(old, -1);\n\n\tkdebug(\"override_creds() = %p{%d,%d}\", old,\n\t       atomic_read(&old->usage),\n\t       read_cred_subscribers(old));\n\treturn old;\n}"
  },
  {
    "function_name": "abort_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "500-511",
    "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "new"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&new->usage) < 1"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 509
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(new) != 0"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "new"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"abort_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
  },
  {
    "function_name": "commit_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "423-490",
    "snippet": "int commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "old"
          ],
          "line": 488
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_id_connector",
          "args": [
            "task",
            "PROC_EVENT_GID"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->fsgid",
            "old->fsgid"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->sgid",
            "old->sgid"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->egid",
            "old->egid"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->gid",
            "old->gid"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_id_connector",
          "args": [
            "task",
            "PROC_EVENT_UID"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "old->fsuid"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->suid",
            "old->suid"
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->euid",
            "old->euid"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->uid",
            "old->uid"
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "old",
            "-2"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "84-91",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&old->user->processes"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->cred",
            "new"
          ],
          "line": 468
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "task->real_cred",
            "new"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&new->user->processes"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_fsgid_changed",
          "args": [
            "task"
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "new->fsgid",
            "old->fsgid"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_fsuid_changed",
          "args": [
            "task"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "new->fsuid",
            "old->fsuid"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_dumpable",
          "args": [
            "task->mm",
            "suid_dumpable"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cred_cap_issubset",
          "args": [
            "old",
            "new"
          ],
          "line": 447
        },
        "resolved": true,
        "details": {
          "function_name": "cred_cap_issubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "384-407",
          "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "old->fsgid",
            "new->fsgid"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->fsuid",
            "new->fsuid"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gid_eq",
          "args": [
            "old->egid",
            "new->egid"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "old->euid",
            "new->euid"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_cred",
          "args": [
            "new"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&new->usage) < 1"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(old) < 2"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "old"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task->cred != old"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"commit_creds(%p{%d,%d})\"",
            "new",
            "atomic_read(&new->usage)",
            "read_cred_subscribers(new)"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&new->usage"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nint commit_creds(struct cred *new)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old = task->real_cred;\n\n\tkdebug(\"commit_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n\tBUG_ON(task->cred != old);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(old) < 2);\n\tvalidate_creds(old);\n\tvalidate_creds(new);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\n\tget_cred(new); /* we will require a ref for the subj creds too */\n\n\t/* dumpability changes */\n\tif (!uid_eq(old->euid, new->euid) ||\n\t    !gid_eq(old->egid, new->egid) ||\n\t    !uid_eq(old->fsuid, new->fsuid) ||\n\t    !gid_eq(old->fsgid, new->fsgid) ||\n\t    !cred_cap_issubset(old, new)) {\n\t\tif (task->mm)\n\t\t\tset_dumpable(task->mm, suid_dumpable);\n\t\ttask->pdeath_signal = 0;\n\t\tsmp_wmb();\n\t}\n\n\t/* alter the thread keyring */\n\tif (!uid_eq(new->fsuid, old->fsuid))\n\t\tkey_fsuid_changed(task);\n\tif (!gid_eq(new->fsgid, old->fsgid))\n\t\tkey_fsgid_changed(task);\n\n\t/* do it\n\t * RLIMIT_NPROC limits on user->processes have already been checked\n\t * in set_user().\n\t */\n\talter_cred_subscribers(new, 2);\n\tif (new->user != old->user)\n\t\tatomic_inc(&new->user->processes);\n\trcu_assign_pointer(task->real_cred, new);\n\trcu_assign_pointer(task->cred, new);\n\tif (new->user != old->user)\n\t\tatomic_dec(&old->user->processes);\n\talter_cred_subscribers(old, -2);\n\n\t/* send notifications */\n\tif (!uid_eq(new->uid,   old->uid)  ||\n\t    !uid_eq(new->euid,  old->euid) ||\n\t    !uid_eq(new->suid,  old->suid) ||\n\t    !uid_eq(new->fsuid, old->fsuid))\n\t\tproc_id_connector(task, PROC_EVENT_UID);\n\n\tif (!gid_eq(new->gid,   old->gid)  ||\n\t    !gid_eq(new->egid,  old->egid) ||\n\t    !gid_eq(new->sgid,  old->sgid) ||\n\t    !gid_eq(new->fsgid, old->fsgid))\n\t\tproc_id_connector(task, PROC_EVENT_GID);\n\n\t/* release the old obj and subj refs both */\n\tput_cred(old);\n\tput_cred(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "cred_cap_issubset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "384-407",
    "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "subset_ns->owner",
            "set->euid"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cap_issubset",
          "args": [
            "subset->cap_permitted",
            "set->cap_permitted"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "cred_cap_issubset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "384-407",
          "snippet": "static bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic bool cred_cap_issubset(const struct cred *set, const struct cred *subset)\n{\n\tconst struct user_namespace *set_ns = set->user_ns;\n\tconst struct user_namespace *subset_ns = subset->user_ns;\n\n\t/* If the two credentials are in the same user namespace see if\n\t * the capabilities of subset are a subset of set.\n\t */\n\tif (set_ns == subset_ns)\n\t\treturn cap_issubset(subset->cap_permitted, set->cap_permitted);\n\n\t/* The credentials are in a different user namespaces\n\t * therefore one is a subset of the other only if a set is an\n\t * ancestor of subset and set->euid is owner of subset or one\n\t * of subsets ancestors.\n\t */\n\tfor (;subset_ns != &init_user_ns; subset_ns = subset_ns->parent) {\n\t\tif ((set_ns == subset_ns->parent)  &&\n\t\t    uid_eq(subset_ns->owner, set->euid))\n\t\t\treturn true;\n\t}\n\n\treturn false;\n}"
  },
  {
    "function_name": "prepare_exec_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "293-312",
    "snippet": "struct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n\tnew->process_keyring = NULL;\n#endif\n\n\treturn new;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "new->process_keyring"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "new->thread_keyring"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_creds",
          "args": [],
          "line": 297
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "244-286",
          "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *cred_jar;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstruct cred *prepare_exec_creds(void)\n{\n\tstruct cred *new;\n\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn new;\n\n#ifdef CONFIG_KEYS\n\t/* newly exec'd tasks don't get a thread keyring */\n\tkey_put(new->thread_keyring);\n\tnew->thread_keyring = NULL;\n\n\t/* inherit the session keyring; new process keyring */\n\tkey_put(new->process_keyring);\n\tnew->process_keyring = NULL;\n#endif\n\n\treturn new;\n}"
  },
  {
    "function_name": "prepare_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "244-286",
    "snippet": "struct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "500-511",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "new"
          ],
          "line": 280
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_prepare_creds",
          "args": [
            "new",
            "old",
            "GFP_KERNEL"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->request_key_auth"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->thread_keyring"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->process_keyring"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_get",
          "args": [
            "new->session_keyring"
          ],
          "line": 268
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_user_ns",
          "args": [
            "new->user_ns"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "new->user"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_group_info",
          "args": [
            "new->group_info"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_cred_subscribers",
          "args": [
            "new",
            "0"
          ],
          "line": 262
        },
        "resolved": true,
        "details": {
          "function_name": "set_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "68-73",
          "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new",
            "old",
            "sizeof(struct cred)"
          ],
          "line": 259
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"prepare_creds() alloc %p\"",
            "new"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validate_process_creds",
          "args": [],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *prepare_creds(void)\n{\n\tstruct task_struct *task = current;\n\tconst struct cred *old;\n\tstruct cred *new;\n\n\tvalidate_process_creds();\n\n\tnew = kmem_cache_alloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tkdebug(\"prepare_creds() alloc %p\", new);\n\n\told = task->cred;\n\tmemcpy(new, old, sizeof(struct cred));\n\n\tatomic_set(&new->usage, 1);\n\tset_cred_subscribers(new, 0);\n\tget_group_info(new->group_info);\n\tget_uid(new->user);\n\tget_user_ns(new->user_ns);\n\n#ifdef CONFIG_KEYS\n\tkey_get(new->session_keyring);\n\tkey_get(new->process_keyring);\n\tkey_get(new->thread_keyring);\n\tkey_get(new->request_key_auth);\n#endif\n\n#ifdef CONFIG_SECURITY\n\tnew->security = NULL;\n#endif\n\n\tif (security_prepare_creds(new, old, GFP_KERNEL) < 0)\n\t\tgoto error;\n\tvalidate_creds(new);\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "cred_alloc_blank",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "207-228",
    "snippet": "struct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\n\tif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "abort_creds",
          "args": [
            "new"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "abort_creds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "500-511",
          "snippet": "void abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid abort_creds(struct cred *new)\n{\n\tkdebug(\"abort_creds(%p{%d,%d})\", new,\n\t       atomic_read(&new->usage),\n\t       read_cred_subscribers(new));\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(new) != 0);\n#endif\n\tBUG_ON(atomic_read(&new->usage) < 1);\n\tput_cred(new);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_cred_alloc_blank",
          "args": [
            "new",
            "GFP_KERNEL"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&new->usage",
            "1"
          ],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "cred_jar",
            "GFP_KERNEL"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstruct cred *cred_alloc_blank(void)\n{\n\tstruct cred *new;\n\n\tnew = kmem_cache_zalloc(cred_jar, GFP_KERNEL);\n\tif (!new)\n\t\treturn NULL;\n\n\tatomic_set(&new->usage, 1);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tnew->magic = CRED_MAGIC;\n#endif\n\n\tif (security_cred_alloc_blank(new, GFP_KERNEL) < 0)\n\t\tgoto error;\n\n\treturn new;\n\nerror:\n\tabort_creds(new);\n\treturn NULL;\n}"
  },
  {
    "function_name": "get_task_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "188-201",
    "snippet": "const struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_not_zero",
          "args": [
            "&((struct cred *)cred)->usage"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!cred"
          ],
          "line": 196
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "(task)"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nconst struct cred *get_task_cred(struct task_struct *task)\n{\n\tconst struct cred *cred;\n\n\trcu_read_lock();\n\n\tdo {\n\t\tcred = __task_cred((task));\n\t\tBUG_ON(!cred);\n\t} while (!atomic_inc_not_zero(&((struct cred *)cred)->usage));\n\n\trcu_read_unlock();\n\treturn cred;\n}"
  },
  {
    "function_name": "exit_creds",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "157-176",
    "snippet": "void exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_cred",
          "args": [
            "cred"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "__put_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "135-151",
          "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "alter_cred_subscribers",
          "args": [
            "cred",
            "-1"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "alter_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "84-91",
          "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "validate_creds",
          "args": [
            "cred"
          ],
          "line": 173
        },
        "resolved": true,
        "details": {
          "function_name": "validate_creds_for_do_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "808-816",
          "snippet": "void validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid validate_creds_for_do_exit(struct task_struct *tsk)\n{\n\tkdebug(\"validate_creds_for_do_exit(%p,%p{%d,%d})\",\n\t       tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\t__validate_process_creds(tsk, __FILE__, __LINE__);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"exit_creds(%u,%p,%p,{%d,%d})\"",
            "tsk->pid",
            "tsk->real_cred",
            "tsk->cred",
            "atomic_read(&tsk->cred->usage)",
            "read_cred_subscribers(tsk->cred)"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "tsk->cred"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&tsk->cred->usage"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid exit_creds(struct task_struct *tsk)\n{\n\tstruct cred *cred;\n\n\tkdebug(\"exit_creds(%u,%p,%p,{%d,%d})\", tsk->pid, tsk->real_cred, tsk->cred,\n\t       atomic_read(&tsk->cred->usage),\n\t       read_cred_subscribers(tsk->cred));\n\n\tcred = (struct cred *) tsk->real_cred;\n\ttsk->real_cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n\n\tcred = (struct cred *) tsk->cred;\n\ttsk->cred = NULL;\n\tvalidate_creds(cred);\n\talter_cred_subscribers(cred, -1);\n\tput_cred(cred);\n}"
  },
  {
    "function_name": "__put_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "135-151",
    "snippet": "void __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu",
          "args": [
            "&cred->rcu",
            "put_cred_rcu"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "call_rcu_tasks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "552-567",
          "snippet": "void call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid call_rcu_tasks(struct rcu_head *rhp, rcu_callback_t func)\n{\n\tunsigned long flags;\n\tbool needwake;\n\n\trhp->next = NULL;\n\trhp->func = func;\n\traw_spin_lock_irqsave(&rcu_tasks_cbs_lock, flags);\n\tneedwake = !rcu_tasks_cbs_head;\n\t*rcu_tasks_cbs_tail = rhp;\n\trcu_tasks_cbs_tail = &rhp->next;\n\traw_spin_unlock_irqrestore(&rcu_tasks_cbs_lock, flags);\n\t/* We can't create the thread unless interrupts are enabled. */\n\tif (needwake && READ_ONCE(rcu_tasks_kthread_ptr))\n\t\twake_up(&rcu_tasks_cbs_wq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cred == current->real_cred"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "cred == current->cred"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__builtin_return_address",
          "args": [
            "0"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "read_cred_subscribers(cred) != 0"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "atomic_read(&cred->usage) != 0"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"__put_cred(%p{%d,%d})\"",
            "cred",
            "atomic_read(&cred->usage)",
            "read_cred_subscribers(cred)"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nvoid __put_cred(struct cred *cred)\n{\n\tkdebug(\"__put_cred(%p{%d,%d})\", cred,\n\t       atomic_read(&cred->usage),\n\t       read_cred_subscribers(cred));\n\n\tBUG_ON(atomic_read(&cred->usage) != 0);\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tBUG_ON(read_cred_subscribers(cred) != 0);\n\tcred->magic = CRED_MAGIC_DEAD;\n\tcred->put_addr = __builtin_return_address(0);\n#endif\n\tBUG_ON(cred == current->cred);\n\tBUG_ON(cred == current->real_cred);\n\n\tcall_rcu(&cred->rcu, put_cred_rcu);\n}"
  },
  {
    "function_name": "put_cred_rcu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "96-127",
    "snippet": "static void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *cred_jar;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "cred_jar",
            "cred"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_user_ns",
          "args": [
            "cred->user_ns"
          ],
          "line": 125
        },
        "resolved": true,
        "details": {
          "function_name": "__put_user_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "209-212",
          "snippet": "void __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void free_user_ns(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nstatic void free_user_ns(struct work_struct *work);\n\nvoid __put_user_ns(struct user_namespace *ns)\n{\n\tschedule_work(&ns->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "cred->user"
          ],
          "line": 124
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "put_group_info",
          "args": [
            "cred->group_info"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->request_key_auth"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->thread_keyring"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->process_keyring"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "key_put",
          "args": [
            "cred->session_keyring"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_cred_free",
          "args": [
            "cred"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "panic",
          "args": [
            "\"CRED: put_cred_rcu() sees %p with usage %d\\n\"",
            "cred",
            "atomic_read(&cred->usage)"
          ],
          "line": 113
        },
        "resolved": true,
        "details": {
          "function_name": "panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "135-307",
          "snippet": "void panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [
            "#define PANIC_BLINK_SPD 18",
            "#define PANIC_TIMER_STEP 100"
          ],
          "globals_used": [
            "bool crash_kexec_post_notifiers;",
            "int panic_timeout = CONFIG_PANIC_TIMEOUT;",
            "long (*panic_blink)(int state);",
            "atomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\n#define PANIC_BLINK_SPD 18\n#define PANIC_TIMER_STEP 100\n\nbool crash_kexec_post_notifiers;\nint panic_timeout = CONFIG_PANIC_TIMEOUT;\nlong (*panic_blink)(int state);\natomic_t panic_cpu = ATOMIC_INIT(PANIC_CPU_INVALID);\n\nvoid panic(const char *fmt, ...)\n{\n\tstatic char buf[1024];\n\tva_list args;\n\tlong i, i_next = 0, len;\n\tint state = 0;\n\tint old_cpu, this_cpu;\n\tbool _crash_kexec_post_notifiers = crash_kexec_post_notifiers;\n\n\t/*\n\t * Disable local interrupts. This will prevent panic_smp_self_stop\n\t * from deadlocking the first cpu that invokes the panic, since\n\t * there is nothing to prevent an interrupt handler (that runs\n\t * after setting panic_cpu) from invoking panic() again.\n\t */\n\tlocal_irq_disable();\n\n\t/*\n\t * It's possible to come here directly from a panic-assertion and\n\t * not have preempt disabled. Some functions called from here want\n\t * preempt to be disabled. No point enabling it later though...\n\t *\n\t * Only one CPU is allowed to execute the panic code from here. For\n\t * multiple parallel invocations of panic, all other CPUs either\n\t * stop themself or will wait until they are stopped by the 1st CPU\n\t * with smp_send_stop().\n\t *\n\t * `old_cpu == PANIC_CPU_INVALID' means this is the 1st CPU which\n\t * comes here, so go ahead.\n\t * `old_cpu == this_cpu' means we came from nmi_panic() which sets\n\t * panic_cpu to this CPU.  In this case, this is also the 1st CPU.\n\t */\n\tthis_cpu = raw_smp_processor_id();\n\told_cpu  = atomic_cmpxchg(&panic_cpu, PANIC_CPU_INVALID, this_cpu);\n\n\tif (old_cpu != PANIC_CPU_INVALID && old_cpu != this_cpu)\n\t\tpanic_smp_self_stop();\n\n\tconsole_verbose();\n\tbust_spinlocks(1);\n\tva_start(args, fmt);\n\tlen = vscnprintf(buf, sizeof(buf), fmt, args);\n\tva_end(args);\n\n\tif (len && buf[len - 1] == '\\n')\n\t\tbuf[len - 1] = '\\0';\n\n\tpr_emerg(\"Kernel panic - not syncing: %s\\n\", buf);\n#ifdef CONFIG_DEBUG_BUGVERBOSE\n\t/*\n\t * Avoid nested stack-dumping if a panic occurs during oops processing\n\t */\n\tif (!test_taint(TAINT_DIE) && oops_in_progress <= 1)\n\t\tdump_stack();\n#endif\n\n\t/*\n\t * If we have crashed and we have a crash kernel loaded let it handle\n\t * everything else.\n\t * If we want to run this after calling panic_notifiers, pass\n\t * the \"crash_kexec_post_notifiers\" option to the kernel.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (!_crash_kexec_post_notifiers) {\n\t\tprintk_safe_flush_on_panic();\n\t\t__crash_kexec(NULL);\n\n\t\t/*\n\t\t * Note smp_send_stop is the usual smp shutdown function, which\n\t\t * unfortunately means it may not be hardened to work in a\n\t\t * panic situation.\n\t\t */\n\t\tsmp_send_stop();\n\t} else {\n\t\t/*\n\t\t * If we want to do crash dump after notifier calls and\n\t\t * kmsg_dump, we will need architecture dependent extra\n\t\t * works in addition to stopping other CPUs.\n\t\t */\n\t\tcrash_smp_send_stop();\n\t}\n\n\t/*\n\t * Run any panic handlers, including those that might need to\n\t * add information to the kmsg dump output.\n\t */\n\tatomic_notifier_call_chain(&panic_notifier_list, 0, buf);\n\n\t/* Call flush even twice. It tries harder with a single online CPU */\n\tprintk_safe_flush_on_panic();\n\tkmsg_dump(KMSG_DUMP_PANIC);\n\n\t/*\n\t * If you doubt kdump always works fine in any situation,\n\t * \"crash_kexec_post_notifiers\" offers you a chance to run\n\t * panic_notifiers and dumping kmsg before kdump.\n\t * Note: since some panic_notifiers can make crashed kernel\n\t * more unstable, it can increase risks of the kdump failure too.\n\t *\n\t * Bypass the panic_cpu check and call __crash_kexec directly.\n\t */\n\tif (_crash_kexec_post_notifiers)\n\t\t__crash_kexec(NULL);\n\n\tbust_spinlocks(0);\n\n\t/*\n\t * We may have ended up stopping the CPU holding the lock (in\n\t * smp_send_stop()) while still having some valuable data in the console\n\t * buffer.  Try to acquire the lock then release it regardless of the\n\t * result.  The release will also print the buffers out.  Locks debug\n\t * should be disabled to avoid reporting bad unlock balance when\n\t * panic() is not being callled from OOPS.\n\t */\n\tdebug_locks_off();\n\tconsole_flush_on_panic();\n\n\tif (!panic_blink)\n\t\tpanic_blink = no_blink;\n\n\tif (panic_timeout > 0) {\n\t\t/*\n\t\t * Delay timeout seconds before rebooting the machine.\n\t\t * We can't use the \"normal\" timers since we just panicked.\n\t\t */\n\t\tpr_emerg(\"Rebooting in %d seconds..\\n\", panic_timeout);\n\n\t\tfor (i = 0; i < panic_timeout * 1000; i += PANIC_TIMER_STEP) {\n\t\t\ttouch_nmi_watchdog();\n\t\t\tif (i >= i_next) {\n\t\t\t\ti += panic_blink(state ^= 1);\n\t\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t\t}\n\t\t\tmdelay(PANIC_TIMER_STEP);\n\t\t}\n\t}\n\tif (panic_timeout != 0) {\n\t\t/*\n\t\t * This will not be a clean reboot, with everything\n\t\t * shutting down.  But if there is a chance of\n\t\t * rebooting the system it will be rebooted.\n\t\t */\n\t\temergency_restart();\n\t}\n#ifdef __sparc__\n\t{\n\t\textern int stop_a_enabled;\n\t\t/* Make sure the user can actually press Stop-A (L1-A) */\n\t\tstop_a_enabled = 1;\n\t\tpr_emerg(\"Press Stop-A (L1-A) from sun keyboard or send break\\n\"\n\t\t\t \"twice on console to return to the boot prom\\n\");\n\t}\n#endif\n#if defined(CONFIG_S390)\n\t{\n\t\tunsigned long caller;\n\n\t\tcaller = (unsigned long)__builtin_return_address(0);\n\t\tdisabled_wait(caller);\n\t}\n#endif\n\tpr_emerg(\"---[ end Kernel panic - not syncing: %s ]---\\n\", buf);\n\tlocal_irq_enable();\n\tfor (i = 0; ; i += PANIC_TIMER_STEP) {\n\t\ttouch_softlockup_watchdog();\n\t\tif (i >= i_next) {\n\t\t\ti += panic_blink(state ^= 1);\n\t\t\ti_next = i + 3600 / PANIC_BLINK_SPD;\n\t\t}\n\t\tmdelay(PANIC_TIMER_STEP);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_cred_subscribers",
          "args": [
            "cred"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "read_cred_subscribers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
          "lines": "75-82",
          "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
          "includes": [
            "#include <linux/cn_proc.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/security.h>",
            "#include <linux/init_task.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/key.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/cred.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->usage"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdebug",
          "args": [
            "\"put_cred_rcu(%p)\"",
            "cred"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "rcu",
            "structcred",
            "rcu"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic struct kmem_cache *cred_jar;\n\nstatic void put_cred_rcu(struct rcu_head *rcu)\n{\n\tstruct cred *cred = container_of(rcu, struct cred, rcu);\n\n\tkdebug(\"put_cred_rcu(%p)\", cred);\n\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tif (cred->magic != CRED_MAGIC_DEAD ||\n\t    atomic_read(&cred->usage) != 0 ||\n\t    read_cred_subscribers(cred) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with\"\n\t\t      \" mag %x, put %p, usage %d, subscr %d\\n\",\n\t\t      cred, cred->magic, cred->put_addr,\n\t\t      atomic_read(&cred->usage),\n\t\t      read_cred_subscribers(cred));\n#else\n\tif (atomic_read(&cred->usage) != 0)\n\t\tpanic(\"CRED: put_cred_rcu() sees %p with usage %d\\n\",\n\t\t      cred, atomic_read(&cred->usage));\n#endif\n\n\tsecurity_cred_free(cred);\n\tkey_put(cred->session_keyring);\n\tkey_put(cred->process_keyring);\n\tkey_put(cred->thread_keyring);\n\tkey_put(cred->request_key_auth);\n\tif (cred->group_info)\n\t\tput_group_info(cred->group_info);\n\tfree_uid(cred->user);\n\tput_user_ns(cred->user_ns);\n\tkmem_cache_free(cred_jar, cred);\n}"
  },
  {
    "function_name": "alter_cred_subscribers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "84-91",
    "snippet": "static inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_add",
          "args": [
            "n",
            "&cred->subscribers"
          ],
          "line": 89
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void alter_cred_subscribers(const struct cred *_cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tstruct cred *cred = (struct cred *) _cred;\n\n\tatomic_add(n, &cred->subscribers);\n#endif\n}"
  },
  {
    "function_name": "read_cred_subscribers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "75-82",
    "snippet": "static inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&cred->subscribers"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline int read_cred_subscribers(const struct cred *cred)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\treturn atomic_read(&cred->subscribers);\n#else\n\treturn 0;\n#endif\n}"
  },
  {
    "function_name": "set_cred_subscribers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cred.c",
    "lines": "68-73",
    "snippet": "static inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}",
    "includes": [
      "#include <linux/cn_proc.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/security.h>",
      "#include <linux/init_task.h>",
      "#include <linux/keyctl.h>",
      "#include <linux/key.h>",
      "#include <linux/sched/coredump.h>",
      "#include <linux/sched.h>",
      "#include <linux/slab.h>",
      "#include <linux/cred.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&cred->subscribers",
            "n"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/cn_proc.h>\n#include <linux/binfmts.h>\n#include <linux/security.h>\n#include <linux/init_task.h>\n#include <linux/keyctl.h>\n#include <linux/key.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/cred.h>\n#include <linux/export.h>\n\nstatic inline void set_cred_subscribers(struct cred *cred, int n)\n{\n#ifdef CONFIG_DEBUG_CREDENTIALS\n\tatomic_set(&cred->subscribers, n);\n#endif\n}"
  }
]