[
  {
    "function_name": "ntp_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "1033-1036",
    "snippet": "void __init ntp_init(void)\n{\n\tntp_clear();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_clear",
          "args": [],
          "line": 1035
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "350-365",
          "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_adjust;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid __init ntp_init(void)\n{\n\tntp_clear();\n}"
  },
  {
    "function_name": "ntp_tick_adj_setup",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "1021-1029",
    "snippet": "static int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtos64(str, 0, &ntp_tick_adj);\n\tif (rc)\n\t\treturn rc;\n\n\tntp_tick_adj <<= NTP_SCALE_SHIFT;\n\treturn 1;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static s64\t\t\tntp_tick_adj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrtos64",
          "args": [
            "str",
            "0",
            "&ntp_tick_adj"
          ],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic s64\t\t\tntp_tick_adj;\n\nstatic int __init ntp_tick_adj_setup(char *str)\n{\n\tint rc = kstrtos64(str, 0, &ntp_tick_adj);\n\tif (rc)\n\t\treturn rc;\n\n\tntp_tick_adj <<= NTP_SCALE_SHIFT;\n\treturn 1;\n}"
  },
  {
    "function_name": "__hardpps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "971-1018",
    "snippet": "void __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hardpps_update_phase",
          "args": [
            "pts_norm.nsec"
          ],
          "line": 1016
        },
        "resolved": true,
        "details": {
          "function_name": "hardpps_update_phase",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "929-957",
          "snippet": "static void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */",
            "#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_adjust;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_adjust;\n\nstatic void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hardpps_update_freq",
          "args": [
            "freq_norm"
          ],
          "line": 1013
        },
        "resolved": true,
        "details": {
          "function_name": "hardpps_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "873-926",
          "snippet": "static long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */",
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
          ],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_freq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_freq;\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_normalize_ts",
          "args": [
            "timespec64_sub(*raw_ts, pps_fbase)"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "pps_normalize_ts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "802-815",
          "snippet": "static inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_sub",
          "args": [
            "*raw_ts",
            "pps_fbase"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "pps_fbase.tv_sec == 0"
          ],
          "line": 986
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_VALID\t10\t/* PPS signal watchdog max (s) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nvoid __hardpps(const struct timespec64 *phase_ts, const struct timespec64 *raw_ts)\n{\n\tstruct pps_normtime pts_norm, freq_norm;\n\n\tpts_norm = pps_normalize_ts(*phase_ts);\n\n\t/* clear the error bits, they will be set again if needed */\n\ttime_status &= ~(STA_PPSJITTER | STA_PPSWANDER | STA_PPSERROR);\n\n\t/* indicate signal presence */\n\ttime_status |= STA_PPSSIGNAL;\n\tpps_valid = PPS_VALID;\n\n\t/* when called for the first time,\n\t * just start the frequency interval */\n\tif (unlikely(pps_fbase.tv_sec == 0)) {\n\t\tpps_fbase = *raw_ts;\n\t\treturn;\n\t}\n\n\t/* ok, now we have a base for frequency calculation */\n\tfreq_norm = pps_normalize_ts(timespec64_sub(*raw_ts, pps_fbase));\n\n\t/* check that the signal is in the range\n\t * [1s - MAXFREQ us, 1s + MAXFREQ us], otherwise reject it */\n\tif ((freq_norm.sec == 0) ||\n\t\t\t(freq_norm.nsec > MAXFREQ * freq_norm.sec) ||\n\t\t\t(freq_norm.nsec < -MAXFREQ * freq_norm.sec)) {\n\t\ttime_status |= STA_PPSJITTER;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\tprintk_deferred(KERN_ERR \"hardpps: PPSJITTER: bad pulse\\n\");\n\t\treturn;\n\t}\n\n\t/* signal is ok */\n\n\t/* check if the current frequency interval is finished */\n\tif (freq_norm.sec >= (1 << pps_shift)) {\n\t\tpps_calcnt++;\n\t\t/* restart the frequency calibration interval */\n\t\tpps_fbase = *raw_ts;\n\t\thardpps_update_freq(freq_norm);\n\t}\n\n\thardpps_update_phase(pts_norm.nsec);\n\n}"
  },
  {
    "function_name": "hardpps_update_phase",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "929-957",
    "snippet": "static void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */",
      "#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_adjust;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)correction) << NTP_SCALE_SHIFT",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 950
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\"",
            "jitter",
            "(pps_jitter << PPS_POPCORN)"
          ],
          "line": 943
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_phase_filter_get",
          "args": [
            "&jitter"
          ],
          "line": 936
        },
        "resolved": true,
        "details": {
          "function_name": "pps_phase_filter_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "818-826",
          "snippet": "static inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_phase_filter_add",
          "args": [
            "correction"
          ],
          "line": 935
        },
        "resolved": true,
        "details": {
          "function_name": "pps_phase_filter_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "829-834",
          "snippet": "static inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n#define PPS_POPCORN\t4\t/* popcorn spike threshold (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_adjust;\n\nstatic void hardpps_update_phase(long error)\n{\n\tlong correction = -error;\n\tlong jitter;\n\n\t/* add the sample to the median filter */\n\tpps_phase_filter_add(correction);\n\tcorrection = pps_phase_filter_get(&jitter);\n\n\t/* Nominal jitter is due to PPS signal noise. If it exceeds the\n\t * threshold, the sample is discarded; otherwise, if so enabled,\n\t * the time offset is updated.\n\t */\n\tif (jitter > (pps_jitter << PPS_POPCORN)) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSJITTER: jitter=%ld, limit=%ld\\n\",\n\t\t\t\tjitter, (pps_jitter << PPS_POPCORN));\n\t\ttime_status |= STA_PPSJITTER;\n\t\tpps_jitcnt++;\n\t} else if (time_status & STA_PPSTIME) {\n\t\t/* correct the time using the phase offset */\n\t\ttime_offset = div_s64(((s64)correction) << NTP_SCALE_SHIFT,\n\t\t\t\tNTP_INTERVAL_FREQ);\n\t\t/* cancel running adjtime() */\n\t\ttime_adjust = 0;\n\t}\n\t/* update jitter */\n\tpps_jitter += (jitter - pps_jitter) >> PPS_INTMIN;\n}"
  },
  {
    "function_name": "hardpps_update_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "873-926",
    "snippet": "static long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */",
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_freq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 922
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "258-278",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC)",
            "NSEC_PER_USEC"
          ],
          "line": 914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_inc_freq_interval",
          "args": [],
          "line": 904
        },
        "resolved": true,
        "details": {
          "function_name": "pps_inc_freq_interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "853-862",
          "snippet": "static inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
            "#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */\n\nstatic inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_dec_freq_interval",
          "args": [],
          "line": 902
        },
        "resolved": true,
        "details": {
          "function_name": "pps_dec_freq_interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "839-848",
          "snippet": "static inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [
            "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
            "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk_deferred",
          "args": [
            "KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\"",
            "delta"
          ],
          "line": 898
        },
        "resolved": true,
        "details": {
          "function_name": "printk_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "2926-2936",
          "snippet": "int printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nint printk_deferred(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n\n\tva_start(args, fmt);\n\tr = vprintk_deferred(fmt, args);\n\tva_end(args);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "ftemp - pps_freq",
            "NTP_SCALE_SHIFT"
          ],
          "line": 895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT",
            "freq_norm.sec"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "-freq_norm.nsec"
          ],
          "line": 893
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_MAXWANDER\t100000\t/* max PPS freq wander (ns/s) */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_freq;\n\nstatic long hardpps_update_freq(struct pps_normtime freq_norm)\n{\n\tlong delta, delta_mod;\n\ts64 ftemp;\n\n\t/* check if the frequency interval was too long */\n\tif (freq_norm.sec > (2 << pps_shift)) {\n\t\ttime_status |= STA_PPSERROR;\n\t\tpps_errcnt++;\n\t\tpps_dec_freq_interval();\n\t\tprintk_deferred(KERN_ERR\n\t\t\t\"hardpps: PPSERROR: interval too long - %lld s\\n\",\n\t\t\tfreq_norm.sec);\n\t\treturn 0;\n\t}\n\n\t/* here the raw frequency offset and wander (stability) is\n\t * calculated. If the wander is less than the wander threshold\n\t * the interval is increased; otherwise it is decreased.\n\t */\n\tftemp = div_s64(((s64)(-freq_norm.nsec)) << NTP_SCALE_SHIFT,\n\t\t\tfreq_norm.sec);\n\tdelta = shift_right(ftemp - pps_freq, NTP_SCALE_SHIFT);\n\tpps_freq = ftemp;\n\tif (delta > PPS_MAXWANDER || delta < -PPS_MAXWANDER) {\n\t\tprintk_deferred(KERN_WARNING\n\t\t\t\t\"hardpps: PPSWANDER: change=%ld\\n\", delta);\n\t\ttime_status |= STA_PPSWANDER;\n\t\tpps_stbcnt++;\n\t\tpps_dec_freq_interval();\n\t} else {\t/* good sample */\n\t\tpps_inc_freq_interval();\n\t}\n\n\t/* the stability metric is calculated as the average of recent\n\t * frequency changes, but is used only for performance\n\t * monitoring\n\t */\n\tdelta_mod = delta;\n\tif (delta_mod < 0)\n\t\tdelta_mod = -delta_mod;\n\tpps_stabil += (div_s64(((s64)delta_mod) <<\n\t\t\t\t(NTP_SCALE_SHIFT - SHIFT_USEC),\n\t\t\t\tNSEC_PER_USEC) - pps_stabil) >> PPS_INTMIN;\n\n\t/* if enabled, the system clock frequency is updated */\n\tif ((time_status & STA_PPSFREQ) != 0 &&\n\t    (time_status & STA_FREQHOLD) == 0) {\n\t\ttime_freq = pps_freq;\n\t\tntp_update_frequency();\n\t}\n\n\treturn delta;\n}"
  },
  {
    "function_name": "pps_inc_freq_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "853-862",
    "snippet": "static inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
      "#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMAX\t8\t/* max freq interval (s) (shift) */\n\nstatic inline void pps_inc_freq_interval(void)\n{\n\tif (++pps_intcnt >= PPS_INTCOUNT) {\n\t\tpps_intcnt = PPS_INTCOUNT;\n\t\tif (pps_shift < PPS_INTMAX) {\n\t\t\tpps_shift++;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pps_dec_freq_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "839-848",
    "snippet": "static inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */",
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTCOUNT\t4\t/* number of consecutive good intervals to\n\t\t\t\t   increase pps_shift or consecutive bad\n\t\t\t\t   intervals to decrease it */\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_dec_freq_interval(void)\n{\n\tif (--pps_intcnt <= -PPS_INTCOUNT) {\n\t\tpps_intcnt = -PPS_INTCOUNT;\n\t\tif (pps_shift > PPS_INTMIN) {\n\t\t\tpps_shift--;\n\t\t\tpps_intcnt = 0;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "pps_phase_filter_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "829-834",
    "snippet": "static inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_phase_filter_add(long err)\n{\n\tpps_tf[2] = pps_tf[1];\n\tpps_tf[1] = pps_tf[0];\n\tpps_tf[0] = err;\n}"
  },
  {
    "function_name": "pps_phase_filter_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "818-826",
    "snippet": "static inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline long pps_phase_filter_get(long *jitter)\n{\n\t*jitter = pps_tf[0] - pps_tf[1];\n\tif (*jitter < 0)\n\t\t*jitter = -*jitter;\n\n\t/* TODO: test various filters */\n\treturn pps_tf[0];\n}"
  },
  {
    "function_name": "pps_normalize_ts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "802-815",
    "snippet": "static inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline struct pps_normtime pps_normalize_ts(struct timespec64 ts)\n{\n\tstruct pps_normtime norm = {\n\t\t.sec = ts.tv_sec,\n\t\t.nsec = ts.tv_nsec\n\t};\n\n\tif (norm.nsec > (NSEC_PER_SEC >> 1)) {\n\t\tnorm.nsec -= NSEC_PER_SEC;\n\t\tnorm.sec++;\n\t}\n\n\treturn norm;\n}"
  },
  {
    "function_name": "__do_adjtimex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "719-787",
    "snippet": "int __do_adjtimex(struct timex *txc, const struct timespec64 *ts, s32 *time_tai)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes)\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset /= NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = (time_t)ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec /= NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_constant = 2;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static s64\t\t\ttime_freq;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ts->tv_sec >= ntp_next_leap_sec"
          ],
          "line": 769
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_fill_timex",
          "args": [
            "txc"
          ],
          "line": 761
        },
        "resolved": true,
        "details": {
          "function_name": "pps_fill_timex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "224-235",
          "snippet": "static inline void pps_fill_timex(struct timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_fill_timex(struct timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "(time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV",
            "NTP_SCALE_SHIFT"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_error_status",
          "args": [
            "time_status"
          ],
          "line": 746
        },
        "resolved": true,
        "details": {
          "function_name": "is_error_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "219-222",
          "snippet": "static inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}"
        }
      },
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "time_offset * NTP_INTERVAL_FREQ",
            "NTP_SCALE_SHIFT"
          ],
          "line": 738
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "process_adjtimex_modes",
          "args": [
            "txc",
            "time_tai"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "process_adjtimex_modes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "668-712",
          "snippet": "static inline void process_adjtimex_modes(const struct timex *txc, s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI && txc->constant > 0)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static long\t\t\ttime_constant = 2;",
            "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
            "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
            "static s64\t\t\ttime_freq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\n\nstatic inline void process_adjtimex_modes(const struct timex *txc, s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI && txc->constant > 0)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "258-278",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint __do_adjtimex(struct timex *txc, const struct timespec64 *ts, s32 *time_tai)\n{\n\tint result;\n\n\tif (txc->modes & ADJ_ADJTIME) {\n\t\tlong save_adjust = time_adjust;\n\n\t\tif (!(txc->modes & ADJ_OFFSET_READONLY)) {\n\t\t\t/* adjtime() is independent from ntp_adjtime() */\n\t\t\ttime_adjust = txc->offset;\n\t\t\tntp_update_frequency();\n\t\t}\n\t\ttxc->offset = save_adjust;\n\t} else {\n\n\t\t/* If there are input parameters, then process them: */\n\t\tif (txc->modes)\n\t\t\tprocess_adjtimex_modes(txc, time_tai);\n\n\t\ttxc->offset = shift_right(time_offset * NTP_INTERVAL_FREQ,\n\t\t\t\t  NTP_SCALE_SHIFT);\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttxc->offset /= NSEC_PER_USEC;\n\t}\n\n\tresult = time_state;\t/* mostly `TIME_OK' */\n\t/* check for errors */\n\tif (is_error_status(time_status))\n\t\tresult = TIME_ERROR;\n\n\ttxc->freq\t   = shift_right((time_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->maxerror\t   = time_maxerror;\n\ttxc->esterror\t   = time_esterror;\n\ttxc->status\t   = time_status;\n\ttxc->constant\t   = time_constant;\n\ttxc->precision\t   = 1;\n\ttxc->tolerance\t   = MAXFREQ_SCALED / PPM_SCALE;\n\ttxc->tick\t   = tick_usec;\n\ttxc->tai\t   = *time_tai;\n\n\t/* fill PPS status fields */\n\tpps_fill_timex(txc);\n\n\ttxc->time.tv_sec = (time_t)ts->tv_sec;\n\ttxc->time.tv_usec = ts->tv_nsec;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->time.tv_usec /= NSEC_PER_USEC;\n\n\t/* Handle leapsec adjustments */\n\tif (unlikely(ts->tv_sec >= ntp_next_leap_sec)) {\n\t\tif ((time_state == TIME_INS) && (time_status & STA_INS)) {\n\t\t\tresult = TIME_OOP;\n\t\t\ttxc->tai++;\n\t\t\ttxc->time.tv_sec--;\n\t\t}\n\t\tif ((time_state == TIME_DEL) && (time_status & STA_DEL)) {\n\t\t\tresult = TIME_WAIT;\n\t\t\ttxc->tai--;\n\t\t\ttxc->time.tv_sec++;\n\t\t}\n\t\tif ((time_state == TIME_OOP) &&\n\t\t\t\t\t(ts->tv_sec == ntp_next_leap_sec)) {\n\t\t\tresult = TIME_WAIT;\n\t\t}\n\t}\n\n\treturn result;\n}"
  },
  {
    "function_name": "process_adjtimex_modes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "668-712",
    "snippet": "static inline void process_adjtimex_modes(const struct timex *txc, s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI && txc->constant > 0)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static long\t\t\ttime_constant = 2;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static s64\t\t\ttime_freq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 711
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "258-278",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_update_offset",
          "args": [
            "txc->offset"
          ],
          "line": 705
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "295-345",
          "snippet": "static void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static s64\t\t\ttime_offset;",
            "static long\t\t\ttime_constant = 2;",
            "static s64\t\t\ttime_freq;",
            "static time64_t\t\ttime_reftime;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic s64\t\t\ttime_freq;\nstatic time64_t\t\ttime_reftime;\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "time_constant",
            "0l"
          ],
          "line": 698
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "time_constant",
            "(long)MAXTC"
          ],
          "line": 697
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_set_freq",
          "args": [
            "time_freq"
          ],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "pps_set_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "217-217",
          "snippet": "static inline void pps_set_freq(s64 freq) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq) {}"
        }
      },
      {
        "call_info": {
          "callee": "process_adj_status",
          "args": [
            "txc"
          ],
          "line": 671
        },
        "resolved": true,
        "details": {
          "function_name": "process_adj_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "645-665",
          "snippet": "static inline void process_adj_status(const struct timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_state = TIME_OK;",
            "static int\t\t\ttime_status = STA_UNSYNC;",
            "static time64_t\t\ttime_reftime;",
            "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\ttime_reftime;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nstatic inline void process_adj_status(const struct timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic s64\t\t\ttime_freq;\n\nstatic inline void process_adjtimex_modes(const struct timex *txc, s32 *time_tai)\n{\n\tif (txc->modes & ADJ_STATUS)\n\t\tprocess_adj_status(txc);\n\n\tif (txc->modes & ADJ_NANO)\n\t\ttime_status |= STA_NANO;\n\n\tif (txc->modes & ADJ_MICRO)\n\t\ttime_status &= ~STA_NANO;\n\n\tif (txc->modes & ADJ_FREQUENCY) {\n\t\ttime_freq = txc->freq * PPM_SCALE;\n\t\ttime_freq = min(time_freq, MAXFREQ_SCALED);\n\t\ttime_freq = max(time_freq, -MAXFREQ_SCALED);\n\t\t/* update pps_freq */\n\t\tpps_set_freq(time_freq);\n\t}\n\n\tif (txc->modes & ADJ_MAXERROR)\n\t\ttime_maxerror = txc->maxerror;\n\n\tif (txc->modes & ADJ_ESTERROR)\n\t\ttime_esterror = txc->esterror;\n\n\tif (txc->modes & ADJ_TIMECONST) {\n\t\ttime_constant = txc->constant;\n\t\tif (!(time_status & STA_NANO))\n\t\t\ttime_constant += 4;\n\t\ttime_constant = min(time_constant, (long)MAXTC);\n\t\ttime_constant = max(time_constant, 0l);\n\t}\n\n\tif (txc->modes & ADJ_TAI && txc->constant > 0)\n\t\t*time_tai = txc->constant;\n\n\tif (txc->modes & ADJ_OFFSET)\n\t\tntp_update_offset(txc->offset);\n\n\tif (txc->modes & ADJ_TICK)\n\t\ttick_usec = txc->tick;\n\n\tif (txc->modes & (ADJ_TICK|ADJ_FREQUENCY|ADJ_OFFSET))\n\t\tntp_update_frequency();\n}"
  },
  {
    "function_name": "process_adj_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "645-665",
    "snippet": "static inline void process_adj_status(const struct timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static time64_t\t\ttime_reftime;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pps_reset_freq_interval",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "pps_reset_freq_interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "214-214",
          "snippet": "static inline void pps_reset_freq_interval(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\ttime_reftime;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nstatic inline void process_adj_status(const struct timex *txc)\n{\n\tif ((time_status & STA_PLL) && !(txc->status & STA_PLL)) {\n\t\ttime_state = TIME_OK;\n\t\ttime_status = STA_UNSYNC;\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t/* restart PPS frequency calibration */\n\t\tpps_reset_freq_interval();\n\t}\n\n\t/*\n\t * If we turn on PLL adjustments then reset the\n\t * reference time to current time.\n\t */\n\tif (!(time_status & STA_PLL) && (txc->status & STA_PLL))\n\t\ttime_reftime = __ktime_get_real_seconds();\n\n\t/* only set allowed bits */\n\ttime_status &= STA_RONLY;\n\ttime_status |= txc->status & ~STA_RONLY;\n}"
  },
  {
    "function_name": "ntp_notify_cmos_timer",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "632-640",
    "snippet": "void ntp_notify_cmos_timer(void)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||\n\t    IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\tqueue_delayed_work(system_power_efficient_wq, &sync_work, 0);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_power_efficient_wq",
            "&sync_work",
            "0"
          ],
          "line": 639
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RTC_SYSTOHC"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_CMOS_UPDATE"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_synced",
          "args": [],
          "line": 634
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_synced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "244-247",
          "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nvoid ntp_notify_cmos_timer(void)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE) ||\n\t    IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\tqueue_delayed_work(system_power_efficient_wq, &sync_work, 0);\n}"
  },
  {
    "function_name": "sync_hw_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "621-630",
    "snippet": "static void sync_hw_clock(struct work_struct *work)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (sync_cmos_clock())\n\t\treturn;\n\n\tsync_rtc_clock();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void sync_hw_clock(struct work_struct *work);",
      "static DECLARE_DELAYED_WORK(sync_work, sync_hw_clock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sync_rtc_clock",
          "args": [],
          "line": 629
        },
        "resolved": true,
        "details": {
          "function_name": "sync_rtc_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "531-555",
          "snippet": "static void sync_rtc_clock(void)\n{\n\tunsigned long target_nsec;\n\tstruct timespec64 adjust, now;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\n\tadjust = now;\n\tif (persistent_clock_is_local)\n\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/*\n\t * The current RTC in use will provide the target_nsec it wants to be\n\t * called at, and does rtc_tv_nsec_ok internally.\n\t */\n\trc = rtc_set_ntp_time(adjust, &target_nsec);\n\tif (rc == -ENODEV)\n\t\treturn;\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_rtc_clock(void)\n{\n\tunsigned long target_nsec;\n\tstruct timespec64 adjust, now;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\n\tadjust = now;\n\tif (persistent_clock_is_local)\n\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/*\n\t * The current RTC in use will provide the target_nsec it wants to be\n\t * called at, and does rtc_tv_nsec_ok internally.\n\t */\n\trc = rtc_set_ntp_time(adjust, &target_nsec);\n\tif (rc == -ENODEV)\n\t\treturn;\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sync_cmos_clock",
          "args": [],
          "line": 626
        },
        "resolved": true,
        "details": {
          "function_name": "sync_cmos_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "572-611",
          "snippet": "static bool sync_cmos_clock(void)\n{\n\tstatic bool no_cmos;\n\tstruct timespec64 now;\n\tstruct timespec64 adjust;\n\tint rc = -EPROTO;\n\tlong target_nsec = NSEC_PER_SEC / 2;\n\n\tif (!IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE))\n\t\treturn false;\n\n\tif (no_cmos)\n\t\treturn false;\n\n\t/*\n\t * Historically update_persistent_clock64() has followed x86\n\t * semantics, which match the MC146818A/etc RTC. This RTC will store\n\t * 'adjust' and then in .5s it will advance once second.\n\t *\n\t * Architectures are strongly encouraged to use rtclib and not\n\t * implement this legacy API.\n\t */\n\tktime_get_real_ts64(&now);\n\tif (rtc_tv_nsec_ok(-1 * target_nsec, &adjust, &now)) {\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\t\trc = update_persistent_clock64(adjust);\n\t\t/*\n\t\t * The machine does not support update_persistent_clock64 even\n\t\t * though it defines CONFIG_GENERIC_CMOS_UPDATE.\n\t\t */\n\t\tif (rc == -ENODEV) {\n\t\t\tno_cmos = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n\treturn true;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic bool sync_cmos_clock(void)\n{\n\tstatic bool no_cmos;\n\tstruct timespec64 now;\n\tstruct timespec64 adjust;\n\tint rc = -EPROTO;\n\tlong target_nsec = NSEC_PER_SEC / 2;\n\n\tif (!IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE))\n\t\treturn false;\n\n\tif (no_cmos)\n\t\treturn false;\n\n\t/*\n\t * Historically update_persistent_clock64() has followed x86\n\t * semantics, which match the MC146818A/etc RTC. This RTC will store\n\t * 'adjust' and then in .5s it will advance once second.\n\t *\n\t * Architectures are strongly encouraged to use rtclib and not\n\t * implement this legacy API.\n\t */\n\tktime_get_real_ts64(&now);\n\tif (rtc_tv_nsec_ok(-1 * target_nsec, &adjust, &now)) {\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\t\trc = update_persistent_clock64(adjust);\n\t\t/*\n\t\t * The machine does not support update_persistent_clock64 even\n\t\t * though it defines CONFIG_GENERIC_CMOS_UPDATE.\n\t\t */\n\t\tif (rc == -ENODEV) {\n\t\t\tno_cmos = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_synced",
          "args": [],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_synced",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "244-247",
          "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_hw_clock(struct work_struct *work);\nstatic DECLARE_DELAYED_WORK(sync_work, sync_hw_clock);\n\nstatic void sync_hw_clock(struct work_struct *work)\n{\n\tif (!ntp_synced())\n\t\treturn;\n\n\tif (sync_cmos_clock())\n\t\treturn;\n\n\tsync_rtc_clock();\n}"
  },
  {
    "function_name": "sync_cmos_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "572-611",
    "snippet": "static bool sync_cmos_clock(void)\n{\n\tstatic bool no_cmos;\n\tstruct timespec64 now;\n\tstruct timespec64 adjust;\n\tint rc = -EPROTO;\n\tlong target_nsec = NSEC_PER_SEC / 2;\n\n\tif (!IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE))\n\t\treturn false;\n\n\tif (no_cmos)\n\t\treturn false;\n\n\t/*\n\t * Historically update_persistent_clock64() has followed x86\n\t * semantics, which match the MC146818A/etc RTC. This RTC will store\n\t * 'adjust' and then in .5s it will advance once second.\n\t *\n\t * Architectures are strongly encouraged to use rtclib and not\n\t * implement this legacy API.\n\t */\n\tktime_get_real_ts64(&now);\n\tif (rtc_tv_nsec_ok(-1 * target_nsec, &adjust, &now)) {\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\t\trc = update_persistent_clock64(adjust);\n\t\t/*\n\t\t * The machine does not support update_persistent_clock64 even\n\t\t * though it defines CONFIG_GENERIC_CMOS_UPDATE.\n\t\t */\n\t\tif (rc == -ENODEV) {\n\t\t\tno_cmos = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n\treturn true;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_sync_hw_clock",
          "args": [
            "now",
            "target_nsec",
            "rc"
          ],
          "line": 609
        },
        "resolved": true,
        "details": {
          "function_name": "sched_sync_hw_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "499-529",
          "snippet": "static void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_hw_clock(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_hw_clock(struct work_struct *work);\n\nstatic void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}"
        }
      },
      {
        "call_info": {
          "callee": "update_persistent_clock64",
          "args": [
            "adjust"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "update_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "563-569",
          "snippet": "int __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_tv_nsec_ok",
          "args": [
            "-1 * target_nsec",
            "&adjust",
            "&now"
          ],
          "line": 595
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&now"
          ],
          "line": 594
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_GENERIC_CMOS_UPDATE"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic bool sync_cmos_clock(void)\n{\n\tstatic bool no_cmos;\n\tstruct timespec64 now;\n\tstruct timespec64 adjust;\n\tint rc = -EPROTO;\n\tlong target_nsec = NSEC_PER_SEC / 2;\n\n\tif (!IS_ENABLED(CONFIG_GENERIC_CMOS_UPDATE))\n\t\treturn false;\n\n\tif (no_cmos)\n\t\treturn false;\n\n\t/*\n\t * Historically update_persistent_clock64() has followed x86\n\t * semantics, which match the MC146818A/etc RTC. This RTC will store\n\t * 'adjust' and then in .5s it will advance once second.\n\t *\n\t * Architectures are strongly encouraged to use rtclib and not\n\t * implement this legacy API.\n\t */\n\tktime_get_real_ts64(&now);\n\tif (rtc_tv_nsec_ok(-1 * target_nsec, &adjust, &now)) {\n\t\tif (persistent_clock_is_local)\n\t\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\t\trc = update_persistent_clock64(adjust);\n\t\t/*\n\t\t * The machine does not support update_persistent_clock64 even\n\t\t * though it defines CONFIG_GENERIC_CMOS_UPDATE.\n\t\t */\n\t\tif (rc == -ENODEV) {\n\t\t\tno_cmos = true;\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n\treturn true;\n}"
  },
  {
    "function_name": "update_persistent_clock64",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "563-569",
    "snippet": "int __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "update_persistent_clock",
          "args": [
            "now"
          ],
          "line": 568
        },
        "resolved": true,
        "details": {
          "function_name": "update_persistent_clock64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "563-569",
          "snippet": "int __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_timespec",
          "args": [
            "now64"
          ],
          "line": 567
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nint __weak update_persistent_clock64(struct timespec64 now64)\n{\n\tstruct timespec now;\n\n\tnow = timespec64_to_timespec(now64);\n\treturn update_persistent_clock(now);\n}"
  },
  {
    "function_name": "update_persistent_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "558-561",
    "snippet": "int __weak update_persistent_clock(struct timespec now)\n{\n\treturn -ENODEV;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nint __weak update_persistent_clock(struct timespec now)\n{\n\treturn -ENODEV;\n}"
  },
  {
    "function_name": "sync_rtc_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "531-555",
    "snippet": "static void sync_rtc_clock(void)\n{\n\tunsigned long target_nsec;\n\tstruct timespec64 adjust, now;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\n\tadjust = now;\n\tif (persistent_clock_is_local)\n\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/*\n\t * The current RTC in use will provide the target_nsec it wants to be\n\t * called at, and does rtc_tv_nsec_ok internally.\n\t */\n\trc = rtc_set_ntp_time(adjust, &target_nsec);\n\tif (rc == -ENODEV)\n\t\treturn;\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_sync_hw_clock",
          "args": [
            "now",
            "target_nsec",
            "rc"
          ],
          "line": 554
        },
        "resolved": true,
        "details": {
          "function_name": "sched_sync_hw_clock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "499-529",
          "snippet": "static void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void sync_hw_clock(struct work_struct *work);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_hw_clock(struct work_struct *work);\n\nstatic void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rtc_set_ntp_time",
          "args": [
            "adjust",
            "&target_nsec"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&now"
          ],
          "line": 540
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "IS_ENABLED",
          "args": [
            "CONFIG_RTC_SYSTOHC"
          ],
          "line": 537
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_rtc_clock(void)\n{\n\tunsigned long target_nsec;\n\tstruct timespec64 adjust, now;\n\tint rc;\n\n\tif (!IS_ENABLED(CONFIG_RTC_SYSTOHC))\n\t\treturn;\n\n\tktime_get_real_ts64(&now);\n\n\tadjust = now;\n\tif (persistent_clock_is_local)\n\t\tadjust.tv_sec -= (sys_tz.tz_minuteswest * 60);\n\n\t/*\n\t * The current RTC in use will provide the target_nsec it wants to be\n\t * called at, and does rtc_tv_nsec_ok internally.\n\t */\n\trc = rtc_set_ntp_time(adjust, &target_nsec);\n\tif (rc == -ENODEV)\n\t\treturn;\n\n\tsched_sync_hw_clock(now, target_nsec, rc);\n}"
  },
  {
    "function_name": "sched_sync_hw_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "499-529",
    "snippet": "static void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static void sync_hw_clock(struct work_struct *work);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "queue_delayed_work",
          "args": [
            "system_power_efficient_wq",
            "&sync_work",
            "timespec64_to_jiffies(&next)"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_delayed_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "903-920",
          "snippet": "bool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_delayed_work(struct kthread_worker *worker,\n\t\t\t\tstruct kthread_delayed_work *dwork,\n\t\t\t\tunsigned long delay)\n{\n\tstruct kthread_work *work = &dwork->work;\n\tunsigned long flags;\n\tbool ret = false;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\n\tif (!queuing_blocked(worker, work)) {\n\t\t__kthread_queue_delayed_work(worker, dwork, delay);\n\t\tret = true;\n\t}\n\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "timespec64_to_jiffies",
          "args": [
            "&next"
          ],
          "line": 528
        },
        "resolved": true,
        "details": {
          "function_name": "timespec64_to_jiffies",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "620-624",
          "snippet": "unsigned long\ntimespec64_to_jiffies(const struct timespec64 *value)\n{\n\treturn __timespec64_to_jiffies(value->tv_sec, value->tv_nsec);\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nunsigned long\ntimespec64_to_jiffies(const struct timespec64 *value)\n{\n\treturn __timespec64_to_jiffies(value->tv_sec, value->tv_nsec);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_real_ts64",
          "args": [
            "&next"
          ],
          "line": 505
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "723-741",
          "snippet": "void ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\tu64 nsecs;\n\n\tWARN_ON(timekeeping_suspended);\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\tts->tv_sec = tk->xtime_sec;\n\t\tnsecs = timekeeping_get_ns(&tk->tkr_mono);\n\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n\n\tts->tv_nsec = 0;\n\ttimespec64_add_ns(ts, nsecs);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic void sync_hw_clock(struct work_struct *work);\n\nstatic void sched_sync_hw_clock(struct timespec64 now,\n\t\t\t\tunsigned long target_nsec, bool fail)\n\n{\n\tstruct timespec64 next;\n\n\tktime_get_real_ts64(&next);\n\tif (!fail)\n\t\tnext.tv_sec = 659;\n\telse {\n\t\t/*\n\t\t * Try again as soon as possible. Delaying long periods\n\t\t * decreases the accuracy of the work queue timer. Due to this\n\t\t * the algorithm is very likely to require a short-sleep retry\n\t\t * after the above long sleep to synchronize ts_nsec.\n\t\t */\n\t\tnext.tv_sec = 0;\n\t}\n\n\t/* Compute the needed delay that will get to tv_nsec == target_nsec */\n\tnext.tv_nsec = target_nsec - next.tv_nsec;\n\tif (next.tv_nsec <= 0)\n\t\tnext.tv_nsec += NSEC_PER_SEC;\n\tif (next.tv_nsec >= NSEC_PER_SEC) {\n\t\tnext.tv_sec++;\n\t\tnext.tv_nsec -= NSEC_PER_SEC;\n\t}\n\n\tqueue_delayed_work(system_power_efficient_wq, &sync_work,\n\t\t\t   timespec64_to_jiffies(&next));\n}"
  },
  {
    "function_name": "second_overflow",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "399-494",
    "snippet": "int second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)",
      "#define MAX_TICKADJ\t\t500LL\t\t/* usecs */",
      "#define SECS_PER_DAY\t\t86400"
    ],
    "globals_used": [
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pps_dec_valid",
          "args": [],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "pps_dec_valid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "216-216",
          "snippet": "static inline void pps_dec_valid(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_dec_valid(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_offset_chunk",
          "args": [
            "time_offset"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_offset_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "209-212",
          "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static long\t\t\ttime_constant = 2;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\""
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "secs + 1",
            "SECS_PER_DAY",
            "&rem"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_s64_rem",
          "args": [
            "secs",
            "SECS_PER_DAY",
            "&rem"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define MAX_TICKADJ_SCALED \\\n\t(((MAX_TICKADJ * NSEC_PER_USEC) << NTP_SCALE_SHIFT) / NTP_INTERVAL_FREQ)\n#define MAX_TICKADJ\t\t500LL\t\t/* usecs */\n#define SECS_PER_DAY\t\t86400\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nint second_overflow(time64_t secs)\n{\n\ts64 delta;\n\tint leap = 0;\n\ts32 rem;\n\n\t/*\n\t * Leap second processing. If in leap-insert state at the end of the\n\t * day, the system clock is set back one second; if in leap-delete\n\t * state, the system clock is set ahead one second.\n\t */\n\tswitch (time_state) {\n\tcase TIME_OK:\n\t\tif (time_status & STA_INS) {\n\t\t\ttime_state = TIME_INS;\n\t\t\tdiv_s64_rem(secs, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t} else if (time_status & STA_DEL) {\n\t\t\ttime_state = TIME_DEL;\n\t\t\tdiv_s64_rem(secs + 1, SECS_PER_DAY, &rem);\n\t\t\tntp_next_leap_sec = secs + SECS_PER_DAY - rem;\n\t\t}\n\t\tbreak;\n\tcase TIME_INS:\n\t\tif (!(time_status & STA_INS)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = -1;\n\t\t\ttime_state = TIME_OOP;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: inserting leap second 23:59:60 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_DEL:\n\t\tif (!(time_status & STA_DEL)) {\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_OK;\n\t\t} else if (secs == ntp_next_leap_sec) {\n\t\t\tleap = 1;\n\t\t\tntp_next_leap_sec = TIME64_MAX;\n\t\t\ttime_state = TIME_WAIT;\n\t\t\tprintk(KERN_NOTICE\n\t\t\t\t\"Clock: deleting leap second 23:59:59 UTC\\n\");\n\t\t}\n\t\tbreak;\n\tcase TIME_OOP:\n\t\tntp_next_leap_sec = TIME64_MAX;\n\t\ttime_state = TIME_WAIT;\n\t\tbreak;\n\tcase TIME_WAIT:\n\t\tif (!(time_status & (STA_INS | STA_DEL)))\n\t\t\ttime_state = TIME_OK;\n\t\tbreak;\n\t}\n\n\n\t/* Bump the maxerror field */\n\ttime_maxerror += MAXFREQ / NSEC_PER_USEC;\n\tif (time_maxerror > NTP_PHASE_LIMIT) {\n\t\ttime_maxerror = NTP_PHASE_LIMIT;\n\t\ttime_status |= STA_UNSYNC;\n\t}\n\n\t/* Compute the phase adjustment for the next second */\n\ttick_length\t = tick_length_base;\n\n\tdelta\t\t = ntp_offset_chunk(time_offset);\n\ttime_offset\t-= delta;\n\ttick_length\t+= delta;\n\n\t/* Check PPS signal */\n\tpps_dec_valid();\n\n\tif (!time_adjust)\n\t\tgoto out;\n\n\tif (time_adjust > MAX_TICKADJ) {\n\t\ttime_adjust -= MAX_TICKADJ;\n\t\ttick_length += MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\tif (time_adjust < -MAX_TICKADJ) {\n\t\ttime_adjust += MAX_TICKADJ;\n\t\ttick_length -= MAX_TICKADJ_SCALED;\n\t\tgoto out;\n\t}\n\n\ttick_length += (s64)(time_adjust * NSEC_PER_USEC / NTP_INTERVAL_FREQ)\n\t\t\t\t\t\t\t << NTP_SCALE_SHIFT;\n\ttime_adjust = 0;\n\nout:\n\treturn leap;\n}"
  },
  {
    "function_name": "ntp_get_next_leap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "379-387",
    "snippet": "ktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_state = TIME_OK;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_set",
          "args": [
            "ntp_next_leap_sec",
            "0"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_state = TIME_OK;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nktime_t ntp_get_next_leap(void)\n{\n\tktime_t ret;\n\n\tif ((time_state == TIME_INS) && (time_status & STA_INS))\n\t\treturn ktime_set(ntp_next_leap_sec, 0);\n\tret = KTIME_MAX;\n\treturn ret;\n}"
  },
  {
    "function_name": "ntp_tick_length",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "368-371",
    "snippet": "u64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64\t\t\ttick_length;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\n\nu64 ntp_tick_length(void)\n{\n\treturn tick_length;\n}"
  },
  {
    "function_name": "ntp_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "350-365",
    "snippet": "void ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_esterror = NTP_PHASE_LIMIT;",
      "static long\t\t\ttime_adjust;",
      "static time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_clear",
          "args": [],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "pps_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "215-215",
          "snippet": "static inline void pps_clear(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
        }
      },
      {
        "call_info": {
          "callee": "ntp_update_frequency",
          "args": [],
          "line": 357
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_frequency",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "258-278",
          "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
            "unsigned long\t\t\ttick_nsec;",
            "static u64\t\t\ttick_length;",
            "static u64\t\t\ttick_length_base;",
            "static s64\t\t\ttime_freq;",
            "static s64\t\t\tntp_tick_adj;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_maxerror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_esterror = NTP_PHASE_LIMIT;\nstatic long\t\t\ttime_adjust;\nstatic time64_t\t\t\tntp_next_leap_sec = TIME64_MAX;\n\nvoid ntp_clear(void)\n{\n\ttime_adjust\t= 0;\t\t/* stop active adjtime() */\n\ttime_status\t|= STA_UNSYNC;\n\ttime_maxerror\t= NTP_PHASE_LIMIT;\n\ttime_esterror\t= NTP_PHASE_LIMIT;\n\n\tntp_update_frequency();\n\n\ttick_length\t= tick_length_base;\n\ttime_offset\t= 0;\n\n\tntp_next_leap_sec = TIME64_MAX;\n\t/* Clear PPS state variables */\n\tpps_clear();\n}"
  },
  {
    "function_name": "ntp_update_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "295-345",
    "snippet": "static void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static s64\t\t\ttime_offset;",
      "static long\t\t\ttime_constant = 2;",
      "static s64\t\t\ttime_freq;",
      "static time64_t\t\ttime_reftime;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_s64",
          "args": [
            "offset64 << NTP_SCALE_SHIFT",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "max",
          "args": [
            "freq_adj",
            "-MAXFREQ_SCALED"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "workqueue_set_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4232-4251",
          "snippet": "void workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(workqueues);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic LIST_HEAD(workqueues);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid workqueue_set_max_active(struct workqueue_struct *wq, int max_active)\n{\n\tstruct pool_workqueue *pwq;\n\n\t/* disallow meddling with max_active for ordered workqueues */\n\tif (WARN_ON(wq->flags & __WQ_ORDERED_EXPLICIT))\n\t\treturn;\n\n\tmax_active = wq_clamp_max_active(max_active, wq->flags, wq->name);\n\n\tmutex_lock(&wq->mutex);\n\n\twq->flags &= ~__WQ_ORDERED;\n\twq->saved_max_active = max_active;\n\n\tfor_each_pwq(pwq, wq)\n\t\tpwq_adjust_max_active(pwq);\n\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "freq_adj + time_freq",
            "MAXFREQ_SCALED"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "clocksource_stop_suspend_timing",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/clocksource.c",
          "lines": "574-606",
          "snippet": "u64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/kthread.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/device.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct clocksource *suspend_clocksource;",
            "static u64 suspend_start;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/kthread.h>\n#include <linux/tick.h>\n#include <linux/sched.h> /* for spin_unlock_irq() using preempt_count() m68k */\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n#include <linux/device.h>\n\nstatic struct clocksource *suspend_clocksource;\nstatic u64 suspend_start;\n\nu64 clocksource_stop_suspend_timing(struct clocksource *cs, u64 cycle_now)\n{\n\tu64 now, delta, nsec = 0;\n\n\tif (!suspend_clocksource)\n\t\treturn 0;\n\n\t/*\n\t * If current clocksource is the suspend timer, we should use the\n\t * tkr_mono.cycle_last value from timekeeping as current cycle to\n\t * avoid same reading from suspend timer.\n\t */\n\tif (clocksource_is_suspend(cs))\n\t\tnow = cycle_now;\n\telse\n\t\tnow = suspend_clocksource->read(suspend_clocksource);\n\n\tif (now > suspend_start) {\n\t\tdelta = clocksource_delta(now, suspend_start,\n\t\t\t\t\t  suspend_clocksource->mask);\n\t\tnsec = mul_u64_u32_shr(delta, suspend_clocksource->mult,\n\t\t\t\t       suspend_clocksource->shift);\n\t}\n\n\t/*\n\t * Disable the suspend timer to save power if current clocksource is\n\t * not the suspend timer.\n\t */\n\tif (!clocksource_is_suspend(cs) && suspend_clocksource->disable)\n\t\tsuspend_clocksource->disable(suspend_clocksource);\n\n\treturn nsec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "secs > 1 << (SHIFT_PLL + 1 + time_constant)"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ntp_update_offset_fll",
          "args": [
            "offset64",
            "secs"
          ],
          "line": 327
        },
        "resolved": true,
        "details": {
          "function_name": "ntp_update_offset_fll",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "280-293",
          "snippet": "static inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int\t\t\ttime_status = STA_UNSYNC;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "time_status & STA_FREQHOLD"
          ],
          "line": 321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clamp",
          "args": [
            "offset",
            "-MAXPHASE",
            "MAXPHASE"
          ],
          "line": 314
        },
        "resolved": true,
        "details": {
          "function_name": "wq_clamp_max_active",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4004-4014",
          "snippet": "static int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic int wq_clamp_max_active(int max_active, unsigned int flags,\n\t\t\t       const char *name)\n{\n\tint lim = flags & WQ_UNBOUND ? WQ_UNBOUND_MAX_ACTIVE : WQ_MAX_ACTIVE;\n\n\tif (max_active < 1 || max_active > lim)\n\t\tpr_warn(\"workqueue: max_active %d requested for %s is out of range, clamping between %d and %d\\n\",\n\t\t\tmax_active, name, 1, lim);\n\n\treturn clamp_val(max_active, 1, lim);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic s64\t\t\ttime_offset;\nstatic long\t\t\ttime_constant = 2;\nstatic s64\t\t\ttime_freq;\nstatic time64_t\t\ttime_reftime;\n\nstatic void ntp_update_offset(long offset)\n{\n\ts64 freq_adj;\n\ts64 offset64;\n\tlong secs;\n\n\tif (!(time_status & STA_PLL))\n\t\treturn;\n\n\tif (!(time_status & STA_NANO)) {\n\t\t/* Make sure the multiplication below won't overflow */\n\t\toffset = clamp(offset, -USEC_PER_SEC, USEC_PER_SEC);\n\t\toffset *= NSEC_PER_USEC;\n\t}\n\n\t/*\n\t * Scale the phase adjustment and\n\t * clamp to the operating range.\n\t */\n\toffset = clamp(offset, -MAXPHASE, MAXPHASE);\n\n\t/*\n\t * Select how the frequency is to be controlled\n\t * and in which mode (PLL or FLL).\n\t */\n\tsecs = (long)(__ktime_get_real_seconds() - time_reftime);\n\tif (unlikely(time_status & STA_FREQHOLD))\n\t\tsecs = 0;\n\n\ttime_reftime = __ktime_get_real_seconds();\n\n\toffset64    = offset;\n\tfreq_adj    = ntp_update_offset_fll(offset64, secs);\n\n\t/*\n\t * Clamp update interval to reduce PLL gain with low\n\t * sampling rate (e.g. intermittent network connection)\n\t * to avoid instability.\n\t */\n\tif (unlikely(secs > 1 << (SHIFT_PLL + 1 + time_constant)))\n\t\tsecs = 1 << (SHIFT_PLL + 1 + time_constant);\n\n\tfreq_adj    += (offset64 * secs) <<\n\t\t\t(NTP_SCALE_SHIFT - 2 * (SHIFT_PLL + 2 + time_constant));\n\n\tfreq_adj    = min(freq_adj + time_freq, MAXFREQ_SCALED);\n\n\ttime_freq   = max(freq_adj, -MAXFREQ_SCALED);\n\n\ttime_offset = div_s64(offset64 << NTP_SCALE_SHIFT, NTP_INTERVAL_FREQ);\n}"
  },
  {
    "function_name": "ntp_update_offset_fll",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "280-293",
    "snippet": "static inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div64_long",
          "args": [
            "offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL)",
            "secs"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline s64 ntp_update_offset_fll(s64 offset64, long secs)\n{\n\ttime_status &= ~STA_MODE;\n\n\tif (secs < MINSEC)\n\t\treturn 0;\n\n\tif (!(time_status & STA_FLL) && (secs <= MAXSEC))\n\t\treturn 0;\n\n\ttime_status |= STA_MODE;\n\n\treturn div64_long(offset64 << (NTP_SCALE_SHIFT - SHIFT_FLL), secs);\n}"
  },
  {
    "function_name": "ntp_update_frequency",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "258-278",
    "snippet": "static void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "unsigned long\t\t\ttick_usec = USER_TICK_USEC;",
      "unsigned long\t\t\ttick_nsec;",
      "static u64\t\t\ttick_length;",
      "static u64\t\t\ttick_length_base;",
      "static s64\t\t\ttime_freq;",
      "static s64\t\t\tntp_tick_adj;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "second_length",
            "NTP_INTERVAL_FREQ"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "second_length",
            "HZ"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "tick_usec * NSEC_PER_USEC * USER_HZ"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nunsigned long\t\t\ttick_usec = USER_TICK_USEC;\nunsigned long\t\t\ttick_nsec;\nstatic u64\t\t\ttick_length;\nstatic u64\t\t\ttick_length_base;\nstatic s64\t\t\ttime_freq;\nstatic s64\t\t\tntp_tick_adj;\n\nstatic void ntp_update_frequency(void)\n{\n\tu64 second_length;\n\tu64 new_base;\n\n\tsecond_length\t\t = (u64)(tick_usec * NSEC_PER_USEC * USER_HZ)\n\t\t\t\t\t\t<< NTP_SCALE_SHIFT;\n\n\tsecond_length\t\t+= ntp_tick_adj;\n\tsecond_length\t\t+= time_freq;\n\n\ttick_nsec\t\t = div_u64(second_length, HZ) >> NTP_SCALE_SHIFT;\n\tnew_base\t\t = div_u64(second_length, NTP_INTERVAL_FREQ);\n\n\t/*\n\t * Don't wait for the next second_overflow, apply\n\t * the change to the tick length immediately:\n\t */\n\ttick_length\t\t+= new_base - tick_length_base;\n\ttick_length_base\t = new_base;\n}"
  },
  {
    "function_name": "ntp_synced",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "244-247",
    "snippet": "static inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline int ntp_synced(void)\n{\n\treturn !(time_status & STA_UNSYNC);\n}"
  },
  {
    "function_name": "pps_fill_timex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "224-235",
    "snippet": "static inline void pps_fill_timex(struct timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_fill_timex(struct timex *txc)\n{\n\t/* PPS is not implemented, so these are zero */\n\ttxc->ppsfreq\t   = 0;\n\ttxc->jitter\t   = 0;\n\ttxc->shift\t   = 0;\n\ttxc->stabil\t   = 0;\n\ttxc->jitcnt\t   = 0;\n\ttxc->calcnt\t   = 0;\n\ttxc->errcnt\t   = 0;\n\ttxc->stbcnt\t   = 0;\n}"
  },
  {
    "function_name": "is_error_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "219-222",
    "snippet": "static inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn status & (STA_UNSYNC|STA_CLOCKERR);\n}"
  },
  {
    "function_name": "pps_set_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "217-217",
    "snippet": "static inline void pps_set_freq(s64 freq) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq) {}"
  },
  {
    "function_name": "pps_dec_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "216-216",
    "snippet": "static inline void pps_dec_valid(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_dec_valid(void) {}"
  },
  {
    "function_name": "pps_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "215-215",
    "snippet": "static inline void pps_clear(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
  },
  {
    "function_name": "pps_reset_freq_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "214-214",
    "snippet": "static inline void pps_reset_freq_interval(void) {}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
  },
  {
    "function_name": "ntp_offset_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "209-212",
    "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static long\t\t\ttime_constant = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "offset",
            "SHIFT_PLL + time_constant"
          ],
          "line": 211
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
  },
  {
    "function_name": "pps_fill_timex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "192-205",
    "snippet": "static inline void pps_fill_timex(struct timex *txc)\n{\n\ttxc->ppsfreq\t   = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->jitter\t   = pps_jitter;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->jitter /= NSEC_PER_USEC;\n\ttxc->shift\t   = pps_shift;\n\ttxc->stabil\t   = pps_stabil;\n\ttxc->jitcnt\t   = pps_jitcnt;\n\ttxc->calcnt\t   = pps_calcnt;\n\ttxc->errcnt\t   = pps_errcnt;\n\ttxc->stbcnt\t   = pps_stbcnt;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "(pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV",
            "NTP_SCALE_SHIFT"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline void pps_fill_timex(struct timex *txc)\n{\n\ttxc->ppsfreq\t   = shift_right((pps_freq >> PPM_SCALE_INV_SHIFT) *\n\t\t\t\t\t PPM_SCALE_INV, NTP_SCALE_SHIFT);\n\ttxc->jitter\t   = pps_jitter;\n\tif (!(time_status & STA_NANO))\n\t\ttxc->jitter /= NSEC_PER_USEC;\n\ttxc->shift\t   = pps_shift;\n\ttxc->stabil\t   = pps_stabil;\n\ttxc->jitcnt\t   = pps_jitcnt;\n\ttxc->calcnt\t   = pps_calcnt;\n\ttxc->errcnt\t   = pps_errcnt;\n\ttxc->stbcnt\t   = pps_stbcnt;\n}"
  },
  {
    "function_name": "is_error_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "173-190",
    "snippet": "static inline int is_error_status(int status)\n{\n\treturn (status & (STA_UNSYNC|STA_CLOCKERR))\n\t\t/* PPS signal lost when either PPS time or\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & (STA_PPSFREQ|STA_PPSTIME))\n\t\t\t&& !(status & STA_PPSSIGNAL))\n\t\t/* PPS jitter exceeded when\n\t\t * PPS time synchronization requested */\n\t\t|| ((status & (STA_PPSTIME|STA_PPSJITTER))\n\t\t\t== (STA_PPSTIME|STA_PPSJITTER))\n\t\t/* PPS wander exceeded or calibration error when\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & STA_PPSFREQ)\n\t\t\t&& (status & (STA_PPSWANDER|STA_PPSERROR)));\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline int is_error_status(int status)\n{\n\treturn (status & (STA_UNSYNC|STA_CLOCKERR))\n\t\t/* PPS signal lost when either PPS time or\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & (STA_PPSFREQ|STA_PPSTIME))\n\t\t\t&& !(status & STA_PPSSIGNAL))\n\t\t/* PPS jitter exceeded when\n\t\t * PPS time synchronization requested */\n\t\t|| ((status & (STA_PPSTIME|STA_PPSJITTER))\n\t\t\t== (STA_PPSTIME|STA_PPSJITTER))\n\t\t/* PPS wander exceeded or calibration error when\n\t\t * PPS frequency synchronization requested\n\t\t */\n\t\t|| ((status & STA_PPSFREQ)\n\t\t\t&& (status & (STA_PPSWANDER|STA_PPSERROR)));\n}"
  },
  {
    "function_name": "pps_set_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "168-171",
    "snippet": "static inline void pps_set_freq(s64 freq)\n{\n\tpps_freq = freq;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_set_freq(s64 freq)\n{\n\tpps_freq = freq;\n}"
  },
  {
    "function_name": "pps_dec_valid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "157-166",
    "snippet": "static inline void pps_dec_valid(void)\n{\n\tif (pps_valid > 0)\n\t\tpps_valid--;\n\telse {\n\t\ttime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\n\t\t\t\t STA_PPSWANDER | STA_PPSERROR);\n\t\tpps_clear();\n\t}\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_clear",
          "args": [],
          "line": 164
        },
        "resolved": true,
        "details": {
          "function_name": "pps_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "215-215",
          "snippet": "static inline void pps_clear(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\n\nstatic inline void pps_dec_valid(void)\n{\n\tif (pps_valid > 0)\n\t\tpps_valid--;\n\telse {\n\t\ttime_status &= ~(STA_PPSSIGNAL | STA_PPSJITTER |\n\t\t\t\t STA_PPSWANDER | STA_PPSERROR);\n\t\tpps_clear();\n\t}\n}"
  },
  {
    "function_name": "pps_clear",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "143-151",
    "snippet": "static inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pps_reset_freq_interval",
          "args": [],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "pps_reset_freq_interval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
          "lines": "214-214",
          "snippet": "static inline void pps_reset_freq_interval(void) {}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include <linux/math64.h>",
            "#include <linux/rtc.h>",
            "#include <linux/module.h>",
            "#include <linux/mm.h>",
            "#include <linux/time.h>",
            "#include <linux/timex.h>",
            "#include <linux/math64.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/capability.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_reset_freq_interval(void) {}"
        }
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic inline void pps_clear(void)\n{\n\tpps_reset_freq_interval();\n\tpps_tf[0] = 0;\n\tpps_tf[1] = 0;\n\tpps_tf[2] = 0;\n\tpps_fbase.tv_sec = pps_fbase.tv_nsec = 0;\n\tpps_freq = 0;\n}"
  },
  {
    "function_name": "pps_reset_freq_interval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "132-138",
    "snippet": "static inline void pps_reset_freq_interval(void)\n{\n\t/* the PPS calibration interval may end\n\t   surprisingly early */\n\tpps_shift = PPS_INTMIN;\n\tpps_intcnt = 0;\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [
      "#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\n#define PPS_INTMIN\t2\t/* min freq interval (s) (shift) */\n\nstatic inline void pps_reset_freq_interval(void)\n{\n\t/* the PPS calibration interval may end\n\t   surprisingly early */\n\tpps_shift = PPS_INTMIN;\n\tpps_intcnt = 0;\n}"
  },
  {
    "function_name": "ntp_offset_chunk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/ntp.c",
    "lines": "124-130",
    "snippet": "static inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}",
    "includes": [
      "#include \"timekeeping_internal.h\"",
      "#include \"ntp_internal.h\"",
      "#include <linux/math64.h>",
      "#include <linux/rtc.h>",
      "#include <linux/module.h>",
      "#include <linux/mm.h>",
      "#include <linux/time.h>",
      "#include <linux/timex.h>",
      "#include <linux/math64.h>",
      "#include <linux/jiffies.h>",
      "#include <linux/hrtimer.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/clocksource.h>",
      "#include <linux/capability.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int\t\t\ttime_status = STA_UNSYNC;",
      "static long\t\t\ttime_constant = 2;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "shift_right",
          "args": [
            "offset",
            "SHIFT_PLL + time_constant"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include <linux/math64.h>\n#include <linux/rtc.h>\n#include <linux/module.h>\n#include <linux/mm.h>\n#include <linux/time.h>\n#include <linux/timex.h>\n#include <linux/math64.h>\n#include <linux/jiffies.h>\n#include <linux/hrtimer.h>\n#include <linux/workqueue.h>\n#include <linux/clocksource.h>\n#include <linux/capability.h>\n\nstatic int\t\t\ttime_status = STA_UNSYNC;\nstatic long\t\t\ttime_constant = 2;\n\nstatic inline s64 ntp_offset_chunk(s64 offset)\n{\n\tif (time_status & STA_PPSTIME && time_status & STA_PPSSIGNAL)\n\t\treturn offset;\n\telse\n\t\treturn shift_right(offset, SHIFT_PLL + time_constant);\n}"
  }
]