[
  {
    "function_name": "test_ww_mutex_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "638-641",
    "snippet": "static void __exit test_ww_mutex_exit(void)\n{\n\tdestroy_workqueue(wq);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_workqueue",
          "args": [
            "wq"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4149-4219",
          "snippet": "void destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);",
            "static DEFINE_MUTEX(wq_pool_mutex);",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstruct pool_workqueue {\n\tstruct worker_pool\t*pool;\t\t/* I: the associated pool */\n\tstruct workqueue_struct *wq;\t\t/* I: the owning workqueue */\n\tint\t\t\twork_color;\t/* L: current color */\n\tint\t\t\tflush_color;\t/* L: flushing color */\n\tint\t\t\trefcnt;\t\t/* L: reference count */\n\tint\t\t\tnr_in_flight[WORK_NR_COLORS];\n\t\t\t\t\t\t/* L: nr of in_flight works */\n\tint\t\t\tnr_active;\t/* L: nr of active works */\n\tint\t\t\tmax_active;\t/* L: max active works */\n\tstruct list_head\tdelayed_works;\t/* L: delayed works */\n\tstruct list_head\tpwqs_node;\t/* WR: node on wq->pwqs */\n\tstruct list_head\tmayday_node;\t/* MD: node on wq->maydays */\n\n\t/*\n\t * Release of unbound pwq is punted to system_wq.  See put_pwq()\n\t * and pwq_unbound_release_workfn() for details.  pool_workqueue\n\t * itself is also sched-RCU protected so that the first pwq can be\n\t * determined without grabbing wq->mutex.\n\t */\n\tstruct work_struct\tunbound_release_work;\n\tstruct rcu_head\t\trcu;\n} __aligned(1 << WORK_STRUCT_FLAG_BITS);\nstatic DEFINE_MUTEX(wq_pool_mutex);\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid destroy_workqueue(struct workqueue_struct *wq)\n{\n\tstruct pool_workqueue *pwq;\n\tint node;\n\n\t/* drain it before proceeding with destruction */\n\tdrain_workqueue(wq);\n\n\t/* sanity checks */\n\tmutex_lock(&wq->mutex);\n\tfor_each_pwq(pwq, wq) {\n\t\tint i;\n\n\t\tfor (i = 0; i < WORK_NR_COLORS; i++) {\n\t\t\tif (WARN_ON(pwq->nr_in_flight[i])) {\n\t\t\t\tmutex_unlock(&wq->mutex);\n\t\t\t\tshow_workqueue_state();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (WARN_ON((pwq != wq->dfl_pwq) && (pwq->refcnt > 1)) ||\n\t\t    WARN_ON(pwq->nr_active) ||\n\t\t    WARN_ON(!list_empty(&pwq->delayed_works))) {\n\t\t\tmutex_unlock(&wq->mutex);\n\t\t\tshow_workqueue_state();\n\t\t\treturn;\n\t\t}\n\t}\n\tmutex_unlock(&wq->mutex);\n\n\t/*\n\t * wq list is used to freeze wq, remove from list after\n\t * flushing is complete in case freeze races us.\n\t */\n\tmutex_lock(&wq_pool_mutex);\n\tlist_del_rcu(&wq->list);\n\tmutex_unlock(&wq_pool_mutex);\n\n\tworkqueue_sysfs_unregister(wq);\n\n\tif (wq->rescuer)\n\t\tkthread_stop(wq->rescuer->task);\n\n\tif (!(wq->flags & WQ_UNBOUND)) {\n\t\t/*\n\t\t * The base ref is never dropped on per-cpu pwqs.  Directly\n\t\t * schedule RCU free.\n\t\t */\n\t\tcall_rcu_sched(&wq->rcu, rcu_free_wq);\n\t} else {\n\t\t/*\n\t\t * We're the sole accessor of @wq at this point.  Directly\n\t\t * access numa_pwq_tbl[] and dfl_pwq to put the base refs.\n\t\t * @wq will be freed when the last pwq is released.\n\t\t */\n\t\tfor_each_node(node) {\n\t\t\tpwq = rcu_access_pointer(wq->numa_pwq_tbl[node]);\n\t\t\tRCU_INIT_POINTER(wq->numa_pwq_tbl[node], NULL);\n\t\t\tput_pwq_unlocked(pwq);\n\t\t}\n\n\t\t/*\n\t\t * Put dfl_pwq.  @wq may be freed any time after dfl_pwq is\n\t\t * put.  Don't access it afterwards.\n\t\t */\n\t\tpwq = wq->dfl_pwq;\n\t\twq->dfl_pwq = NULL;\n\t\tput_pwq_unlocked(pwq);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstruct workqueue_struct *wq;\n\nstatic void __exit test_ww_mutex_exit(void)\n{\n\tdestroy_workqueue(wq);\n}"
  },
  {
    "function_name": "test_ww_mutex_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "594-636",
    "snippet": "static int __init test_ww_mutex_init(void)\n{\n\tint ncpus = num_online_cpus();\n\tint ret;\n\n\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = test_mutex();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_abba(false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_abba(true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_cycle(ncpus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_INORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_REORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(4095, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define STRESS_ALL (STRESS_INORDER | STRESS_REORDER | STRESS_ONE)",
      "#define STRESS_REORDER BIT(1)",
      "#define STRESS_INORDER BIT(0)"
    ],
    "globals_used": [
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "stress",
          "args": [
            "4095",
            "hweight32(STRESS_ALL)*ncpus",
            "STRESS_ALL"
          ],
          "line": 631
        },
        "resolved": true,
        "details": {
          "function_name": "stress",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "537-592",
          "snippet": "static int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define STRESS_ONE BIT(2)",
            "#define STRESS_REORDER BIT(1)",
            "#define STRESS_INORDER BIT(0)"
          ],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);",
            "struct workqueue_struct *wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ONE BIT(2)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hweight32",
          "args": [
            "STRESS_ALL"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "test_cycle",
          "args": [
            "ncpus"
          ],
          "line": 619
        },
        "resolved": true,
        "details": {
          "function_name": "test_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "341-353",
          "snippet": "static int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_abba",
          "args": [
            "true"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "test_abba",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "197-248",
          "snippet": "static int test_abba(bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba.a_mutex, &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_abba(bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba.a_mutex, &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_aa",
          "args": [],
          "line": 607
        },
        "resolved": true,
        "details": {
          "function_name": "test_aa",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "125-158",
          "snippet": "static int test_aa(void)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tww_mutex_lock(&mutex, &ctx);\n\n\tif (ww_mutex_trylock(&mutex))  {\n\t\tpr_err(\"%s: trylocked itself!\\n\", __func__);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d\\n\",\n\t\t       __func__, ret);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tww_mutex_unlock(&mutex);\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_aa(void)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tww_mutex_lock(&mutex, &ctx);\n\n\tif (ww_mutex_trylock(&mutex))  {\n\t\tpr_err(\"%s: trylocked itself!\\n\", __func__);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d\\n\",\n\t\t       __func__, ret);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tww_mutex_unlock(&mutex);\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "test_mutex",
          "args": [],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "test_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "111-123",
          "snippet": "static int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define __TEST_MTX_LAST BIT(3)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define __TEST_MTX_LAST BIT(3)\n\nstatic int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_workqueue",
          "args": [
            "\"test-ww_mutex\"",
            "WQ_UNBOUND",
            "0"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "num_online_cpus",
          "args": [],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ALL (STRESS_INORDER | STRESS_REORDER | STRESS_ONE)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstruct workqueue_struct *wq;\n\nstatic int __init test_ww_mutex_init(void)\n{\n\tint ncpus = num_online_cpus();\n\tint ret;\n\n\twq = alloc_workqueue(\"test-ww_mutex\", WQ_UNBOUND, 0);\n\tif (!wq)\n\t\treturn -ENOMEM;\n\n\tret = test_mutex();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_aa();\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_abba(false);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_abba(true);\n\tif (ret)\n\t\treturn ret;\n\n\tret = test_cycle(ncpus);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_INORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(16, 2*ncpus, STRESS_REORDER);\n\tif (ret)\n\t\treturn ret;\n\n\tret = stress(4095, hweight32(STRESS_ALL)*ncpus, STRESS_ALL);\n\tif (ret)\n\t\treturn ret;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stress",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "537-592",
    "snippet": "static int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define STRESS_ONE BIT(2)",
      "#define STRESS_REORDER BIT(1)",
      "#define STRESS_INORDER BIT(0)"
    ],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);",
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "locks"
          ],
          "line": 589
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_destroy",
          "args": [
            "&locks[n]"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2643-2791",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "wq",
            "&stress->work"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&stress->work",
            "fn"
          ],
          "line": 576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*stress)",
            "GFP_KERNEL"
          ],
          "line": 572
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&locks[n]",
            "&ww_class"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nlocks",
            "sizeof(*locks)",
            "GFP_KERNEL"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define STRESS_ONE BIT(2)\n#define STRESS_REORDER BIT(1)\n#define STRESS_INORDER BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int stress(int nlocks, int nthreads, unsigned int flags)\n{\n\tstruct ww_mutex *locks;\n\tint n;\n\n\tlocks = kmalloc_array(nlocks, sizeof(*locks), GFP_KERNEL);\n\tif (!locks)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_init(&locks[n], &ww_class);\n\n\tfor (n = 0; nthreads; n++) {\n\t\tstruct stress *stress;\n\t\tvoid (*fn)(struct work_struct *work);\n\n\t\tfn = NULL;\n\t\tswitch (n & 3) {\n\t\tcase 0:\n\t\t\tif (flags & STRESS_INORDER)\n\t\t\t\tfn = stress_inorder_work;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif (flags & STRESS_REORDER)\n\t\t\t\tfn = stress_reorder_work;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tif (flags & STRESS_ONE)\n\t\t\t\tfn = stress_one_work;\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!fn)\n\t\t\tcontinue;\n\n\t\tstress = kmalloc(sizeof(*stress), GFP_KERNEL);\n\t\tif (!stress)\n\t\t\tbreak;\n\n\t\tINIT_WORK(&stress->work, fn);\n\t\tstress->locks = locks;\n\t\tstress->nlocks = nlocks;\n\t\tstress->timeout = jiffies + 2*HZ;\n\n\t\tqueue_work(wq, &stress->work);\n\t\tnthreads--;\n\t}\n\n\tflush_workqueue(wq);\n\n\tfor (n = 0; n < nlocks; n++)\n\t\tww_mutex_destroy(&locks[n]);\n\tkfree(locks);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "stress_one_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "510-530",
    "snippet": "static void stress_one_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *lock = stress->locks + (get_random_int() % nlocks);\n\tint err;\n\n\tdo {\n\t\terr = ww_mutex_lock(lock, NULL);\n\t\tif (!err) {\n\t\t\tdummy_load(stress);\n\t\t\tww_mutex_unlock(lock);\n\t\t} else {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "lock"
          ],
          "line": 521
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 520
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "386-389",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "lock",
            "NULL"
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void stress_one_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *lock = stress->locks + (get_random_int() % nlocks);\n\tint err;\n\n\tdo {\n\t\terr = ww_mutex_lock(lock, NULL);\n\t\tif (!err) {\n\t\t\tdummy_load(stress);\n\t\t\tww_mutex_unlock(lock);\n\t\t} else {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(stress);\n}"
  },
  {
    "function_name": "stress_reorder_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "450-508",
    "snippet": "static void stress_reorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tLIST_HEAD(locks);\n\tstruct ww_acquire_ctx ctx;\n\tstruct reorder_lock *ll, *ln;\n\tint *order;\n\tint n, err;\n\n\torder = get_random_order(stress->nlocks);\n\tif (!order)\n\t\treturn;\n\n\tfor (n = 0; n < stress->nlocks; n++) {\n\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);\n\t\tif (!ll)\n\t\t\tgoto out;\n\n\t\tll->lock = &stress->locks[order[n]];\n\t\tlist_add(&ll->link, &locks);\n\t}\n\tkfree(order);\n\torder = NULL;\n\n\tdo {\n\t\tww_acquire_init(&ctx, &ww_class);\n\n\t\tlist_for_each_entry(ll, &locks, link) {\n\t\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\tln = ll;\n\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)\n\t\t\t\tww_mutex_unlock(ln->lock);\n\n\t\t\tif (err != -EDEADLK) {\n\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t\t    __func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\t\tlist_move(&ll->link, &locks); /* restarts iteration */\n\t\t}\n\n\t\tdummy_load(stress);\n\t\tlist_for_each_entry(ll, &locks, link)\n\t\t\tww_mutex_unlock(ll->lock);\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\nout:\n\tlist_for_each_entry_safe(ll, ln, &locks, link)\n\t\tkfree(ll);\n\tkfree(order);\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 507
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "ll",
            "ln",
            "&locks",
            "link"
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "ll->lock"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&locks",
            "link"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "386-389",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_move",
          "args": [
            "&ll->link",
            "&locks"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 492
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_continue_reverse",
          "args": [
            "ln",
            "&locks",
            "link"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "ll->lock",
            "&ctx"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "ll",
            "&locks",
            "link"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&ll->link",
            "&locks"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ll)",
            "GFP_KERNEL"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_random_order",
          "args": [
            "stress->nlocks"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "362-384",
          "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "LIST_HEAD",
          "args": [
            "locks"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void stress_reorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tLIST_HEAD(locks);\n\tstruct ww_acquire_ctx ctx;\n\tstruct reorder_lock *ll, *ln;\n\tint *order;\n\tint n, err;\n\n\torder = get_random_order(stress->nlocks);\n\tif (!order)\n\t\treturn;\n\n\tfor (n = 0; n < stress->nlocks; n++) {\n\t\tll = kmalloc(sizeof(*ll), GFP_KERNEL);\n\t\tif (!ll)\n\t\t\tgoto out;\n\n\t\tll->lock = &stress->locks[order[n]];\n\t\tlist_add(&ll->link, &locks);\n\t}\n\tkfree(order);\n\torder = NULL;\n\n\tdo {\n\t\tww_acquire_init(&ctx, &ww_class);\n\n\t\tlist_for_each_entry(ll, &locks, link) {\n\t\t\terr = ww_mutex_lock(ll->lock, &ctx);\n\t\t\tif (!err)\n\t\t\t\tcontinue;\n\n\t\t\tln = ll;\n\t\t\tlist_for_each_entry_continue_reverse(ln, &locks, link)\n\t\t\t\tww_mutex_unlock(ln->lock);\n\n\t\t\tif (err != -EDEADLK) {\n\t\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t\t    __func__, err);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tww_mutex_lock_slow(ll->lock, &ctx);\n\t\t\tlist_move(&ll->link, &locks); /* restarts iteration */\n\t\t}\n\n\t\tdummy_load(stress);\n\t\tlist_for_each_entry(ll, &locks, link)\n\t\t\tww_mutex_unlock(ll->lock);\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\nout:\n\tlist_for_each_entry_safe(ll, ln, &locks, link)\n\t\tkfree(ll);\n\tkfree(order);\n\tkfree(stress);\n}"
  },
  {
    "function_name": "stress_inorder_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "391-443",
    "snippet": "static void stress_inorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *locks = stress->locks;\n\tstruct ww_acquire_ctx ctx;\n\tint *order;\n\n\torder = get_random_order(nlocks);\n\tif (!order)\n\t\treturn;\n\n\tdo {\n\t\tint contended = -1;\n\t\tint n, err;\n\n\t\tww_acquire_init(&ctx, &ww_class);\nretry:\n\t\terr = 0;\n\t\tfor (n = 0; n < nlocks; n++) {\n\t\t\tif (n == contended)\n\t\t\t\tcontinue;\n\n\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!err)\n\t\t\tdummy_load(stress);\n\n\t\tif (contended > n)\n\t\t\tww_mutex_unlock(&locks[order[contended]]);\n\t\tcontended = n;\n\t\twhile (n--)\n\t\t\tww_mutex_unlock(&locks[order[n]]);\n\n\t\tif (err == -EDEADLK) {\n\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(order);\n\tkfree(stress);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "stress"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_after",
          "args": [
            "jiffies",
            "stress->timeout"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err_once",
          "args": [
            "\"stress (%s) failed with %d\\n\"",
            "__func__",
            "err"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&locks[order[contended]]",
            "&ctx"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&locks[order[n]]"
          ],
          "line": 425
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dummy_load",
          "args": [
            "stress"
          ],
          "line": 419
        },
        "resolved": true,
        "details": {
          "function_name": "dummy_load",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "386-389",
          "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&locks[order[n]]",
            "&ctx"
          ],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_random_order",
          "args": [
            "nlocks"
          ],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "get_random_order",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "362-384",
          "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*stress)",
            "work"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*stress"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void stress_inorder_work(struct work_struct *work)\n{\n\tstruct stress *stress = container_of(work, typeof(*stress), work);\n\tconst int nlocks = stress->nlocks;\n\tstruct ww_mutex *locks = stress->locks;\n\tstruct ww_acquire_ctx ctx;\n\tint *order;\n\n\torder = get_random_order(nlocks);\n\tif (!order)\n\t\treturn;\n\n\tdo {\n\t\tint contended = -1;\n\t\tint n, err;\n\n\t\tww_acquire_init(&ctx, &ww_class);\nretry:\n\t\terr = 0;\n\t\tfor (n = 0; n < nlocks; n++) {\n\t\t\tif (n == contended)\n\t\t\t\tcontinue;\n\n\t\t\terr = ww_mutex_lock(&locks[order[n]], &ctx);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!err)\n\t\t\tdummy_load(stress);\n\n\t\tif (contended > n)\n\t\t\tww_mutex_unlock(&locks[order[contended]]);\n\t\tcontended = n;\n\t\twhile (n--)\n\t\t\tww_mutex_unlock(&locks[order[n]]);\n\n\t\tif (err == -EDEADLK) {\n\t\t\tww_mutex_lock_slow(&locks[order[contended]], &ctx);\n\t\t\tgoto retry;\n\t\t}\n\n\t\tif (err) {\n\t\t\tpr_err_once(\"stress (%s) failed with %d\\n\",\n\t\t\t\t    __func__, err);\n\t\t\tbreak;\n\t\t}\n\n\t\tww_acquire_fini(&ctx);\n\t} while (!time_after(jiffies, stress->timeout));\n\n\tkfree(order);\n\tkfree(stress);\n}"
  },
  {
    "function_name": "dummy_load",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "386-389",
    "snippet": "static void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "usleep_range",
          "args": [
            "1000",
            "2000"
          ],
          "line": 388
        },
        "resolved": true,
        "details": {
          "function_name": "usleep_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timer.c",
          "lines": "1987-1998",
          "snippet": "void __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/io.h>",
            "#include <asm/timex.h>",
            "#include <asm/div64.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/tick.h>",
            "#include <linux/delay.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cpu.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/time.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/notifier.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel_stat.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "__visible u64"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/io.h>\n#include <asm/timex.h>\n#include <asm/div64.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/slab.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/irq_work.h>\n#include <linux/kallsyms.h>\n#include <linux/tick.h>\n#include <linux/delay.h>\n#include <linux/syscalls.h>\n#include <linux/cpu.h>\n#include <linux/posix-timers.h>\n#include <linux/jiffies.h>\n#include <linux/time.h>\n#include <linux/thread_info.h>\n#include <linux/notifier.h>\n#include <linux/pid_namespace.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/kernel_stat.h>\n\n__visible u64;\n\nvoid __sched usleep_range(unsigned long min, unsigned long max)\n{\n\tktime_t exp = ktime_add_us(ktime_get(), min);\n\tu64 delta = (u64)(max - min) * NSEC_PER_USEC;\n\n\tfor (;;) {\n\t\t__set_current_state(TASK_UNINTERRUPTIBLE);\n\t\t/* Do not return before the requested sleep time has elapsed */\n\t\tif (!schedule_hrtimeout_range(&exp, delta, HRTIMER_MODE_ABS))\n\t\t\tbreak;\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic void dummy_load(struct stress *stress)\n{\n\tusleep_range(1000, 2000);\n}"
  },
  {
    "function_name": "get_random_order",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "362-384",
    "snippet": "static int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_random_int",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "count",
            "sizeof(*order)",
            "GFP_KERNEL"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int *get_random_order(int count)\n{\n\tint *order;\n\tint n, r, tmp;\n\n\torder = kmalloc_array(count, sizeof(*order), GFP_KERNEL);\n\tif (!order)\n\t\treturn order;\n\n\tfor (n = 0; n < count; n++)\n\t\torder[n] = n;\n\n\tfor (n = count - 1; n > 1; n--) {\n\t\tr = get_random_int() % (n + 1);\n\t\tif (r != n) {\n\t\t\ttmp = order[n];\n\t\t\torder[n] = order[r];\n\t\t\torder[r] = tmp;\n\t\t}\n\t}\n\n\treturn order;\n}"
  },
  {
    "function_name": "test_cycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "341-353",
    "snippet": "static int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_cycle",
          "args": [
            "n"
          ],
          "line": 347
        },
        "resolved": true,
        "details": {
          "function_name": "__test_cycle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "288-339",
          "snippet": "static int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);",
            "struct workqueue_struct *wq;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic int test_cycle(unsigned int ncpus)\n{\n\tunsigned int n;\n\tint ret;\n\n\tfor (n = 2; n <= ncpus + 1; n++) {\n\t\tret = __test_cycle(n);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__test_cycle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "288-339",
    "snippet": "static int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);",
      "struct workqueue_struct *wq;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "cycles"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_destroy",
          "args": [
            "&cycles[n].a_mutex"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\"",
            "n",
            "nthreads",
            "cycle->result"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flush_workqueue",
          "args": [
            "wq"
          ],
          "line": 320
        },
        "resolved": true,
        "details": {
          "function_name": "flush_workqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2643-2791",
          "snippet": "void flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool wq_online;",
            "static void workqueue_sysfs_unregister(struct workqueue_struct *wq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic bool wq_online;\nstatic void workqueue_sysfs_unregister(struct workqueue_struct *wq);\n\nvoid flush_workqueue(struct workqueue_struct *wq)\n{\n\tstruct wq_flusher this_flusher = {\n\t\t.list = LIST_HEAD_INIT(this_flusher.list),\n\t\t.flush_color = -1,\n\t\t.done = COMPLETION_INITIALIZER_ONSTACK_MAP(this_flusher.done, wq->lockdep_map),\n\t};\n\tint next_color;\n\n\tif (WARN_ON(!wq_online))\n\t\treturn;\n\n\tlock_map_acquire(&wq->lockdep_map);\n\tlock_map_release(&wq->lockdep_map);\n\n\tmutex_lock(&wq->mutex);\n\n\t/*\n\t * Start-to-wait phase\n\t */\n\tnext_color = work_next_color(wq->work_color);\n\n\tif (next_color != wq->flush_color) {\n\t\t/*\n\t\t * Color space is not full.  The current work_color\n\t\t * becomes our flush_color and work_color is advanced\n\t\t * by one.\n\t\t */\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow));\n\t\tthis_flusher.flush_color = wq->work_color;\n\t\twq->work_color = next_color;\n\n\t\tif (!wq->first_flusher) {\n\t\t\t/* no flush in progress, become the first flusher */\n\t\t\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\t\t\twq->first_flusher = &this_flusher;\n\n\t\t\tif (!flush_workqueue_prep_pwqs(wq, wq->flush_color,\n\t\t\t\t\t\t       wq->work_color)) {\n\t\t\t\t/* nothing to flush, done */\n\t\t\t\twq->flush_color = next_color;\n\t\t\t\twq->first_flusher = NULL;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t} else {\n\t\t\t/* wait in queue */\n\t\t\tWARN_ON_ONCE(wq->flush_color == this_flusher.flush_color);\n\t\t\tlist_add_tail(&this_flusher.list, &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\t} else {\n\t\t/*\n\t\t * Oops, color space is full, wait on overflow queue.\n\t\t * The next flush completion will assign us\n\t\t * flush_color and transfer to flusher_queue.\n\t\t */\n\t\tlist_add_tail(&this_flusher.list, &wq->flusher_overflow);\n\t}\n\n\tcheck_flush_dependency(wq, NULL);\n\n\tmutex_unlock(&wq->mutex);\n\n\twait_for_completion(&this_flusher.done);\n\n\t/*\n\t * Wake-up-and-cascade phase\n\t *\n\t * First flushers are responsible for cascading flushes and\n\t * handling overflow.  Non-first flushers can simply return.\n\t */\n\tif (wq->first_flusher != &this_flusher)\n\t\treturn;\n\n\tmutex_lock(&wq->mutex);\n\n\t/* we might have raced, check again with mutex held */\n\tif (wq->first_flusher != &this_flusher)\n\t\tgoto out_unlock;\n\n\twq->first_flusher = NULL;\n\n\tWARN_ON_ONCE(!list_empty(&this_flusher.list));\n\tWARN_ON_ONCE(wq->flush_color != this_flusher.flush_color);\n\n\twhile (true) {\n\t\tstruct wq_flusher *next, *tmp;\n\n\t\t/* complete all the flushers sharing the current flush color */\n\t\tlist_for_each_entry_safe(next, tmp, &wq->flusher_queue, list) {\n\t\t\tif (next->flush_color != wq->flush_color)\n\t\t\t\tbreak;\n\t\t\tlist_del_init(&next->list);\n\t\t\tcomplete(&next->done);\n\t\t}\n\n\t\tWARN_ON_ONCE(!list_empty(&wq->flusher_overflow) &&\n\t\t\t     wq->flush_color != work_next_color(wq->work_color));\n\n\t\t/* this flush_color is finished, advance by one */\n\t\twq->flush_color = work_next_color(wq->flush_color);\n\n\t\t/* one color has been freed, handle overflow queue */\n\t\tif (!list_empty(&wq->flusher_overflow)) {\n\t\t\t/*\n\t\t\t * Assign the same color to all overflowed\n\t\t\t * flushers, advance work_color and append to\n\t\t\t * flusher_queue.  This is the start-to-wait\n\t\t\t * phase for these overflowed flushers.\n\t\t\t */\n\t\t\tlist_for_each_entry(tmp, &wq->flusher_overflow, list)\n\t\t\t\ttmp->flush_color = wq->work_color;\n\n\t\t\twq->work_color = work_next_color(wq->work_color);\n\n\t\t\tlist_splice_tail_init(&wq->flusher_overflow,\n\t\t\t\t\t      &wq->flusher_queue);\n\t\t\tflush_workqueue_prep_pwqs(wq, -1, wq->work_color);\n\t\t}\n\n\t\tif (list_empty(&wq->flusher_queue)) {\n\t\t\tWARN_ON_ONCE(wq->flush_color != wq->work_color);\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * Need to flush more colors.  Make the next flusher\n\t\t * the new first flusher and arm pwqs.\n\t\t */\n\t\tWARN_ON_ONCE(wq->flush_color == wq->work_color);\n\t\tWARN_ON_ONCE(wq->flush_color != next->flush_color);\n\n\t\tlist_del_init(&next->list);\n\t\twq->first_flusher = next;\n\n\t\tif (flush_workqueue_prep_pwqs(wq, wq->flush_color, -1))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * Meh... this color is already done, clear first\n\t\t * flusher and repeat cascading.\n\t\t */\n\t\twq->first_flusher = NULL;\n\t}\n\nout_unlock:\n\tmutex_unlock(&wq->mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "queue_work",
          "args": [
            "wq",
            "&cycles[n].work"
          ],
          "line": 318
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_stop_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/stop_machine.c",
          "lines": "77-97",
          "snippet": "static bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}",
          "includes": [
            "#include <linux/sched/wake_q.h>",
            "#include <linux/nmi.h>",
            "#include <linux/atomic.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/sched.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/kthread.h>",
            "#include <linux/init.h>",
            "#include <linux/cpu.h>",
            "#include <linux/completion.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/wake_q.h>\n#include <linux/nmi.h>\n#include <linux/atomic.h>\n#include <linux/smpboot.h>\n#include <linux/kallsyms.h>\n#include <linux/interrupt.h>\n#include <linux/stop_machine.h>\n#include <linux/sched.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/kthread.h>\n#include <linux/init.h>\n#include <linux/cpu.h>\n#include <linux/completion.h>\n\nstatic DEFINE_PER_CPU(struct cpu_stopper, cpu_stopper);\n\nstatic bool cpu_stop_queue_work(unsigned int cpu, struct cpu_stop_work *work)\n{\n\tstruct cpu_stopper *stopper = &per_cpu(cpu_stopper, cpu);\n\tDEFINE_WAKE_Q(wakeq);\n\tunsigned long flags;\n\tbool enabled;\n\n\tpreempt_disable();\n\traw_spin_lock_irqsave(&stopper->lock, flags);\n\tenabled = stopper->enabled;\n\tif (enabled)\n\t\t__cpu_stop_queue_work(stopper, work, &wakeq);\n\telse if (work->done)\n\t\tcpu_stop_signal_done(work->done);\n\traw_spin_unlock_irqrestore(&stopper->lock, flags);\n\n\twake_up_q(&wakeq);\n\tpreempt_enable();\n\n\treturn enabled;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_WORK",
          "args": [
            "&cycle->work",
            "test_cycle_work"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&cycle->b_signal"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&cycle->a_mutex",
            "&ww_class"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "nthreads",
            "sizeof(*cycles)",
            "GFP_KERNEL"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\nstruct workqueue_struct *wq;\n\nstatic int __test_cycle(unsigned int nthreads)\n{\n\tstruct test_cycle *cycles;\n\tunsigned int n, last = nthreads - 1;\n\tint ret;\n\n\tcycles = kmalloc_array(nthreads, sizeof(*cycles), GFP_KERNEL);\n\tif (!cycles)\n\t\treturn -ENOMEM;\n\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tww_mutex_init(&cycle->a_mutex, &ww_class);\n\t\tif (n == last)\n\t\t\tcycle->b_mutex = &cycles[0].a_mutex;\n\t\telse\n\t\t\tcycle->b_mutex = &cycles[n + 1].a_mutex;\n\n\t\tif (n == 0)\n\t\t\tcycle->a_signal = &cycles[last].b_signal;\n\t\telse\n\t\t\tcycle->a_signal = &cycles[n - 1].b_signal;\n\t\tinit_completion(&cycle->b_signal);\n\n\t\tINIT_WORK(&cycle->work, test_cycle_work);\n\t\tcycle->result = 0;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tqueue_work(wq, &cycles[n].work);\n\n\tflush_workqueue(wq);\n\n\tret = 0;\n\tfor (n = 0; n < nthreads; n++) {\n\t\tstruct test_cycle *cycle = &cycles[n];\n\n\t\tif (!cycle->result)\n\t\t\tcontinue;\n\n\t\tpr_err(\"cyclic deadlock not resolved, ret[%d/%d] = %d\\n\",\n\t\t       n, nthreads, cycle->result);\n\t\tret = -EINVAL;\n\t\tbreak;\n\t}\n\n\tfor (n = 0; n < nthreads; n++)\n\t\tww_mutex_destroy(&cycles[n].a_mutex);\n\tkfree(cycles);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_cycle_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "259-286",
    "snippet": "static void test_cycle_work(struct work_struct *work)\n{\n\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err, erra = 0;\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&cycle->a_mutex, &ctx);\n\n\tcomplete(cycle->a_signal);\n\twait_for_completion(&cycle->b_signal);\n\n\terr = ww_mutex_lock(cycle->b_mutex, &ctx);\n\tif (err == -EDEADLK) {\n\t\terr = 0;\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);\n\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(cycle->b_mutex);\n\tif (!erra)\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tcycle->result = err ?: erra;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&cycle->a_mutex"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&cycle->a_mutex",
            "&ctx"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "cycle->b_mutex",
            "&ctx"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&cycle->b_signal"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "cycle->a_signal"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*cycle)",
            "work"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*cycle"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void test_cycle_work(struct work_struct *work)\n{\n\tstruct test_cycle *cycle = container_of(work, typeof(*cycle), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err, erra = 0;\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&cycle->a_mutex, &ctx);\n\n\tcomplete(cycle->a_signal);\n\twait_for_completion(&cycle->b_signal);\n\n\terr = ww_mutex_lock(cycle->b_mutex, &ctx);\n\tif (err == -EDEADLK) {\n\t\terr = 0;\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\t\tww_mutex_lock_slow(cycle->b_mutex, &ctx);\n\t\terra = ww_mutex_lock(&cycle->a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(cycle->b_mutex);\n\tif (!erra)\n\t\tww_mutex_unlock(&cycle->a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tcycle->result = err ?: erra;\n}"
  },
  {
    "function_name": "test_abba",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "197-248",
    "snippet": "static int test_abba(bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba.a_mutex, &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\"",
            "__func__",
            "err",
            "abba.result"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\"",
            "__func__",
            "err",
            "abba.result"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&abba.work"
          ],
          "line": 231
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "508-511",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&abba.work"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&abba.a_mutex"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&abba.a_mutex",
            "&ctx"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&abba.b_mutex",
            "&ctx"
          ],
          "line": 221
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&abba.b_ready"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&abba.a_ready"
          ],
          "line": 215
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 212
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&abba.work"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&abba.b_ready"
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&abba.a_ready"
          ],
          "line": 206
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&abba.work",
            "test_abba_work"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&abba.b_mutex",
            "&ww_class"
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&abba.a_mutex",
            "&ww_class"
          ],
          "line": 203
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_abba(bool resolve)\n{\n\tstruct test_abba abba;\n\tstruct ww_acquire_ctx ctx;\n\tint err, ret;\n\n\tww_mutex_init(&abba.a_mutex, &ww_class);\n\tww_mutex_init(&abba.b_mutex, &ww_class);\n\tINIT_WORK_ONSTACK(&abba.work, test_abba_work);\n\tinit_completion(&abba.a_ready);\n\tinit_completion(&abba.b_ready);\n\tabba.resolve = resolve;\n\n\tschedule_work(&abba.work);\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba.a_mutex, &ctx);\n\n\tcomplete(&abba.a_ready);\n\twait_for_completion(&abba.b_ready);\n\n\terr = ww_mutex_lock(&abba.b_mutex, &ctx);\n\tif (resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba.a_mutex);\n\t\tww_mutex_lock_slow(&abba.b_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba.a_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba.b_mutex);\n\tww_mutex_unlock(&abba.a_mutex);\n\tww_acquire_fini(&ctx);\n\n\tflush_work(&abba.work);\n\tdestroy_work_on_stack(&abba.work);\n\n\tret = 0;\n\tif (resolve) {\n\t\tif (err || abba.result) {\n\t\t\tpr_err(\"%s: failed to resolve ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t} else {\n\t\tif (err != -EDEADLK && abba.result != -EDEADLK) {\n\t\t\tpr_err(\"%s: missed ABBA deadlock, A err=%d, B err=%d\\n\",\n\t\t\t       __func__, err, abba.result);\n\t\t\tret = -EINVAL;\n\t\t}\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "test_abba_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "170-195",
    "snippet": "static void test_abba_work(struct work_struct *work)\n{\n\tstruct test_abba *abba = container_of(work, typeof(*abba), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err;\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba->b_mutex, &ctx);\n\n\tcomplete(&abba->b_ready);\n\twait_for_completion(&abba->a_ready);\n\n\terr = ww_mutex_lock(&abba->a_mutex, &ctx);\n\tif (abba->resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba->b_mutex);\n\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba->a_mutex);\n\tww_mutex_unlock(&abba->b_mutex);\n\tww_acquire_fini(&ctx);\n\n\tabba->result = err;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&abba->b_mutex"
          ],
          "line": 191
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&abba->b_mutex",
            "&ctx"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock_slow",
          "args": [
            "&abba->a_mutex",
            "&ctx"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "__ww_mutex_lock_slowpath",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1348-1353",
          "snippet": "__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\n__sched\n__ww_mutex_lock_slowpath(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\treturn __ww_mutex_lock(&lock->base, TASK_UNINTERRUPTIBLE, 0, NULL,\n\t\t\t       _RET_IP_, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&abba->a_ready"
          ],
          "line": 180
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&abba->b_ready"
          ],
          "line": 179
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*abba)",
            "work"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*abba"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic void test_abba_work(struct work_struct *work)\n{\n\tstruct test_abba *abba = container_of(work, typeof(*abba), work);\n\tstruct ww_acquire_ctx ctx;\n\tint err;\n\n\tww_acquire_init(&ctx, &ww_class);\n\tww_mutex_lock(&abba->b_mutex, &ctx);\n\n\tcomplete(&abba->b_ready);\n\twait_for_completion(&abba->a_ready);\n\n\terr = ww_mutex_lock(&abba->a_mutex, &ctx);\n\tif (abba->resolve && err == -EDEADLK) {\n\t\tww_mutex_unlock(&abba->b_mutex);\n\t\tww_mutex_lock_slow(&abba->a_mutex, &ctx);\n\t\terr = ww_mutex_lock(&abba->b_mutex, &ctx);\n\t}\n\n\tif (!err)\n\t\tww_mutex_unlock(&abba->a_mutex);\n\tww_mutex_unlock(&abba->b_mutex);\n\tww_acquire_fini(&ctx);\n\n\tabba->result = err;\n}"
  },
  {
    "function_name": "test_aa",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "125-158",
    "snippet": "static int test_aa(void)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tww_mutex_lock(&mutex, &ctx);\n\n\tif (ww_mutex_trylock(&mutex))  {\n\t\tpr_err(\"%s: trylocked itself!\\n\", __func__);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d\\n\",\n\t\t       __func__, ret);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tww_mutex_unlock(&mutex);\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mutex"
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: missed deadlock for recursing, ret=%d\\n\"",
            "__func__",
            "ret"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mutex",
            "&ctx"
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s: trylocked itself!\\n\"",
            "__func__"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&mutex"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&mutex",
            "&ww_class"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int test_aa(void)\n{\n\tstruct ww_mutex mutex;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tww_mutex_lock(&mutex, &ctx);\n\n\tif (ww_mutex_trylock(&mutex))  {\n\t\tpr_err(\"%s: trylocked itself!\\n\", __func__);\n\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = ww_mutex_lock(&mutex, &ctx);\n\tif (ret != -EALREADY) {\n\t\tpr_err(\"%s: missed deadlock for recursing, ret=%d\\n\",\n\t\t       __func__, ret);\n\t\tif (!ret)\n\t\t\tww_mutex_unlock(&mutex);\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tret = 0;\nout:\n\tww_mutex_unlock(&mutex);\n\tww_acquire_fini(&ctx);\n\treturn ret;\n}"
  },
  {
    "function_name": "test_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "111-123",
    "snippet": "static int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define __TEST_MTX_LAST BIT(3)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__test_mutex",
          "args": [
            "i"
          ],
          "line": 117
        },
        "resolved": true,
        "details": {
          "function_name": "__test_mutex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
          "lines": "61-109",
          "snippet": "static int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}",
          "includes": [
            "#include <linux/ww_mutex.h>",
            "#include <linux/slab.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/kthread.h>",
            "#include <linux/delay.h>",
            "#include <linux/completion.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TIMEOUT (HZ / 16)",
            "#define TEST_MTX_CTX BIT(2)",
            "#define TEST_MTX_SPIN BIT(0)"
          ],
          "globals_used": [
            "static DEFINE_WD_CLASS(ww_class);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TIMEOUT (HZ / 16)\n#define TEST_MTX_CTX BIT(2)\n#define TEST_MTX_SPIN BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define __TEST_MTX_LAST BIT(3)\n\nstatic int test_mutex(void)\n{\n\tint ret;\n\tint i;\n\n\tfor (i = 0; i < __TEST_MTX_LAST; i++) {\n\t\tret = __test_mutex(i);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__test_mutex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "61-109",
    "snippet": "static int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TIMEOUT (HZ / 16)",
      "#define TEST_MTX_CTX BIT(2)",
      "#define TEST_MTX_SPIN BIT(0)"
    ],
    "globals_used": [
      "static DEFINE_WD_CLASS(ww_class);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_work_on_stack",
          "args": [
            "&mtx.work"
          ],
          "line": 106
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_work_on_stack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "508-511",
          "snippet": "void destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nvoid destroy_work_on_stack(struct work_struct *work)\n{\n\tdebug_object_free(work, &work_debug_descr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_work",
          "args": [
            "&mtx.work"
          ],
          "line": 105
        },
        "resolved": true,
        "details": {
          "function_name": "flush_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "2936-2939",
          "snippet": "bool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nbool flush_work(struct work_struct *work)\n{\n\treturn __flush_work(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"%s(flags=%x): mutual exclusion failure\\n\"",
            "__func__",
            "flags"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_fini",
          "args": [
            "&ctx"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mtx.mutex"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion_timeout",
          "args": [
            "&mtx.done",
            "TIMEOUT"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "wait_for_completion_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "152-156",
          "snippet": "unsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nunsigned long __sched\nwait_for_completion_timeout(struct completion *x, unsigned long timeout)\n{\n\treturn wait_for_common(x, timeout, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "time_before",
          "args": [
            "jiffies",
            "timeout"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "completion_done",
          "args": [
            "&mtx.done"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "completion_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "313-328",
          "snippet": "bool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool completion_done(struct completion *x)\n{\n\tunsigned long flags;\n\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\t/*\n\t * If ->done, we need to wait for complete() to release ->wait.lock\n\t * otherwise we can end up freeing the completion before complete()\n\t * is done referencing it.\n\t */\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&mtx.go"
          ],
          "line": 81
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mtx.mutex",
            "(flags & TEST_MTX_CTX) ? &ctx : NULL"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&mtx.ready"
          ],
          "line": 79
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&mtx.work"
          ],
          "line": 77
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.done"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.go"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "init_completion",
          "args": [
            "&mtx.ready"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_WORK_ONSTACK",
          "args": [
            "&mtx.work",
            "test_mutex_work"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_acquire_init",
          "args": [
            "&ctx",
            "&ww_class"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ww_mutex_init",
          "args": [
            "&mtx.mutex",
            "&ww_class"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TIMEOUT (HZ / 16)\n#define TEST_MTX_CTX BIT(2)\n#define TEST_MTX_SPIN BIT(0)\n\nstatic DEFINE_WD_CLASS(ww_class);\n\nstatic int __test_mutex(unsigned int flags)\n{\n#define TIMEOUT (HZ / 16)\n\tstruct test_mutex mtx;\n\tstruct ww_acquire_ctx ctx;\n\tint ret;\n\n\tww_mutex_init(&mtx.mutex, &ww_class);\n\tww_acquire_init(&ctx, &ww_class);\n\n\tINIT_WORK_ONSTACK(&mtx.work, test_mutex_work);\n\tinit_completion(&mtx.ready);\n\tinit_completion(&mtx.go);\n\tinit_completion(&mtx.done);\n\tmtx.flags = flags;\n\n\tschedule_work(&mtx.work);\n\n\twait_for_completion(&mtx.ready);\n\tww_mutex_lock(&mtx.mutex, (flags & TEST_MTX_CTX) ? &ctx : NULL);\n\tcomplete(&mtx.go);\n\tif (flags & TEST_MTX_SPIN) {\n\t\tunsigned long timeout = jiffies + TIMEOUT;\n\n\t\tret = 0;\n\t\tdo {\n\t\t\tif (completion_done(&mtx.done)) {\n\t\t\t\tret = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcond_resched();\n\t\t} while (time_before(jiffies, timeout));\n\t} else {\n\t\tret = wait_for_completion_timeout(&mtx.done, TIMEOUT);\n\t}\n\tww_mutex_unlock(&mtx.mutex);\n\tww_acquire_fini(&ctx);\n\n\tif (ret) {\n\t\tpr_err(\"%s(flags=%x): mutual exclusion failure\\n\",\n\t\t       __func__, flags);\n\t\tret = -EINVAL;\n\t}\n\n\tflush_work(&mtx.work);\n\tdestroy_work_on_stack(&mtx.work);\n\treturn ret;\n#undef TIMEOUT\n}"
  },
  {
    "function_name": "test_mutex_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/test-ww_mutex.c",
    "lines": "44-59",
    "snippet": "static void test_mutex_work(struct work_struct *work)\n{\n\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);\n\n\tcomplete(&mtx->ready);\n\twait_for_completion(&mtx->go);\n\n\tif (mtx->flags & TEST_MTX_TRY) {\n\t\twhile (!ww_mutex_trylock(&mtx->mutex))\n\t\t\tcond_resched();\n\t} else {\n\t\tww_mutex_lock(&mtx->mutex, NULL);\n\t}\n\tcomplete(&mtx->done);\n\tww_mutex_unlock(&mtx->mutex);\n}",
    "includes": [
      "#include <linux/ww_mutex.h>",
      "#include <linux/slab.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/kthread.h>",
      "#include <linux/delay.h>",
      "#include <linux/completion.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TEST_MTX_TRY BIT(1)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ww_mutex_unlock",
          "args": [
            "&mtx->mutex"
          ],
          "line": 58
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "728-744",
          "snippet": "void __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nvoid __sched ww_mutex_unlock(struct ww_mutex *lock)\n{\n\t/*\n\t * The unlocking fastpath is the 0->1 transition from 'locked'\n\t * into 'unlocked' state:\n\t */\n\tif (lock->ctx) {\n#ifdef CONFIG_DEBUG_MUTEXES\n\t\tDEBUG_LOCKS_WARN_ON(!lock->ctx->acquired);\n#endif\n\t\tif (lock->ctx->acquired > 0)\n\t\t\tlock->ctx->acquired--;\n\t\tlock->ctx = NULL;\n\t}\n\n\tmutex_unlock(&lock->base);\n}"
        }
      },
      {
        "call_info": {
          "callee": "complete",
          "args": [
            "&mtx->done"
          ],
          "line": 57
        },
        "resolved": true,
        "details": {
          "function_name": "complete_vfork_done",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1205-1216",
          "snippet": "static void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void complete_vfork_done(struct task_struct *tsk)\n{\n\tstruct completion *vfork;\n\n\ttask_lock(tsk);\n\tvfork = tsk->vfork_done;\n\tif (likely(vfork)) {\n\t\ttsk->vfork_done = NULL;\n\t\tcomplete(vfork);\n\t}\n\ttask_unlock(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_lock",
          "args": [
            "&mtx->mutex",
            "NULL"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "ww_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/mutex.c",
          "lines": "1406-1418",
          "snippet": "int __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}",
          "includes": [
            "# include \"mutex.h\"",
            "# include \"mutex-debug.h\"",
            "#include <linux/osq_lock.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/ww_mutex.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "# include \"mutex.h\"\n# include \"mutex-debug.h\"\n#include <linux/osq_lock.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/ww_mutex.h>\n#include <linux/mutex.h>\n\nint __sched\nww_mutex_lock_interruptible(struct ww_mutex *lock, struct ww_acquire_ctx *ctx)\n{\n\tmight_sleep();\n\n\tif (__mutex_trylock_fast(&lock->base)) {\n\t\tif (ctx)\n\t\t\tww_mutex_set_context_fastpath(lock, ctx);\n\t\treturn 0;\n\t}\n\n\treturn __ww_mutex_lock_interruptible_slowpath(lock, ctx);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cond_resched",
          "args": [],
          "line": 53
        },
        "resolved": true,
        "details": {
          "function_name": "_cond_resched",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4957-4965",
          "snippet": "int __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nint __sched _cond_resched(void)\n{\n\tif (should_resched(0)) {\n\t\tpreempt_schedule_common();\n\t\treturn 1;\n\t}\n\trcu_all_qs();\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ww_mutex_trylock",
          "args": [
            "&mtx->mutex"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_for_completion",
          "args": [
            "&mtx->go"
          ],
          "line": 49
        },
        "resolved": true,
        "details": {
          "function_name": "try_wait_for_completion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/completion.c",
          "lines": "280-301",
          "snippet": "bool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nbool try_wait_for_completion(struct completion *x)\n{\n\tunsigned long flags;\n\tbool ret = true;\n\n\t/*\n\t * Since x->done will need to be locked only\n\t * in the non-blocking case, we check x->done\n\t * first without taking the lock so we can\n\t * return early in the blocking case.\n\t */\n\tif (!READ_ONCE(x->done))\n\t\treturn false;\n\n\tspin_lock_irqsave(&x->wait.lock, flags);\n\tif (!x->done)\n\t\tret = false;\n\telse if (x->done != UINT_MAX)\n\t\tx->done--;\n\tspin_unlock_irqrestore(&x->wait.lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "typeof(*mtx)",
            "work"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "typeof",
          "args": [
            "*mtx"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/ww_mutex.h>\n#include <linux/slab.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/kthread.h>\n#include <linux/delay.h>\n#include <linux/completion.h>\n#include <linux/kernel.h>\n\n#define TEST_MTX_TRY BIT(1)\n\nstatic void test_mutex_work(struct work_struct *work)\n{\n\tstruct test_mutex *mtx = container_of(work, typeof(*mtx), work);\n\n\tcomplete(&mtx->ready);\n\twait_for_completion(&mtx->go);\n\n\tif (mtx->flags & TEST_MTX_TRY) {\n\t\twhile (!ww_mutex_trylock(&mtx->mutex))\n\t\t\tcond_resched();\n\t} else {\n\t\tww_mutex_lock(&mtx->mutex, NULL);\n\t}\n\tcomplete(&mtx->done);\n\tww_mutex_unlock(&mtx->mutex);\n}"
  }
]