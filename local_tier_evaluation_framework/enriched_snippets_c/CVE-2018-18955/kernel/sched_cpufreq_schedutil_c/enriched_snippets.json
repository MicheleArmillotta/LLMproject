[
  {
    "function_name": "sugov_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "881-884",
    "snippet": "static int __init sugov_register(void)\n{\n\treturn cpufreq_register_governor(&schedutil_gov);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpufreq_governor schedutil_gov;",
      "static struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_register_governor",
          "args": [
            "&schedutil_gov"
          ],
          "line": 883
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct cpufreq_governor schedutil_gov;\nstatic struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};\n\nstatic int __init sugov_register(void)\n{\n\treturn cpufreq_register_governor(&schedutil_gov);\n}"
  },
  {
    "function_name": "cpufreq_default_governor",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "875-878",
    "snippet": "struct cpufreq_governor *cpufreq_default_governor(void)\n{\n\treturn &schedutil_gov;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct cpufreq_governor schedutil_gov;",
      "static struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct cpufreq_governor schedutil_gov;\nstatic struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};\n\nstruct cpufreq_governor *cpufreq_default_governor(void)\n{\n\treturn &schedutil_gov;\n}"
  },
  {
    "function_name": "sugov_limits",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "850-861",
    "snippet": "static void sugov_limits(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\n\tif (!policy->fast_switch_enabled) {\n\t\tmutex_lock(&sg_policy->work_lock);\n\t\tcpufreq_policy_apply_limits(policy);\n\t\tmutex_unlock(&sg_policy->work_lock);\n\t}\n\n\tsg_policy->need_freq_update = true;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 857
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpufreq_policy_apply_limits",
          "args": [
            "policy"
          ],
          "line": 856
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 855
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_limits(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\n\tif (!policy->fast_switch_enabled) {\n\t\tmutex_lock(&sg_policy->work_lock);\n\t\tcpufreq_policy_apply_limits(policy);\n\t\tmutex_unlock(&sg_policy->work_lock);\n\t}\n\n\tsg_policy->need_freq_update = true;\n}"
  },
  {
    "function_name": "sugov_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "834-848",
    "snippet": "static void sugov_stop(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->cpus)\n\t\tcpufreq_remove_update_util_hook(cpu);\n\n\tsynchronize_sched();\n\n\tif (!policy->fast_switch_enabled) {\n\t\tirq_work_sync(&sg_policy->irq_work);\n\t\tkthread_cancel_work_sync(&sg_policy->work);\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_cancel_work_sync",
          "args": [
            "&sg_policy->work"
          ],
          "line": 846
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_cancel_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "1120-1123",
          "snippet": "bool kthread_cancel_work_sync(struct kthread_work *work)\n{\n\treturn __kthread_cancel_work_sync(work, false);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_cancel_work_sync(struct kthread_work *work)\n{\n\treturn __kthread_cancel_work_sync(work, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_work_sync",
          "args": [
            "&sg_policy->irq_work"
          ],
          "line": 845
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_sync",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "188-194",
          "snippet": "void irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nvoid irq_work_sync(struct irq_work *work)\n{\n\tlockdep_assert_irqs_enabled();\n\n\twhile (work->flags & IRQ_WORK_BUSY)\n\t\tcpu_relax();\n}"
        }
      },
      {
        "call_info": {
          "callee": "synchronize_sched",
          "args": [],
          "line": 842
        },
        "resolved": true,
        "details": {
          "function_name": "synchronize_sched_expedited_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_exp.h",
          "lines": "468-540",
          "snippet": "static void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}",
          "includes": [
            "#include <linux/lockdep.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/lockdep.h>\n\nstatic void synchronize_sched_expedited_wait(void)\n{\n\tint cpu;\n\tunsigned long jiffies_stall;\n\tunsigned long jiffies_start;\n\tunsigned long mask;\n\tint ndetected;\n\tstruct rcu_node *rnp;\n\tstruct rcu_node *rnp_root = rcu_get_root();\n\tint ret;\n\n\ttrace_rcu_exp_grace_period(rcu_state.name, rcu_exp_gp_seq_endval(), TPS(\"startwait\"));\n\tjiffies_stall = rcu_jiffies_till_stall_check();\n\tjiffies_start = jiffies;\n\n\tfor (;;) {\n\t\tret = swait_event_timeout_exclusive(\n\t\t\t\trcu_state.expedited_wq,\n\t\t\t\tsync_rcu_preempt_exp_done_unlocked(rnp_root),\n\t\t\t\tjiffies_stall);\n\t\tif (ret > 0 || sync_rcu_preempt_exp_done_unlocked(rnp_root))\n\t\t\treturn;\n\t\tWARN_ON(ret < 0);  /* workqueues should not be signaled. */\n\t\tif (rcu_cpu_stall_suppress)\n\t\t\tcontinue;\n\t\tpanic_on_rcu_stall();\n\t\tpr_err(\"INFO: %s detected expedited stalls on CPUs/tasks: {\",\n\t\t       rcu_state.name);\n\t\tndetected = 0;\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tndetected += rcu_print_task_exp_stall(rnp);\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tstruct rcu_data *rdp;\n\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tndetected++;\n\t\t\t\trdp = per_cpu_ptr(&rcu_data, cpu);\n\t\t\t\tpr_cont(\" %d-%c%c%c\", cpu,\n\t\t\t\t\t\"O.\"[!!cpu_online(cpu)],\n\t\t\t\t\t\"o.\"[!!(rdp->grpmask & rnp->expmaskinit)],\n\t\t\t\t\t\"N.\"[!!(rdp->grpmask & rnp->expmaskinitnext)]);\n\t\t\t}\n\t\t}\n\t\tpr_cont(\" } %lu jiffies s: %lu root: %#lx/%c\\n\",\n\t\t\tjiffies - jiffies_start, rcu_state.expedited_sequence,\n\t\t\trnp_root->expmask, \".T\"[!!rnp_root->exp_tasks]);\n\t\tif (ndetected) {\n\t\t\tpr_err(\"blocking rcu_node structures:\");\n\t\t\trcu_for_each_node_breadth_first(rnp) {\n\t\t\t\tif (rnp == rnp_root)\n\t\t\t\t\tcontinue; /* printed unconditionally */\n\t\t\t\tif (sync_rcu_preempt_exp_done_unlocked(rnp))\n\t\t\t\t\tcontinue;\n\t\t\t\tpr_cont(\" l=%u:%d-%d:%#lx/%c\",\n\t\t\t\t\trnp->level, rnp->grplo, rnp->grphi,\n\t\t\t\t\trnp->expmask,\n\t\t\t\t\t\".T\"[!!rnp->exp_tasks]);\n\t\t\t}\n\t\t\tpr_cont(\"\\n\");\n\t\t}\n\t\trcu_for_each_leaf_node(rnp) {\n\t\t\tfor_each_leaf_node_possible_cpu(rnp, cpu) {\n\t\t\t\tmask = leaf_node_cpu_bit(rnp, cpu);\n\t\t\t\tif (!(rnp->expmask & mask))\n\t\t\t\t\tcontinue;\n\t\t\t\tdump_cpu_task(cpu);\n\t\t\t}\n\t\t}\n\t\tjiffies_stall = 3 * rcu_jiffies_till_stall_check() + 3;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpufreq_remove_update_util_hook",
          "args": [
            "cpu"
          ],
          "line": 840
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_remove_update_util_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq.c",
          "lines": "58-61",
          "snippet": "void cpufreq_remove_update_util_hook(int cpu)\n{\n\trcu_assign_pointer(per_cpu(cpufreq_update_util_data, cpu), NULL);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpufreq_remove_update_util_hook(int cpu)\n{\n\trcu_assign_pointer(per_cpu(cpufreq_update_util_data, cpu), NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "policy->cpus"
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_stop(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tunsigned int cpu;\n\n\tfor_each_cpu(cpu, policy->cpus)\n\t\tcpufreq_remove_update_util_hook(cpu);\n\n\tsynchronize_sched();\n\n\tif (!policy->fast_switch_enabled) {\n\t\tirq_work_sync(&sg_policy->irq_work);\n\t\tkthread_cancel_work_sync(&sg_policy->work);\n\t}\n}"
  },
  {
    "function_name": "sugov_start",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "802-832",
    "snippet": "static int sugov_start(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tunsigned int cpu;\n\n\tsg_policy->freq_update_delay_ns\t= sg_policy->tunables->rate_limit_us * NSEC_PER_USEC;\n\tsg_policy->last_freq_update_time\t= 0;\n\tsg_policy->next_freq\t\t\t= 0;\n\tsg_policy->work_in_progress\t\t= false;\n\tsg_policy->need_freq_update\t\t= false;\n\tsg_policy->cached_raw_freq\t\t= 0;\n\n\tfor_each_cpu(cpu, policy->cpus) {\n\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);\n\n\t\tmemset(sg_cpu, 0, sizeof(*sg_cpu));\n\t\tsg_cpu->cpu\t\t\t= cpu;\n\t\tsg_cpu->sg_policy\t\t= sg_policy;\n\t\tsg_cpu->iowait_boost_max\t= policy->cpuinfo.max_freq;\n\t}\n\n\tfor_each_cpu(cpu, policy->cpus) {\n\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);\n\n\t\tcpufreq_add_update_util_hook(cpu, &sg_cpu->update_util,\n\t\t\t\t\t     policy_is_shared(policy) ?\n\t\t\t\t\t\t\tsugov_update_shared :\n\t\t\t\t\t\t\tsugov_update_single);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);",
      "static struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_add_update_util_hook",
          "args": [
            "cpu",
            "&sg_cpu->update_util",
            "policy_is_shared(policy) ?\n\t\t\t\t\t\t\tsugov_update_shared :\n\t\t\t\t\t\t\tsugov_update_single"
          ],
          "line": 826
        },
        "resolved": true,
        "details": {
          "function_name": "cpufreq_add_update_util_hook",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq.c",
          "lines": "33-45",
          "snippet": "void cpufreq_add_update_util_hook(int cpu, struct update_util_data *data,\n\t\t\tvoid (*func)(struct update_util_data *data, u64 time,\n\t\t\t\t     unsigned int flags))\n{\n\tif (WARN_ON(!data || !func))\n\t\treturn;\n\n\tif (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))\n\t\treturn;\n\n\tdata->func = func;\n\trcu_assign_pointer(per_cpu(cpufreq_update_util_data, cpu), data);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid cpufreq_add_update_util_hook(int cpu, struct update_util_data *data,\n\t\t\tvoid (*func)(struct update_util_data *data, u64 time,\n\t\t\t\t     unsigned int flags))\n{\n\tif (WARN_ON(!data || !func))\n\t\treturn;\n\n\tif (WARN_ON(per_cpu(cpufreq_update_util_data, cpu)))\n\t\treturn;\n\n\tdata->func = func;\n\trcu_assign_pointer(per_cpu(cpufreq_update_util_data, cpu), data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "policy_is_shared",
          "args": [
            "policy"
          ],
          "line": 827
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sugov_cpu",
            "cpu"
          ],
          "line": 824
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "policy->cpus"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "sg_cpu",
            "0",
            "sizeof(*sg_cpu)"
          ],
          "line": 817
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "policy->cpus"
          ],
          "line": 814
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\nstatic struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);\n\nstatic int sugov_start(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tunsigned int cpu;\n\n\tsg_policy->freq_update_delay_ns\t= sg_policy->tunables->rate_limit_us * NSEC_PER_USEC;\n\tsg_policy->last_freq_update_time\t= 0;\n\tsg_policy->next_freq\t\t\t= 0;\n\tsg_policy->work_in_progress\t\t= false;\n\tsg_policy->need_freq_update\t\t= false;\n\tsg_policy->cached_raw_freq\t\t= 0;\n\n\tfor_each_cpu(cpu, policy->cpus) {\n\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);\n\n\t\tmemset(sg_cpu, 0, sizeof(*sg_cpu));\n\t\tsg_cpu->cpu\t\t\t= cpu;\n\t\tsg_cpu->sg_policy\t\t= sg_policy;\n\t\tsg_cpu->iowait_boost_max\t= policy->cpuinfo.max_freq;\n\t}\n\n\tfor_each_cpu(cpu, policy->cpus) {\n\t\tstruct sugov_cpu *sg_cpu = &per_cpu(sugov_cpu, cpu);\n\n\t\tcpufreq_add_update_util_hook(cpu, &sg_cpu->update_util,\n\t\t\t\t\t     policy_is_shared(policy) ?\n\t\t\t\t\t\t\tsugov_update_shared :\n\t\t\t\t\t\t\tsugov_update_single);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "sugov_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "782-800",
    "snippet": "static void sugov_exit(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tstruct sugov_tunables *tunables = sg_policy->tunables;\n\tunsigned int count;\n\n\tmutex_lock(&global_tunables_lock);\n\n\tcount = gov_attr_set_put(&tunables->attr_set, &sg_policy->tunables_hook);\n\tpolicy->governor_data = NULL;\n\tif (!count)\n\t\tsugov_tunables_free(tunables);\n\n\tmutex_unlock(&global_tunables_lock);\n\n\tsugov_kthread_stop(sg_policy);\n\tsugov_policy_free(sg_policy);\n\tcpufreq_disable_fast_switch(policy);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(global_tunables_lock);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_disable_fast_switch",
          "args": [
            "policy"
          ],
          "line": 799
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sugov_policy_free",
          "args": [
            "sg_policy"
          ],
          "line": 798
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_policy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "619-622",
          "snippet": "static void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_kthread_stop",
          "args": [
            "sg_policy"
          ],
          "line": 797
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "675-684",
          "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&global_tunables_lock"
          ],
          "line": 795
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_tunables_free",
          "args": [
            "tunables"
          ],
          "line": 793
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_tunables_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "699-705",
          "snippet": "static void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sugov_tunables *global_tunables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\n\nstatic void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}"
        }
      },
      {
        "call_info": {
          "callee": "gov_attr_set_put",
          "args": [
            "&tunables->attr_set",
            "&sg_policy->tunables_hook"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&global_tunables_lock"
          ],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_MUTEX(global_tunables_lock);\n\nstatic void sugov_exit(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy = policy->governor_data;\n\tstruct sugov_tunables *tunables = sg_policy->tunables;\n\tunsigned int count;\n\n\tmutex_lock(&global_tunables_lock);\n\n\tcount = gov_attr_set_put(&tunables->attr_set, &sg_policy->tunables_hook);\n\tpolicy->governor_data = NULL;\n\tif (!count)\n\t\tsugov_tunables_free(tunables);\n\n\tmutex_unlock(&global_tunables_lock);\n\n\tsugov_kthread_stop(sg_policy);\n\tsugov_policy_free(sg_policy);\n\tcpufreq_disable_fast_switch(policy);\n}"
  },
  {
    "function_name": "sugov_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "707-780",
    "snippet": "static int sugov_init(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\tstruct sugov_tunables *tunables;\n\tint ret = 0;\n\n\t/* State should be equivalent to EXIT */\n\tif (policy->governor_data)\n\t\treturn -EBUSY;\n\n\tcpufreq_enable_fast_switch(policy);\n\n\tsg_policy = sugov_policy_alloc(policy);\n\tif (!sg_policy) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_fast_switch;\n\t}\n\n\tret = sugov_kthread_create(sg_policy);\n\tif (ret)\n\t\tgoto free_sg_policy;\n\n\tmutex_lock(&global_tunables_lock);\n\n\tif (global_tunables) {\n\t\tif (WARN_ON(have_governor_per_policy())) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto stop_kthread;\n\t\t}\n\t\tpolicy->governor_data = sg_policy;\n\t\tsg_policy->tunables = global_tunables;\n\n\t\tgov_attr_set_get(&global_tunables->attr_set, &sg_policy->tunables_hook);\n\t\tgoto out;\n\t}\n\n\ttunables = sugov_tunables_alloc(sg_policy);\n\tif (!tunables) {\n\t\tret = -ENOMEM;\n\t\tgoto stop_kthread;\n\t}\n\n\ttunables->rate_limit_us = cpufreq_policy_transition_delay_us(policy);\n\n\tpolicy->governor_data = sg_policy;\n\tsg_policy->tunables = tunables;\n\n\tret = kobject_init_and_add(&tunables->attr_set.kobj, &sugov_tunables_ktype,\n\t\t\t\t   get_governor_parent_kobj(policy), \"%s\",\n\t\t\t\t   schedutil_gov.name);\n\tif (ret)\n\t\tgoto fail;\n\nout:\n\tmutex_unlock(&global_tunables_lock);\n\treturn 0;\n\nfail:\n\tpolicy->governor_data = NULL;\n\tsugov_tunables_free(tunables);\n\nstop_kthread:\n\tsugov_kthread_stop(sg_policy);\n\tmutex_unlock(&global_tunables_lock);\n\nfree_sg_policy:\n\tsugov_policy_free(sg_policy);\n\ndisable_fast_switch:\n\tcpufreq_disable_fast_switch(policy);\n\n\tpr_err(\"initialization failed (error %d)\\n\", ret);\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sugov_tunables *global_tunables;",
      "static DEFINE_MUTEX(global_tunables_lock);",
      "static struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);",
      "static struct kobj_type sugov_tunables_ktype = {\n\t.default_attrs = sugov_attributes,\n\t.sysfs_ops = &governor_sysfs_ops,\n};",
      "static struct cpufreq_governor schedutil_gov;",
      "static struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"initialization failed (error %d)\\n\"",
            "ret"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_disable_fast_switch",
          "args": [
            "policy"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sugov_policy_free",
          "args": [
            "sg_policy"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_policy_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "619-622",
          "snippet": "static void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&global_tunables_lock"
          ],
          "line": 770
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_kthread_stop",
          "args": [
            "sg_policy"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "675-684",
          "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_tunables_free",
          "args": [
            "tunables"
          ],
          "line": 766
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_tunables_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "699-705",
          "snippet": "static void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sugov_tunables *global_tunables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\n\nstatic void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kobject_init_and_add",
          "args": [
            "&tunables->attr_set.kobj",
            "&sugov_tunables_ktype",
            "get_governor_parent_kobj(policy)",
            "\"%s\"",
            "schedutil_gov.name"
          ],
          "line": 754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_governor_parent_kobj",
          "args": [
            "policy"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_policy_transition_delay_us",
          "args": [
            "policy"
          ],
          "line": 749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sugov_tunables_alloc",
          "args": [
            "sg_policy"
          ],
          "line": 743
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_tunables_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "686-697",
          "snippet": "static struct sugov_tunables *sugov_tunables_alloc(struct sugov_policy *sg_policy)\n{\n\tstruct sugov_tunables *tunables;\n\n\ttunables = kzalloc(sizeof(*tunables), GFP_KERNEL);\n\tif (tunables) {\n\t\tgov_attr_set_init(&tunables->attr_set, &sg_policy->tunables_hook);\n\t\tif (!have_governor_per_policy())\n\t\t\tglobal_tunables = tunables;\n\t}\n\treturn tunables;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sugov_tunables *global_tunables;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\n\nstatic struct sugov_tunables *sugov_tunables_alloc(struct sugov_policy *sg_policy)\n{\n\tstruct sugov_tunables *tunables;\n\n\ttunables = kzalloc(sizeof(*tunables), GFP_KERNEL);\n\tif (tunables) {\n\t\tgov_attr_set_init(&tunables->attr_set, &sg_policy->tunables_hook);\n\t\tif (!have_governor_per_policy())\n\t\t\tglobal_tunables = tunables;\n\t}\n\treturn tunables;\n}"
        }
      },
      {
        "call_info": {
          "callee": "gov_attr_set_get",
          "args": [
            "&global_tunables->attr_set",
            "&sg_policy->tunables_hook"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "have_governor_per_policy()"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "have_governor_per_policy",
          "args": [],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&global_tunables_lock"
          ],
          "line": 729
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_kthread_create",
          "args": [
            "sg_policy"
          ],
          "line": 725
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "624-673",
          "snippet": "static int sugov_kthread_create(struct sugov_policy *sg_policy)\n{\n\tstruct task_struct *thread;\n\tstruct sched_attr attr = {\n\t\t.size\t\t= sizeof(struct sched_attr),\n\t\t.sched_policy\t= SCHED_DEADLINE,\n\t\t.sched_flags\t= SCHED_FLAG_SUGOV,\n\t\t.sched_nice\t= 0,\n\t\t.sched_priority\t= 0,\n\t\t/*\n\t\t * Fake (unused) bandwidth; workaround to \"fix\"\n\t\t * priority inheritance.\n\t\t */\n\t\t.sched_runtime\t=  1000000,\n\t\t.sched_deadline = 10000000,\n\t\t.sched_period\t= 10000000,\n\t};\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tint ret;\n\n\t/* kthread only required for slow path */\n\tif (policy->fast_switch_enabled)\n\t\treturn 0;\n\n\tkthread_init_work(&sg_policy->work, sugov_work);\n\tkthread_init_worker(&sg_policy->worker);\n\tthread = kthread_create(kthread_worker_fn, &sg_policy->worker,\n\t\t\t\t\"sugov:%d\",\n\t\t\t\tcpumask_first(policy->related_cpus));\n\tif (IS_ERR(thread)) {\n\t\tpr_err(\"failed to create sugov thread: %ld\\n\", PTR_ERR(thread));\n\t\treturn PTR_ERR(thread);\n\t}\n\n\tret = sched_setattr_nocheck(thread, &attr);\n\tif (ret) {\n\t\tkthread_stop(thread);\n\t\tpr_warn(\"%s: failed to set SCHED_DEADLINE\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsg_policy->thread = thread;\n\tkthread_bind_mask(thread, policy->related_cpus);\n\tinit_irq_work(&sg_policy->irq_work, sugov_irq_work);\n\tmutex_init(&sg_policy->work_lock);\n\n\twake_up_process(thread);\n\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int sugov_kthread_create(struct sugov_policy *sg_policy)\n{\n\tstruct task_struct *thread;\n\tstruct sched_attr attr = {\n\t\t.size\t\t= sizeof(struct sched_attr),\n\t\t.sched_policy\t= SCHED_DEADLINE,\n\t\t.sched_flags\t= SCHED_FLAG_SUGOV,\n\t\t.sched_nice\t= 0,\n\t\t.sched_priority\t= 0,\n\t\t/*\n\t\t * Fake (unused) bandwidth; workaround to \"fix\"\n\t\t * priority inheritance.\n\t\t */\n\t\t.sched_runtime\t=  1000000,\n\t\t.sched_deadline = 10000000,\n\t\t.sched_period\t= 10000000,\n\t};\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tint ret;\n\n\t/* kthread only required for slow path */\n\tif (policy->fast_switch_enabled)\n\t\treturn 0;\n\n\tkthread_init_work(&sg_policy->work, sugov_work);\n\tkthread_init_worker(&sg_policy->worker);\n\tthread = kthread_create(kthread_worker_fn, &sg_policy->worker,\n\t\t\t\t\"sugov:%d\",\n\t\t\t\tcpumask_first(policy->related_cpus));\n\tif (IS_ERR(thread)) {\n\t\tpr_err(\"failed to create sugov thread: %ld\\n\", PTR_ERR(thread));\n\t\treturn PTR_ERR(thread);\n\t}\n\n\tret = sched_setattr_nocheck(thread, &attr);\n\tif (ret) {\n\t\tkthread_stop(thread);\n\t\tpr_warn(\"%s: failed to set SCHED_DEADLINE\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsg_policy->thread = thread;\n\tkthread_bind_mask(thread, policy->related_cpus);\n\tinit_irq_work(&sg_policy->irq_work, sugov_irq_work);\n\tmutex_init(&sg_policy->work_lock);\n\n\twake_up_process(thread);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_policy_alloc",
          "args": [
            "policy"
          ],
          "line": 719
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_policy_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "606-617",
          "snippet": "static struct sugov_policy *sugov_policy_alloc(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = kzalloc(sizeof(*sg_policy), GFP_KERNEL);\n\tif (!sg_policy)\n\t\treturn NULL;\n\n\tsg_policy->policy = policy;\n\traw_spin_lock_init(&sg_policy->update_lock);\n\treturn sg_policy;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_policy *sugov_policy_alloc(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = kzalloc(sizeof(*sg_policy), GFP_KERNEL);\n\tif (!sg_policy)\n\t\treturn NULL;\n\n\tsg_policy->policy = policy;\n\traw_spin_lock_init(&sg_policy->update_lock);\n\treturn sg_policy;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpufreq_enable_fast_switch",
          "args": [
            "policy"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\nstatic DEFINE_MUTEX(global_tunables_lock);\nstatic struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);\nstatic struct kobj_type sugov_tunables_ktype = {\n\t.default_attrs = sugov_attributes,\n\t.sysfs_ops = &governor_sysfs_ops,\n};\nstatic struct cpufreq_governor schedutil_gov;\nstatic struct cpufreq_governor schedutil_gov = {\n\t.name\t\t\t= \"schedutil\",\n\t.owner\t\t\t= THIS_MODULE,\n\t.dynamic_switching\t= true,\n\t.init\t\t\t= sugov_init,\n\t.exit\t\t\t= sugov_exit,\n\t.start\t\t\t= sugov_start,\n\t.stop\t\t\t= sugov_stop,\n\t.limits\t\t\t= sugov_limits,\n};\n\nstatic int sugov_init(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\tstruct sugov_tunables *tunables;\n\tint ret = 0;\n\n\t/* State should be equivalent to EXIT */\n\tif (policy->governor_data)\n\t\treturn -EBUSY;\n\n\tcpufreq_enable_fast_switch(policy);\n\n\tsg_policy = sugov_policy_alloc(policy);\n\tif (!sg_policy) {\n\t\tret = -ENOMEM;\n\t\tgoto disable_fast_switch;\n\t}\n\n\tret = sugov_kthread_create(sg_policy);\n\tif (ret)\n\t\tgoto free_sg_policy;\n\n\tmutex_lock(&global_tunables_lock);\n\n\tif (global_tunables) {\n\t\tif (WARN_ON(have_governor_per_policy())) {\n\t\t\tret = -EINVAL;\n\t\t\tgoto stop_kthread;\n\t\t}\n\t\tpolicy->governor_data = sg_policy;\n\t\tsg_policy->tunables = global_tunables;\n\n\t\tgov_attr_set_get(&global_tunables->attr_set, &sg_policy->tunables_hook);\n\t\tgoto out;\n\t}\n\n\ttunables = sugov_tunables_alloc(sg_policy);\n\tif (!tunables) {\n\t\tret = -ENOMEM;\n\t\tgoto stop_kthread;\n\t}\n\n\ttunables->rate_limit_us = cpufreq_policy_transition_delay_us(policy);\n\n\tpolicy->governor_data = sg_policy;\n\tsg_policy->tunables = tunables;\n\n\tret = kobject_init_and_add(&tunables->attr_set.kobj, &sugov_tunables_ktype,\n\t\t\t\t   get_governor_parent_kobj(policy), \"%s\",\n\t\t\t\t   schedutil_gov.name);\n\tif (ret)\n\t\tgoto fail;\n\nout:\n\tmutex_unlock(&global_tunables_lock);\n\treturn 0;\n\nfail:\n\tpolicy->governor_data = NULL;\n\tsugov_tunables_free(tunables);\n\nstop_kthread:\n\tsugov_kthread_stop(sg_policy);\n\tmutex_unlock(&global_tunables_lock);\n\nfree_sg_policy:\n\tsugov_policy_free(sg_policy);\n\ndisable_fast_switch:\n\tcpufreq_disable_fast_switch(policy);\n\n\tpr_err(\"initialization failed (error %d)\\n\", ret);\n\treturn ret;\n}"
  },
  {
    "function_name": "sugov_tunables_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "699-705",
    "snippet": "static void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sugov_tunables *global_tunables;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tunables"
          ],
          "line": 704
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "have_governor_per_policy",
          "args": [],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\n\nstatic void sugov_tunables_free(struct sugov_tunables *tunables)\n{\n\tif (!have_governor_per_policy())\n\t\tglobal_tunables = NULL;\n\n\tkfree(tunables);\n}"
  },
  {
    "function_name": "sugov_tunables_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "686-697",
    "snippet": "static struct sugov_tunables *sugov_tunables_alloc(struct sugov_policy *sg_policy)\n{\n\tstruct sugov_tunables *tunables;\n\n\ttunables = kzalloc(sizeof(*tunables), GFP_KERNEL);\n\tif (tunables) {\n\t\tgov_attr_set_init(&tunables->attr_set, &sg_policy->tunables_hook);\n\t\tif (!have_governor_per_policy())\n\t\t\tglobal_tunables = tunables;\n\t}\n\treturn tunables;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct sugov_tunables *global_tunables;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "have_governor_per_policy",
          "args": [],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "gov_attr_set_init",
          "args": [
            "&tunables->attr_set",
            "&sg_policy->tunables_hook"
          ],
          "line": 692
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*tunables)",
            "GFP_KERNEL"
          ],
          "line": 690
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_tunables *global_tunables;\n\nstatic struct sugov_tunables *sugov_tunables_alloc(struct sugov_policy *sg_policy)\n{\n\tstruct sugov_tunables *tunables;\n\n\ttunables = kzalloc(sizeof(*tunables), GFP_KERNEL);\n\tif (tunables) {\n\t\tgov_attr_set_init(&tunables->attr_set, &sg_policy->tunables_hook);\n\t\tif (!have_governor_per_policy())\n\t\t\tglobal_tunables = tunables;\n\t}\n\treturn tunables;\n}"
  },
  {
    "function_name": "sugov_kthread_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "675-684",
    "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_destroy",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 683
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1658-1664",
          "snippet": "void rt_mutex_destroy(struct rt_mutex *lock)\n{\n\tWARN_ON(rt_mutex_is_locked(lock));\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tlock->magic = NULL;\n#endif\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid rt_mutex_destroy(struct rt_mutex *lock)\n{\n\tWARN_ON(rt_mutex_is_locked(lock));\n#ifdef CONFIG_DEBUG_RT_MUTEXES\n\tlock->magic = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "sg_policy->thread"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "675-684",
          "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "kthread_flush_worker",
          "args": [
            "&sg_policy->worker"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_flush_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "1148-1157",
          "snippet": "void kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_flush_worker(struct kthread_worker *worker)\n{\n\tstruct kthread_flush_work fwork = {\n\t\tKTHREAD_WORK_INIT(fwork.work, kthread_flush_work_fn),\n\t\tCOMPLETION_INITIALIZER_ONSTACK(fwork.done),\n\t};\n\n\tkthread_queue_work(worker, &fwork.work);\n\twait_for_completion(&fwork.done);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}"
  },
  {
    "function_name": "sugov_kthread_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "624-673",
    "snippet": "static int sugov_kthread_create(struct sugov_policy *sg_policy)\n{\n\tstruct task_struct *thread;\n\tstruct sched_attr attr = {\n\t\t.size\t\t= sizeof(struct sched_attr),\n\t\t.sched_policy\t= SCHED_DEADLINE,\n\t\t.sched_flags\t= SCHED_FLAG_SUGOV,\n\t\t.sched_nice\t= 0,\n\t\t.sched_priority\t= 0,\n\t\t/*\n\t\t * Fake (unused) bandwidth; workaround to \"fix\"\n\t\t * priority inheritance.\n\t\t */\n\t\t.sched_runtime\t=  1000000,\n\t\t.sched_deadline = 10000000,\n\t\t.sched_period\t= 10000000,\n\t};\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tint ret;\n\n\t/* kthread only required for slow path */\n\tif (policy->fast_switch_enabled)\n\t\treturn 0;\n\n\tkthread_init_work(&sg_policy->work, sugov_work);\n\tkthread_init_worker(&sg_policy->worker);\n\tthread = kthread_create(kthread_worker_fn, &sg_policy->worker,\n\t\t\t\t\"sugov:%d\",\n\t\t\t\tcpumask_first(policy->related_cpus));\n\tif (IS_ERR(thread)) {\n\t\tpr_err(\"failed to create sugov thread: %ld\\n\", PTR_ERR(thread));\n\t\treturn PTR_ERR(thread);\n\t}\n\n\tret = sched_setattr_nocheck(thread, &attr);\n\tif (ret) {\n\t\tkthread_stop(thread);\n\t\tpr_warn(\"%s: failed to set SCHED_DEADLINE\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsg_policy->thread = thread;\n\tkthread_bind_mask(thread, policy->related_cpus);\n\tinit_irq_work(&sg_policy->irq_work, sugov_irq_work);\n\tmutex_init(&sg_policy->work_lock);\n\n\twake_up_process(thread);\n\n\treturn 0;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_process",
          "args": [
            "thread"
          ],
          "line": 670
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "2127-2130",
          "snippet": "int wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint wake_up_process(struct task_struct *p)\n{\n\treturn try_to_wake_up(p, TASK_NORMAL, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_init",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 668
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_init_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "1604-1612",
          "snippet": "static void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nstatic void rt_mutex_init_task(struct task_struct *p)\n{\n\traw_spin_lock_init(&p->pi_lock);\n#ifdef CONFIG_RT_MUTEXES\n\tp->pi_waiters = RB_ROOT_CACHED;\n\tp->pi_top_task = NULL;\n\tp->pi_blocked_on = NULL;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "init_irq_work",
          "args": [
            "&sg_policy->irq_work",
            "sugov_irq_work"
          ],
          "line": 667
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_bind_mask",
          "args": [
            "thread",
            "policy->related_cpus"
          ],
          "line": 666
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_bind_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "407-410",
          "snippet": "void kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nvoid kthread_bind_mask(struct task_struct *p, const struct cpumask *mask)\n{\n\t__kthread_bind_mask(p, mask, TASK_UNINTERRUPTIBLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"%s: failed to set SCHED_DEADLINE\\n\"",
            "__func__"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_stop",
          "args": [
            "thread"
          ],
          "line": 660
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_kthread_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "675-684",
          "snippet": "static void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_kthread_stop(struct sugov_policy *sg_policy)\n{\n\t/* kthread only required for slow path */\n\tif (sg_policy->policy->fast_switch_enabled)\n\t\treturn;\n\n\tkthread_flush_worker(&sg_policy->worker);\n\tkthread_stop(sg_policy->thread);\n\tmutex_destroy(&sg_policy->work_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_setattr_nocheck",
          "args": [
            "thread",
            "&attr"
          ],
          "line": 658
        },
        "resolved": true,
        "details": {
          "function_name": "sched_setattr_nocheck",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "4398-4401",
          "snippet": "int sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nint sched_setattr_nocheck(struct task_struct *p, const struct sched_attr *attr)\n{\n\treturn __sched_setscheduler(p, attr, false, true);\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "thread"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_err",
          "args": [
            "\"failed to create sugov thread: %ld\\n\"",
            "PTR_ERR(thread)"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "thread"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "thread"
          ],
          "line": 653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_create",
          "args": [
            "kthread_worker_fn",
            "&sg_policy->worker",
            "\"sugov:%d\"",
            "cpumask_first(policy->related_cpus)"
          ],
          "line": 650
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_create_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "716-727",
          "snippet": "struct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;",
            "static __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nstatic __printf(4, 0)\nstruct task_struct *__kthread_create_on_node(int (*threadfn)(void *data),\n\t\t\t\t\t\t    void *data, int node,\n\t\t\t\t\t\t    const char namefmt[],\n\t\t\t\t\t\t    va_list args)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tstruct task_struct *task;\nstatic __printf(3, 0) struct kthread_worker *\n__kthread_create_worker(int cpu, unsigned int flags,\n\t\t\tconst char namefmt[], va_list args)\n{\n\tstruct kthread_worker *worker;\n\nstruct kthread_worker *\nkthread_create_worker(unsigned int flags, const char namefmt[], ...)\n{\n\tstruct kthread_worker *worker;\n\tva_list args;\n\n\tva_start(args, namefmt);\n\tworker = __kthread_create_worker(-1, flags, namefmt, args);\n\tva_end(args);\n\n\treturn worker;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_first",
          "args": [
            "policy->related_cpus"
          ],
          "line": 652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_init_worker",
          "args": [
            "&sg_policy->worker"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kthread_init_work",
          "args": [
            "&sg_policy->work",
            "sugov_work"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic int sugov_kthread_create(struct sugov_policy *sg_policy)\n{\n\tstruct task_struct *thread;\n\tstruct sched_attr attr = {\n\t\t.size\t\t= sizeof(struct sched_attr),\n\t\t.sched_policy\t= SCHED_DEADLINE,\n\t\t.sched_flags\t= SCHED_FLAG_SUGOV,\n\t\t.sched_nice\t= 0,\n\t\t.sched_priority\t= 0,\n\t\t/*\n\t\t * Fake (unused) bandwidth; workaround to \"fix\"\n\t\t * priority inheritance.\n\t\t */\n\t\t.sched_runtime\t=  1000000,\n\t\t.sched_deadline = 10000000,\n\t\t.sched_period\t= 10000000,\n\t};\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tint ret;\n\n\t/* kthread only required for slow path */\n\tif (policy->fast_switch_enabled)\n\t\treturn 0;\n\n\tkthread_init_work(&sg_policy->work, sugov_work);\n\tkthread_init_worker(&sg_policy->worker);\n\tthread = kthread_create(kthread_worker_fn, &sg_policy->worker,\n\t\t\t\t\"sugov:%d\",\n\t\t\t\tcpumask_first(policy->related_cpus));\n\tif (IS_ERR(thread)) {\n\t\tpr_err(\"failed to create sugov thread: %ld\\n\", PTR_ERR(thread));\n\t\treturn PTR_ERR(thread);\n\t}\n\n\tret = sched_setattr_nocheck(thread, &attr);\n\tif (ret) {\n\t\tkthread_stop(thread);\n\t\tpr_warn(\"%s: failed to set SCHED_DEADLINE\\n\", __func__);\n\t\treturn ret;\n\t}\n\n\tsg_policy->thread = thread;\n\tkthread_bind_mask(thread, policy->related_cpus);\n\tinit_irq_work(&sg_policy->irq_work, sugov_irq_work);\n\tmutex_init(&sg_policy->work_lock);\n\n\twake_up_process(thread);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sugov_policy_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "619-622",
    "snippet": "static void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "sg_policy"
          ],
          "line": 621
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_policy_free(struct sugov_policy *sg_policy)\n{\n\tkfree(sg_policy);\n}"
  },
  {
    "function_name": "sugov_policy_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "606-617",
    "snippet": "static struct sugov_policy *sugov_policy_alloc(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = kzalloc(sizeof(*sg_policy), GFP_KERNEL);\n\tif (!sg_policy)\n\t\treturn NULL;\n\n\tsg_policy->policy = policy;\n\traw_spin_lock_init(&sg_policy->update_lock);\n\treturn sg_policy;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_lock_init",
          "args": [
            "&sg_policy->update_lock"
          ],
          "line": 615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*sg_policy)",
            "GFP_KERNEL"
          ],
          "line": 610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct sugov_policy *sugov_policy_alloc(struct cpufreq_policy *policy)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = kzalloc(sizeof(*sg_policy), GFP_KERNEL);\n\tif (!sg_policy)\n\t\treturn NULL;\n\n\tsg_policy->policy = policy;\n\traw_spin_lock_init(&sg_policy->update_lock);\n\treturn sg_policy;\n}"
  },
  {
    "function_name": "rate_limit_us_store",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "572-588",
    "snippet": "static ssize_t\nrate_limit_us_store(struct gov_attr_set *attr_set, const char *buf, size_t count)\n{\n\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);\n\tstruct sugov_policy *sg_policy;\n\tunsigned int rate_limit_us;\n\n\tif (kstrtouint(buf, 10, &rate_limit_us))\n\t\treturn -EINVAL;\n\n\ttunables->rate_limit_us = rate_limit_us;\n\n\tlist_for_each_entry(sg_policy, &attr_set->policy_list, tunables_hook)\n\t\tsg_policy->freq_update_delay_ns = rate_limit_us * NSEC_PER_USEC;\n\n\treturn count;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "sg_policy",
            "&attr_set->policy_list",
            "tunables_hook"
          ],
          "line": 584
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kstrtouint",
          "args": [
            "buf",
            "10",
            "&rate_limit_us"
          ],
          "line": 579
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_sugov_tunables",
          "args": [
            "attr_set"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "to_sugov_tunables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "560-563",
          "snippet": "static inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);\n\nstatic ssize_t\nrate_limit_us_store(struct gov_attr_set *attr_set, const char *buf, size_t count)\n{\n\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);\n\tstruct sugov_policy *sg_policy;\n\tunsigned int rate_limit_us;\n\n\tif (kstrtouint(buf, 10, &rate_limit_us))\n\t\treturn -EINVAL;\n\n\ttunables->rate_limit_us = rate_limit_us;\n\n\tlist_for_each_entry(sg_policy, &attr_set->policy_list, tunables_hook)\n\t\tsg_policy->freq_update_delay_ns = rate_limit_us * NSEC_PER_USEC;\n\n\treturn count;\n}"
  },
  {
    "function_name": "rate_limit_us_show",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "565-570",
    "snippet": "static ssize_t rate_limit_us_show(struct gov_attr_set *attr_set, char *buf)\n{\n\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);\n\n\treturn sprintf(buf, \"%u\\n\", tunables->rate_limit_us);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "buf",
            "\"%u\\n\"",
            "tunables->rate_limit_us"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "to_sugov_tunables",
          "args": [
            "attr_set"
          ],
          "line": 567
        },
        "resolved": true,
        "details": {
          "function_name": "to_sugov_tunables",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "560-563",
          "snippet": "static inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic struct governor_attr rate_limit_us = __ATTR_RW(rate_limit_us);\n\nstatic ssize_t rate_limit_us_show(struct gov_attr_set *attr_set, char *buf)\n{\n\tstruct sugov_tunables *tunables = to_sugov_tunables(attr_set);\n\n\treturn sprintf(buf, \"%u\\n\", tunables->rate_limit_us);\n}"
  },
  {
    "function_name": "to_sugov_tunables",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "560-563",
    "snippet": "static inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "attr_set",
            "structsugov_tunables",
            "attr_set"
          ],
          "line": 562
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic inline struct sugov_tunables *to_sugov_tunables(struct gov_attr_set *attr_set)\n{\n\treturn container_of(attr_set, struct sugov_tunables, attr_set);\n}"
  },
  {
    "function_name": "sugov_irq_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "546-553",
    "snippet": "static void sugov_irq_work(struct irq_work *irq_work)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = container_of(irq_work, struct sugov_policy, irq_work);\n\n\tkthread_queue_work(&sg_policy->worker, &sg_policy->work);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kthread_queue_work",
          "args": [
            "&sg_policy->worker",
            "&sg_policy->work"
          ],
          "line": 552
        },
        "resolved": true,
        "details": {
          "function_name": "kthread_queue_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kthread.c",
          "lines": "809-822",
          "snippet": "bool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/sched.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/slab.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>",
            "#include <linux/file.h>",
            "#include <linux/unistd.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/err.h>",
            "#include <linux/completion.h>",
            "#include <linux/kthread.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <uapi/linux/sched/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/sched.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/freezer.h>\n#include <linux/slab.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n#include <linux/file.h>\n#include <linux/unistd.h>\n#include <linux/cpuset.h>\n#include <linux/err.h>\n#include <linux/completion.h>\n#include <linux/kthread.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <uapi/linux/sched/types.h>\n\nbool kthread_queue_work(struct kthread_worker *worker,\n\t\t\tstruct kthread_work *work)\n{\n\tbool ret = false;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&worker->lock, flags);\n\tif (!queuing_blocked(worker, work)) {\n\t\tkthread_insert_work(worker, work, &worker->work_list);\n\t\tret = true;\n\t}\n\tspin_unlock_irqrestore(&worker->lock, flags);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "irq_work",
            "structsugov_policy",
            "irq_work"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_irq_work(struct irq_work *irq_work)\n{\n\tstruct sugov_policy *sg_policy;\n\n\tsg_policy = container_of(irq_work, struct sugov_policy, irq_work);\n\n\tkthread_queue_work(&sg_policy->worker, &sg_policy->work);\n}"
  },
  {
    "function_name": "sugov_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "520-544",
    "snippet": "static void sugov_work(struct kthread_work *work)\n{\n\tstruct sugov_policy *sg_policy = container_of(work, struct sugov_policy, work);\n\tunsigned int freq;\n\tunsigned long flags;\n\n\t/*\n\t * Hold sg_policy->update_lock shortly to handle the case where:\n\t * incase sg_policy->next_freq is read here, and then updated by\n\t * sugov_deferred_update() just before work_in_progress is set to false\n\t * here, we may miss queueing the new update.\n\t *\n\t * Note: If a work was queued after the update_lock is released,\n\t * sugov_work() will just be called again by kthread_work code; and the\n\t * request will be proceed before the sugov thread sleeps.\n\t */\n\traw_spin_lock_irqsave(&sg_policy->update_lock, flags);\n\tfreq = sg_policy->next_freq;\n\tsg_policy->work_in_progress = false;\n\traw_spin_unlock_irqrestore(&sg_policy->update_lock, flags);\n\n\tmutex_lock(&sg_policy->work_lock);\n\t__cpufreq_driver_target(sg_policy->policy, freq, CPUFREQ_RELATION_L);\n\tmutex_unlock(&sg_policy->work_lock);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__cpufreq_driver_target",
          "args": [
            "sg_policy->policy",
            "freq",
            "CPUFREQ_RELATION_L"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&sg_policy->work_lock"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_unlock_irqrestore",
          "args": [
            "&sg_policy->update_lock",
            "flags"
          ],
          "line": 539
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock_irqsave",
          "args": [
            "&sg_policy->update_lock",
            "flags"
          ],
          "line": 536
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "work",
            "structsugov_policy",
            "work"
          ],
          "line": 522
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_work(struct kthread_work *work)\n{\n\tstruct sugov_policy *sg_policy = container_of(work, struct sugov_policy, work);\n\tunsigned int freq;\n\tunsigned long flags;\n\n\t/*\n\t * Hold sg_policy->update_lock shortly to handle the case where:\n\t * incase sg_policy->next_freq is read here, and then updated by\n\t * sugov_deferred_update() just before work_in_progress is set to false\n\t * here, we may miss queueing the new update.\n\t *\n\t * Note: If a work was queued after the update_lock is released,\n\t * sugov_work() will just be called again by kthread_work code; and the\n\t * request will be proceed before the sugov thread sleeps.\n\t */\n\traw_spin_lock_irqsave(&sg_policy->update_lock, flags);\n\tfreq = sg_policy->next_freq;\n\tsg_policy->work_in_progress = false;\n\traw_spin_unlock_irqrestore(&sg_policy->update_lock, flags);\n\n\tmutex_lock(&sg_policy->work_lock);\n\t__cpufreq_driver_target(sg_policy->policy, freq, CPUFREQ_RELATION_L);\n\tmutex_unlock(&sg_policy->work_lock);\n}"
  },
  {
    "function_name": "sugov_update_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "494-518",
    "snippet": "static void\nsugov_update_shared(struct update_util_data *hook, u64 time, unsigned int flags)\n{\n\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tunsigned int next_f;\n\n\traw_spin_lock(&sg_policy->update_lock);\n\n\tsugov_iowait_boost(sg_cpu, time, flags);\n\tsg_cpu->last_update = time;\n\n\tignore_dl_rate_limit(sg_cpu, sg_policy);\n\n\tif (sugov_should_update_freq(sg_policy, time)) {\n\t\tnext_f = sugov_next_freq_shared(sg_cpu, time);\n\n\t\tif (sg_policy->policy->fast_switch_enabled)\n\t\t\tsugov_fast_switch(sg_policy, time, next_f);\n\t\telse\n\t\t\tsugov_deferred_update(sg_policy, time, next_f);\n\t}\n\n\traw_spin_unlock(&sg_policy->update_lock);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&sg_policy->update_lock"
          ],
          "line": 517
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_deferred_update",
          "args": [
            "sg_policy",
            "time",
            "next_f"
          ],
          "line": 514
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_deferred_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "129-139",
          "snippet": "static void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_fast_switch",
          "args": [
            "sg_policy",
            "time",
            "next_f"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_fast_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "113-127",
          "snippet": "static void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_next_freq_shared",
          "args": [
            "sg_cpu",
            "time"
          ],
          "line": 509
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_next_freq_shared",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "470-492",
          "snippet": "static unsigned int sugov_next_freq_shared(struct sugov_cpu *sg_cpu, u64 time)\n{\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned long util = 0, max = 1;\n\tunsigned int j;\n\n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct sugov_cpu *j_sg_cpu = &per_cpu(sugov_cpu, j);\n\t\tunsigned long j_util, j_max;\n\n\t\tj_util = sugov_get_util(j_sg_cpu);\n\t\tj_max = j_sg_cpu->max;\n\t\tsugov_iowait_apply(j_sg_cpu, time, &j_util, &j_max);\n\n\t\tif (j_util * max > j_max * util) {\n\t\t\tutil = j_util;\n\t\t\tmax = j_max;\n\t\t}\n\t}\n\n\treturn get_next_freq(sg_policy, util, max);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic unsigned int sugov_next_freq_shared(struct sugov_cpu *sg_cpu, u64 time)\n{\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned long util = 0, max = 1;\n\tunsigned int j;\n\n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct sugov_cpu *j_sg_cpu = &per_cpu(sugov_cpu, j);\n\t\tunsigned long j_util, j_max;\n\n\t\tj_util = sugov_get_util(j_sg_cpu);\n\t\tj_max = j_sg_cpu->max;\n\t\tsugov_iowait_apply(j_sg_cpu, time, &j_util, &j_max);\n\n\t\tif (j_util * max > j_max * util) {\n\t\t\tutil = j_util;\n\t\t\tmax = j_max;\n\t\t}\n\t}\n\n\treturn get_next_freq(sg_policy, util, max);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_should_update_freq",
          "args": [
            "sg_policy",
            "time"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_should_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "69-99",
          "snippet": "static bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_dl_rate_limit",
          "args": [
            "sg_cpu",
            "sg_policy"
          ],
          "line": 506
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_dl_rate_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "416-420",
          "snippet": "static inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_iowait_boost",
          "args": [
            "sg_cpu",
            "time",
            "flags"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "306-335",
          "snippet": "static void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&sg_policy->update_lock"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "hook",
            "structsugov_cpu",
            "update_util"
          ],
          "line": 497
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void\nsugov_update_shared(struct update_util_data *hook, u64 time, unsigned int flags)\n{\n\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tunsigned int next_f;\n\n\traw_spin_lock(&sg_policy->update_lock);\n\n\tsugov_iowait_boost(sg_cpu, time, flags);\n\tsg_cpu->last_update = time;\n\n\tignore_dl_rate_limit(sg_cpu, sg_policy);\n\n\tif (sugov_should_update_freq(sg_policy, time)) {\n\t\tnext_f = sugov_next_freq_shared(sg_cpu, time);\n\n\t\tif (sg_policy->policy->fast_switch_enabled)\n\t\t\tsugov_fast_switch(sg_policy, time, next_f);\n\t\telse\n\t\t\tsugov_deferred_update(sg_policy, time, next_f);\n\t}\n\n\traw_spin_unlock(&sg_policy->update_lock);\n}"
  },
  {
    "function_name": "sugov_next_freq_shared",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "470-492",
    "snippet": "static unsigned int sugov_next_freq_shared(struct sugov_cpu *sg_cpu, u64 time)\n{\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned long util = 0, max = 1;\n\tunsigned int j;\n\n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct sugov_cpu *j_sg_cpu = &per_cpu(sugov_cpu, j);\n\t\tunsigned long j_util, j_max;\n\n\t\tj_util = sugov_get_util(j_sg_cpu);\n\t\tj_max = j_sg_cpu->max;\n\t\tsugov_iowait_apply(j_sg_cpu, time, &j_util, &j_max);\n\n\t\tif (j_util * max > j_max * util) {\n\t\t\tutil = j_util;\n\t\t\tmax = j_max;\n\t\t}\n\t}\n\n\treturn get_next_freq(sg_policy, util, max);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_next_freq",
          "args": [
            "sg_policy",
            "util",
            "max"
          ],
          "line": 491
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "163-178",
          "snippet": "static unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_iowait_apply",
          "args": [
            "j_sg_cpu",
            "time",
            "&j_util",
            "&j_max"
          ],
          "line": 483
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "356-397",
          "snippet": "static void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_get_util",
          "args": [
            "j_sg_cpu"
          ],
          "line": 481
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_get_util",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "200-264",
          "snippet": "static unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sugov_cpu",
            "j"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "j",
            "policy->cpus"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic unsigned int sugov_next_freq_shared(struct sugov_cpu *sg_cpu, u64 time)\n{\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned long util = 0, max = 1;\n\tunsigned int j;\n\n\tfor_each_cpu(j, policy->cpus) {\n\t\tstruct sugov_cpu *j_sg_cpu = &per_cpu(sugov_cpu, j);\n\t\tunsigned long j_util, j_max;\n\n\t\tj_util = sugov_get_util(j_sg_cpu);\n\t\tj_max = j_sg_cpu->max;\n\t\tsugov_iowait_apply(j_sg_cpu, time, &j_util, &j_max);\n\n\t\tif (j_util * max > j_max * util) {\n\t\t\tutil = j_util;\n\t\t\tmax = j_max;\n\t\t}\n\t}\n\n\treturn get_next_freq(sg_policy, util, max);\n}"
  },
  {
    "function_name": "sugov_update_single",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "422-468",
    "snippet": "static void sugov_update_single(struct update_util_data *hook, u64 time,\n\t\t\t\tunsigned int flags)\n{\n\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tunsigned long util, max;\n\tunsigned int next_f;\n\tbool busy;\n\n\tsugov_iowait_boost(sg_cpu, time, flags);\n\tsg_cpu->last_update = time;\n\n\tignore_dl_rate_limit(sg_cpu, sg_policy);\n\n\tif (!sugov_should_update_freq(sg_policy, time))\n\t\treturn;\n\n\tbusy = sugov_cpu_is_busy(sg_cpu);\n\n\tutil = sugov_get_util(sg_cpu);\n\tmax = sg_cpu->max;\n\tsugov_iowait_apply(sg_cpu, time, &util, &max);\n\tnext_f = get_next_freq(sg_policy, util, max);\n\t/*\n\t * Do not reduce the frequency if the CPU has not been idle\n\t * recently, as the reduction is likely to be premature then.\n\t */\n\tif (busy && next_f < sg_policy->next_freq) {\n\t\tnext_f = sg_policy->next_freq;\n\n\t\t/* Reset cached freq as next_freq has changed */\n\t\tsg_policy->cached_raw_freq = 0;\n\t}\n\n\t/*\n\t * This code runs under rq->lock for the target CPU, so it won't run\n\t * concurrently on two different CPUs for the same target and it is not\n\t * necessary to acquire the lock in the fast switch case.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled) {\n\t\tsugov_fast_switch(sg_policy, time, next_f);\n\t} else {\n\t\traw_spin_lock(&sg_policy->update_lock);\n\t\tsugov_deferred_update(sg_policy, time, next_f);\n\t\traw_spin_unlock(&sg_policy->update_lock);\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "raw_spin_unlock",
          "args": [
            "&sg_policy->update_lock"
          ],
          "line": 466
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "198-201",
          "snippet": "void __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_deferred_update",
          "args": [
            "sg_policy",
            "time",
            "next_f"
          ],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_deferred_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "129-139",
          "snippet": "static void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_spin_lock",
          "args": [
            "&sg_policy->update_lock"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_fast_switch",
          "args": [
            "sg_policy",
            "time",
            "next_f"
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_fast_switch",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "113-127",
          "snippet": "static void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_next_freq",
          "args": [
            "sg_policy",
            "util",
            "max"
          ],
          "line": 444
        },
        "resolved": true,
        "details": {
          "function_name": "get_next_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "163-178",
          "snippet": "static unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_iowait_apply",
          "args": [
            "sg_cpu",
            "time",
            "&util",
            "&max"
          ],
          "line": 443
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_apply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "356-397",
          "snippet": "static void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_get_util",
          "args": [
            "sg_cpu"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_get_util",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "200-264",
          "snippet": "static unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_cpu_is_busy",
          "args": [
            "sg_cpu"
          ],
          "line": 439
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_cpu_is_busy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "409-409",
          "snippet": "static inline bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu) { return false; }",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic inline bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu) { return false; }"
        }
      },
      {
        "call_info": {
          "callee": "sugov_should_update_freq",
          "args": [
            "sg_policy",
            "time"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_should_update_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "69-99",
          "snippet": "static bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ignore_dl_rate_limit",
          "args": [
            "sg_cpu",
            "sg_policy"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "ignore_dl_rate_limit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "416-420",
          "snippet": "static inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_iowait_boost",
          "args": [
            "sg_cpu",
            "time",
            "flags"
          ],
          "line": 431
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_boost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "306-335",
          "snippet": "static void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}"
        }
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "hook",
            "structsugov_cpu",
            "update_util"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_update_single(struct update_util_data *hook, u64 time,\n\t\t\t\tunsigned int flags)\n{\n\tstruct sugov_cpu *sg_cpu = container_of(hook, struct sugov_cpu, update_util);\n\tstruct sugov_policy *sg_policy = sg_cpu->sg_policy;\n\tunsigned long util, max;\n\tunsigned int next_f;\n\tbool busy;\n\n\tsugov_iowait_boost(sg_cpu, time, flags);\n\tsg_cpu->last_update = time;\n\n\tignore_dl_rate_limit(sg_cpu, sg_policy);\n\n\tif (!sugov_should_update_freq(sg_policy, time))\n\t\treturn;\n\n\tbusy = sugov_cpu_is_busy(sg_cpu);\n\n\tutil = sugov_get_util(sg_cpu);\n\tmax = sg_cpu->max;\n\tsugov_iowait_apply(sg_cpu, time, &util, &max);\n\tnext_f = get_next_freq(sg_policy, util, max);\n\t/*\n\t * Do not reduce the frequency if the CPU has not been idle\n\t * recently, as the reduction is likely to be premature then.\n\t */\n\tif (busy && next_f < sg_policy->next_freq) {\n\t\tnext_f = sg_policy->next_freq;\n\n\t\t/* Reset cached freq as next_freq has changed */\n\t\tsg_policy->cached_raw_freq = 0;\n\t}\n\n\t/*\n\t * This code runs under rq->lock for the target CPU, so it won't run\n\t * concurrently on two different CPUs for the same target and it is not\n\t * necessary to acquire the lock in the fast switch case.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled) {\n\t\tsugov_fast_switch(sg_policy, time, next_f);\n\t} else {\n\t\traw_spin_lock(&sg_policy->update_lock);\n\t\tsugov_deferred_update(sg_policy, time, next_f);\n\t\traw_spin_unlock(&sg_policy->update_lock);\n\t}\n}"
  },
  {
    "function_name": "ignore_dl_rate_limit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "416-420",
    "snippet": "static inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_bw_dl",
          "args": [
            "cpu_rq(sg_cpu->cpu)"
          ],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bw_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2212-2215",
          "snippet": "static inline unsigned long cpu_bw_dl(struct rq *rq)\n{\n\treturn (rq->dl.running_bw * SCHED_CAPACITY_SCALE) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BW_SHIFT\t\t20"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define BW_SHIFT\t\t20\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_bw_dl(struct rq *rq)\n{\n\treturn (rq->dl.running_bw * SCHED_CAPACITY_SCALE) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "sg_cpu->cpu"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic inline void ignore_dl_rate_limit(struct sugov_cpu *sg_cpu, struct sugov_policy *sg_policy)\n{\n\tif (cpu_bw_dl(cpu_rq(sg_cpu->cpu)) > sg_cpu->bw_dl)\n\t\tsg_policy->need_freq_update = true;\n}"
  },
  {
    "function_name": "sugov_cpu_is_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "409-409",
    "snippet": "static inline bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu) { return false; }",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic inline bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu) { return false; }"
  },
  {
    "function_name": "sugov_cpu_is_busy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "400-407",
    "snippet": "static bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu)\n{\n\tunsigned long idle_calls = tick_nohz_get_idle_calls_cpu(sg_cpu->cpu);\n\tbool ret = idle_calls == sg_cpu->saved_idle_calls;\n\n\tsg_cpu->saved_idle_calls = idle_calls;\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_nohz_get_idle_calls_cpu",
          "args": [
            "sg_cpu->cpu"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "tick_nohz_get_idle_calls_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/tick-sched.c",
          "lines": "1073-1078",
          "snippet": "unsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}",
          "includes": [
            "#include <trace/events/timer.h>",
            "#include \"tick-internal.h\"",
            "#include <asm/irq_regs.h>",
            "#include <linux/mm.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/module.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/profile.h>",
            "#include <linux/nmi.h>",
            "#include <linux/percpu.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/err.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/timer.h>\n#include \"tick-internal.h\"\n#include <asm/irq_regs.h>\n#include <linux/mm.h>\n#include <linux/context_tracking.h>\n#include <linux/posix-timers.h>\n#include <linux/irq_work.h>\n#include <linux/module.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/signal.h>\n#include <linux/profile.h>\n#include <linux/nmi.h>\n#include <linux/percpu.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/hrtimer.h>\n#include <linux/err.h>\n#include <linux/cpu.h>\n\nunsigned long tick_nohz_get_idle_calls_cpu(int cpu)\n{\n\tstruct tick_sched *ts = tick_get_tick_sched(cpu);\n\n\treturn ts->idle_calls;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic bool sugov_cpu_is_busy(struct sugov_cpu *sg_cpu)\n{\n\tunsigned long idle_calls = tick_nohz_get_idle_calls_cpu(sg_cpu->cpu);\n\tbool ret = idle_calls == sg_cpu->saved_idle_calls;\n\n\tsg_cpu->saved_idle_calls = idle_calls;\n\treturn ret;\n}"
  },
  {
    "function_name": "sugov_iowait_apply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "356-397",
    "snippet": "static void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sugov_iowait_reset",
          "args": [
            "sg_cpu",
            "time",
            "false"
          ],
          "line": 366
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "277-291",
          "snippet": "static bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_apply(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned long *util, unsigned long *max)\n{\n\tunsigned int boost_util, boost_max;\n\n\t/* No boost currently required */\n\tif (!sg_cpu->iowait_boost)\n\t\treturn;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sugov_iowait_reset(sg_cpu, time, false))\n\t\treturn;\n\n\t/*\n\t * An IO waiting task has just woken up:\n\t * allow to further double the boost value\n\t */\n\tif (sg_cpu->iowait_boost_pending) {\n\t\tsg_cpu->iowait_boost_pending = false;\n\t} else {\n\t\t/*\n\t\t * Otherwise: reduce the boost value and disable it when we\n\t\t * reach the minimum.\n\t\t */\n\t\tsg_cpu->iowait_boost >>= 1;\n\t\tif (sg_cpu->iowait_boost < sg_cpu->sg_policy->policy->min) {\n\t\t\tsg_cpu->iowait_boost = 0;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * Apply the current boost value: a CPU is boosted only if its current\n\t * utilization is smaller then the current IO boost level.\n\t */\n\tboost_util = sg_cpu->iowait_boost;\n\tboost_max = sg_cpu->iowait_boost_max;\n\tif (*util * boost_max < *max * boost_util) {\n\t\t*util = boost_util;\n\t\t*max = boost_max;\n\t}\n}"
  },
  {
    "function_name": "sugov_iowait_boost",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "306-335",
    "snippet": "static void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sugov_iowait_reset",
          "args": [
            "sg_cpu",
            "time",
            "set_iowait_boost"
          ],
          "line": 313
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_iowait_reset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "277-291",
          "snippet": "static bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic void sugov_iowait_boost(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       unsigned int flags)\n{\n\tbool set_iowait_boost = flags & SCHED_CPUFREQ_IOWAIT;\n\n\t/* Reset boost if the CPU appears to have been idle enough */\n\tif (sg_cpu->iowait_boost &&\n\t    sugov_iowait_reset(sg_cpu, time, set_iowait_boost))\n\t\treturn;\n\n\t/* Boost only tasks waking up after IO */\n\tif (!set_iowait_boost)\n\t\treturn;\n\n\t/* Ensure boost doubles only one time at each request */\n\tif (sg_cpu->iowait_boost_pending)\n\t\treturn;\n\tsg_cpu->iowait_boost_pending = true;\n\n\t/* Double the boost at each request */\n\tif (sg_cpu->iowait_boost) {\n\t\tsg_cpu->iowait_boost <<= 1;\n\t\tif (sg_cpu->iowait_boost > sg_cpu->iowait_boost_max)\n\t\t\tsg_cpu->iowait_boost = sg_cpu->iowait_boost_max;\n\t\treturn;\n\t}\n\n\t/* First wakeup after IO: start with minimum boost */\n\tsg_cpu->iowait_boost = sg_cpu->sg_policy->policy->min;\n}"
  },
  {
    "function_name": "sugov_iowait_reset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "277-291",
    "snippet": "static bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic bool sugov_iowait_reset(struct sugov_cpu *sg_cpu, u64 time,\n\t\t\t       bool set_iowait_boost)\n{\n\ts64 delta_ns = time - sg_cpu->last_update;\n\n\t/* Reset boost only if a tick has elapsed since last request */\n\tif (delta_ns <= TICK_NSEC)\n\t\treturn false;\n\n\tsg_cpu->iowait_boost = set_iowait_boost\n\t\t? sg_cpu->sg_policy->policy->min : 0;\n\tsg_cpu->iowait_boost_pending = set_iowait_boost;\n\n\treturn true;\n}"
  },
  {
    "function_name": "sugov_get_util",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "200-264",
    "snippet": "static unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "min",
          "args": [
            "max",
            "util + sg_cpu->bw_dl"
          ],
          "line": 263
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "248-251",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "scale_irq_capacity",
          "args": [
            "util",
            "irq",
            "max"
          ],
          "line": 250
        },
        "resolved": true,
        "details": {
          "function_name": "scale_irq_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2261-2265",
          "snippet": "static inline\nunsigned long scale_irq_capacity(unsigned long util, unsigned long irq, unsigned long max)\n{\n\treturn util;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nstatic inline\nunsigned long scale_irq_capacity(unsigned long util, unsigned long irq, unsigned long max)\n{\n\treturn util;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_util_dl",
          "args": [
            "rq"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_util_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2217-2220",
          "snippet": "static inline unsigned long cpu_util_dl(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_dl.util_avg);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_util_dl(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_dl.util_avg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_util_rt",
          "args": [
            "rq"
          ],
          "line": 227
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_util_rt",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2234-2237",
          "snippet": "static inline unsigned long cpu_util_rt(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_rt.util_avg);\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_util_rt(struct rq *rq)\n{\n\treturn READ_ONCE(rq->avg_rt.util_avg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_util_cfs",
          "args": [
            "rq"
          ],
          "line": 226
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_util_cfs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2222-2232",
          "snippet": "static inline unsigned long cpu_util_cfs(struct rq *rq)\n{\n\tunsigned long util = READ_ONCE(rq->cfs.avg.util_avg);\n\n\tif (sched_feat(UTIL_EST)) {\n\t\tutil = max_t(unsigned long, util,\n\t\t\t     READ_ONCE(rq->cfs.avg.util_est.enqueued));\n\t}\n\n\treturn util;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_util_cfs(struct rq *rq)\n{\n\tunsigned long util = READ_ONCE(rq->cfs.avg.util_avg);\n\n\tif (sched_feat(UTIL_EST)) {\n\t\tutil = max_t(unsigned long, util,\n\t\t\t     READ_ONCE(rq->cfs.avg.util_est.enqueued));\n\t}\n\n\treturn util;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "irq >= max"
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_util_irq",
          "args": [
            "rq"
          ],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_util_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2256-2259",
          "snippet": "static inline unsigned long cpu_util_irq(struct rq *rq)\n{\n\treturn 0;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_util_irq(struct rq *rq)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rt_rq_is_runnable",
          "args": [
            "&rq->rt"
          ],
          "line": 208
        },
        "resolved": true,
        "details": {
          "function_name": "rt_rq_is_runnable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "618-621",
          "snippet": "static inline bool rt_rq_is_runnable(struct rt_rq *rt_rq)\n{\n\treturn rt_rq->rt_queued && rt_rq->rt_nr_running;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void init_rt_rq(struct rt_rq *rt_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern void init_rt_rq(struct rt_rq *rt_rq);\n\nstatic inline bool rt_rq_is_runnable(struct rt_rq *rt_rq)\n{\n\treturn rt_rq->rt_queued && rt_rq->rt_nr_running;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_bw_dl",
          "args": [
            "rq"
          ],
          "line": 206
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_bw_dl",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "2212-2215",
          "snippet": "static inline unsigned long cpu_bw_dl(struct rq *rq)\n{\n\treturn (rq->dl.running_bw * SCHED_CAPACITY_SCALE) >> BW_SHIFT;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [
            "#define BW_SHIFT\t\t20"
          ],
          "globals_used": [
            "extern void update_rq_clock(struct rq *rq);",
            "extern void resched_curr(struct rq *rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\n#define BW_SHIFT\t\t20\n\nextern void update_rq_clock(struct rq *rq);\nextern void resched_curr(struct rq *rq);\n\nstatic inline unsigned long cpu_bw_dl(struct rq *rq)\n{\n\treturn (rq->dl.running_bw * SCHED_CAPACITY_SCALE) >> BW_SHIFT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_scale_cpu_capacity",
          "args": [
            "NULL",
            "sg_cpu->cpu"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "arch_scale_cpu_capacity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/sched.h",
          "lines": "1872-1876",
          "snippet": "static __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include \"features.h\"",
            "# include <linux/static_key.h>",
            "#include \"autogroup.h\"",
            "#include \"stats.h\"",
            "#include <linux/psi.h>",
            "#include <linux/cgroup.h>",
            "#include \"cpudeadline.h\"",
            "#include \"cpupri.h\"",
            "# include <asm/paravirt.h>",
            "#include <asm/tlb.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/task_work.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swait.h>",
            "#include <linux/suspend.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/security.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/psi.h>",
            "#include <linux/profile.h>",
            "#include <linux/prefetch.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mmu_context.h>",
            "#include <linux/migrate.h>",
            "#include <linux/membarrier.h>",
            "#include <linux/kthread.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/init_task.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ctype.h>",
            "#include <linux/cpuset.h>",
            "#include <linux/cpuidle.h>",
            "#include <linux/cpufreq.h>",
            "#include <linux/context_tracking.h>",
            "#include <linux/compat.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/binfmts.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/xacct.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/topology.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/prio.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched/jobctl.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/sched/init.h>",
            "#include <linux/sched/idle.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/cpufreq.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern bool dl_cpu_busy(unsigned int cpu);",
            "extern void resched_cpu(int cpu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include \"features.h\"\n# include <linux/static_key.h>\n#include \"autogroup.h\"\n#include \"stats.h\"\n#include <linux/psi.h>\n#include <linux/cgroup.h>\n#include \"cpudeadline.h\"\n#include \"cpupri.h\"\n# include <asm/paravirt.h>\n#include <asm/tlb.h>\n#include <linux/tsacct_kern.h>\n#include <linux/task_work.h>\n#include <linux/syscalls.h>\n#include <linux/swait.h>\n#include <linux/suspend.h>\n#include <linux/stop_machine.h>\n#include <linux/security.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/psi.h>\n#include <linux/profile.h>\n#include <linux/prefetch.h>\n#include <linux/proc_fs.h>\n#include <linux/nmi.h>\n#include <linux/mmu_context.h>\n#include <linux/migrate.h>\n#include <linux/membarrier.h>\n#include <linux/kthread.h>\n#include <linux/kprobes.h>\n#include <linux/init_task.h>\n#include <linux/delayacct.h>\n#include <linux/debugfs.h>\n#include <linux/ctype.h>\n#include <linux/cpuset.h>\n#include <linux/cpuidle.h>\n#include <linux/cpufreq.h>\n#include <linux/context_tracking.h>\n#include <linux/compat.h>\n#include <linux/blkdev.h>\n#include <linux/binfmts.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/xacct.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/user.h>\n#include <linux/sched/topology.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/signal.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/prio.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched/jobctl.h>\n#include <linux/sched/isolation.h>\n#include <linux/sched/init.h>\n#include <linux/sched/idle.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/cpufreq.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/autogroup.h>\n#include <linux/sched.h>\n\nextern bool dl_cpu_busy(unsigned int cpu);\nextern void resched_cpu(int cpu);\n\nstatic __always_inline\nunsigned long arch_scale_cpu_capacity(void __always_unused *sd, int cpu)\n{\n\treturn SCHED_CAPACITY_SCALE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpu_rq",
          "args": [
            "sg_cpu->cpu"
          ],
          "line": 202
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic DEFINE_PER_CPU(struct sugov_cpu, sugov_cpu);\n\nstatic unsigned long sugov_get_util(struct sugov_cpu *sg_cpu)\n{\n\tstruct rq *rq = cpu_rq(sg_cpu->cpu);\n\tunsigned long util, irq, max;\n\n\tsg_cpu->max = max = arch_scale_cpu_capacity(NULL, sg_cpu->cpu);\n\tsg_cpu->bw_dl = cpu_bw_dl(rq);\n\n\tif (rt_rq_is_runnable(&rq->rt))\n\t\treturn max;\n\n\t/*\n\t * Early check to see if IRQ/steal time saturates the CPU, can be\n\t * because of inaccuracies in how we track these -- see\n\t * update_irq_load_avg().\n\t */\n\tirq = cpu_util_irq(rq);\n\tif (unlikely(irq >= max))\n\t\treturn max;\n\n\t/*\n\t * Because the time spend on RT/DL tasks is visible as 'lost' time to\n\t * CFS tasks and we use the same metric to track the effective\n\t * utilization (PELT windows are synchronized) we can directly add them\n\t * to obtain the CPU's actual utilization.\n\t */\n\tutil = cpu_util_cfs(rq);\n\tutil += cpu_util_rt(rq);\n\n\t/*\n\t * We do not make cpu_util_dl() a permanent part of this sum because we\n\t * want to use cpu_bw_dl() later on, but we need to check if the\n\t * CFS+RT+DL sum is saturated (ie. no idle time) such that we select\n\t * f_max when there is no idle time.\n\t *\n\t * NOTE: numerical errors or stop class might cause us to not quite hit\n\t * saturation when we should -- something for later.\n\t */\n\tif ((util + cpu_util_dl(rq)) >= max)\n\t\treturn max;\n\n\t/*\n\t * There is still idle time; further improve the number by using the\n\t * irq metric. Because IRQ/steal time is hidden from the task clock we\n\t * need to scale the task numbers:\n\t *\n\t *              1 - irq\n\t *   U' = irq + ------- * U\n\t *                max\n\t */\n\tutil = scale_irq_capacity(util, irq, max);\n\tutil += irq;\n\n\t/*\n\t * Bandwidth required by DEADLINE must always be granted while, for\n\t * FAIR and RT, we use blocked utilization of IDLE CPUs as a mechanism\n\t * to gracefully reduce the frequency when no tasks show up for longer\n\t * periods of time.\n\t *\n\t * Ideally we would like to set bw_dl as min/guaranteed freq and util +\n\t * bw_dl as requested freq. However, cpufreq is not yet ready for such\n\t * an interface. So, we only do the latter for now.\n\t */\n\treturn min(max, util + sg_cpu->bw_dl);\n}"
  },
  {
    "function_name": "get_next_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "163-178",
    "snippet": "static unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpufreq_driver_resolve_freq",
          "args": [
            "policy",
            "freq"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_scale_freq_invariant",
          "args": [],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic unsigned int get_next_freq(struct sugov_policy *sg_policy,\n\t\t\t\t  unsigned long util, unsigned long max)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\tunsigned int freq = arch_scale_freq_invariant() ?\n\t\t\t\tpolicy->cpuinfo.max_freq : policy->cur;\n\n\tfreq = (freq + (freq >> 2)) * util / max;\n\n\tif (freq == sg_policy->cached_raw_freq && !sg_policy->need_freq_update)\n\t\treturn sg_policy->next_freq;\n\n\tsg_policy->need_freq_update = false;\n\tsg_policy->cached_raw_freq = freq;\n\treturn cpufreq_driver_resolve_freq(policy, freq);\n}"
  },
  {
    "function_name": "sugov_deferred_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "129-139",
    "snippet": "static void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "irq_work_queue",
          "args": [
            "&sg_policy->irq_work"
          ],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "irq_work_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq_work.c",
          "lines": "90-112",
          "snippet": "bool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}",
          "includes": [
            "#include <asm/processor.h>",
            "#include <linux/smp.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/tick.h>",
            "#include <linux/sched.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/percpu.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/export.h>",
            "#include <linux/kernel.h>",
            "#include <linux/bug.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct llist_head, raised_list);",
            "static DEFINE_PER_CPU(struct llist_head, lazy_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/processor.h>\n#include <linux/smp.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/tick.h>\n#include <linux/sched.h>\n#include <linux/irqflags.h>\n#include <linux/hardirq.h>\n#include <linux/percpu.h>\n#include <linux/irq_work.h>\n#include <linux/export.h>\n#include <linux/kernel.h>\n#include <linux/bug.h>\n\nstatic DEFINE_PER_CPU(struct llist_head, raised_list);\nstatic DEFINE_PER_CPU(struct llist_head, lazy_list);\n\nbool irq_work_queue(struct irq_work *work)\n{\n\t/* Only queue if not already pending */\n\tif (!irq_work_claim(work))\n\t\treturn false;\n\n\t/* Queue the entry and raise the IPI if needed. */\n\tpreempt_disable();\n\n\t/* If the work is \"lazy\", handle it from next tick if any */\n\tif (work->flags & IRQ_WORK_LAZY) {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&lazy_list)) &&\n\t\t    tick_nohz_tick_stopped())\n\t\t\tarch_irq_work_raise();\n\t} else {\n\t\tif (llist_add(&work->llnode, this_cpu_ptr(&raised_list)))\n\t\t\tarch_irq_work_raise();\n\t}\n\n\tpreempt_enable();\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sugov_update_next_freq",
          "args": [
            "sg_policy",
            "time",
            "next_freq"
          ],
          "line": 132
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_update_next_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "101-111",
          "snippet": "static bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_deferred_update(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t  unsigned int next_freq)\n{\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tif (!sg_policy->work_in_progress) {\n\t\tsg_policy->work_in_progress = true;\n\t\tirq_work_queue(&sg_policy->irq_work);\n\t}\n}"
  },
  {
    "function_name": "sugov_fast_switch",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "113-127",
    "snippet": "static void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_cpu_frequency",
          "args": [
            "next_freq",
            "smp_processor_id()"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_driver_fast_switch",
          "args": [
            "policy",
            "next_freq"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sugov_update_next_freq",
          "args": [
            "sg_policy",
            "time",
            "next_freq"
          ],
          "line": 118
        },
        "resolved": true,
        "details": {
          "function_name": "sugov_update_next_freq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
          "lines": "101-111",
          "snippet": "static bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}",
          "includes": [
            "#include <trace/events/power.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic void sugov_fast_switch(struct sugov_policy *sg_policy, u64 time,\n\t\t\t      unsigned int next_freq)\n{\n\tstruct cpufreq_policy *policy = sg_policy->policy;\n\n\tif (!sugov_update_next_freq(sg_policy, time, next_freq))\n\t\treturn;\n\n\tnext_freq = cpufreq_driver_fast_switch(policy, next_freq);\n\tif (!next_freq)\n\t\treturn;\n\n\tpolicy->cur = next_freq;\n\ttrace_cpu_frequency(next_freq, smp_processor_id());\n}"
  },
  {
    "function_name": "sugov_update_next_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "101-111",
    "snippet": "static bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_update_next_freq(struct sugov_policy *sg_policy, u64 time,\n\t\t\t\t   unsigned int next_freq)\n{\n\tif (sg_policy->next_freq == next_freq)\n\t\treturn false;\n\n\tsg_policy->next_freq = next_freq;\n\tsg_policy->last_freq_update_time = time;\n\n\treturn true;\n}"
  },
  {
    "function_name": "sugov_should_update_freq",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cpufreq_schedutil.c",
    "lines": "69-99",
    "snippet": "static bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}",
    "includes": [
      "#include <trace/events/power.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sg_policy->need_freq_update"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpufreq_this_cpu_can_update",
          "args": [
            "sg_policy->policy"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/power.h>\n#include \"sched.h\"\n\nstatic bool sugov_should_update_freq(struct sugov_policy *sg_policy, u64 time)\n{\n\ts64 delta_ns;\n\n\t/*\n\t * Since cpufreq_update_util() is called with rq->lock held for\n\t * the @target_cpu, our per-CPU data is fully serialized.\n\t *\n\t * However, drivers cannot in general deal with cross-CPU\n\t * requests, so while get_next_freq() will work, our\n\t * sugov_update_commit() call may not for the fast switching platforms.\n\t *\n\t * Hence stop here for remote requests if they aren't supported\n\t * by the hardware, as calculating the frequency is pointless if\n\t * we cannot in fact act on it.\n\t *\n\t * For the slow switching platforms, the kthread is always scheduled on\n\t * the right set of CPUs and any CPU can find the next frequency and\n\t * schedule the kthread.\n\t */\n\tif (sg_policy->policy->fast_switch_enabled &&\n\t    !cpufreq_this_cpu_can_update(sg_policy->policy))\n\t\treturn false;\n\n\tif (unlikely(sg_policy->need_freq_update))\n\t\treturn true;\n\n\tdelta_ns = time - sg_policy->last_freq_update_time;\n\n\treturn delta_ns >= sg_policy->freq_update_delay_ns;\n}"
  }
]