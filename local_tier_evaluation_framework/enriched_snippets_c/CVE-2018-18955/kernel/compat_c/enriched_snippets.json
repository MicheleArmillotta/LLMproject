[
  {
    "function_name": "compat_alloc_user_space",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "431-445",
    "snippet": "void __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t/* If len would occupy more than half of the entire compat space... */\n\tif (unlikely(len > (((compat_uptr_t)~0) >> 1)))\n\t\treturn NULL;\n\n\tptr = arch_compat_alloc_user_space(len);\n\n\tif (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))\n\t\treturn NULL;\n\n\treturn ptr;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!access_ok(VERIFY_WRITE, ptr, len)"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "ptr",
            "len"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_compat_alloc_user_space",
          "args": [
            "len"
          ],
          "line": 439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "len > (((compat_uptr_t)~0) >> 1)"
          ],
          "line": 436
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nvoid __user *compat_alloc_user_space(unsigned long len)\n{\n\tvoid __user *ptr;\n\n\t/* If len would occupy more than half of the entire compat space... */\n\tif (unlikely(len > (((compat_uptr_t)~0) >> 1)))\n\t\treturn NULL;\n\n\tptr = arch_compat_alloc_user_space(len);\n\n\tif (unlikely(!access_ok(VERIFY_WRITE, ptr, len)))\n\t\treturn NULL;\n\n\treturn ptr;\n}"
  },
  {
    "function_name": "get_compat_sigset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "406-424",
    "snippet": "int\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "set",
            "compat",
            "sizeof(compat_sigset_t)"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&v",
            "compat",
            "sizeof(compat_sigset_t)"
          ],
          "line": 411
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint\nget_compat_sigset(sigset_t *set, const compat_sigset_t __user *compat)\n{\n#ifdef __BIG_ENDIAN\n\tcompat_sigset_t v;\n\tif (copy_from_user(&v, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n\tswitch (_NSIG_WORDS) {\n\tcase 4: set->sig[3] = v.sig[6] | (((long)v.sig[7]) << 32 );\n\tcase 3: set->sig[2] = v.sig[4] | (((long)v.sig[5]) << 32 );\n\tcase 2: set->sig[1] = v.sig[2] | (((long)v.sig[3]) << 32 );\n\tcase 1: set->sig[0] = v.sig[0] | (((long)v.sig[1]) << 32 );\n\t}\n#else\n\tif (copy_from_user(set, compat, sizeof(compat_sigset_t)))\n\t\treturn -EFAULT;\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_put_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "378-404",
    "snippet": "long compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_WRITE, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_access_end",
          "args": [],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_access_end",
          "args": [],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "(compat_ulong_t)*mask",
            "umask++",
            "Efault"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "m >> BITS_PER_COMPAT_LONG",
            "umask++",
            "Efault"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_put_user",
          "args": [
            "(compat_ulong_t)m",
            "umask++",
            "Efault"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_access_begin",
          "args": [],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "umask",
            "bitmap_size / 8"
          ],
          "line": 387
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_COMPAT_LONGS",
          "args": [
            "bitmap_size"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bitmap_size",
            "BITS_PER_COMPAT_LONG"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_put_bitmap(compat_ulong_t __user *umask, unsigned long *mask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_WRITE, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tunsigned long m = *mask++;\n\t\tunsafe_put_user((compat_ulong_t)m, umask++, Efault);\n\t\tunsafe_put_user(m >> BITS_PER_COMPAT_LONG, umask++, Efault);\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_put_user((compat_ulong_t)*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "compat_get_bitmap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "348-376",
    "snippet": "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "user_access_end",
          "args": [],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_access_end",
          "args": [],
          "line": 370
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "*mask",
            "umask++",
            "Efault"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "l2",
            "umask++",
            "Efault"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unsafe_get_user",
          "args": [
            "l1",
            "umask++",
            "Efault"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_access_begin",
          "args": [],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "umask",
            "bitmap_size / 8"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BITS_TO_COMPAT_LONGS",
          "args": [
            "bitmap_size"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ALIGN",
          "args": [
            "bitmap_size",
            "BITS_PER_COMPAT_LONG"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}"
  },
  {
    "function_name": "get_compat_sigevent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "334-346",
    "snippet": "int get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_notify_thread_id",
            "&u_event->sigev_notify_thread_id"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_notify",
            "&u_event->sigev_notify"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_signo",
            "&u_event->sigev_signo"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "event->sigev_value.sival_int",
            "&u_event->sigev_value.sival_int"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "u_event",
            "sizeof(*u_event)"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "event",
            "0",
            "sizeof(*event)"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint get_compat_sigevent(struct sigevent *event,\n\t\tconst struct compat_sigevent __user *u_event)\n{\n\tmemset(event, 0, sizeof(*event));\n\treturn (!access_ok(VERIFY_READ, u_event, sizeof(*u_event)) ||\n\t\t__get_user(event->sigev_value.sival_int,\n\t\t\t&u_event->sigev_value.sival_int) ||\n\t\t__get_user(event->sigev_signo, &u_event->sigev_signo) ||\n\t\t__get_user(event->sigev_notify, &u_event->sigev_notify) ||\n\t\t__get_user(event->sigev_notify_thread_id,\n\t\t\t&u_event->sigev_notify_thread_id))\n\t\t? -EFAULT : 0;\n}"
  },
  {
    "function_name": "compat_get_user_cpu_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "265-277",
    "snippet": "static int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_get_bitmap",
          "args": [
            "k",
            "user_mask_ptr",
            "len * 8"
          ],
          "line": 276
        },
        "resolved": true,
        "details": {
          "function_name": "compat_get_bitmap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
          "lines": "348-376",
          "snippet": "long compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/timex.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nlong compat_get_bitmap(unsigned long *mask, const compat_ulong_t __user *umask,\n\t\t       unsigned long bitmap_size)\n{\n\tunsigned long nr_compat_longs;\n\n\t/* align bitmap up to nearest compat_long_t boundary */\n\tbitmap_size = ALIGN(bitmap_size, BITS_PER_COMPAT_LONG);\n\tnr_compat_longs = BITS_TO_COMPAT_LONGS(bitmap_size);\n\n\tif (!access_ok(VERIFY_READ, umask, bitmap_size / 8))\n\t\treturn -EFAULT;\n\n\tuser_access_begin();\n\twhile (nr_compat_longs > 1) {\n\t\tcompat_ulong_t l1, l2;\n\t\tunsafe_get_user(l1, umask++, Efault);\n\t\tunsafe_get_user(l2, umask++, Efault);\n\t\t*mask++ = ((unsigned long)l2 << BITS_PER_COMPAT_LONG) | l1;\n\t\tnr_compat_longs -= 2;\n\t}\n\tif (nr_compat_longs)\n\t\tunsafe_get_user(*mask, umask++, Efault);\n\tuser_access_end();\n\treturn 0;\n\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpumask_bits",
          "args": [
            "new_mask"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new_mask",
            "0",
            "cpumask_size()"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_size",
          "args": [],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int compat_get_user_cpu_mask(compat_ulong_t __user *user_mask_ptr,\n\t\t\t\t    unsigned len, struct cpumask *new_mask)\n{\n\tunsigned long *k;\n\n\tif (len < cpumask_size())\n\t\tmemset(new_mask, 0, cpumask_size());\n\telse if (len > cpumask_size())\n\t\tlen = cpumask_size();\n\n\tk = cpumask_bits(new_mask);\n\treturn compat_get_bitmap(k, user_mask_ptr, len * 8);\n}"
  },
  {
    "function_name": "put_compat_rusage",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "238-263",
    "snippet": "int put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "ru",
            "&r32",
            "sizeof(r32)"
          ],
          "line": 260
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&r32",
            "0",
            "sizeof(r32)"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint put_compat_rusage(const struct rusage *r, struct compat_rusage __user *ru)\n{\n\tstruct compat_rusage r32;\n\tmemset(&r32, 0, sizeof(r32));\n\tr32.ru_utime.tv_sec = r->ru_utime.tv_sec;\n\tr32.ru_utime.tv_usec = r->ru_utime.tv_usec;\n\tr32.ru_stime.tv_sec = r->ru_stime.tv_sec;\n\tr32.ru_stime.tv_usec = r->ru_stime.tv_usec;\n\tr32.ru_maxrss = r->ru_maxrss;\n\tr32.ru_ixrss = r->ru_ixrss;\n\tr32.ru_idrss = r->ru_idrss;\n\tr32.ru_isrss = r->ru_isrss;\n\tr32.ru_minflt = r->ru_minflt;\n\tr32.ru_majflt = r->ru_majflt;\n\tr32.ru_nswap = r->ru_nswap;\n\tr32.ru_inblock = r->ru_inblock;\n\tr32.ru_oublock = r->ru_oublock;\n\tr32.ru_msgsnd = r->ru_msgsnd;\n\tr32.ru_msgrcv = r->ru_msgrcv;\n\tr32.ru_nsignals = r->ru_nsignals;\n\tr32.ru_nvcsw = r->ru_nvcsw;\n\tr32.ru_nivcsw = r->ru_nivcsw;\n\tif (copy_to_user(ru, &r32, sizeof(r32)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_sig_setmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "190-193",
    "snippet": "static inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "blocked->sig",
            "&set",
            "sizeof(set)"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic inline void compat_sig_setmask(sigset_t *blocked, compat_sigset_word set)\n{\n\tmemcpy(blocked->sig, &set, sizeof(set));\n}"
  },
  {
    "function_name": "put_compat_itimerval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "173-182",
    "snippet": "int put_compat_itimerval(struct compat_itimerval __user *o, const struct itimerval *i)\n{\n\tstruct compat_itimerval v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_usec;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_usec;\n\treturn copy_to_user(o, &v32, sizeof(struct compat_itimerval)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "o",
            "&v32",
            "sizeof(struct compat_itimerval)"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint put_compat_itimerval(struct compat_itimerval __user *o, const struct itimerval *i)\n{\n\tstruct compat_itimerval v32;\n\n\tv32.it_interval.tv_sec = i->it_interval.tv_sec;\n\tv32.it_interval.tv_usec = i->it_interval.tv_usec;\n\tv32.it_value.tv_sec = i->it_value.tv_sec;\n\tv32.it_value.tv_usec = i->it_value.tv_usec;\n\treturn copy_to_user(o, &v32, sizeof(struct compat_itimerval)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "get_compat_itimerval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "160-171",
    "snippet": "int get_compat_itimerval(struct itimerval *o, const struct compat_itimerval __user *i)\n{\n\tstruct compat_itimerval v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct compat_itimerval)))\n\t\treturn -EFAULT;\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_usec = v32.it_interval.tv_usec;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_usec = v32.it_value.tv_usec;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&v32",
            "i",
            "sizeof(struct compat_itimerval)"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint get_compat_itimerval(struct itimerval *o, const struct compat_itimerval __user *i)\n{\n\tstruct compat_itimerval v32;\n\n\tif (copy_from_user(&v32, i, sizeof(struct compat_itimerval)))\n\t\treturn -EFAULT;\n\to->it_interval.tv_sec = v32.it_interval.tv_sec;\n\to->it_interval.tv_usec = v32.it_interval.tv_usec;\n\to->it_value.tv_sec = v32.it_value.tv_sec;\n\to->it_value.tv_usec = v32.it_value.tv_usec;\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_put_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "151-157",
    "snippet": "int compat_put_timespec(const struct timespec *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec(ts, uts);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__compat_put_timespec",
          "args": [
            "ts",
            "uts"
          ],
          "line": 156
        },
        "resolved": true,
        "details": {
          "function_name": "__compat_put_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
          "lines": "117-122",
          "snippet": "static int __compat_put_timespec(const struct timespec *ts, struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/timex.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_put_timespec(const struct timespec *ts, struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uts",
            "ts",
            "sizeof(*ts)"
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_put_timespec(const struct timespec *ts, void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(uts, ts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timespec(ts, uts);\n}"
  },
  {
    "function_name": "compat_get_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "142-148",
    "snippet": "int compat_get_timespec(struct timespec *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec(ts, uts);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__compat_get_timespec",
          "args": [
            "ts",
            "uts"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "__compat_get_timespec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
          "lines": "110-115",
          "snippet": "static int __compat_get_timespec(struct timespec *ts, const struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/timex.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_get_timespec(struct timespec *ts, const struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "ts",
            "uts",
            "sizeof(*ts)"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_get_timespec(struct timespec *ts, const void __user *uts)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(ts, uts, sizeof(*ts)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timespec(ts, uts);\n}"
  },
  {
    "function_name": "compat_put_timeval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "133-139",
    "snippet": "int compat_put_timeval(const struct timeval *tv, void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(utv, tv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timeval(tv, utv);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__compat_put_timeval",
          "args": [
            "tv",
            "utv"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__compat_put_timeval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
          "lines": "103-108",
          "snippet": "static int __compat_put_timeval(const struct timeval *tv, struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/timex.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_put_timeval(const struct timeval *tv, struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "utv",
            "tv",
            "sizeof(*tv)"
          ],
          "line": 136
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_put_timeval(const struct timeval *tv, void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_to_user(utv, tv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_put_timeval(tv, utv);\n}"
  },
  {
    "function_name": "compat_get_timeval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "124-130",
    "snippet": "int compat_get_timeval(struct timeval *tv, const void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(tv, utv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timeval(tv, utv);\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__compat_get_timeval",
          "args": [
            "tv",
            "utv"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "__compat_get_timeval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
          "lines": "96-101",
          "snippet": "static int __compat_get_timeval(struct timeval *tv, const struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/gfp.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/times.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/migrate.h>",
            "#include <linux/export.h>",
            "#include <linux/timex.h>",
            "#include <linux/security.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
            "#include <linux/signal.h>",
            "#include <linux/time.h>",
            "#include <linux/errno.h>",
            "#include <linux/compat.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_get_timeval(struct timeval *tv, const struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "tv",
            "utv",
            "sizeof(*tv)"
          ],
          "line": 127
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_get_timeval(struct timeval *tv, const void __user *utv)\n{\n\tif (COMPAT_USE_64BIT_TIME)\n\t\treturn copy_from_user(tv, utv, sizeof(*tv)) ? -EFAULT : 0;\n\telse\n\t\treturn __compat_get_timeval(tv, utv);\n}"
  },
  {
    "function_name": "__compat_put_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "117-122",
    "snippet": "static int __compat_put_timespec(const struct timespec *ts, struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ts->tv_nsec",
            "&cts->tv_nsec"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ts->tv_sec",
            "&cts->tv_sec"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "cts",
            "sizeof(*cts)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_put_timespec(const struct timespec *ts, struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_WRITE, cts, sizeof(*cts)) ||\n\t\t\t__put_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__put_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "__compat_get_timespec",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "110-115",
    "snippet": "static int __compat_get_timespec(struct timespec *ts, const struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ts->tv_nsec",
            "&cts->tv_nsec"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "ts->tv_sec",
            "&cts->tv_sec"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "cts",
            "sizeof(*cts)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_get_timespec(struct timespec *ts, const struct old_timespec32 __user *cts)\n{\n\treturn (!access_ok(VERIFY_READ, cts, sizeof(*cts)) ||\n\t\t\t__get_user(ts->tv_sec, &cts->tv_sec) ||\n\t\t\t__get_user(ts->tv_nsec, &cts->tv_nsec)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "__compat_put_timeval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "103-108",
    "snippet": "static int __compat_put_timeval(const struct timeval *tv, struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tv->tv_usec",
            "&ctv->tv_usec"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "tv->tv_sec",
            "&ctv->tv_sec"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_WRITE",
            "ctv",
            "sizeof(*ctv)"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_put_timeval(const struct timeval *tv, struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_WRITE, ctv, sizeof(*ctv)) ||\n\t\t\t__put_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__put_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "__compat_get_timeval",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "96-101",
    "snippet": "static int __compat_get_timeval(struct timeval *tv, const struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tv->tv_usec",
            "&ctv->tv_usec"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__get_user",
          "args": [
            "tv->tv_sec",
            "&ctv->tv_sec"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "access_ok",
          "args": [
            "VERIFY_READ",
            "ctv",
            "sizeof(*ctv)"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nstatic int __compat_get_timeval(struct timeval *tv, const struct old_timeval32 __user *ctv)\n{\n\treturn (!access_ok(VERIFY_READ, ctv, sizeof(*ctv)) ||\n\t\t\t__get_user(tv->tv_sec, &ctv->tv_sec) ||\n\t\t\t__get_user(tv->tv_usec, &ctv->tv_usec)) ? -EFAULT : 0;\n}"
  },
  {
    "function_name": "compat_put_timex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "65-94",
    "snippet": "int compat_put_timex(struct compat_timex __user *utp, const struct timex *txc)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(&tx32, 0, sizeof(struct compat_timex));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "utp",
            "&tx32",
            "sizeof(struct compat_timex)"
          ],
          "line": 91
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&tx32",
            "0",
            "sizeof(struct compat_timex)"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_put_timex(struct compat_timex __user *utp, const struct timex *txc)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(&tx32, 0, sizeof(struct compat_timex));\n\ttx32.modes = txc->modes;\n\ttx32.offset = txc->offset;\n\ttx32.freq = txc->freq;\n\ttx32.maxerror = txc->maxerror;\n\ttx32.esterror = txc->esterror;\n\ttx32.status = txc->status;\n\ttx32.constant = txc->constant;\n\ttx32.precision = txc->precision;\n\ttx32.tolerance = txc->tolerance;\n\ttx32.time.tv_sec = txc->time.tv_sec;\n\ttx32.time.tv_usec = txc->time.tv_usec;\n\ttx32.tick = txc->tick;\n\ttx32.ppsfreq = txc->ppsfreq;\n\ttx32.jitter = txc->jitter;\n\ttx32.shift = txc->shift;\n\ttx32.stabil = txc->stabil;\n\ttx32.jitcnt = txc->jitcnt;\n\ttx32.calcnt = txc->calcnt;\n\ttx32.errcnt = txc->errcnt;\n\ttx32.stbcnt = txc->stbcnt;\n\ttx32.tai = txc->tai;\n\tif (copy_to_user(utp, &tx32, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_get_timex",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "33-63",
    "snippet": "int compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&tx32",
            "utp",
            "sizeof(struct compat_timex)"
          ],
          "line": 38
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "txc",
            "0",
            "sizeof(struct timex)"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nint compat_get_timex(struct timex *txc, const struct compat_timex __user *utp)\n{\n\tstruct compat_timex tx32;\n\n\tmemset(txc, 0, sizeof(struct timex));\n\tif (copy_from_user(&tx32, utp, sizeof(struct compat_timex)))\n\t\treturn -EFAULT;\n\n\ttxc->modes = tx32.modes;\n\ttxc->offset = tx32.offset;\n\ttxc->freq = tx32.freq;\n\ttxc->maxerror = tx32.maxerror;\n\ttxc->esterror = tx32.esterror;\n\ttxc->status = tx32.status;\n\ttxc->constant = tx32.constant;\n\ttxc->precision = tx32.precision;\n\ttxc->tolerance = tx32.tolerance;\n\ttxc->time.tv_sec = tx32.time.tv_sec;\n\ttxc->time.tv_usec = tx32.time.tv_usec;\n\ttxc->tick = tx32.tick;\n\ttxc->ppsfreq = tx32.ppsfreq;\n\ttxc->jitter = tx32.jitter;\n\ttxc->shift = tx32.shift;\n\ttxc->stabil = tx32.stabil;\n\ttxc->jitcnt = tx32.jitcnt;\n\ttxc->calcnt = tx32.calcnt;\n\ttxc->errcnt = tx32.errcnt;\n\ttxc->stbcnt = tx32.stbcnt;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "195-234",
    "snippet": "SYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sigprocmask, int, how,\n\t\t       compat_old_sigset_t __user *, nset,\n\t\t       compat_old_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (get_user(new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tnew_set &= ~(sigmask(SIGKILL) | sigmask(SIGSTOP));\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tcompat_sig_setmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (put_user(old_set, oset))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_setaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "279-297",
    "snippet": "SYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sched_setaffinity, compat_pid_t, pid,\n\t\t       unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tcpumask_var_t new_mask;\n\tint retval;\n\n\tif (!alloc_cpumask_var(&new_mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tretval = compat_get_user_cpu_mask(user_mask_ptr, len, new_mask);\n\tif (retval)\n\t\tgoto out;\n\n\tretval = sched_setaffinity(pid, new_mask);\nout:\n\tfree_cpumask_var(new_mask);\n\treturn retval;\n}"
  },
  {
    "function_name": "sched_getaffinity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/compat.c",
    "lines": "299-325",
    "snippet": "SYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/uaccess.h>",
      "#include <linux/gfp.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/times.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/migrate.h>",
      "#include <linux/export.h>",
      "#include <linux/timex.h>",
      "#include <linux/security.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */",
      "#include <linux/signal.h>",
      "#include <linux/time.h>",
      "#include <linux/errno.h>",
      "#include <linux/compat.h>",
      "#include <linux/linkage.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/gfp.h>\n#include <linux/ptrace.h>\n#include <linux/times.h>\n#include <linux/posix-timers.h>\n#include <linux/migrate.h>\n#include <linux/export.h>\n#include <linux/timex.h>\n#include <linux/security.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/sched.h>\t/* for MAX_SCHEDULE_TIMEOUT */\n#include <linux/signal.h>\n#include <linux/time.h>\n#include <linux/errno.h>\n#include <linux/compat.h>\n#include <linux/linkage.h>\n\nSYSCALL_DEFINE3(sched_getaffinity, compat_pid_t,  pid, unsigned int, len,\n\t\t       compat_ulong_t __user *, user_mask_ptr)\n{\n\tint ret;\n\tcpumask_var_t mask;\n\n\tif ((len * BITS_PER_BYTE) < nr_cpu_ids)\n\t\treturn -EINVAL;\n\tif (len & (sizeof(compat_ulong_t)-1))\n\t\treturn -EINVAL;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\n\tret = sched_getaffinity(pid, mask);\n\tif (ret == 0) {\n\t\tunsigned int retlen = min(len, cpumask_size());\n\n\t\tif (compat_put_bitmap(user_mask_ptr, cpumask_bits(mask), retlen * 8))\n\t\t\tret = -EFAULT;\n\t\telse\n\t\t\tret = retlen;\n\t}\n\tfree_cpumask_var(mask);\n\n\treturn ret;\n}"
  }
]