[
  {
    "function_name": "kdb_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2920-2939",
    "snippet": "void __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_cmd_init",
          "args": [],
          "line": 2934
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cmd_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2904-2917",
          "snippet": "static void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_initbptab",
          "args": [],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_initbptab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_bp.c",
          "lines": "519-558",
          "snippet": "void __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_flags(\"bp\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Set/Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bl\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_flags(\"bph\", kdb_bp, \"[<vaddr>]\",\n\t\t\"[datar [length]|dataw [length]]   Set hw brk\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bc\", kdb_bc, \"<bpnum>\",\n\t\t\"Clear Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"be\", kdb_bc, \"<bpnum>\",\n\t\t\"Enable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"bd\", kdb_bc, \"<bpnum>\",\n\t\t\"Disable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\n\tkdb_register_flags(\"ss\", kdb_ss, \"\",\n\t\t\"Single Step\", 1,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\t/*\n\t * Architecture dependent initialization.\n\t */\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/interrupt.h>",
            "#include <linux/sched.h>",
            "#include <linux/smp.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kdb.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "kdb_bp_t kdb_breakpoints[KDB_MAXBPT];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/interrupt.h>\n#include <linux/sched.h>\n#include <linux/smp.h>\n#include <linux/kgdb.h>\n#include <linux/kdb.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n\nkdb_bp_t kdb_breakpoints[KDB_MAXBPT];\n\nvoid __init kdb_initbptab(void)\n{\n\tint i;\n\tkdb_bp_t *bp;\n\n\t/*\n\t * First time initialization.\n\t */\n\tmemset(&kdb_breakpoints, '\\0', sizeof(kdb_breakpoints));\n\n\tfor (i = 0, bp = kdb_breakpoints; i < KDB_MAXBPT; i++, bp++)\n\t\tbp->bp_free = 1;\n\n\tkdb_register_flags(\"bp\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Set/Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bl\", kdb_bp, \"[<vaddr>]\",\n\t\t\"Display breakpoints\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tif (arch_kgdb_ops.flags & KGDB_HW_BREAKPOINT)\n\t\tkdb_register_flags(\"bph\", kdb_bp, \"[<vaddr>]\",\n\t\t\"[datar [length]|dataw [length]]   Set hw brk\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"bc\", kdb_bc, \"<bpnum>\",\n\t\t\"Clear Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"be\", kdb_bc, \"<bpnum>\",\n\t\t\"Enable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\tkdb_register_flags(\"bd\", kdb_bc, \"<bpnum>\",\n\t\t\"Disable Breakpoint\", 0,\n\t\tKDB_ENABLE_FLOW_CTRL);\n\n\tkdb_register_flags(\"ss\", kdb_ss, \"\",\n\t\t\"Single Step\", 1,\n\t\tKDB_ENABLE_FLOW_CTRL | KDB_REPEAT_NO_ARGS);\n\t/*\n\t * Architecture dependent initialization.\n\t */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_inittab",
          "args": [],
          "line": 2930
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_inittab",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2790-2901",
          "snippet": "static void __init kdb_inittab(void)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\tfor_each_kdbcmd(kp, i)\n\t\tkp->cmd_name = NULL;\n\n\tkdb_register_flags(\"md\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Contents, also mdWcN, e.g. md8c1\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdr\", kdb_md, \"<vaddr> <bytes>\",\n\t  \"Display Raw Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdp\", kdb_md, \"<paddr> <bytes>\",\n\t  \"Display Physical Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mds\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Symbolically\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mm\", kdb_mm, \"<vaddr> <contents>\",\n\t  \"Modify Memory Contents\", 0,\n\t  KDB_ENABLE_MEM_WRITE | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"go\", kdb_go, \"[<vaddr>]\",\n\t  \"Continue Execution\", 1,\n\t  KDB_ENABLE_REG_WRITE | KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"rd\", kdb_rd, \"\",\n\t  \"Display Registers\", 0,\n\t  KDB_ENABLE_REG_READ);\n\tkdb_register_flags(\"rm\", kdb_rm, \"<reg> <contents>\",\n\t  \"Modify Registers\", 0,\n\t  KDB_ENABLE_REG_WRITE);\n\tkdb_register_flags(\"ef\", kdb_ef, \"<vaddr>\",\n\t  \"Display exception frame\", 0,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"bt\", kdb_bt, \"[<vaddr>]\",\n\t  \"Stack traceback\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"btp\", kdb_bt, \"<pid>\",\n\t  \"Display stack for process <pid>\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"bta\", kdb_bt, \"[D|R|S|T|C|Z|E|U|I|M|A]\",\n\t  \"Backtrace all processes matching state flag\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btc\", kdb_bt, \"\",\n\t  \"Backtrace current process on each cpu\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btt\", kdb_bt, \"<vaddr>\",\n\t  \"Backtrace process given its struct task address\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"env\", kdb_env, \"\",\n\t  \"Show environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"set\", kdb_set, \"\",\n\t  \"Set environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"help\", kdb_help, \"\",\n\t  \"Display Help Message\", 1,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"?\", kdb_help, \"\",\n\t  \"Display Help Message\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"cpu\", kdb_cpu, \"<cpunum>\",\n\t  \"Switch to new cpu\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"kgdb\", kdb_kgdb, \"\",\n\t  \"Enter kgdb mode\", 0, 0);\n\tkdb_register_flags(\"ps\", kdb_ps, \"[<flags>|A]\",\n\t  \"Display active task list\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"pid\", kdb_pid, \"<pidnum>\",\n\t  \"Switch to another task\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"reboot\", kdb_reboot, \"\",\n\t  \"Reboot the machine immediately\", 0,\n\t  KDB_ENABLE_REBOOT);\n#if defined(CONFIG_MODULES)\n\tkdb_register_flags(\"lsmod\", kdb_lsmod, \"\",\n\t  \"List loaded kernel modules\", 0,\n\t  KDB_ENABLE_INSPECT);\n#endif\n#if defined(CONFIG_MAGIC_SYSRQ)\n\tkdb_register_flags(\"sr\", kdb_sr, \"<key>\",\n\t  \"Magic SysRq key\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n#if defined(CONFIG_PRINTK)\n\tkdb_register_flags(\"dmesg\", kdb_dmesg, \"[lines]\",\n\t  \"Display syslog buffer\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n\tif (arch_kgdb_ops.enable_nmi) {\n\t\tkdb_register_flags(\"disable_nmi\", kdb_disable_nmi, \"\",\n\t\t  \"Disable NMI entry to KDB\", 0,\n\t\t  KDB_ENABLE_ALWAYS_SAFE);\n\t}\n\tkdb_register_flags(\"defcmd\", kdb_defcmd, \"name \\\"usage\\\" \\\"help\\\"\",\n\t  \"Define a set of commands, down to endefcmd\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"kill\", kdb_kill, \"<-signal> <pid>\",\n\t  \"Send a signal to a process\", 0,\n\t  KDB_ENABLE_SIGNAL);\n\tkdb_register_flags(\"summary\", kdb_summary, \"\",\n\t  \"Summarize the system\", 4,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"per_cpu\", kdb_per_cpu, \"<sym> [<bytes>] [<cpu>]\",\n\t  \"Display per_cpu variables\", 3,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"grephelp\", kdb_grep_help, \"\",\n\t  \"Display help on | grep\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_inittab(void)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\tfor_each_kdbcmd(kp, i)\n\t\tkp->cmd_name = NULL;\n\n\tkdb_register_flags(\"md\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Contents, also mdWcN, e.g. md8c1\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdr\", kdb_md, \"<vaddr> <bytes>\",\n\t  \"Display Raw Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdp\", kdb_md, \"<paddr> <bytes>\",\n\t  \"Display Physical Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mds\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Symbolically\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mm\", kdb_mm, \"<vaddr> <contents>\",\n\t  \"Modify Memory Contents\", 0,\n\t  KDB_ENABLE_MEM_WRITE | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"go\", kdb_go, \"[<vaddr>]\",\n\t  \"Continue Execution\", 1,\n\t  KDB_ENABLE_REG_WRITE | KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"rd\", kdb_rd, \"\",\n\t  \"Display Registers\", 0,\n\t  KDB_ENABLE_REG_READ);\n\tkdb_register_flags(\"rm\", kdb_rm, \"<reg> <contents>\",\n\t  \"Modify Registers\", 0,\n\t  KDB_ENABLE_REG_WRITE);\n\tkdb_register_flags(\"ef\", kdb_ef, \"<vaddr>\",\n\t  \"Display exception frame\", 0,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"bt\", kdb_bt, \"[<vaddr>]\",\n\t  \"Stack traceback\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"btp\", kdb_bt, \"<pid>\",\n\t  \"Display stack for process <pid>\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"bta\", kdb_bt, \"[D|R|S|T|C|Z|E|U|I|M|A]\",\n\t  \"Backtrace all processes matching state flag\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btc\", kdb_bt, \"\",\n\t  \"Backtrace current process on each cpu\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btt\", kdb_bt, \"<vaddr>\",\n\t  \"Backtrace process given its struct task address\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"env\", kdb_env, \"\",\n\t  \"Show environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"set\", kdb_set, \"\",\n\t  \"Set environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"help\", kdb_help, \"\",\n\t  \"Display Help Message\", 1,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"?\", kdb_help, \"\",\n\t  \"Display Help Message\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"cpu\", kdb_cpu, \"<cpunum>\",\n\t  \"Switch to new cpu\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"kgdb\", kdb_kgdb, \"\",\n\t  \"Enter kgdb mode\", 0, 0);\n\tkdb_register_flags(\"ps\", kdb_ps, \"[<flags>|A]\",\n\t  \"Display active task list\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"pid\", kdb_pid, \"<pidnum>\",\n\t  \"Switch to another task\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"reboot\", kdb_reboot, \"\",\n\t  \"Reboot the machine immediately\", 0,\n\t  KDB_ENABLE_REBOOT);\n#if defined(CONFIG_MODULES)\n\tkdb_register_flags(\"lsmod\", kdb_lsmod, \"\",\n\t  \"List loaded kernel modules\", 0,\n\t  KDB_ENABLE_INSPECT);\n#endif\n#if defined(CONFIG_MAGIC_SYSRQ)\n\tkdb_register_flags(\"sr\", kdb_sr, \"<key>\",\n\t  \"Magic SysRq key\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n#if defined(CONFIG_PRINTK)\n\tkdb_register_flags(\"dmesg\", kdb_dmesg, \"[lines]\",\n\t  \"Display syslog buffer\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n\tif (arch_kgdb_ops.enable_nmi) {\n\t\tkdb_register_flags(\"disable_nmi\", kdb_disable_nmi, \"\",\n\t\t  \"Disable NMI entry to KDB\", 0,\n\t\t  KDB_ENABLE_ALWAYS_SAFE);\n\t}\n\tkdb_register_flags(\"defcmd\", kdb_defcmd, \"name \\\"usage\\\" \\\"help\\\"\",\n\t  \"Define a set of commands, down to endefcmd\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"kill\", kdb_kill, \"<-signal> <pid>\",\n\t  \"Send a signal to a process\", 0,\n\t  KDB_ENABLE_SIGNAL);\n\tkdb_register_flags(\"summary\", kdb_summary, \"\",\n\t  \"Summarize the system\", 4,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"per_cpu\", kdb_per_cpu, \"<sym> [<bytes>] [<cpu>]\",\n\t  \"Display per_cpu variables\", 3,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"grephelp\", kdb_grep_help, \"\",\n\t  \"Display help on | grep\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid __init kdb_init(int lvl)\n{\n\tstatic int kdb_init_lvl = KDB_NOT_INITIALIZED;\n\tint i;\n\n\tif (kdb_init_lvl == KDB_INIT_FULL || lvl <= kdb_init_lvl)\n\t\treturn;\n\tfor (i = kdb_init_lvl; i < lvl; i++) {\n\t\tswitch (i) {\n\t\tcase KDB_NOT_INITIALIZED:\n\t\t\tkdb_inittab();\t\t/* Initialize Command Table */\n\t\t\tkdb_initbptab();\t/* Initialize Breakpoints */\n\t\t\tbreak;\n\t\tcase KDB_INIT_EARLY:\n\t\t\tkdb_cmd_init();\t\t/* Build kdb_cmds tables */\n\t\t\tbreak;\n\t\t}\n\t}\n\tkdb_init_lvl = lvl;\n}"
  },
  {
    "function_name": "kdb_cmd_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2904-2917",
    "snippet": "static void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "\"endefcmd\""
          ],
          "line": 2915
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "911-1091",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Incomplete 'defcmd' set, forcing endefcmd\\n\""
          ],
          "line": 2914
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_cmd_init(void)\n{\n\tint i, diag;\n\tfor (i = 0; kdb_cmds[i]; ++i) {\n\t\tdiag = kdb_parse(kdb_cmds[i]);\n\t\tif (diag)\n\t\t\tkdb_printf(\"kdb command %s failed, kdb diag %d\\n\",\n\t\t\t\tkdb_cmds[i], diag);\n\t}\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"Incomplete 'defcmd' set, forcing endefcmd\\n\");\n\t\tkdb_parse(\"endefcmd\");\n\t}\n}"
  },
  {
    "function_name": "kdb_inittab",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2790-2901",
    "snippet": "static void __init kdb_inittab(void)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\tfor_each_kdbcmd(kp, i)\n\t\tkp->cmd_name = NULL;\n\n\tkdb_register_flags(\"md\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Contents, also mdWcN, e.g. md8c1\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdr\", kdb_md, \"<vaddr> <bytes>\",\n\t  \"Display Raw Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdp\", kdb_md, \"<paddr> <bytes>\",\n\t  \"Display Physical Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mds\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Symbolically\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mm\", kdb_mm, \"<vaddr> <contents>\",\n\t  \"Modify Memory Contents\", 0,\n\t  KDB_ENABLE_MEM_WRITE | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"go\", kdb_go, \"[<vaddr>]\",\n\t  \"Continue Execution\", 1,\n\t  KDB_ENABLE_REG_WRITE | KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"rd\", kdb_rd, \"\",\n\t  \"Display Registers\", 0,\n\t  KDB_ENABLE_REG_READ);\n\tkdb_register_flags(\"rm\", kdb_rm, \"<reg> <contents>\",\n\t  \"Modify Registers\", 0,\n\t  KDB_ENABLE_REG_WRITE);\n\tkdb_register_flags(\"ef\", kdb_ef, \"<vaddr>\",\n\t  \"Display exception frame\", 0,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"bt\", kdb_bt, \"[<vaddr>]\",\n\t  \"Stack traceback\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"btp\", kdb_bt, \"<pid>\",\n\t  \"Display stack for process <pid>\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"bta\", kdb_bt, \"[D|R|S|T|C|Z|E|U|I|M|A]\",\n\t  \"Backtrace all processes matching state flag\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btc\", kdb_bt, \"\",\n\t  \"Backtrace current process on each cpu\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btt\", kdb_bt, \"<vaddr>\",\n\t  \"Backtrace process given its struct task address\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"env\", kdb_env, \"\",\n\t  \"Show environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"set\", kdb_set, \"\",\n\t  \"Set environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"help\", kdb_help, \"\",\n\t  \"Display Help Message\", 1,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"?\", kdb_help, \"\",\n\t  \"Display Help Message\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"cpu\", kdb_cpu, \"<cpunum>\",\n\t  \"Switch to new cpu\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"kgdb\", kdb_kgdb, \"\",\n\t  \"Enter kgdb mode\", 0, 0);\n\tkdb_register_flags(\"ps\", kdb_ps, \"[<flags>|A]\",\n\t  \"Display active task list\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"pid\", kdb_pid, \"<pidnum>\",\n\t  \"Switch to another task\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"reboot\", kdb_reboot, \"\",\n\t  \"Reboot the machine immediately\", 0,\n\t  KDB_ENABLE_REBOOT);\n#if defined(CONFIG_MODULES)\n\tkdb_register_flags(\"lsmod\", kdb_lsmod, \"\",\n\t  \"List loaded kernel modules\", 0,\n\t  KDB_ENABLE_INSPECT);\n#endif\n#if defined(CONFIG_MAGIC_SYSRQ)\n\tkdb_register_flags(\"sr\", kdb_sr, \"<key>\",\n\t  \"Magic SysRq key\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n#if defined(CONFIG_PRINTK)\n\tkdb_register_flags(\"dmesg\", kdb_dmesg, \"[lines]\",\n\t  \"Display syslog buffer\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n\tif (arch_kgdb_ops.enable_nmi) {\n\t\tkdb_register_flags(\"disable_nmi\", kdb_disable_nmi, \"\",\n\t\t  \"Disable NMI entry to KDB\", 0,\n\t\t  KDB_ENABLE_ALWAYS_SAFE);\n\t}\n\tkdb_register_flags(\"defcmd\", kdb_defcmd, \"name \\\"usage\\\" \\\"help\\\"\",\n\t  \"Define a set of commands, down to endefcmd\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"kill\", kdb_kill, \"<-signal> <pid>\",\n\t  \"Send a signal to a process\", 0,\n\t  KDB_ENABLE_SIGNAL);\n\tkdb_register_flags(\"summary\", kdb_summary, \"\",\n\t  \"Summarize the system\", 4,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"per_cpu\", kdb_per_cpu, \"<sym> [<bytes>] [<cpu>]\",\n\t  \"Display per_cpu variables\", 3,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"grephelp\", kdb_grep_help, \"\",\n\t  \"Display help on | grep\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_register_flags",
          "args": [
            "\"grephelp\"",
            "kdb_grep_help",
            "\"\"",
            "\"Display help on | grep\"",
            "0",
            "KDB_ENABLE_ALWAYS_SAFE"
          ],
          "line": 2898
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2674-2734",
          "snippet": "int kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define kdb_command_extend 50\t/* arbitrary */",
            "#define KDB_BASE_CMD_MAX 50"
          ],
          "globals_used": [
            "static kdbtab_t *kdb_commands;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define kdb_command_extend 50\t/* arbitrary */\n#define KDB_BASE_CMD_MAX 50\n\nstatic kdbtab_t *kdb_commands;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "kp",
            "i"
          ],
          "line": 2795
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void __init kdb_inittab(void)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\tfor_each_kdbcmd(kp, i)\n\t\tkp->cmd_name = NULL;\n\n\tkdb_register_flags(\"md\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Contents, also mdWcN, e.g. md8c1\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdr\", kdb_md, \"<vaddr> <bytes>\",\n\t  \"Display Raw Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mdp\", kdb_md, \"<paddr> <bytes>\",\n\t  \"Display Physical Memory\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mds\", kdb_md, \"<vaddr>\",\n\t  \"Display Memory Symbolically\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"mm\", kdb_mm, \"<vaddr> <contents>\",\n\t  \"Modify Memory Contents\", 0,\n\t  KDB_ENABLE_MEM_WRITE | KDB_REPEAT_NO_ARGS);\n\tkdb_register_flags(\"go\", kdb_go, \"[<vaddr>]\",\n\t  \"Continue Execution\", 1,\n\t  KDB_ENABLE_REG_WRITE | KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"rd\", kdb_rd, \"\",\n\t  \"Display Registers\", 0,\n\t  KDB_ENABLE_REG_READ);\n\tkdb_register_flags(\"rm\", kdb_rm, \"<reg> <contents>\",\n\t  \"Modify Registers\", 0,\n\t  KDB_ENABLE_REG_WRITE);\n\tkdb_register_flags(\"ef\", kdb_ef, \"<vaddr>\",\n\t  \"Display exception frame\", 0,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"bt\", kdb_bt, \"[<vaddr>]\",\n\t  \"Stack traceback\", 1,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"btp\", kdb_bt, \"<pid>\",\n\t  \"Display stack for process <pid>\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"bta\", kdb_bt, \"[D|R|S|T|C|Z|E|U|I|M|A]\",\n\t  \"Backtrace all processes matching state flag\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btc\", kdb_bt, \"\",\n\t  \"Backtrace current process on each cpu\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"btt\", kdb_bt, \"<vaddr>\",\n\t  \"Backtrace process given its struct task address\", 0,\n\t  KDB_ENABLE_MEM_READ | KDB_ENABLE_INSPECT_NO_ARGS);\n\tkdb_register_flags(\"env\", kdb_env, \"\",\n\t  \"Show environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"set\", kdb_set, \"\",\n\t  \"Set environment variables\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"help\", kdb_help, \"\",\n\t  \"Display Help Message\", 1,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"?\", kdb_help, \"\",\n\t  \"Display Help Message\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"cpu\", kdb_cpu, \"<cpunum>\",\n\t  \"Switch to new cpu\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE_NO_ARGS);\n\tkdb_register_flags(\"kgdb\", kdb_kgdb, \"\",\n\t  \"Enter kgdb mode\", 0, 0);\n\tkdb_register_flags(\"ps\", kdb_ps, \"[<flags>|A]\",\n\t  \"Display active task list\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"pid\", kdb_pid, \"<pidnum>\",\n\t  \"Switch to another task\", 0,\n\t  KDB_ENABLE_INSPECT);\n\tkdb_register_flags(\"reboot\", kdb_reboot, \"\",\n\t  \"Reboot the machine immediately\", 0,\n\t  KDB_ENABLE_REBOOT);\n#if defined(CONFIG_MODULES)\n\tkdb_register_flags(\"lsmod\", kdb_lsmod, \"\",\n\t  \"List loaded kernel modules\", 0,\n\t  KDB_ENABLE_INSPECT);\n#endif\n#if defined(CONFIG_MAGIC_SYSRQ)\n\tkdb_register_flags(\"sr\", kdb_sr, \"<key>\",\n\t  \"Magic SysRq key\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n#if defined(CONFIG_PRINTK)\n\tkdb_register_flags(\"dmesg\", kdb_dmesg, \"[lines]\",\n\t  \"Display syslog buffer\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n#endif\n\tif (arch_kgdb_ops.enable_nmi) {\n\t\tkdb_register_flags(\"disable_nmi\", kdb_disable_nmi, \"\",\n\t\t  \"Disable NMI entry to KDB\", 0,\n\t\t  KDB_ENABLE_ALWAYS_SAFE);\n\t}\n\tkdb_register_flags(\"defcmd\", kdb_defcmd, \"name \\\"usage\\\" \\\"help\\\"\",\n\t  \"Define a set of commands, down to endefcmd\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"kill\", kdb_kill, \"<-signal> <pid>\",\n\t  \"Send a signal to a process\", 0,\n\t  KDB_ENABLE_SIGNAL);\n\tkdb_register_flags(\"summary\", kdb_summary, \"\",\n\t  \"Summarize the system\", 4,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n\tkdb_register_flags(\"per_cpu\", kdb_per_cpu, \"<sym> [<bytes>] [<cpu>]\",\n\t  \"Display per_cpu variables\", 3,\n\t  KDB_ENABLE_MEM_READ);\n\tkdb_register_flags(\"grephelp\", kdb_grep_help, \"\",\n\t  \"Display help on | grep\", 0,\n\t  KDB_ENABLE_ALWAYS_SAFE);\n}"
  },
  {
    "function_name": "kdb_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2769-2786",
    "snippet": "int kdb_unregister(char *cmd)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  find the command.\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkp->cmd_name = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Couldn't find it.  */\n\treturn 1;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kp->cmd_name",
            "cmd"
          ],
          "line": 2778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "kp",
            "i"
          ],
          "line": 2777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_unregister(char *cmd)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  find the command.\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkp->cmd_name = NULL;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/* Couldn't find it.  */\n\treturn 1;\n}"
  },
  {
    "function_name": "kdb_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2750-2757",
    "snippet": "int kdb_register(char *cmd,\n\t     kdb_func_t func,\n\t     char *usage,\n\t     char *help,\n\t     short minlen)\n{\n\treturn kdb_register_flags(cmd, func, usage, help, minlen, 0);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_register_flags",
          "args": [
            "cmd",
            "func",
            "usage",
            "help",
            "minlen",
            "0"
          ],
          "line": 2756
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2674-2734",
          "snippet": "int kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define kdb_command_extend 50\t/* arbitrary */",
            "#define KDB_BASE_CMD_MAX 50"
          ],
          "globals_used": [
            "static kdbtab_t *kdb_commands;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define kdb_command_extend 50\t/* arbitrary */\n#define KDB_BASE_CMD_MAX 50\n\nstatic kdbtab_t *kdb_commands;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_register(char *cmd,\n\t     kdb_func_t func,\n\t     char *usage,\n\t     char *help,\n\t     short minlen)\n{\n\treturn kdb_register_flags(cmd, func, usage, help, minlen, 0);\n}"
  },
  {
    "function_name": "kdb_register_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2674-2734",
    "snippet": "int kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define kdb_command_extend 50\t/* arbitrary */",
      "#define KDB_BASE_CMD_MAX 50"
    ],
    "globals_used": [
      "static kdbtab_t *kdb_commands;",
      "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "new + kdb_max_commands - KDB_BASE_CMD_MAX",
            "0",
            "kdb_command_extend * sizeof(*new)"
          ],
          "line": 2719
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "kdb_commands"
          ],
          "line": 2717
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new",
            "kdb_commands",
            "(kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new)"
          ],
          "line": 2715
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\""
          ],
          "line": 2710
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend",
            "sizeof(*new)",
            "GFP_KDB"
          ],
          "line": 2704
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "kp",
            "i"
          ],
          "line": 2698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "kp->cmd_name",
            "cmd"
          ],
          "line": 2688
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "kp",
            "i"
          ],
          "line": 2687
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define kdb_command_extend 50\t/* arbitrary */\n#define KDB_BASE_CMD_MAX 50\n\nstatic kdbtab_t *kdb_commands;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_grep_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2645-2659",
    "snippet": "static int kdb_grep_help(int argc, const char **argv)\n{\n\tkdb_printf(\"Usage of  cmd args | grep pattern:\\n\");\n\tkdb_printf(\"  Any command's output may be filtered through an \");\n\tkdb_printf(\"emulated 'pipe'.\\n\");\n\tkdb_printf(\"  'grep' is just a key word.\\n\");\n\tkdb_printf(\"  The pattern may include a very limited set of \"\n\t\t   \"metacharacters:\\n\");\n\tkdb_printf(\"   pattern or ^pattern or pattern$ or ^pattern$\\n\");\n\tkdb_printf(\"  And if there are spaces in the pattern, you may \"\n\t\t   \"quote it:\\n\");\n\tkdb_printf(\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\""
          ],
          "line": 2656
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_grep_help(int argc, const char **argv)\n{\n\tkdb_printf(\"Usage of  cmd args | grep pattern:\\n\");\n\tkdb_printf(\"  Any command's output may be filtered through an \");\n\tkdb_printf(\"emulated 'pipe'.\\n\");\n\tkdb_printf(\"  'grep' is just a key word.\\n\");\n\tkdb_printf(\"  The pattern may include a very limited set of \"\n\t\t   \"metacharacters:\\n\");\n\tkdb_printf(\"   pattern or ^pattern or pattern$ or ^pattern$\\n\");\n\tkdb_printf(\"  And if there are spaces in the pattern, you may \"\n\t\t   \"quote it:\\n\");\n\tkdb_printf(\"   \\\"pat tern\\\" or \\\"^pat tern\\\" or \\\"pat tern$\\\"\"\n\t\t   \" or \\\"^pat tern$\\\"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_per_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2575-2640",
    "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_md_line",
          "args": [
            "fmtstr",
            "addr",
            "bytesperword == KDB_WORD_SIZE",
            "1",
            "bytesperword",
            "1",
            "1",
            "0"
          ],
          "line": 2634
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_md_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1487-1565",
          "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%5d \"",
            "cpu"
          ],
          "line": 2633
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&val",
            "addr",
            "bytesperword"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "453-490",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_PCU",
          "args": [
            "cpu"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2621
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "whichcpu"
          ],
          "line": 2602
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[3]",
            "&whichcpu"
          ],
          "line": 2599
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%0%dlx \"",
            "(int)(2*bytesperword)"
          ],
          "line": 2597
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&symaddr",
            "NULL",
            "NULL"
          ],
          "line": 2584
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_summary",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2525-2570",
    "snippet": "static int kdb_summary(int argc, const char **argv)\n{\n\ttime64_t now;\n\tstruct tm tm;\n\tstruct sysinfo val;\n\n\tif (argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"sysname    %s\\n\", init_uts_ns.name.sysname);\n\tkdb_printf(\"release    %s\\n\", init_uts_ns.name.release);\n\tkdb_printf(\"version    %s\\n\", init_uts_ns.name.version);\n\tkdb_printf(\"machine    %s\\n\", init_uts_ns.name.machine);\n\tkdb_printf(\"nodename   %s\\n\", init_uts_ns.name.nodename);\n\tkdb_printf(\"domainname %s\\n\", init_uts_ns.name.domainname);\n\tkdb_printf(\"ccversion  %s\\n\", __stringify(CCVERSION));\n\n\tnow = __ktime_get_real_seconds();\n\ttime64_to_tm(now, 0, &tm);\n\tkdb_printf(\"date       %04ld-%02d-%02d %02d:%02d:%02d \"\n\t\t   \"tz_minuteswest %d\\n\",\n\t\t1900+tm.tm_year, tm.tm_mon+1, tm.tm_mday,\n\t\ttm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\tsys_tz.tz_minuteswest);\n\n\tkdb_sysinfo(&val);\n\tkdb_printf(\"uptime     \");\n\tif (val.uptime > (24*60*60)) {\n\t\tint days = val.uptime / (24*60*60);\n\t\tval.uptime %= (24*60*60);\n\t\tkdb_printf(\"%d day%s \", days, days == 1 ? \"\" : \"s\");\n\t}\n\tkdb_printf(\"%02ld:%02ld\\n\", val.uptime/(60*60), (val.uptime/60)%60);\n\n\tkdb_printf(\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\",\n\t\tLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\n\t\tLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\n\t\tLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\n\n\t/* Display in kilobytes */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tkdb_printf(\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\",\n\t\t   K(val.totalram), K(val.freeram), K(val.bufferram));\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\"",
            "K(val.totalram)",
            "K(val.freeram)",
            "K(val.bufferram)"
          ],
          "line": 2566
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.bufferram"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.freeram"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "K",
          "args": [
            "val.totalram"
          ],
          "line": 2568
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[2]"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[2]"
          ],
          "line": 2562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[1]"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[1]"
          ],
          "line": 2561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_FRAC",
          "args": [
            "val.loads[0]"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "LOAD_INT",
          "args": [
            "val.loads[0]"
          ],
          "line": 2560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_sysinfo",
          "args": [
            "&val"
          ],
          "line": 2550
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_sysinfo",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2507-2520",
          "snippet": "static void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "time64_to_tm",
          "args": [
            "now",
            "0",
            "&tm"
          ],
          "line": 2543
        },
        "resolved": true,
        "details": {
          "function_name": "time64_to_tm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timeconv.c",
          "lines": "77-127",
          "snippet": "void time64_to_tm(time64_t totalsecs, int offset, struct tm *result)\n{\n\tlong days, rem, y;\n\tint remainder;\n\tconst unsigned short *ip;\n\n\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);\n\trem = remainder;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += SECS_PER_DAY;\n\t\t--days;\n\t}\n\twhile (rem >= SECS_PER_DAY) {\n\t\trem -= SECS_PER_DAY;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t/* January 1, 1970 was a Thursday. */\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\ty = 1970;\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\t/* Guess a corrected year, assuming 365 days per year. */\n\t\tlong yg = y + math_div(days, 365);\n\n\t\t/* Adjust DAYS and Y to match the guessed year. */\n\t\tdays -= (yg - y) * 365 + leaps_between(y, yg);\n\t\ty = yg;\n\t}\n\n\tresult->tm_year = y - 1900;\n\n\tresult->tm_yday = days;\n\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < ip[y]; y--)\n\t\tcontinue;\n\tdays -= ip[y];\n\n\tresult->tm_mon = y;\n\tresult->tm_mday = days + 1;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/time.h>"
          ],
          "macros_used": [
            "#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)",
            "#define SECS_PER_HOUR\t(60 * 60)"
          ],
          "globals_used": [
            "static const unsigned short __mon_yday[2][13] = {\n\t/* Normal years. */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years. */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/time.h>\n\n#define SECS_PER_DAY\t(SECS_PER_HOUR * 24)\n#define SECS_PER_HOUR\t(60 * 60)\n\nstatic const unsigned short __mon_yday[2][13] = {\n\t/* Normal years. */\n\t{0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334, 365},\n\t/* Leap years. */\n\t{0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335, 366}\n};\n\nvoid time64_to_tm(time64_t totalsecs, int offset, struct tm *result)\n{\n\tlong days, rem, y;\n\tint remainder;\n\tconst unsigned short *ip;\n\n\tdays = div_s64_rem(totalsecs, SECS_PER_DAY, &remainder);\n\trem = remainder;\n\trem += offset;\n\twhile (rem < 0) {\n\t\trem += SECS_PER_DAY;\n\t\t--days;\n\t}\n\twhile (rem >= SECS_PER_DAY) {\n\t\trem -= SECS_PER_DAY;\n\t\t++days;\n\t}\n\n\tresult->tm_hour = rem / SECS_PER_HOUR;\n\trem %= SECS_PER_HOUR;\n\tresult->tm_min = rem / 60;\n\tresult->tm_sec = rem % 60;\n\n\t/* January 1, 1970 was a Thursday. */\n\tresult->tm_wday = (4 + days) % 7;\n\tif (result->tm_wday < 0)\n\t\tresult->tm_wday += 7;\n\n\ty = 1970;\n\n\twhile (days < 0 || days >= (__isleap(y) ? 366 : 365)) {\n\t\t/* Guess a corrected year, assuming 365 days per year. */\n\t\tlong yg = y + math_div(days, 365);\n\n\t\t/* Adjust DAYS and Y to match the guessed year. */\n\t\tdays -= (yg - y) * 365 + leaps_between(y, yg);\n\t\ty = yg;\n\t}\n\n\tresult->tm_year = y - 1900;\n\n\tresult->tm_yday = days;\n\n\tip = __mon_yday[__isleap(y)];\n\tfor (y = 11; days < ip[y]; y--)\n\t\tcontinue;\n\tdays -= ip[y];\n\n\tresult->tm_mon = y;\n\tresult->tm_mday = days + 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__ktime_get_real_seconds",
          "args": [],
          "line": 2542
        },
        "resolved": true,
        "details": {
          "function_name": "__ktime_get_real_seconds",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "952-957",
          "snippet": "time64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\ntime64_t __ktime_get_real_seconds(void)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\n\treturn tk->xtime_sec;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__stringify",
          "args": [
            "CCVERSION"
          ],
          "line": 2540
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_summary(int argc, const char **argv)\n{\n\ttime64_t now;\n\tstruct tm tm;\n\tstruct sysinfo val;\n\n\tif (argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"sysname    %s\\n\", init_uts_ns.name.sysname);\n\tkdb_printf(\"release    %s\\n\", init_uts_ns.name.release);\n\tkdb_printf(\"version    %s\\n\", init_uts_ns.name.version);\n\tkdb_printf(\"machine    %s\\n\", init_uts_ns.name.machine);\n\tkdb_printf(\"nodename   %s\\n\", init_uts_ns.name.nodename);\n\tkdb_printf(\"domainname %s\\n\", init_uts_ns.name.domainname);\n\tkdb_printf(\"ccversion  %s\\n\", __stringify(CCVERSION));\n\n\tnow = __ktime_get_real_seconds();\n\ttime64_to_tm(now, 0, &tm);\n\tkdb_printf(\"date       %04ld-%02d-%02d %02d:%02d:%02d \"\n\t\t   \"tz_minuteswest %d\\n\",\n\t\t1900+tm.tm_year, tm.tm_mon+1, tm.tm_mday,\n\t\ttm.tm_hour, tm.tm_min, tm.tm_sec,\n\t\tsys_tz.tz_minuteswest);\n\n\tkdb_sysinfo(&val);\n\tkdb_printf(\"uptime     \");\n\tif (val.uptime > (24*60*60)) {\n\t\tint days = val.uptime / (24*60*60);\n\t\tval.uptime %= (24*60*60);\n\t\tkdb_printf(\"%d day%s \", days, days == 1 ? \"\" : \"s\");\n\t}\n\tkdb_printf(\"%02ld:%02ld\\n\", val.uptime/(60*60), (val.uptime/60)%60);\n\n\tkdb_printf(\"load avg   %ld.%02ld %ld.%02ld %ld.%02ld\\n\",\n\t\tLOAD_INT(val.loads[0]), LOAD_FRAC(val.loads[0]),\n\t\tLOAD_INT(val.loads[1]), LOAD_FRAC(val.loads[1]),\n\t\tLOAD_INT(val.loads[2]), LOAD_FRAC(val.loads[2]));\n\n\t/* Display in kilobytes */\n#define K(x) ((x) << (PAGE_SHIFT - 10))\n\tkdb_printf(\"\\nMemTotal:       %8lu kB\\nMemFree:        %8lu kB\\n\"\n\t\t   \"Buffers:        %8lu kB\\n\",\n\t\t   K(val.totalram), K(val.freeram), K(val.bufferram));\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_sysinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2507-2520",
    "snippet": "static void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "si_meminfo",
          "args": [
            "val"
          ],
          "line": 2517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "uptime",
            "NSEC_PER_SEC"
          ],
          "line": 2512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "val",
            "0",
            "sizeof(*val)"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ktime_get_mono_fast_ns",
          "args": [],
          "line": 2509
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_mono_fast_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "469-472",
          "snippet": "u64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nu64 ktime_get_mono_fast_ns(void)\n{\n\treturn __ktime_get_fast_ns(&tk_fast_mono);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_sysinfo(struct sysinfo *val)\n{\n\tu64 uptime = ktime_get_mono_fast_ns();\n\n\tmemset(val, 0, sizeof(*val));\n\tval->uptime = div_u64(uptime, NSEC_PER_SEC);\n\tval->loads[0] = avenrun[0];\n\tval->loads[1] = avenrun[1];\n\tval->loads[2] = avenrun[2];\n\tval->procs = nr_threads-1;\n\tsi_meminfo(val);\n\n\treturn;\n}"
  },
  {
    "function_name": "kdb_kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2465-2500",
    "snippet": "static int kdb_kill(int argc, const char **argv)\n{\n\tlong sig, pid;\n\tchar *endp;\n\tstruct task_struct *p;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tsig = simple_strtol(argv[1], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif ((sig >= 0) || !valid_signal(-sig)) {\n\t\tkdb_printf(\"Invalid signal parameter.<-signal>\\n\");\n\t\treturn 0;\n\t}\n\tsig = -sig;\n\n\tpid = simple_strtol(argv[2], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif (pid <= 0) {\n\t\tkdb_printf(\"Process ID must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Find the process. */\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"The specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->group_leader;\n\tkdb_send_sig(p, sig);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_send_sig",
          "args": [
            "p",
            "sig"
          ],
          "line": 2498
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_send_sig",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "4111-4140",
          "snippet": "void kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"The specified process isn't found.\\n\""
          ],
          "line": 2494
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "pid",
            "&init_pid_ns"
          ],
          "line": 2492
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "341-346",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[2]",
            "&endp",
            "0"
          ],
          "line": 2483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "-sig"
          ],
          "line": 2477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[1]",
            "&endp",
            "0"
          ],
          "line": 2474
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_kill(int argc, const char **argv)\n{\n\tlong sig, pid;\n\tchar *endp;\n\tstruct task_struct *p;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tsig = simple_strtol(argv[1], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif ((sig >= 0) || !valid_signal(-sig)) {\n\t\tkdb_printf(\"Invalid signal parameter.<-signal>\\n\");\n\t\treturn 0;\n\t}\n\tsig = -sig;\n\n\tpid = simple_strtol(argv[2], &endp, 0);\n\tif (*endp)\n\t\treturn KDB_BADINT;\n\tif (pid <= 0) {\n\t\tkdb_printf(\"Process ID must be large than 0.\\n\");\n\t\treturn 0;\n\t}\n\n\t/* Find the process. */\n\tp = find_task_by_pid_ns(pid, &init_pid_ns);\n\tif (!p) {\n\t\tkdb_printf(\"The specified process isn't found.\\n\");\n\t\treturn 0;\n\t}\n\tp = p->group_leader;\n\tkdb_send_sig(p, sig);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_help",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2438-2460",
    "snippet": "static int kdb_help(int argc, const char **argv)\n{\n\tkdbtab_t *kt;\n\tint i;\n\n\tkdb_printf(\"%-15.15s %-20.20s %s\\n\", \"Command\", \"Usage\", \"Description\");\n\tkdb_printf(\"-----------------------------\"\n\t\t   \"-----------------------------\\n\");\n\tfor_each_kdbcmd(kt, i) {\n\t\tchar *space = \"\";\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (!kt->cmd_name)\n\t\t\tcontinue;\n\t\tif (!kdb_check_flags(kt->cmd_flags, kdb_cmd_enabled, true))\n\t\t\tcontinue;\n\t\tif (strlen(kt->cmd_usage) > 20)\n\t\t\tspace = \"\\n                                    \";\n\t\tkdb_printf(\"%-15.15s %-20s%s%s\\n\", kt->cmd_name,\n\t\t\t   kt->cmd_usage, space, kt->cmd_help);\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%-15.15s %-20s%s%s\\n\"",
            "kt->cmd_name",
            "kt->cmd_usage",
            "space",
            "kt->cmd_help"
          ],
          "line": 2456
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "kt->cmd_usage"
          ],
          "line": 2454
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "kt->cmd_flags",
            "kdb_cmd_enabled",
            "true"
          ],
          "line": 2452
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "204-218",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "kt",
            "i"
          ],
          "line": 2446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nstatic int kdb_help(int argc, const char **argv)\n{\n\tkdbtab_t *kt;\n\tint i;\n\n\tkdb_printf(\"%-15.15s %-20.20s %s\\n\", \"Command\", \"Usage\", \"Description\");\n\tkdb_printf(\"-----------------------------\"\n\t\t   \"-----------------------------\\n\");\n\tfor_each_kdbcmd(kt, i) {\n\t\tchar *space = \"\";\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (!kt->cmd_name)\n\t\t\tcontinue;\n\t\tif (!kdb_check_flags(kt->cmd_flags, kdb_cmd_enabled, true))\n\t\t\tcontinue;\n\t\tif (strlen(kt->cmd_usage) > 20)\n\t\t\tspace = \"\\n                                    \";\n\t\tkdb_printf(\"%-15.15s %-20s%s%s\\n\", kt->cmd_name,\n\t\t\t   kt->cmd_usage, space, kt->cmd_help);\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_kgdb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2430-2433",
    "snippet": "static int kdb_kgdb(int argc, const char **argv)\n{\n\treturn KDB_CMD_KGDB;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_kgdb(int argc, const char **argv)\n{\n\treturn KDB_CMD_KGDB;\n}"
  },
  {
    "function_name": "kdb_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2398-2428",
    "snippet": "static int kdb_pid(int argc, const char **argv)\n{\n\tstruct task_struct *p;\n\tunsigned long val;\n\tint diag;\n\n\tif (argc > 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tif (strcmp(argv[1], \"R\") == 0) {\n\t\t\tp = KDB_TSK(kdb_initial_cpu);\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[1], &val);\n\t\t\tif (diag)\n\t\t\t\treturn KDB_BADINT;\n\n\t\t\tp = find_task_by_pid_ns((pid_t)val,\t&init_pid_ns);\n\t\t\tif (!p) {\n\t\t\t\tkdb_printf(\"No task with pid=%d\\n\", (pid_t)val);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tkdb_set_current_task(p);\n\t}\n\tkdb_printf(\"KDB current process is %s(pid=%d)\\n\",\n\t\t   kdb_current_task->comm,\n\t\t   kdb_current_task->pid);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "struct task_struct *kdb_current_task;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"KDB current process is %s(pid=%d)\\n\"",
            "kdb_current_task->comm",
            "kdb_current_task->pid"
          ],
          "line": 2423
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set_current_task",
          "args": [
            "p"
          ],
          "line": 2421
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set_current_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1142-1151",
          "snippet": "void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct task_struct *kdb_current_task;",
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nvoid kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_pid_ns",
          "args": [
            "(pid_t)val",
            "&init_pid_ns"
          ],
          "line": 2415
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "341-346",
          "snippet": "struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)\n{\n\tRCU_LOCKDEP_WARN(!rcu_read_lock_held(),\n\t\t\t \"find_task_by_pid_ns() needs rcu_read_lock() protection\");\n\treturn pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[1]",
            "&val"
          ],
          "line": 2411
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "kdb_initial_cpu"
          ],
          "line": 2409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"R\""
          ],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nstruct task_struct *kdb_current_task;\n\nstatic int kdb_pid(int argc, const char **argv)\n{\n\tstruct task_struct *p;\n\tunsigned long val;\n\tint diag;\n\n\tif (argc > 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tif (argc) {\n\t\tif (strcmp(argv[1], \"R\") == 0) {\n\t\t\tp = KDB_TSK(kdb_initial_cpu);\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[1], &val);\n\t\t\tif (diag)\n\t\t\t\treturn KDB_BADINT;\n\n\t\t\tp = find_task_by_pid_ns((pid_t)val,\t&init_pid_ns);\n\t\t\tif (!p) {\n\t\t\t\tkdb_printf(\"No task with pid=%d\\n\", (pid_t)val);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tkdb_set_current_task(p);\n\t}\n\tkdb_printf(\"KDB current process is %s(pid=%d)\\n\",\n\t\t   kdb_current_task->comm,\n\t\t   kdb_current_task->pid);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2362-2391",
    "snippet": "static int kdb_ps(int argc, const char **argv)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long mask, cpu;\n\n\tif (argc == 0)\n\t\tkdb_ps_suppressed();\n\tkdb_printf(\"%-*s      Pid   Parent [*] cpu State %-*s Command\\n\",\n\t\t(int)(2*sizeof(void *))+2, \"Task Addr\",\n\t\t(int)(2*sizeof(void *))+2, \"Thread\");\n\tmask = kdb_task_state_string(argc ? argv[1] : NULL);\n\t/* Run the active tasks first */\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\tkdb_printf(\"\\n\");\n\t/* Now the real tasks */\n\tkdb_do_each_thread(g, p) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t} kdb_while_each_thread(g, p);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_while_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_ps1",
          "args": [
            "p"
          ],
          "line": 2387
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps1",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2335-2360",
          "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "mask"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "661-665",
          "snippet": "unsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nunsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_do_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2381
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 2377
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_state_string",
          "args": [
            "argc ? argv[1] : NULL"
          ],
          "line": 2372
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "561-612",
          "snippet": "unsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))",
            "#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))",
            "#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))",
            "#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))\n#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))\n#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))\n#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_ps_suppressed",
          "args": [],
          "line": 2368
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_ps_suppressed",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2301-2328",
          "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_ps(int argc, const char **argv)\n{\n\tstruct task_struct *g, *p;\n\tunsigned long mask, cpu;\n\n\tif (argc == 0)\n\t\tkdb_ps_suppressed();\n\tkdb_printf(\"%-*s      Pid   Parent [*] cpu State %-*s Command\\n\",\n\t\t(int)(2*sizeof(void *))+2, \"Task Addr\",\n\t\t(int)(2*sizeof(void *))+2, \"Thread\");\n\tmask = kdb_task_state_string(argc ? argv[1] : NULL);\n\t/* Run the active tasks first */\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t}\n\tkdb_printf(\"\\n\");\n\t/* Now the real tasks */\n\tkdb_do_each_thread(g, p) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tif (kdb_task_state(p, mask))\n\t\t\tkdb_ps1(p);\n\t} kdb_while_each_thread(g, p);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ps1",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2335-2360",
    "snippet": "void kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\"",
            "KDB_TSK(cpu)"
          ],
          "line": 2356
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2355
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 2352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 2351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "p"
          ],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "621-650",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 2343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "probe_kernel_read",
          "args": [
            "&tmp",
            "(char *)p",
            "sizeof(unsigned long)"
          ],
          "line": 2340
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps1(const struct task_struct *p)\n{\n\tint cpu;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn;\n\n\tcpu = kdb_process_cpu(p);\n\tkdb_printf(\"0x%p %8d %8d  %d %4d   %c  0x%p %c%s\\n\",\n\t\t   (void *)p, p->pid, p->parent->pid,\n\t\t   kdb_task_has_cpu(p), kdb_process_cpu(p),\n\t\t   kdb_task_state_char(p),\n\t\t   (void *)(&p->thread),\n\t\t   p == kdb_curr_task(raw_smp_processor_id()) ? '*' : ' ',\n\t\t   p->comm);\n\tif (kdb_task_has_cpu(p)) {\n\t\tif (!KDB_TSK(cpu)) {\n\t\t\tkdb_printf(\"  Error: no saved data for this cpu\\n\");\n\t\t} else {\n\t\t\tif (KDB_TSK(cpu) != p)\n\t\t\t\tkdb_printf(\"  Error: does not match running \"\n\t\t\t\t   \"process table (0x%p)\\n\", KDB_TSK(cpu));\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "kdb_ps_suppressed",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2301-2328",
    "snippet": "void kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\" suppressed,\\nuse 'ps A' to see all.\\n\""
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_while_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_state",
          "args": [
            "p",
            "mask_M"
          ],
          "line": 2314
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "661-665",
          "snippet": "unsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nunsigned long kdb_task_state(const struct task_struct *p, unsigned long mask)\n{\n\tchar state[] = { kdb_task_state_char(p), '\\0' };\n\treturn (mask & kdb_task_state_string(state)) != 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_do_each_thread",
          "args": [
            "g",
            "p"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "cpu"
          ],
          "line": 2309
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state_string",
          "args": [
            "\"M\""
          ],
          "line": 2305
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "561-612",
          "snippet": "unsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))",
            "#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))",
            "#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))",
            "#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define DAEMON\t\t(1UL << (8*sizeof(unsigned long) - 4))\n#define IDLE\t\t(1UL << (8*sizeof(unsigned long) - 3))\n#define RUNNING\t\t(1UL << (8*sizeof(unsigned long) - 2))\n#define UNRUNNABLE\t(1UL << (8*sizeof(unsigned long) - 1))\n\nunsigned long kdb_task_state_string(const char *s)\n{\n\tlong res = 0;\n\tif (!s) {\n\t\ts = kdbgetenv(\"PS\");\n\t\tif (!s)\n\t\t\ts = \"DRSTCZEU\";\t/* default value for ps */\n\t}\n\twhile (*s) {\n\t\tswitch (*s) {\n\t\tcase 'D':\n\t\t\tres |= TASK_UNINTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'R':\n\t\t\tres |= RUNNING;\n\t\t\tbreak;\n\t\tcase 'S':\n\t\t\tres |= TASK_INTERRUPTIBLE;\n\t\t\tbreak;\n\t\tcase 'T':\n\t\t\tres |= TASK_STOPPED;\n\t\t\tbreak;\n\t\tcase 'C':\n\t\t\tres |= TASK_TRACED;\n\t\t\tbreak;\n\t\tcase 'Z':\n\t\t\tres |= EXIT_ZOMBIE << 16;\n\t\t\tbreak;\n\t\tcase 'E':\n\t\t\tres |= EXIT_DEAD << 16;\n\t\t\tbreak;\n\t\tcase 'U':\n\t\t\tres |= UNRUNNABLE;\n\t\t\tbreak;\n\t\tcase 'I':\n\t\t\tres |= IDLE;\n\t\t\tbreak;\n\t\tcase 'M':\n\t\t\tres |= DAEMON;\n\t\t\tbreak;\n\t\tcase 'A':\n\t\t\tres = ~0UL;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t  kdb_printf(\"%s: unknown flag '%c' ignored\\n\",\n\t\t\t\t     __func__, *s);\n\t\t\t  break;\n\t\t}\n\t\t++s;\n\t}\n\treturn res;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nvoid kdb_ps_suppressed(void)\n{\n\tint idle = 0, daemon = 0;\n\tunsigned long mask_I = kdb_task_state_string(\"I\"),\n\t\t      mask_M = kdb_task_state_string(\"M\");\n\tunsigned long cpu;\n\tconst struct task_struct *p, *g;\n\tfor_each_online_cpu(cpu) {\n\t\tp = kdb_curr_task(cpu);\n\t\tif (kdb_task_state(p, mask_I))\n\t\t\t++idle;\n\t}\n\tkdb_do_each_thread(g, p) {\n\t\tif (kdb_task_state(p, mask_M))\n\t\t\t++daemon;\n\t} kdb_while_each_thread(g, p);\n\tif (idle || daemon) {\n\t\tif (idle)\n\t\t\tkdb_printf(\"%d idle process%s (state I)%s\\n\",\n\t\t\t\t   idle, idle == 1 ? \"\" : \"es\",\n\t\t\t\t   daemon ? \" and \" : \"\");\n\t\tif (daemon)\n\t\t\tkdb_printf(\"%d sleeping system daemon (state M) \"\n\t\t\t\t   \"process%s\", daemon,\n\t\t\t\t   daemon == 1 ? \"\" : \"es\");\n\t\tkdb_printf(\" suppressed,\\nuse 'ps A' to see all.\\n\");\n\t}\n}"
  },
  {
    "function_name": "kdb_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2267-2296",
    "snippet": "static int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t/*\n\t * Validate cpunum\n\t */\n\tif ((cpunum >= CONFIG_NR_CPUS) || !kgdb_info[cpunum].enter_kgdb)\n\t\treturn KDB_BADCPUNUM;\n\n\tdbg_switch_cpu = cpunum;\n\n\t/*\n\t * Switch to other cpu\n\t */\n\treturn KDB_CMD_CPU;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[1]",
            "&cpunum"
          ],
          "line": 2280
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_cpu_status",
          "args": [],
          "line": 2273
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cpu_status",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2222-2265",
          "snippet": "static void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == 'I')\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == 'I')\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cpu(int argc, const char **argv)\n{\n\tunsigned long cpunum;\n\tint diag;\n\n\tif (argc == 0) {\n\t\tkdb_cpu_status();\n\t\treturn 0;\n\t}\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetularg(argv[1], &cpunum);\n\tif (diag)\n\t\treturn diag;\n\n\t/*\n\t * Validate cpunum\n\t */\n\tif ((cpunum >= CONFIG_NR_CPUS) || !kgdb_info[cpunum].enter_kgdb)\n\t\treturn KDB_BADCPUNUM;\n\n\tdbg_switch_cpu = cpunum;\n\n\t/*\n\t * Switch to other cpu\n\t */\n\treturn KDB_CMD_CPU;\n}"
  },
  {
    "function_name": "kdb_cpu_status",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2222-2265",
    "snippet": "static void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == 'I')\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 2264
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_task_state_char",
          "args": [
            "KDB_TSK(i)"
          ],
          "line": 2236
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_task_state_char",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "621-650",
          "snippet": "char kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar kdb_task_state_char (const struct task_struct *p)\n{\n\tint cpu;\n\tchar state;\n\tunsigned long tmp;\n\n\tif (!p || probe_kernel_read(&tmp, (char *)p, sizeof(unsigned long)))\n\t\treturn 'E';\n\n\tcpu = kdb_process_cpu(p);\n\tstate = (p->state == 0) ? 'R' :\n\t\t(p->state < 0) ? 'U' :\n\t\t(p->state & TASK_UNINTERRUPTIBLE) ? 'D' :\n\t\t(p->state & TASK_STOPPED) ? 'T' :\n\t\t(p->state & TASK_TRACED) ? 'C' :\n\t\t(p->exit_state & EXIT_ZOMBIE) ? 'Z' :\n\t\t(p->exit_state & EXIT_DEAD) ? 'E' :\n\t\t(p->state & TASK_INTERRUPTIBLE) ? 'S' : '?';\n\tif (is_idle_task(p)) {\n\t\t/* Idle task.  Is it really idle, apart from the kdb\n\t\t * interrupt? */\n\t\tif (!kdb_task_has_cpu(p) || kgdb_info[cpu].irq_depth == 1) {\n\t\t\tif (cpu != kdb_initial_cpu)\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t} else if (!p->mm && state == 'S') {\n\t\tstate = 'M';\t/* sleeping system daemon */\n\t}\n\treturn state;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "i"
          ],
          "line": 2236
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_online",
          "args": [
            "i"
          ],
          "line": 2230
        },
        "resolved": true,
        "details": {
          "function_name": "init_cpu_online",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cpu.c",
          "lines": "2274-2277",
          "snippet": "void init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}",
          "includes": [
            "#include \"smpboot.h\"",
            "#include <trace/events/cpuhp.h>",
            "#include <trace/events/power.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/slab.h>",
            "#include <linux/relay.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/nmi.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/suspend.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/kthread.h>",
            "#include <linux/bug.h>",
            "#include <linux/export.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/oom.h>",
            "#include <linux/cpu.h>",
            "#include <linux/unistd.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/hotplug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/notifier.h>",
            "#include <linux/init.h>",
            "#include <linux/smp.h>",
            "#include <linux/proc_fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct cpumask __cpu_online_mask"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"smpboot.h\"\n#include <trace/events/cpuhp.h>\n#include <trace/events/power.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/slab.h>\n#include <linux/relay.h>\n#include <linux/smpboot.h>\n#include <linux/nmi.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/lockdep.h>\n#include <linux/suspend.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/stop_machine.h>\n#include <linux/kthread.h>\n#include <linux/bug.h>\n#include <linux/export.h>\n#include <linux/rcupdate.h>\n#include <linux/oom.h>\n#include <linux/cpu.h>\n#include <linux/unistd.h>\n#include <linux/sched/task.h>\n#include <linux/sched/hotplug.h>\n#include <linux/sched/signal.h>\n#include <linux/notifier.h>\n#include <linux/init.h>\n#include <linux/smp.h>\n#include <linux/proc_fs.h>\n\nstruct cpumask __cpu_online_mask;\n\nvoid init_cpu_online(const struct cpumask *src)\n{\n\tcpumask_copy(&__cpu_online_mask, src);\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_cpu_status(void)\n{\n\tint i, start_cpu, first_print = 1;\n\tchar state, prev_state = '?';\n\n\tkdb_printf(\"Currently on cpu %d\\n\", raw_smp_processor_id());\n\tkdb_printf(\"Available cpus: \");\n\tfor (start_cpu = -1, i = 0; i < NR_CPUS; i++) {\n\t\tif (!cpu_online(i)) {\n\t\t\tstate = 'F';\t/* cpu is offline */\n\t\t} else if (!kgdb_info[i].enter_kgdb) {\n\t\t\tstate = 'D';\t/* cpu is online but unresponsive */\n\t\t} else {\n\t\t\tstate = ' ';\t/* cpu is responding to kdb */\n\t\t\tif (kdb_task_state_char(KDB_TSK(i)) == 'I')\n\t\t\t\tstate = 'I';\t/* idle task */\n\t\t}\n\t\tif (state != prev_state) {\n\t\t\tif (prev_state != '?') {\n\t\t\t\tif (!first_print)\n\t\t\t\t\tkdb_printf(\", \");\n\t\t\t\tfirst_print = 0;\n\t\t\t\tkdb_printf(\"%d\", start_cpu);\n\t\t\t\tif (start_cpu < i-1)\n\t\t\t\t\tkdb_printf(\"-%d\", i-1);\n\t\t\t\tif (prev_state != ' ')\n\t\t\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t\t\t}\n\t\t\tprev_state = state;\n\t\t\tstart_cpu = i;\n\t\t}\n\t}\n\t/* print the trailing cpus, ignoring them if they are all offline */\n\tif (prev_state != 'F') {\n\t\tif (!first_print)\n\t\t\tkdb_printf(\", \");\n\t\tkdb_printf(\"%d\", start_cpu);\n\t\tif (start_cpu < i-1)\n\t\t\tkdb_printf(\"-%d\", i-1);\n\t\tif (prev_state != ' ')\n\t\t\tkdb_printf(\"(%c)\", prev_state);\n\t}\n\tkdb_printf(\"\\n\");\n}"
  },
  {
    "function_name": "kdb_param_enable_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2203-2209",
    "snippet": "static int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -EINVAL;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "1"
          ],
          "line": 2207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_add_unless",
          "args": [
            "&kdb_nmi_disabled",
            "-1",
            "0"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_param_enable_nmi(const char *val, const struct kernel_param *kp)\n{\n\tif (!atomic_add_unless(&kdb_nmi_disabled, -1, 0))\n\t\treturn -EINVAL;\n\tarch_kgdb_ops.enable_nmi(1);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_disable_nmi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2194-2201",
    "snippet": "static int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "arch_kgdb_ops.enable_nmi",
          "args": [
            "0"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_set",
          "args": [
            "&kdb_nmi_disabled",
            "1"
          ],
          "line": 2198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kdb_nmi_disabled"
          ],
          "line": 2196
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_disable_nmi(int argc, const char *argv[])\n{\n\tif (atomic_read(&kdb_nmi_disabled))\n\t\treturn 0;\n\tatomic_set(&kdb_nmi_disabled, 1);\n\tarch_kgdb_ops.enable_nmi(0);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_dmesg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2107-2188",
    "snippet": "static int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dumper dumper = { .active = 1 };\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\tif (argc) {\n\t\tchar *cp;\n\t\tlines = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tlines = 0;\n\t\tif (argc > 1) {\n\t\t\tadjust = simple_strtoul(argv[2], &cp, 0);\n\t\t\tif (*cp || adjust < 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t/* disable LOGGING if set */\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"LOGGING\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, NULL, 0, NULL))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, nothing \"\n\t\t\t\t   \"printed\\n\", n);\n\t\telse if (adjust - lines >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, last %d \"\n\t\t\t\t   \"lines printed\\n\", n, n - adjust);\n\t\tskip = adjust;\n\t\tlines = abs(lines);\n\t} else if (lines > 0) {\n\t\tskip = n - lines - adjust;\n\t\tlines = abs(lines);\n\t\tif (adjust >= n) {\n\t\t\tkdb_printf(\"buffer only contains %d lines, \"\n\t\t\t\t   \"nothing printed\\n\", n);\n\t\t\tskip = n;\n\t\t} else if (skip < 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >= n || skip < 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%.*s\\n\"",
            "(int)len - 1",
            "buf"
          ],
          "line": 2184
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 2181
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmsg_dump_get_line_nolock",
          "args": [
            "&dumper",
            "1",
            "buf",
            "sizeof(buf)",
            "&len"
          ],
          "line": 2174
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_get_line_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "3094-3124",
          "snippet": "bool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nbool kmsg_dump_get_line_nolock(struct kmsg_dumper *dumper, bool syslog,\n\t\t\t       char *line, size_t size, size_t *len)\n{\n\tstruct printk_log *msg;\n\tsize_t l = 0;\n\tbool ret = false;\n\n\tif (!dumper->active)\n\t\tgoto out;\n\n\tif (dumper->cur_seq < log_first_seq) {\n\t\t/* messages are gone, move to first available one */\n\t\tdumper->cur_seq = log_first_seq;\n\t\tdumper->cur_idx = log_first_idx;\n\t}\n\n\t/* last entry */\n\tif (dumper->cur_seq >= log_next_seq)\n\t\tgoto out;\n\n\tmsg = log_from_idx(dumper->cur_idx);\n\tl = msg_print_text(msg, syslog, line, size);\n\n\tdumper->cur_idx = log_next(dumper->cur_idx);\n\tdumper->cur_seq++;\n\tret = true;\nout:\n\tif (len)\n\t\t*len = l;\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmsg_dump_rewind_nolock",
          "args": [
            "&dumper"
          ],
          "line": 2173
        },
        "resolved": true,
        "details": {
          "function_name": "kmsg_dump_rewind_nolock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/printk/printk.c",
          "lines": "3259-3265",
          "snippet": "void kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}",
          "includes": [
            "#include \"internal.h\"",
            "#include \"braille.h\"",
            "#include \"console_cmdline.h\"",
            "#include <trace/events/printk.h>",
            "#include <trace/events/initcall.h>",
            "#include <asm/sections.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/uio.h>",
            "#include <linux/ctype.h>",
            "#include <linux/irq_work.h>",
            "#include <linux/poll.h>",
            "#include <linux/rculist.h>",
            "#include <linux/cpu.h>",
            "#include <linux/syslog.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/kdb.h>",
            "#include <linux/crash_core.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/memblock.h>",
            "#include <linux/security.h>",
            "#include <linux/smp.h>",
            "#include <linux/delay.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/console.h>",
            "#include <linux/tty_driver.h>",
            "#include <linux/tty.h>",
            "#include <linux/mm.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internal.h\"\n#include \"braille.h\"\n#include \"console_cmdline.h\"\n#include <trace/events/printk.h>\n#include <trace/events/initcall.h>\n#include <asm/sections.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/clock.h>\n#include <linux/uio.h>\n#include <linux/ctype.h>\n#include <linux/irq_work.h>\n#include <linux/poll.h>\n#include <linux/rculist.h>\n#include <linux/cpu.h>\n#include <linux/syslog.h>\n#include <linux/kmsg_dump.h>\n#include <linux/ratelimit.h>\n#include <linux/kdb.h>\n#include <linux/crash_core.h>\n#include <linux/syscalls.h>\n#include <linux/memblock.h>\n#include <linux/security.h>\n#include <linux/smp.h>\n#include <linux/delay.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/nmi.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/console.h>\n#include <linux/tty_driver.h>\n#include <linux/tty.h>\n#include <linux/mm.h>\n#include <linux/kernel.h>\n\nvoid kmsg_dump_rewind_nolock(struct kmsg_dumper *dumper)\n{\n\tdumper->cur_seq = clear_seq;\n\tdumper->cur_idx = clear_idx;\n\tdumper->next_seq = log_next_seq;\n\tdumper->next_idx = log_next_idx;\n}"
        }
      },
      {
        "call_info": {
          "callee": "abs",
          "args": [
            "lines"
          ],
          "line": 2155
        },
        "resolved": true,
        "details": {
          "function_name": "torture_shutdown_absorb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/torture.c",
          "lines": "462-469",
          "snippet": "void torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}",
          "includes": [
            "#include \"rcu/rcu.h\"",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/ktime.h>",
            "#include <linux/trace_clock.h>",
            "#include <linux/slab.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [
            "#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */"
          ],
          "globals_used": [
            "static int fullstop = FULLSTOP_RMMOD;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu/rcu.h\"\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/ktime.h>\n#include <linux/trace_clock.h>\n#include <linux/slab.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\n#define FULLSTOP_SHUTDOWN 1\t/* System shutdown with torture running. */\n\nstatic int fullstop = FULLSTOP_RMMOD;\n\nvoid torture_shutdown_absorb(const char *title)\n{\n\twhile (READ_ONCE(fullstop) == FULLSTOP_SHUTDOWN) {\n\t\tpr_notice(\"torture thread %s parking due to system shutdown\\n\",\n\t\t\t  title);\n\t\tschedule_timeout_uninterruptible(MAX_SCHEDULE_TIMEOUT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_set",
          "args": [
            "2",
            "setargs"
          ],
          "line": 2137
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "382-457",
          "snippet": "int kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(KDB_DEBUG_FLAG_MASK << KDB_DEBUG_FLAG_SHIFT))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int kdb_flags;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_flags;\n\nint kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(KDB_DEBUG_FLAG_MASK << KDB_DEBUG_FLAG_SHIFT))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"LOGGING\"",
            "&logging"
          ],
          "line": 2134
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "316-325",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[2]",
            "&cp",
            "0"
          ],
          "line": 2127
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtol",
          "args": [
            "argv[1]",
            "&cp",
            "0"
          ],
          "line": 2123
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_dmesg(int argc, const char **argv)\n{\n\tint diag;\n\tint logging;\n\tint lines = 0;\n\tint adjust = 0;\n\tint n = 0;\n\tint skip = 0;\n\tstruct kmsg_dumper dumper = { .active = 1 };\n\tsize_t len;\n\tchar buf[201];\n\n\tif (argc > 2)\n\t\treturn KDB_ARGCOUNT;\n\tif (argc) {\n\t\tchar *cp;\n\t\tlines = simple_strtol(argv[1], &cp, 0);\n\t\tif (*cp)\n\t\t\tlines = 0;\n\t\tif (argc > 1) {\n\t\t\tadjust = simple_strtoul(argv[2], &cp, 0);\n\t\t\tif (*cp || adjust < 0)\n\t\t\t\tadjust = 0;\n\t\t}\n\t}\n\n\t/* disable LOGGING if set */\n\tdiag = kdbgetintenv(\"LOGGING\", &logging);\n\tif (!diag && logging) {\n\t\tconst char *setargs[] = { \"set\", \"LOGGING\", \"0\" };\n\t\tkdb_set(2, setargs);\n\t}\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, NULL, 0, NULL))\n\t\tn++;\n\n\tif (lines < 0) {\n\t\tif (adjust >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, nothing \"\n\t\t\t\t   \"printed\\n\", n);\n\t\telse if (adjust - lines >= n)\n\t\t\tkdb_printf(\"buffer only contains %d lines, last %d \"\n\t\t\t\t   \"lines printed\\n\", n, n - adjust);\n\t\tskip = adjust;\n\t\tlines = abs(lines);\n\t} else if (lines > 0) {\n\t\tskip = n - lines - adjust;\n\t\tlines = abs(lines);\n\t\tif (adjust >= n) {\n\t\t\tkdb_printf(\"buffer only contains %d lines, \"\n\t\t\t\t   \"nothing printed\\n\", n);\n\t\t\tskip = n;\n\t\t} else if (skip < 0) {\n\t\t\tlines += skip;\n\t\t\tskip = 0;\n\t\t\tkdb_printf(\"buffer only contains %d lines, first \"\n\t\t\t\t   \"%d lines printed\\n\", n, lines);\n\t\t}\n\t} else {\n\t\tlines = n;\n\t}\n\n\tif (skip >= n || skip < 0)\n\t\treturn 0;\n\n\tkmsg_dump_rewind_nolock(&dumper);\n\twhile (kmsg_dump_get_line_nolock(&dumper, 1, buf, sizeof(buf), &len)) {\n\t\tif (skip) {\n\t\t\tskip--;\n\t\t\tcontinue;\n\t\t}\n\t\tif (!lines--)\n\t\t\tbreak;\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tkdb_printf(\"%.*s\\n\", (int)len - 1, buf);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_env",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2086-2099",
    "snippet": "static int kdb_env(int argc, const char **argv)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n\n\tif (KDB_DEBUG(MASK))\n\t\tkdb_printf(\"KDBFLAGS=0x%x\\n\", kdb_flags);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"KDBFLAGS=0x%x\\n\"",
            "kdb_flags"
          ],
          "line": 2096
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG",
          "args": [
            "MASK"
          ],
          "line": 2095
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_flags;\n\nstatic int kdb_env(int argc, const char **argv)\n{\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i])\n\t\t\tkdb_printf(\"%s\\n\", __env[i]);\n\t}\n\n\tif (KDB_DEBUG(MASK))\n\t\tkdb_printf(\"KDBFLAGS=0x%x\\n\", kdb_flags);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_lsmod",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2039-2077",
    "snippet": "static int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"Module                  Size  modstruct     Used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tkdb_printf(\"%-20s%8u  0x%p \", mod->name,\n\t\t\t   mod->core_layout.size, (void *)mod);\n#ifdef CONFIG_MODULE_UNLOAD\n\t\tkdb_printf(\"%4d \", module_refcount(mod));\n#endif\n\t\tif (mod->state == MODULE_STATE_GOING)\n\t\t\tkdb_printf(\" (Unloading)\");\n\t\telse if (mod->state == MODULE_STATE_COMING)\n\t\t\tkdb_printf(\" (Loading)\");\n\t\telse\n\t\t\tkdb_printf(\" (Live)\");\n\t\tkdb_printf(\" 0x%p\", mod->core_layout.base);\n\n#ifdef CONFIG_MODULE_UNLOAD\n\t\t{\n\t\t\tstruct module_use *use;\n\t\t\tkdb_printf(\" [ \");\n\t\t\tlist_for_each_entry(use, &mod->source_list,\n\t\t\t\t\t    source_list)\n\t\t\t\tkdb_printf(\"%s \", use->target->name);\n\t\t\tkdb_printf(\"]\\n\");\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"]\\n\""
          ],
          "line": 2071
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "use",
            "&mod->source_list",
            "source_list"
          ],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_refcount",
          "args": [
            "mod"
          ],
          "line": 2054
        },
        "resolved": true,
        "details": {
          "function_name": "module_refcount",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "951-954",
          "snippet": "int module_refcount(struct module *mod)\n{\n\treturn atomic_read(&mod->refcnt) - MODULE_REF_BASE;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [
            "#define MODULE_REF_BASE\t1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\n#define MODULE_REF_BASE\t1\n\nint module_refcount(struct module *mod)\n{\n\treturn atomic_read(&mod->refcnt) - MODULE_REF_BASE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "mod",
            "kdb_modules",
            "list"
          ],
          "line": 2047
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_lsmod(int argc, const char **argv)\n{\n\tstruct module *mod;\n\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_printf(\"Module                  Size  modstruct     Used by\\n\");\n\tlist_for_each_entry(mod, kdb_modules, list) {\n\t\tif (mod->state == MODULE_STATE_UNFORMED)\n\t\t\tcontinue;\n\n\t\tkdb_printf(\"%-20s%8u  0x%p \", mod->name,\n\t\t\t   mod->core_layout.size, (void *)mod);\n#ifdef CONFIG_MODULE_UNLOAD\n\t\tkdb_printf(\"%4d \", module_refcount(mod));\n#endif\n\t\tif (mod->state == MODULE_STATE_GOING)\n\t\t\tkdb_printf(\" (Unloading)\");\n\t\telse if (mod->state == MODULE_STATE_COMING)\n\t\t\tkdb_printf(\" (Loading)\");\n\t\telse\n\t\t\tkdb_printf(\" (Live)\");\n\t\tkdb_printf(\" 0x%p\", mod->core_layout.base);\n\n#ifdef CONFIG_MODULE_UNLOAD\n\t\t{\n\t\t\tstruct module_use *use;\n\t\t\tkdb_printf(\" [ \");\n\t\t\tlist_for_each_entry(use, &mod->source_list,\n\t\t\t\t\t    source_list)\n\t\t\t\tkdb_printf(\"%s \", use->target->name);\n\t\t\tkdb_printf(\"]\\n\");\n\t\t}\n#endif\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_ef",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "2015-2031",
    "snippet": "static int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "(struct pt_regs *)addr"
          ],
          "line": 2029
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 2026
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_ef(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset;\n\tint nextarg;\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\tshow_regs((struct pt_regs *)addr);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_sr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1990-2003",
    "snippet": "static int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(KDB_ENABLE_ALL, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__handle_sysrq",
          "args": [
            "*argv[1]",
            "check_mask"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "KDB_ENABLE_ALL",
            "kdb_cmd_enabled",
            "false"
          ],
          "line": 1993
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "204-218",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nstatic int kdb_sr(int argc, const char **argv)\n{\n\tbool check_mask =\n\t    !kdb_check_flags(KDB_ENABLE_ALL, kdb_cmd_enabled, false);\n\n\tif (argc != 1)\n\t\treturn KDB_ARGCOUNT;\n\n\tkdb_trap_printk++;\n\t__handle_sysrq(*argv[1], check_mask);\n\tkdb_trap_printk--;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_rm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1923-1982",
    "snippet": "static int kdb_rm(int argc, const char **argv)\n{\n#if DBG_MAX_REG_NUM > 0\n\tint diag;\n\tconst char *rname;\n\tint i;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Allow presence or absence of leading '%' symbol.\n\t */\n\trname = argv[1];\n\tif (*rname == '%')\n\t\trname++;\n\n\tdiag = kdbgetu64arg(argv[2], &reg64);\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = kdb_check_regs();\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = KDB_BADREG;\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"ERROR: Register set currently not implemented\\n\");\n    return 0;\n#endif\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"ERROR: Register set currently not implemented\\n\""
          ],
          "line": 1979
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg64",
            "kdb_current_regs"
          ],
          "line": 1973
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg32",
            "kdb_current_regs"
          ],
          "line": 1970
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg16",
            "kdb_current_regs"
          ],
          "line": 1966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_set_reg",
          "args": [
            "i",
            "&reg8",
            "kdb_current_regs"
          ],
          "line": 1962
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "rname",
            "dbg_reg_def[i].name"
          ],
          "line": 1953
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 1947
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "459-467",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetu64arg",
          "args": [
            "argv[2]",
            "&reg64"
          ],
          "line": 1943
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetu64arg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "359-376",
          "snippet": "int kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_rm(int argc, const char **argv)\n{\n#if DBG_MAX_REG_NUM > 0\n\tint diag;\n\tconst char *rname;\n\tint i;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\t/*\n\t * Allow presence or absence of leading '%' symbol.\n\t */\n\trname = argv[1];\n\tif (*rname == '%')\n\t\trname++;\n\n\tdiag = kdbgetu64arg(argv[2], &reg64);\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = kdb_check_regs();\n\tif (diag)\n\t\treturn diag;\n\n\tdiag = KDB_BADREG;\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\tif (strcmp(rname, dbg_reg_def[i].name) == 0) {\n\t\t\tdiag = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!diag) {\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\treg8 = reg64;\n\t\t\tdbg_set_reg(i, &reg8, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\treg16 = reg64;\n\t\t\tdbg_set_reg(i, &reg16, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\treg32 = reg64;\n\t\t\tdbg_set_reg(i, &reg32, kdb_current_regs);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\tdbg_set_reg(i, &reg64, kdb_current_regs);\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn diag;\n#else\n\tkdb_printf(\"ERROR: Register set currently not implemented\\n\");\n    return 0;\n#endif\n}"
  },
  {
    "function_name": "kdb_rd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1853-1915",
    "snippet": "static int kdb_rd(int argc, const char **argv)\n{\n\tint len = kdb_check_regs();\n#if DBG_MAX_REG_NUM > 0\n\tint i;\n\tchar *rname;\n\tint rsize;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (len)\n\t\treturn len;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize > 16)\n\t\t\trsize = 2;\n\t\tif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\n\t\t\tlen = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tif (len)\n\t\t\tlen += kdb_printf(\"  \");\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\trname = dbg_get_reg(i, &reg8, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %02x\", rname, reg8);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\trname = dbg_get_reg(i, &reg16, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %04x\", rname, reg16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\trname = dbg_get_reg(i, &reg32, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %08x\", rname, reg32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\trname = dbg_get_reg(i, &reg64, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %016llx\", rname, reg64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += kdb_printf(\"%s: ??\", dbg_reg_def[i].name);\n\t\t}\n\t}\n\tkdb_printf(\"\\n\");\n#else\n\tif (len)\n\t\treturn len;\n\n\tkdb_dumpregs(kdb_current_regs);\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_dumpregs",
          "args": [
            "kdb_current_regs"
          ],
          "line": 1912
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1131-1140",
          "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg64",
            "kdb_current_regs"
          ],
          "line": 1898
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg32",
            "kdb_current_regs"
          ],
          "line": 1892
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg16",
            "kdb_current_regs"
          ],
          "line": 1886
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dbg_get_reg",
          "args": [
            "i",
            "&reg8",
            "kdb_current_regs"
          ],
          "line": 1880
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "dbg_reg_def[i].name"
          ],
          "line": 1872
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 1855
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "459-467",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_rd(int argc, const char **argv)\n{\n\tint len = kdb_check_regs();\n#if DBG_MAX_REG_NUM > 0\n\tint i;\n\tchar *rname;\n\tint rsize;\n\tu64 reg64;\n\tu32 reg32;\n\tu16 reg16;\n\tu8 reg8;\n\n\tif (len)\n\t\treturn len;\n\n\tfor (i = 0; i < DBG_MAX_REG_NUM; i++) {\n\t\trsize = dbg_reg_def[i].size * 2;\n\t\tif (rsize > 16)\n\t\t\trsize = 2;\n\t\tif (len + strlen(dbg_reg_def[i].name) + 4 + rsize > 80) {\n\t\t\tlen = 0;\n\t\t\tkdb_printf(\"\\n\");\n\t\t}\n\t\tif (len)\n\t\t\tlen += kdb_printf(\"  \");\n\t\tswitch(dbg_reg_def[i].size * 8) {\n\t\tcase 8:\n\t\t\trname = dbg_get_reg(i, &reg8, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %02x\", rname, reg8);\n\t\t\tbreak;\n\t\tcase 16:\n\t\t\trname = dbg_get_reg(i, &reg16, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %04x\", rname, reg16);\n\t\t\tbreak;\n\t\tcase 32:\n\t\t\trname = dbg_get_reg(i, &reg32, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %08x\", rname, reg32);\n\t\t\tbreak;\n\t\tcase 64:\n\t\t\trname = dbg_get_reg(i, &reg64, kdb_current_regs);\n\t\t\tif (!rname)\n\t\t\t\tbreak;\n\t\t\tlen += kdb_printf(\"%s: %016llx\", rname, reg64);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tlen += kdb_printf(\"%s: ??\", dbg_reg_def[i].name);\n\t\t}\n\t}\n\tkdb_printf(\"\\n\");\n#else\n\tif (len)\n\t\treturn len;\n\n\tkdb_dumpregs(kdb_current_regs);\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_go",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1808-1848",
    "snippet": "static int kdb_go(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tint diag;\n\tint nextarg;\n\tlong offset;\n\n\tif (raw_smp_processor_id() != kdb_initial_cpu) {\n\t\tkdb_printf(\"go must execute on the entry cpu, \"\n\t\t\t   \"please use \\\"cpu %d\\\" and then execute go\\n\",\n\t\t\t   kdb_initial_cpu);\n\t\treturn KDB_BADCPUNUM;\n\t}\n\tif (argc == 1) {\n\t\tnextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg,\n\t\t\t\t     &addr, &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (argc) {\n\t\treturn KDB_ARGCOUNT;\n\t}\n\n\tdiag = KDB_CMD_GO;\n\tif (KDB_FLAG(CATASTROPHIC)) {\n\t\tkdb_printf(\"Catastrophic error detected\\n\");\n\t\tkdb_printf(\"kdb_continue_catastrophic=%d, \",\n\t\t\tkdb_continue_catastrophic);\n\t\tif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\n\t\t\tkdb_printf(\"type go a second time if you really want \"\n\t\t\t\t   \"to continue\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (kdb_continue_catastrophic == 2) {\n\t\t\tkdb_printf(\"forcing reboot\\n\");\n\t\t\tkdb_reboot(0, NULL);\n\t\t}\n\t\tkdb_printf(\"attempting to continue\\n\");\n\t}\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "static int kdb_go_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"attempting to continue\\n\""
          ],
          "line": 1845
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_reboot",
          "args": [
            "0",
            "NULL"
          ],
          "line": 1843
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_reboot",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1121-1129",
          "snippet": "static int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CATASTROPHIC"
          ],
          "line": 1832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 1823
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1815
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nstatic int kdb_go_count;\n\nstatic int kdb_go(int argc, const char **argv)\n{\n\tunsigned long addr;\n\tint diag;\n\tint nextarg;\n\tlong offset;\n\n\tif (raw_smp_processor_id() != kdb_initial_cpu) {\n\t\tkdb_printf(\"go must execute on the entry cpu, \"\n\t\t\t   \"please use \\\"cpu %d\\\" and then execute go\\n\",\n\t\t\t   kdb_initial_cpu);\n\t\treturn KDB_BADCPUNUM;\n\t}\n\tif (argc == 1) {\n\t\tnextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg,\n\t\t\t\t     &addr, &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (argc) {\n\t\treturn KDB_ARGCOUNT;\n\t}\n\n\tdiag = KDB_CMD_GO;\n\tif (KDB_FLAG(CATASTROPHIC)) {\n\t\tkdb_printf(\"Catastrophic error detected\\n\");\n\t\tkdb_printf(\"kdb_continue_catastrophic=%d, \",\n\t\t\tkdb_continue_catastrophic);\n\t\tif (kdb_continue_catastrophic == 0 && kdb_go_count++ == 0) {\n\t\t\tkdb_printf(\"type go a second time if you really want \"\n\t\t\t\t   \"to continue\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (kdb_continue_catastrophic == 2) {\n\t\t\tkdb_printf(\"forcing reboot\\n\");\n\t\t\tkdb_reboot(0, NULL);\n\t\t}\n\t\tkdb_printf(\"attempting to continue\\n\");\n\t}\n\treturn diag;\n}"
  },
  {
    "function_name": "kdb_mm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1765-1802",
    "snippet": "static int kdb_mm(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset = 0;\n\tunsigned long contents;\n\tint nextarg;\n\tint width;\n\n\tif (argv[0][2] && !isdigit(argv[0][2]))\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc < 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg != argc + 1)\n\t\treturn KDB_ARGCOUNT;\n\n\twidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\n\tdiag = kdb_putword(addr, contents, width);\n\tif (diag)\n\t\treturn diag;\n\n\tkdb_printf(kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\", addr, contents);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\"",
            "addr",
            "contents"
          ],
          "line": 1799
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_putword",
          "args": [
            "addr",
            "contents",
            "width"
          ],
          "line": 1795
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_putword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "502-534",
          "snippet": "int kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_putword(unsigned long addr, unsigned long word, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\tswitch (size) {\n\tcase 1:\n\t\tw1 = word;\n\t\tdiag = kdb_putarea(addr, w1);\n\t\tbreak;\n\tcase 2:\n\t\tw2 = word;\n\t\tdiag = kdb_putarea(addr, w2);\n\t\tbreak;\n\tcase 4:\n\t\tw4 = word;\n\t\tdiag = kdb_putarea(addr, w4);\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(word)) {\n\t\t\tw8 = word;\n\t\t\tdiag = kdb_putarea(addr, w8);\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_putword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&contents",
            "NULL",
            "NULL"
          ],
          "line": 1787
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][2]"
          ],
          "line": 1774
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mm(int argc, const char **argv)\n{\n\tint diag;\n\tunsigned long addr;\n\tlong offset = 0;\n\tunsigned long contents;\n\tint nextarg;\n\tint width;\n\n\tif (argv[0][2] && !isdigit(argv[0][2]))\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc < 2)\n\t\treturn KDB_ARGCOUNT;\n\n\tnextarg = 1;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr, &offset, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &contents, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (nextarg != argc + 1)\n\t\treturn KDB_ARGCOUNT;\n\n\twidth = argv[0][2] ? (argv[0][2] - '0') : (KDB_WORD_SIZE);\n\tdiag = kdb_putword(addr, contents, width);\n\tif (diag)\n\t\treturn diag;\n\n\tkdb_printf(kdb_machreg_fmt \" = \" kdb_machreg_fmt \"\\n\", addr, contents);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_md",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1567-1757",
    "snippet": "static int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\tint raw = 0;\n\n\tkdbgetintenv(\"MDCOUNT\", &mdcount);\n\tkdbgetintenv(\"RADIX\", &radix);\n\tkdbgetintenv(\"BYTESPERWORD\", &bytesperword);\n\n\t/* Assume 'md <addr>' and start with environment values */\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc == 2 || (argc == 0 && last_addr != 0))\n\t\t\tvalid = raw = 1;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn KDB_ARGCOUNT;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tif (raw)\n\t\t\tmdcount = repeat;\n\t\telse\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc > nextarg+2)\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tif (argc >= nextarg) {\n\t\t\tdiag = kdbgetularg(argv[nextarg], &val);\n\t\t\tif (!diag) {\n\t\t\t\tmdcount = (int) val;\n\t\t\t\tif (raw)\n\t\t\t\t\trepeat = mdcount;\n\t\t\t\telse\n\t\t\t\t\trepeat = mdcount * 16 / bytesperword;\n\t\t\t}\n\t\t}\n\t\tif (argc >= nextarg+1) {\n\t\t\tdiag = kdbgetularg(argv[nextarg+1], &val);\n\t\t\tif (!diag)\n\t\t\t\tradix = (int) val;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tint ret;\n\t\tlast_addr = addr;\n\t\tret = kdb_mdr(addr, mdcount);\n\t\tlast_addr += mdcount;\n\t\tlast_repeat = mdcount;\n\t\tlast_bytesperword = bytesperword; // to make REPEAT happy\n\t\treturn ret;\n\t}\n\n\tswitch (radix) {\n\tcase 10:\n\t\tfmtchar = 'd';\n\t\tbreak;\n\tcase 16:\n\t\tfmtchar = 'x';\n\t\tbreak;\n\tcase 8:\n\t\tfmtchar = 'o';\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADRADIX;\n\t}\n\n\tlast_radix = radix;\n\n\tif (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\n\tswitch (bytesperword) {\n\tcase 8:\n\t\tsprintf(fmtstr, \"%%16.16l%c \", fmtchar);\n\t\tbreak;\n\tcase 4:\n\t\tsprintf(fmtstr, \"%%8.8l%c \", fmtchar);\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(fmtstr, \"%%4.4l%c \", fmtchar);\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(fmtstr, \"%%2.2l%c \", fmtchar);\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADWIDTH;\n\t}\n\n\tlast_repeat = repeat;\n\tlast_bytesperword = bytesperword;\n\n\tif (strcmp(argv[0], \"mds\") == 0) {\n\t\tsymbolic = 1;\n\t\t/* Do not save these changes as last_*, they are temporary mds\n\t\t * overrides.\n\t\t */\n\t\tbytesperword = KDB_WORD_SIZE;\n\t\trepeat = mdcount;\n\t\tkdbgetintenv(\"NOSECT\", &nosect);\n\t}\n\n\t/* Round address down modulo BYTESPERWORD */\n\n\taddr &= ~(bytesperword-1);\n\n\twhile (repeat > 0) {\n\t\tunsigned long a;\n\t\tint n, z, num = (symbolic ? 1 : (16 / bytesperword));\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z > 2) {\n\t\t\tint s = num * (z-2);\n\t\t\tkdb_printf(kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\",\n\t\t\t\taddr, addr + bytesperword * s - 1);\n\t\t\taddr += bytesperword * s;\n\t\t\trepeat -= s;\n\t\t}\n\t}\n\tlast_addr = addr;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\"",
            "addr",
            "addr + bytesperword * s - 1"
          ],
          "line": 1747
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_md_line",
          "args": [
            "fmtstr",
            "addr",
            "symbolic",
            "nosect",
            "bytesperword",
            "num",
            "repeat",
            "phys"
          ],
          "line": 1740
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_md_line",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1487-1565",
          "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
        }
      },
      {
        "call_info": {
          "callee": "min",
          "args": [
            "num",
            "repeat"
          ],
          "line": 1739
        },
        "resolved": true,
        "details": {
          "function_name": "irq_setup_timings",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/internals.h",
          "lines": "374-375",
          "snippet": "static inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}",
          "includes": [
            "#include <linux/debugfs.h>",
            "#include \"settings.h\"",
            "#include \"debug.h\"",
            "#include <linux/sched/clock.h>",
            "#include <linux/pm_runtime.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/irqdesc.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "extern void __disable_irq(struct irq_desc *desc);",
            "extern void __enable_irq(struct irq_desc *desc);",
            "extern int irq_activate(struct irq_desc *desc);",
            "extern void irq_shutdown(struct irq_desc *desc);",
            "extern void irq_enable(struct irq_desc *desc);",
            "extern void irq_disable(struct irq_desc *desc);",
            "extern void mask_irq(struct irq_desc *desc);",
            "extern void unmask_irq(struct irq_desc *desc);",
            "extern void unmask_threaded_irq(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event_percpu(struct irq_desc *desc);",
            "irqreturn_t handle_irq_event(struct irq_desc *desc);",
            "void check_irq_resend(struct irq_desc *desc);",
            "bool irq_wait_for_poll(struct irq_desc *desc);",
            "extern void irq_set_thread_affinity(struct irq_desc *desc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/debugfs.h>\n#include \"settings.h\"\n#include \"debug.h\"\n#include <linux/sched/clock.h>\n#include <linux/pm_runtime.h>\n#include <linux/kernel_stat.h>\n#include <linux/irqdesc.h>\n\nextern void __disable_irq(struct irq_desc *desc);\nextern void __enable_irq(struct irq_desc *desc);\nextern int irq_activate(struct irq_desc *desc);\nextern void irq_shutdown(struct irq_desc *desc);\nextern void irq_enable(struct irq_desc *desc);\nextern void irq_disable(struct irq_desc *desc);\nextern void mask_irq(struct irq_desc *desc);\nextern void unmask_irq(struct irq_desc *desc);\nextern void unmask_threaded_irq(struct irq_desc *desc);\nirqreturn_t handle_irq_event_percpu(struct irq_desc *desc);\nirqreturn_t handle_irq_event(struct irq_desc *desc);\nvoid check_irq_resend(struct irq_desc *desc);\nbool irq_wait_for_poll(struct irq_desc *desc);\nextern void irq_set_thread_affinity(struct irq_desc *desc);\n\nstatic inline void irq_setup_timings(struct irq_desc *desc,\n\t\t\t\t     struct irqaction *act) {}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&word",
            "a",
            "bytesperword"
          ],
          "line": 1736
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "453-490",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getphysword",
          "args": [
            "&word",
            "a",
            "bytesperword"
          ],
          "line": 1733
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "403-441",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 1729
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetintenv",
          "args": [
            "\"NOSECT\"",
            "&nosect"
          ],
          "line": 1718
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetintenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "316-325",
          "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mds\""
          ],
          "line": 1711
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%2.2l%c \"",
            "fmtchar"
          ],
          "line": 1702
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%4.4l%c \"",
            "fmtchar"
          ],
          "line": 1699
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%8.8l%c \"",
            "fmtchar"
          ],
          "line": 1696
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "fmtstr",
            "\"%%16.16l%c \"",
            "fmtchar"
          ],
          "line": 1693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_mdr",
          "args": [
            "addr",
            "mdcount"
          ],
          "line": 1665
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_mdr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1464-1475",
          "snippet": "static int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mdr\""
          ],
          "line": 1662
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "argv[nextarg+1]",
            "&val"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "argc",
            "argv",
            "&nextarg",
            "&addr",
            "&offset",
            "NULL"
          ],
          "line": 1638
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mdp\""
          ],
          "line": 1616
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mds\""
          ],
          "line": 1614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"md\""
          ],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[0] + 4",
            "&p",
            "10"
          ],
          "line": 1607
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "argv[0][2]"
          ],
          "line": 1594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "\"mdr\""
          ],
          "line": 1589
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_md(int argc, const char **argv)\n{\n\tstatic unsigned long last_addr;\n\tstatic int last_radix, last_bytesperword, last_repeat;\n\tint radix = 16, mdcount = 8, bytesperword = KDB_WORD_SIZE, repeat;\n\tint nosect = 0;\n\tchar fmtchar, fmtstr[64];\n\tunsigned long addr;\n\tunsigned long word;\n\tlong offset = 0;\n\tint symbolic = 0;\n\tint valid = 0;\n\tint phys = 0;\n\tint raw = 0;\n\n\tkdbgetintenv(\"MDCOUNT\", &mdcount);\n\tkdbgetintenv(\"RADIX\", &radix);\n\tkdbgetintenv(\"BYTESPERWORD\", &bytesperword);\n\n\t/* Assume 'md <addr>' and start with environment values */\n\trepeat = mdcount * 16 / bytesperword;\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tif (argc == 2 || (argc == 0 && last_addr != 0))\n\t\t\tvalid = raw = 1;\n\t\telse\n\t\t\treturn KDB_ARGCOUNT;\n\t} else if (isdigit(argv[0][2])) {\n\t\tbytesperword = (int)(argv[0][2] - '0');\n\t\tif (bytesperword == 0) {\n\t\t\tbytesperword = last_bytesperword;\n\t\t\tif (bytesperword == 0)\n\t\t\t\tbytesperword = 4;\n\t\t}\n\t\tlast_bytesperword = bytesperword;\n\t\trepeat = mdcount * 16 / bytesperword;\n\t\tif (!argv[0][3])\n\t\t\tvalid = 1;\n\t\telse if (argv[0][3] == 'c' && argv[0][4]) {\n\t\t\tchar *p;\n\t\t\trepeat = simple_strtoul(argv[0] + 4, &p, 10);\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t\t\tvalid = !*p;\n\t\t}\n\t\tlast_repeat = repeat;\n\t} else if (strcmp(argv[0], \"md\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mds\") == 0)\n\t\tvalid = 1;\n\telse if (strcmp(argv[0], \"mdp\") == 0) {\n\t\tphys = valid = 1;\n\t}\n\tif (!valid)\n\t\treturn KDB_NOTFOUND;\n\n\tif (argc == 0) {\n\t\tif (last_addr == 0)\n\t\t\treturn KDB_ARGCOUNT;\n\t\taddr = last_addr;\n\t\tradix = last_radix;\n\t\tbytesperword = last_bytesperword;\n\t\trepeat = last_repeat;\n\t\tif (raw)\n\t\t\tmdcount = repeat;\n\t\telse\n\t\t\tmdcount = ((repeat * bytesperword) + 15) / 16;\n\t}\n\n\tif (argc) {\n\t\tunsigned long val;\n\t\tint diag, nextarg = 1;\n\t\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &addr,\n\t\t\t\t     &offset, NULL);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (argc > nextarg+2)\n\t\t\treturn KDB_ARGCOUNT;\n\n\t\tif (argc >= nextarg) {\n\t\t\tdiag = kdbgetularg(argv[nextarg], &val);\n\t\t\tif (!diag) {\n\t\t\t\tmdcount = (int) val;\n\t\t\t\tif (raw)\n\t\t\t\t\trepeat = mdcount;\n\t\t\t\telse\n\t\t\t\t\trepeat = mdcount * 16 / bytesperword;\n\t\t\t}\n\t\t}\n\t\tif (argc >= nextarg+1) {\n\t\t\tdiag = kdbgetularg(argv[nextarg+1], &val);\n\t\t\tif (!diag)\n\t\t\t\tradix = (int) val;\n\t\t}\n\t}\n\n\tif (strcmp(argv[0], \"mdr\") == 0) {\n\t\tint ret;\n\t\tlast_addr = addr;\n\t\tret = kdb_mdr(addr, mdcount);\n\t\tlast_addr += mdcount;\n\t\tlast_repeat = mdcount;\n\t\tlast_bytesperword = bytesperword; // to make REPEAT happy\n\t\treturn ret;\n\t}\n\n\tswitch (radix) {\n\tcase 10:\n\t\tfmtchar = 'd';\n\t\tbreak;\n\tcase 16:\n\t\tfmtchar = 'x';\n\t\tbreak;\n\tcase 8:\n\t\tfmtchar = 'o';\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADRADIX;\n\t}\n\n\tlast_radix = radix;\n\n\tif (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\n\tswitch (bytesperword) {\n\tcase 8:\n\t\tsprintf(fmtstr, \"%%16.16l%c \", fmtchar);\n\t\tbreak;\n\tcase 4:\n\t\tsprintf(fmtstr, \"%%8.8l%c \", fmtchar);\n\t\tbreak;\n\tcase 2:\n\t\tsprintf(fmtstr, \"%%4.4l%c \", fmtchar);\n\t\tbreak;\n\tcase 1:\n\t\tsprintf(fmtstr, \"%%2.2l%c \", fmtchar);\n\t\tbreak;\n\tdefault:\n\t\treturn KDB_BADWIDTH;\n\t}\n\n\tlast_repeat = repeat;\n\tlast_bytesperword = bytesperword;\n\n\tif (strcmp(argv[0], \"mds\") == 0) {\n\t\tsymbolic = 1;\n\t\t/* Do not save these changes as last_*, they are temporary mds\n\t\t * overrides.\n\t\t */\n\t\tbytesperword = KDB_WORD_SIZE;\n\t\trepeat = mdcount;\n\t\tkdbgetintenv(\"NOSECT\", &nosect);\n\t}\n\n\t/* Round address down modulo BYTESPERWORD */\n\n\taddr &= ~(bytesperword-1);\n\n\twhile (repeat > 0) {\n\t\tunsigned long a;\n\t\tint n, z, num = (symbolic ? 1 : (16 / bytesperword));\n\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\t\tfor (a = addr, z = 0; z < repeat; a += bytesperword, ++z) {\n\t\t\tif (phys) {\n\t\t\t\tif (kdb_getphysword(&word, a, bytesperword)\n\t\t\t\t\t\t|| word)\n\t\t\t\t\tbreak;\n\t\t\t} else if (kdb_getword(&word, a, bytesperword) || word)\n\t\t\t\tbreak;\n\t\t}\n\t\tn = min(num, repeat);\n\t\tkdb_md_line(fmtstr, addr, symbolic, nosect, bytesperword,\n\t\t\t    num, repeat, phys);\n\t\taddr += bytesperword * n;\n\t\trepeat -= n;\n\t\tz = (z + num - 1) / num;\n\t\tif (z > 2) {\n\t\t\tint s = num * (z-2);\n\t\t\tkdb_printf(kdb_machreg_fmt0 \"-\" kdb_machreg_fmt0\n\t\t\t\t   \" zero suppressed\\n\",\n\t\t\t\taddr, addr + bytesperword * s - 1);\n\t\t\taddr += bytesperword * s;\n\t\t\trepeat -= s;\n\t\t}\n\t}\n\tlast_addr = addr;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_md_line",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1487-1565",
    "snippet": "static void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"%*s %s\\n\"",
            "(int)((num-i)*(2*bytesperword + 1)+1)",
            "\" \"",
            "cbuf"
          ],
          "line": 1563
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1556
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1544
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printable_char",
          "args": [
            "*cp++"
          ],
          "line": 1543
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "word",
            "&symtab",
            "0"
          ],
          "line": 1516
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "258-294",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&symtab",
            "0",
            "sizeof(symtab)"
          ],
          "line": 1514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "word",
            "&symtab"
          ],
          "line": 1512
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-159",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define knt1_size 128\t\t/* must be >= kallsyms table size */"
          ],
          "globals_used": [
            "static char *kdb_name_table[100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\nstatic char *kdb_name_table[100];\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getword",
          "args": [
            "&word",
            "addr",
            "bytesperword"
          ],
          "line": 1508
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "453-490",
          "snippet": "int kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getarea(w1, addr);\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getarea(w2, addr);\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getarea(w4, addr);\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getarea(w8, addr);\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getphysword",
          "args": [
            "&word",
            "addr",
            "bytesperword"
          ],
          "line": 1506
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getphysword",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "403-441",
          "snippet": "int kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdb_getphysword(unsigned long *word, unsigned long addr, size_t size)\n{\n\tint diag;\n\t__u8  w1;\n\t__u16 w2;\n\t__u32 w4;\n\t__u64 w8;\n\t*word = 0;\t/* Default value if addr or size is invalid */\n\n\tswitch (size) {\n\tcase 1:\n\t\tdiag = kdb_getphys(&w1, addr, sizeof(w1));\n\t\tif (!diag)\n\t\t\t*word = w1;\n\t\tbreak;\n\tcase 2:\n\t\tdiag = kdb_getphys(&w2, addr, sizeof(w2));\n\t\tif (!diag)\n\t\t\t*word = w2;\n\t\tbreak;\n\tcase 4:\n\t\tdiag = kdb_getphys(&w4, addr, sizeof(w4));\n\t\tif (!diag)\n\t\t\t*word = w4;\n\t\tbreak;\n\tcase 8:\n\t\tif (size <= sizeof(*word)) {\n\t\t\tdiag = kdb_getphys(&w8, addr, sizeof(w8));\n\t\t\tif (!diag)\n\t\t\t\t*word = w8;\n\t\t\tbreak;\n\t\t}\n\t\t/* drop through */\n\tdefault:\n\t\tdiag = KDB_BADWIDTH;\n\t\tkdb_printf(\"kdb_getphysword: bad width %ld\\n\", (long) size);\n\t}\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "cbuf",
            "'\\0'",
            "sizeof(cbuf)"
          ],
          "line": 1498
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_md_line(const char *fmtstr, unsigned long addr,\n\t\t\tint symbolic, int nosect, int bytesperword,\n\t\t\tint num, int repeat, int phys)\n{\n\t/* print just one line of data */\n\tkdb_symtab_t symtab;\n\tchar cbuf[32];\n\tchar *c = cbuf;\n\tint i;\n\tunsigned long word;\n\n\tmemset(cbuf, '\\0', sizeof(cbuf));\n\tif (phys)\n\t\tkdb_printf(\"phys \" kdb_machreg_fmt0 \" \", addr);\n\telse\n\t\tkdb_printf(kdb_machreg_fmt0 \" \", addr);\n\n\tfor (i = 0; i < num && repeat--; i++) {\n\t\tif (phys) {\n\t\t\tif (kdb_getphysword(&word, addr, bytesperword))\n\t\t\t\tbreak;\n\t\t} else if (kdb_getword(&word, addr, bytesperword))\n\t\t\tbreak;\n\t\tkdb_printf(fmtstr, word);\n\t\tif (symbolic)\n\t\t\tkdbnearsym(word, &symtab);\n\t\telse\n\t\t\tmemset(&symtab, 0, sizeof(symtab));\n\t\tif (symtab.sym_name) {\n\t\t\tkdb_symbol_print(word, &symtab, 0);\n\t\t\tif (!nosect) {\n\t\t\t\tkdb_printf(\"\\n\");\n\t\t\t\tkdb_printf(\"                       %s %s \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt \" \"\n\t\t\t\t\t   kdb_machreg_fmt, symtab.mod_name,\n\t\t\t\t\t   symtab.sec_name, symtab.sec_start,\n\t\t\t\t\t   symtab.sym_start, symtab.sym_end);\n\t\t\t}\n\t\t\taddr += bytesperword;\n\t\t} else {\n\t\t\tunion {\n\t\t\t\tu64 word;\n\t\t\t\tunsigned char c[8];\n\t\t\t} wc;\n\t\t\tunsigned char *cp;\n#ifdef\t__BIG_ENDIAN\n\t\t\tcp = wc.c + 8 - bytesperword;\n#else\n\t\t\tcp = wc.c;\n#endif\n\t\t\twc.word = word;\n#define printable_char(c) \\\n\t({unsigned char __c = c; isascii(__c) && isprint(__c) ? __c : '.'; })\n\t\t\tswitch (bytesperword) {\n\t\t\tcase 8:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 4;\n\t\t\tcase 4:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr += 2;\n\t\t\tcase 2:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\tcase 1:\n\t\t\t\t*c++ = printable_char(*cp++);\n\t\t\t\taddr++;\n\t\t\t\tbreak;\n\t\t\t}\n#undef printable_char\n\t\t}\n\t}\n\tkdb_printf(\"%*s %s\\n\", (int)((num-i)*(2*bytesperword + 1)+1),\n\t\t   \" \", cbuf);\n}"
  },
  {
    "function_name": "kdb_mdr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1464-1475",
    "snippet": "static int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1473
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_getarea",
          "args": [
            "c",
            "addr"
          ],
          "line": 1468
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_mdr(unsigned long addr, unsigned int count)\n{\n\tunsigned char c;\n\twhile (count--) {\n\t\tif (kdb_getarea(c, addr))\n\t\t\treturn 0;\n\t\tkdb_printf(\"%02x\", c);\n\t\taddr++;\n\t}\n\tkdb_printf(\"\\n\");\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_main_loop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1397-1452",
    "snippet": "int kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_kbd_cleanup_state",
          "args": [],
          "line": 1449
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_kbd_cleanup_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_keyboard.c",
          "lines": "199-263",
          "snippet": "void kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}",
          "includes": [
            "#include <linux/io.h>",
            "#include <linux/module.h>",
            "#include <linux/ctype.h>",
            "#include <linux/keyboard.h>",
            "#include <linux/kdb.h>"
          ],
          "macros_used": [
            "#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */",
            "#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */",
            "#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */",
            "#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */"
          ],
          "globals_used": [
            "static int kbd_last_ret;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/io.h>\n#include <linux/module.h>\n#include <linux/ctype.h>\n#include <linux/keyboard.h>\n#include <linux/kdb.h>\n\n#define KBD_STAT_MOUSE_OBF\t0x20\t/* Mouse output buffer full */\n#define KBD_STAT_OBF \t\t0x01\t/* Keyboard output buffer full */\n#define KBD_DATA_REG\t\t0x60\t/* Keyboard data register (R/W) */\n#define KBD_STATUS_REG\t\t0x64\t/* Status register (R) */\n\nstatic int kbd_last_ret;\n\nvoid kdb_kbd_cleanup_state(void)\n{\n\tint scancode, scanstatus;\n\n\t/*\n\t * Nothing to clean up, since either\n\t * ENTER was never pressed, or has already\n\t * gotten cleaned up.\n\t */\n\tif (!kbd_last_ret)\n\t\treturn;\n\n\tkbd_last_ret = 0;\n\t/*\n\t * Enter key. Need to absorb the break code here, lest it gets\n\t * leaked out if we exit KDB as the result of processing 'g'.\n\t *\n\t * This has several interesting implications:\n\t * + Need to handle KP ENTER, which has break code 0xe0 0x9c.\n\t * + Need to handle repeat ENTER and repeat KP ENTER. Repeats\n\t *   only get a break code at the end of the repeated\n\t *   sequence. This means we can't propagate the repeated key\n\t *   press, and must swallow it away.\n\t * + Need to handle possible PS/2 mouse input.\n\t * + Need to handle mashed keys.\n\t */\n\n\twhile (1) {\n\t\twhile ((inb(KBD_STATUS_REG) & KBD_STAT_OBF) == 0)\n\t\t\tcpu_relax();\n\n\t\t/*\n\t\t * Fetch the scancode.\n\t\t */\n\t\tscancode = inb(KBD_DATA_REG);\n\t\tscanstatus = inb(KBD_STATUS_REG);\n\n\t\t/*\n\t\t * Skip mouse input.\n\t\t */\n\t\tif (scanstatus & KBD_STAT_MOUSE_OBF)\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * If we see 0xe0, this is either a break code for KP\n\t\t * ENTER, or a repeat make for KP ENTER. Either way,\n\t\t * since the second byte is equivalent to an ENTER,\n\t\t * skip the 0xe0 and try again.\n\t\t *\n\t\t * If we see 0x1c, this must be a repeat ENTER or KP\n\t\t * ENTER (and we swallowed 0xe0 before). Try again.\n\t\t *\n\t\t * We can also see make and break codes for other keys\n\t\t * mashed before or after pressing ENTER. Thus, if we\n\t\t * see anything other than 0x9c, we have to try again.\n\t\t *\n\t\t * Note, if you held some key as ENTER was depressed,\n\t\t * that break code would get leaked out.\n\t\t */\n\t\tif (scancode != 0x9c)\n\t\t\tcontinue;\n\n\t\treturn;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SSBPT"
          ],
          "line": 1446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_SS"
          ],
          "line": 1445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 4\"",
            "reason"
          ],
          "line": 1442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\nUnexpected kdb_local return code %d\\n\"",
            "result"
          ],
          "line": 1440
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "DOING_KGDB"
          ],
          "line": 1434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "DOING_SS"
          ],
          "line": 1429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 3\"",
            "result"
          ],
          "line": 1423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_local",
          "args": [
            "reason2",
            "error",
            "regs",
            "db_result"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1182-1355",
          "snippet": "static int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%p, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%p, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n#if defined(CONFIG_SMP)\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n#else\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"));\n#endif\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
            "#define KDB_CMD_HISTORY_COUNT\t32"
          ],
          "globals_used": [
            "char kdb_grep_string[KDB_GREP_STRLEN];",
            "int kdb_grepping_flag;",
            "int kdb_nextline = 1;",
            "const char *kdb_diemsg;",
            "static int kdb_go_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_nextline = 1;\nconst char *kdb_diemsg;\nstatic int kdb_go_count;\n\nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%p, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%p, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n#if defined(CONFIG_SMP)\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n#else\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"));\n#endif\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "LEAVING"
          ],
          "line": 1419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 2\"",
            "reason"
          ],
          "line": 1418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KDB"
          ],
          "line": 1414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KDB"
          ],
          "line": 1413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "HOLD_CPU"
          ],
          "line": 1408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_main_loop 1\"",
            "reason"
          ],
          "line": 1407
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_main_loop(kdb_reason_t reason, kdb_reason_t reason2, int error,\n\t      kdb_dbtrap_t db_result, struct pt_regs *regs)\n{\n\tint result = 1;\n\t/* Stay in kdb() until 'go', 'ss[b]' or an error */\n\twhile (1) {\n\t\t/*\n\t\t * All processors except the one that is in control\n\t\t * will spin here.\n\t\t */\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 1\", reason);\n\t\twhile (KDB_STATE(HOLD_CPU)) {\n\t\t\t/* state KDB is turned off by kdb_cpu to see if the\n\t\t\t * other cpus are still live, each cpu in this loop\n\t\t\t * turns it back on.\n\t\t\t */\n\t\t\tif (!KDB_STATE(KDB))\n\t\t\t\tKDB_STATE_SET(KDB);\n\t\t}\n\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 2\", reason);\n\t\tif (KDB_STATE(LEAVING))\n\t\t\tbreak;\t/* Another cpu said 'go' */\n\t\t/* Still using kdb, this processor is in control */\n\t\tresult = kdb_local(reason2, error, regs, db_result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 3\", result);\n\n\t\tif (result == KDB_CMD_CPU)\n\t\t\tbreak;\n\n\t\tif (result == KDB_CMD_SS) {\n\t\t\tKDB_STATE_SET(DOING_SS);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (result == KDB_CMD_KGDB) {\n\t\t\tif (!KDB_STATE(DOING_KGDB))\n\t\t\t\tkdb_printf(\"Entering please attach debugger \"\n\t\t\t\t\t   \"or use $D#44+ or $3#33\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tif (result && result != 1 && result != KDB_CMD_GO)\n\t\t\tkdb_printf(\"\\nUnexpected kdb_local return code %d\\n\",\n\t\t\t\t   result);\n\t\tKDB_DEBUG_STATE(\"kdb_main_loop 4\", reason);\n\t\tbreak;\n\t}\n\tif (KDB_STATE(DOING_SS))\n\t\tKDB_STATE_CLEAR(SSBPT);\n\n\t/* Clean up any keyboard devices before leaving */\n\tkdb_kbd_cleanup_state();\n\n\treturn result;\n}"
  },
  {
    "function_name": "kdb_print_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1365-1370",
    "snippet": "void kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_initial_cpu = -1;",
      "int kdb_state;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"state: %s cpu %d value %d initial %d state %x\\n\"",
            "text",
            "raw_smp_processor_id()",
            "value",
            "kdb_initial_cpu",
            "kdb_state"
          ],
          "line": 1367
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1368
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_initial_cpu = -1;\nint kdb_state;\n\nvoid kdb_print_state(const char *text, int value)\n{\n\tkdb_printf(\"state: %s cpu %d value %d initial %d state %x\\n\",\n\t\t   text, raw_smp_processor_id(), value, kdb_initial_cpu,\n\t\t   kdb_state);\n}"
  },
  {
    "function_name": "kdb_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1182-1355",
    "snippet": "static int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%p, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%p, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n#if defined(CONFIG_SMP)\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n#else\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"));\n#endif\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
      "#define KDB_CMD_HISTORY_COUNT\t32"
    ],
    "globals_used": [
      "char kdb_grep_string[KDB_GREP_STRLEN];",
      "int kdb_grepping_flag;",
      "int kdb_nextline = 1;",
      "const char *kdb_diemsg;",
      "static int kdb_go_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 9\"",
            "diag"
          ],
          "line": 1353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_cmderror",
          "args": [
            "diag"
          ],
          "line": 1351
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_cmderror",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "628-645",
          "snippet": "static void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};",
            "static const int __nkdb_err = ARRAY_SIZE(kdbmsgs);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};\nstatic const int __nkdb_err = ARRAY_SIZE(kdbmsgs);\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Unknown kdb command: '%s'\\n\"",
            "cmdbuf"
          ],
          "line": 1341
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "drop_newline",
          "args": [
            "cmdbuf"
          ],
          "line": 1340
        },
        "resolved": true,
        "details": {
          "function_name": "drop_newline",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1153-1161",
          "snippet": "static void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "cmdbuf"
          ],
          "line": 1338
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "911-1091",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cmd_hist[cmd_head]",
            "cmd_cur",
            "CMD_BUFLEN"
          ],
          "line": 1328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd_cur"
          ],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_ctrl_cmd",
          "args": [
            "cmdbuf"
          ],
          "line": 1323
        },
        "resolved": true,
        "details": {
          "function_name": "handle_ctrl_cmd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1094-1115",
          "snippet": "static int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr-1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define CTRL_N\t14",
            "#define CTRL_P\t16",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
            "#define KDB_CMD_HISTORY_COUNT\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CTRL_N\t14\n#define CTRL_P\t16\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nstatic int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr-1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cmd_hist[cmd_head]",
            "cmd_cur",
            "CMD_BUFLEN"
          ],
          "line": 1318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_getstr",
          "args": [
            "cmdbuf",
            "CMD_BUFLEN",
            "kdb_prompt_str"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_getstr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "443-450",
          "snippet": "char *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define CMD_BUFLEN 256"
          ],
          "globals_used": [
            "char kdb_prompt_str[CMD_BUFLEN];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\n#define CMD_BUFLEN 256\n\nchar kdb_prompt_str[CMD_BUFLEN];\n\nchar *kdb_getstr(char *buffer, size_t bufsize, const char *prompt)\n{\n\tif (prompt && kdb_prompt_str != prompt)\n\t\tstrncpy(kdb_prompt_str, prompt, CMD_BUFLEN);\n\tkdb_printf(kdb_prompt_str);\n\tkdb_nextline = 1;\t/* Prompt and input resets line number */\n\treturn kdb_read(buffer, bufsize);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncat",
          "args": [
            "kdb_prompt_str",
            "\"[defcmd]\"",
            "CMD_BUFLEN"
          ],
          "line": 1309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kdb_prompt_str",
            "CMD_BUFLEN",
            "kdbgetenv(\"PROMPT\")"
          ],
          "line": 1306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "\"PROMPT\""
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "229-249",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "kdb_prompt_str",
            "CMD_BUFLEN",
            "kdbgetenv(\"PROMPT\")",
            "raw_smp_processor_id()"
          ],
          "line": 1303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "SUPPRESS"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 8\"",
            "reason"
          ],
          "line": 1283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 6\"",
            "reason"
          ],
          "line": 1273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_dumpregs",
          "args": [
            "regs"
          ],
          "line": 1251
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_dumpregs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "1131-1140",
          "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
        }
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "KEYBOARD"
          ],
          "line": 1239
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE",
          "args": [
            "KEYBOARD"
          ],
          "line": 1233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 4\"",
            "reason"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "instruction_pointer",
          "args": [
            "regs"
          ],
          "line": 1217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_DEBUG_STATE",
          "args": [
            "\"kdb_local 1\"",
            "reason"
          ],
          "line": 1190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_curr_task",
          "args": [
            "raw_smp_processor_id()"
          ],
          "line": 1188
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_smp_processor_id",
          "args": [],
          "line": 1188
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_nextline = 1;\nconst char *kdb_diemsg;\nstatic int kdb_go_count;\n\nstatic int kdb_local(kdb_reason_t reason, int error, struct pt_regs *regs,\n\t\t     kdb_dbtrap_t db_result)\n{\n\tchar *cmdbuf;\n\tint diag;\n\tstruct task_struct *kdb_current =\n\t\tkdb_curr_task(raw_smp_processor_id());\n\n\tKDB_DEBUG_STATE(\"kdb_local 1\", reason);\n\tkdb_go_count = 0;\n\tif (reason == KDB_REASON_DEBUG) {\n\t\t/* special case below */\n\t} else {\n\t\tkdb_printf(\"\\nEntering kdb (current=0x%p, pid %d) \",\n\t\t\t   kdb_current, kdb_current ? kdb_current->pid : 0);\n#if defined(CONFIG_SMP)\n\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t}\n\n\tswitch (reason) {\n\tcase KDB_REASON_DEBUG:\n\t{\n\t\t/*\n\t\t * If re-entering kdb after a single step\n\t\t * command, don't print the message.\n\t\t */\n\t\tswitch (db_result) {\n\t\tcase KDB_DB_BPT:\n\t\t\tkdb_printf(\"\\nEntering kdb (0x%p, pid %d) \",\n\t\t\t\t   kdb_current, kdb_current->pid);\n#if defined(CONFIG_SMP)\n\t\t\tkdb_printf(\"on processor %d \", raw_smp_processor_id());\n#endif\n\t\t\tkdb_printf(\"due to Debug @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t\t   instruction_pointer(regs));\n\t\t\tbreak;\n\t\tcase KDB_DB_SS:\n\t\t\tbreak;\n\t\tcase KDB_DB_SSBPT:\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 4\", reason);\n\t\t\treturn 1;\t/* kdba_db_trap did the work */\n\t\tdefault:\n\t\t\tkdb_printf(\"kdb: Bad result from kdba_db_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tbreak;\n\t\t}\n\n\t}\n\t\tbreak;\n\tcase KDB_REASON_ENTER:\n\t\tif (KDB_STATE(KEYBOARD))\n\t\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\telse\n\t\t\tkdb_printf(\"due to KDB_ENTER()\\n\");\n\t\tbreak;\n\tcase KDB_REASON_KEYBOARD:\n\t\tKDB_STATE_SET(KEYBOARD);\n\t\tkdb_printf(\"due to Keyboard Entry\\n\");\n\t\tbreak;\n\tcase KDB_REASON_ENTER_SLAVE:\n\t\t/* drop through, slaves only get released via cpu switch */\n\tcase KDB_REASON_SWITCH:\n\t\tkdb_printf(\"due to cpu switch\\n\");\n\t\tbreak;\n\tcase KDB_REASON_OOPS:\n\t\tkdb_printf(\"Oops: %s\\n\", kdb_diemsg);\n\t\tkdb_printf(\"due to oops @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tkdb_dumpregs(regs);\n\t\tbreak;\n\tcase KDB_REASON_SYSTEM_NMI:\n\t\tkdb_printf(\"due to System NonMaskable Interrupt\\n\");\n\t\tbreak;\n\tcase KDB_REASON_NMI:\n\t\tkdb_printf(\"due to NonMaskable Interrupt @ \"\n\t\t\t   kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tcase KDB_REASON_SSTEP:\n\tcase KDB_REASON_BREAK:\n\t\tkdb_printf(\"due to %s @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   reason == KDB_REASON_BREAK ?\n\t\t\t   \"Breakpoint\" : \"SS trap\", instruction_pointer(regs));\n\t\t/*\n\t\t * Determine if this breakpoint is one that we\n\t\t * are interested in.\n\t\t */\n\t\tif (db_result != KDB_DB_BPT) {\n\t\t\tkdb_printf(\"kdb: error return from kdba_bp_trap: %d\\n\",\n\t\t\t\t   db_result);\n\t\t\tKDB_DEBUG_STATE(\"kdb_local 6\", reason);\n\t\t\treturn 0;\t/* Not for us, dismiss it */\n\t\t}\n\t\tbreak;\n\tcase KDB_REASON_RECURSE:\n\t\tkdb_printf(\"due to Recursion @ \" kdb_machreg_fmt \"\\n\",\n\t\t\t   instruction_pointer(regs));\n\t\tbreak;\n\tdefault:\n\t\tkdb_printf(\"kdb: unexpected reason code: %d\\n\", reason);\n\t\tKDB_DEBUG_STATE(\"kdb_local 8\", reason);\n\t\treturn 0;\t/* Not for us, dismiss it */\n\t}\n\n\twhile (1) {\n\t\t/*\n\t\t * Initialize pager context.\n\t\t */\n\t\tkdb_nextline = 1;\n\t\tKDB_STATE_CLEAR(SUPPRESS);\n\t\tkdb_grepping_flag = 0;\n\t\t/* ensure the old search does not leak into '/' commands */\n\t\tkdb_grep_string[0] = '\\0';\n\n\t\tcmdbuf = cmd_cur;\n\t\t*cmdbuf = '\\0';\n\t\t*(cmd_hist[cmd_head]) = '\\0';\n\ndo_full_getstr:\n#if defined(CONFIG_SMP)\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"),\n\t\t\t raw_smp_processor_id());\n#else\n\t\tsnprintf(kdb_prompt_str, CMD_BUFLEN, kdbgetenv(\"PROMPT\"));\n#endif\n\t\tif (defcmd_in_progress)\n\t\t\tstrncat(kdb_prompt_str, \"[defcmd]\", CMD_BUFLEN);\n\n\t\t/*\n\t\t * Fetch command from keyboard\n\t\t */\n\t\tcmdbuf = kdb_getstr(cmdbuf, CMD_BUFLEN, kdb_prompt_str);\n\t\tif (*cmdbuf != '\\n') {\n\t\t\tif (*cmdbuf < 32) {\n\t\t\t\tif (cmdptr == cmd_head) {\n\t\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\t\tCMD_BUFLEN);\n\t\t\t\t\t*(cmd_hist[cmd_head] +\n\t\t\t\t\t  strlen(cmd_hist[cmd_head])-1) = '\\0';\n\t\t\t\t}\n\t\t\t\tif (!handle_ctrl_cmd(cmdbuf))\n\t\t\t\t\t*(cmd_cur+strlen(cmd_cur)-1) = '\\0';\n\t\t\t\tcmdbuf = cmd_cur;\n\t\t\t\tgoto do_full_getstr;\n\t\t\t} else {\n\t\t\t\tstrncpy(cmd_hist[cmd_head], cmd_cur,\n\t\t\t\t\tCMD_BUFLEN);\n\t\t\t}\n\n\t\t\tcmd_head = (cmd_head+1) % KDB_CMD_HISTORY_COUNT;\n\t\t\tif (cmd_head == cmd_tail)\n\t\t\t\tcmd_tail = (cmd_tail+1) % KDB_CMD_HISTORY_COUNT;\n\t\t}\n\n\t\tcmdptr = cmd_head;\n\t\tdiag = kdb_parse(cmdbuf);\n\t\tif (diag == KDB_NOTFOUND) {\n\t\t\tdrop_newline(cmdbuf);\n\t\t\tkdb_printf(\"Unknown kdb command: '%s'\\n\", cmdbuf);\n\t\t\tdiag = 0;\n\t\t}\n\t\tif (diag == KDB_CMD_GO\n\t\t || diag == KDB_CMD_CPU\n\t\t || diag == KDB_CMD_SS\n\t\t || diag == KDB_CMD_KGDB)\n\t\t\tbreak;\n\n\t\tif (diag)\n\t\t\tkdb_cmderror(diag);\n\t}\n\tKDB_DEBUG_STATE(\"kdb_local 9\", diag);\n\treturn diag;\n}"
  },
  {
    "function_name": "drop_newline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1153-1161",
    "snippet": "static void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "buf"
          ],
          "line": 1155
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void drop_newline(char *buf)\n{\n\tsize_t len = strlen(buf);\n\n\tif (len == 0)\n\t\treturn;\n\tif (*(buf + len - 1) == '\\n')\n\t\t*(buf + len - 1) = '\\0';\n}"
  },
  {
    "function_name": "kdb_set_current_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1142-1151",
    "snippet": "void kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct task_struct *kdb_current_task;",
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_TSKREGS",
          "args": [
            "kdb_process_cpu(p)"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_process_cpu",
          "args": [
            "p"
          ],
          "line": 1147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_task_has_cpu",
          "args": [
            "p"
          ],
          "line": 1146
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_current_task;\nstruct pt_regs *kdb_current_regs;\n\nvoid kdb_set_current_task(struct task_struct *p)\n{\n\tkdb_current_task = p;\n\n\tif (kdb_task_has_cpu(p)) {\n\t\tkdb_current_regs = KDB_TSKREGS(kdb_process_cpu(p));\n\t\treturn;\n\t}\n\tkdb_current_regs = NULL;\n}"
  },
  {
    "function_name": "kdb_dumpregs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1131-1140",
    "snippet": "static void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1138
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic void kdb_dumpregs(struct pt_regs *regs)\n{\n\tint old_lvl = console_loglevel;\n\tconsole_loglevel = CONSOLE_LOGLEVEL_MOTORMOUTH;\n\tkdb_trap_printk++;\n\tshow_regs(regs);\n\tkdb_trap_printk--;\n\tkdb_printf(\"\\n\");\n\tconsole_loglevel = old_lvl;\n}"
  },
  {
    "function_name": "kdb_reboot",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1121-1129",
    "snippet": "static int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cpu_relax",
          "args": [],
          "line": 1126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Hmm, kdb_reboot did not reboot, spinning here\\n\""
          ],
          "line": 1124
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "emergency_restart",
          "args": [],
          "line": 1123
        },
        "resolved": true,
        "details": {
          "function_name": "emergency_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/reboot.c",
          "lines": "62-66",
          "snippet": "void emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/suspend.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kmod.h>",
            "#include <linux/kexec.h>",
            "#include <linux/export.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/syscore_ops.h>\n#include <linux/syscalls.h>\n#include <linux/suspend.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kmod.h>\n#include <linux/kexec.h>\n#include <linux/export.h>\n#include <linux/ctype.h>\n\nvoid emergency_restart(void)\n{\n\tkmsg_dump(KMSG_DUMP_EMERG);\n\tmachine_emergency_restart();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_reboot(int argc, const char **argv)\n{\n\temergency_restart();\n\tkdb_printf(\"Hmm, kdb_reboot did not reboot, spinning here\\n\");\n\twhile (1)\n\t\tcpu_relax();\n\t/* NOTREACHED */\n\treturn 0;\n}"
  },
  {
    "function_name": "handle_ctrl_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "1094-1115",
    "snippet": "static int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr-1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define CTRL_N\t14",
      "#define CTRL_P\t16",
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */",
      "#define KDB_CMD_HISTORY_COUNT\t32"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cmd_cur",
            "cmd_hist[cmdptr]",
            "CMD_BUFLEN"
          ],
          "line": 1111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncpy",
          "args": [
            "cmd_cur",
            "cmd_hist[cmdptr]",
            "CMD_BUFLEN"
          ],
          "line": 1106
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define CTRL_N\t14\n#define CTRL_P\t16\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n#define KDB_CMD_HISTORY_COUNT\t32\n\nstatic int handle_ctrl_cmd(char *cmd)\n{\n#define CTRL_P\t16\n#define CTRL_N\t14\n\n\t/* initial situation */\n\tif (cmd_head == cmd_tail)\n\t\treturn 0;\n\tswitch (*cmd) {\n\tcase CTRL_P:\n\t\tif (cmdptr != cmd_tail)\n\t\t\tcmdptr = (cmdptr-1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\tcase CTRL_N:\n\t\tif (cmdptr != cmd_head)\n\t\t\tcmdptr = (cmdptr+1) % KDB_CMD_HISTORY_COUNT;\n\t\tstrncpy(cmd_cur, cmd_hist[cmdptr], CMD_BUFLEN);\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "911-1091",
    "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define MAXARGC\t20",
      "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
    ],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
      "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"\\n\""
          ],
          "line": 1088
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_symbol_print",
          "args": [
            "value",
            "NULL",
            "KDB_SP_DEFAULT"
          ],
          "line": 1087
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_symbol_print",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "258-294",
          "snippet": "void kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nvoid kdb_symbol_print(unsigned long addr, const kdb_symtab_t *symtab_p,\n\t\t      unsigned int punc)\n{\n\tkdb_symtab_t symtab, *symtab_p2;\n\tif (symtab_p) {\n\t\tsymtab_p2 = (kdb_symtab_t *)symtab_p;\n\t} else {\n\t\tsymtab_p2 = &symtab;\n\t\tkdbnearsym(addr, symtab_p2);\n\t}\n\tif (!(symtab_p2->sym_name || (punc & KDB_SP_VALUE)))\n\t\treturn;\n\tif (punc & KDB_SP_SPACEB)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_VALUE)\n\t\tkdb_printf(kdb_machreg_fmt0, addr);\n\tif (symtab_p2->sym_name) {\n\t\tif (punc & KDB_SP_VALUE)\n\t\t\tkdb_printf(\" \");\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\"(\");\n\t\tif (strcmp(symtab_p2->mod_name, \"kernel\"))\n\t\t\tkdb_printf(\"[%s]\", symtab_p2->mod_name);\n\t\tkdb_printf(\"%s\", symtab_p2->sym_name);\n\t\tif (addr != symtab_p2->sym_start)\n\t\t\tkdb_printf(\"+0x%lx\", addr - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_SYMSIZE)\n\t\t\tkdb_printf(\"/0x%lx\",\n\t\t\t\t   symtab_p2->sym_end - symtab_p2->sym_start);\n\t\tif (punc & KDB_SP_PAREN)\n\t\t\tkdb_printf(\")\");\n\t}\n\tif (punc & KDB_SP_SPACEA)\n\t\tkdb_printf(\" \");\n\tif (punc & KDB_SP_NEWLINE)\n\t\tkdb_printf(\"\\n\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetaddrarg",
          "args": [
            "0",
            "(const char **)argv",
            "&nextarg",
            "&value",
            "&offset",
            "&name"
          ],
          "line": 1081
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetaddrarg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "494-626",
          "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "KDB_STATE_CLEAR",
          "args": [
            "CMD"
          ],
          "line": 1057
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "argc-1",
            "(const char **)argv"
          ],
          "line": 1054
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "CMD"
          ],
          "line": 1053
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "tp->cmd_flags",
            "kdb_cmd_enabled",
            "argc <= 1"
          ],
          "line": 1050
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "204-218",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[0]",
            "tp->cmd_name",
            "strlen(tp->cmd_name)"
          ],
          "line": 1038
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "tp->cmd_name"
          ],
          "line": 1040
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "tp",
            "i"
          ],
          "line": 1036
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[0]",
            "tp->cmd_name"
          ],
          "line": 1025
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "argv[0]",
            "tp->cmd_name",
            "tp->cmd_minlen"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_kdbcmd",
          "args": [
            "tp",
            "i"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_defcmd2",
          "args": [
            "cmdstr",
            "argv[0]"
          ],
          "line": 996
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_defcmd2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "674-705",
          "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse_grep",
          "args": [
            "cp"
          ],
          "line": 994
        },
        "resolved": true,
        "details": {
          "function_name": "parse_grep",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "822-881",
          "snippet": "static void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (strncmp(cp, \"grep \", 5)) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char kdb_grep_string[KDB_GREP_STRLEN];",
            "int kdb_grepping_flag;",
            "int kdb_grep_leading;",
            "int kdb_grep_trailing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_grep_leading;\nint kdb_grep_trailing;\n\nstatic void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (strncmp(cp, \"grep \", 5)) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 966
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 939
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_STATE_SET",
          "args": [
            "PAGER"
          ],
          "line": 930
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG_CLEAR",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 929
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KDB_FLAG",
          "args": [
            "CMD_INTERRUPT"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
  },
  {
    "function_name": "parse_grep",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "822-881",
    "snippet": "static void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (strncmp(cp, \"grep \", 5)) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char kdb_grep_string[KDB_GREP_STRLEN];",
      "int kdb_grepping_flag;",
      "int kdb_grep_leading;",
      "int kdb_grep_trailing;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "kdb_grep_string",
            "cp"
          ],
          "line": 878
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"search string too long\\n\""
          ],
          "line": 875
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cp"
          ],
          "line": 871
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'\"'"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cp",
            "'\\n'"
          ],
          "line": 840
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 838
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "cp",
            "\"grep \"",
            "5"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isspace",
          "args": [
            "*cp"
          ],
          "line": 831
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar kdb_grep_string[KDB_GREP_STRLEN];\nint kdb_grepping_flag;\nint kdb_grep_leading;\nint kdb_grep_trailing;\n\nstatic void parse_grep(const char *str)\n{\n\tint\tlen;\n\tchar\t*cp = (char *)str, *cp2;\n\n\t/* sanity check: we should have been called with the \\ first */\n\tif (*cp != '|')\n\t\treturn;\n\tcp++;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tif (strncmp(cp, \"grep \", 5)) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\tcp += 5;\n\twhile (isspace(*cp))\n\t\tcp++;\n\tcp2 = strchr(cp, '\\n');\n\tif (cp2)\n\t\t*cp2 = '\\0'; /* remove the trailing newline */\n\tlen = strlen(cp);\n\tif (len == 0) {\n\t\tkdb_printf(\"invalid 'pipe', see grephelp\\n\");\n\t\treturn;\n\t}\n\t/* now cp points to a nonzero length search string */\n\tif (*cp == '\"') {\n\t\t/* allow it be \"x y z\" by removing the \"'s - there must\n\t\t   be two of them */\n\t\tcp++;\n\t\tcp2 = strchr(cp, '\"');\n\t\tif (!cp2) {\n\t\t\tkdb_printf(\"invalid quoted string, see grephelp\\n\");\n\t\t\treturn;\n\t\t}\n\t\t*cp2 = '\\0'; /* end the string where the 2nd \" was */\n\t}\n\tkdb_grep_leading = 0;\n\tif (*cp == '^') {\n\t\tkdb_grep_leading = 1;\n\t\tcp++;\n\t}\n\tlen = strlen(cp);\n\tkdb_grep_trailing = 0;\n\tif (*(cp+len-1) == '$') {\n\t\tkdb_grep_trailing = 1;\n\t\t*(cp+len-1) = '\\0';\n\t}\n\tlen = strlen(cp);\n\tif (!len)\n\t\treturn;\n\tif (len >= KDB_GREP_STRLEN) {\n\t\tkdb_printf(\"search string too long\\n\");\n\t\treturn;\n\t}\n\tstrcpy(kdb_grep_string, cp);\n\tkdb_grepping_flag++;\n\treturn;\n}"
  },
  {
    "function_name": "kdb_exec_defcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "783-808",
    "snippet": "static int kdb_exec_defcmd(int argc, const char **argv)\n{\n\tint i, ret;\n\tstruct defcmd_set *s;\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\tfor (s = defcmd_set, i = 0; i < defcmd_set_count; ++i, ++s) {\n\t\tif (strcmp(s->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == defcmd_set_count) {\n\t\tkdb_printf(\"kdb_exec_defcmd: could not find commands for %s\\n\",\n\t\t\t   argv[0]);\n\t\treturn KDB_NOTIMP;\n\t}\n\tfor (i = 0; i < s->count; ++i) {\n\t\t/* Recursive use of kdb_parse, do not use argv after\n\t\t * this point */\n\t\targv = NULL;\n\t\tkdb_printf(\"[%s]kdb> %s\\n\", s->name, s->command[i]);\n\t\tret = kdb_parse(s->command[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_parse",
          "args": [
            "s->command[i]"
          ],
          "line": 803
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "911-1091",
          "snippet": "int kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define MAXARGC\t20",
            "#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */"
          ],
          "globals_used": [
            "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define MAXARGC\t20\n#define CMD_BUFLEN\t\t200\t/* kdb_printf: max printline\n\t\t\t\t\t * size == 256 */\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_parse(const char *cmdstr)\n{\n\tstatic char *argv[MAXARGC];\n\tstatic int argc;\n\tstatic char cbuf[CMD_BUFLEN+2];\n\tchar *cp;\n\tchar *cpp, quoted;\n\tkdbtab_t *tp;\n\tint i, escaped, ignore_errors = 0, check_grep = 0;\n\n\t/*\n\t * First tokenize the command string.\n\t */\n\tcp = (char *)cmdstr;\n\n\tif (KDB_FLAG(CMD_INTERRUPT)) {\n\t\t/* Previous command was interrupted, newline must not\n\t\t * repeat the command */\n\t\tKDB_FLAG_CLEAR(CMD_INTERRUPT);\n\t\tKDB_STATE_SET(PAGER);\n\t\targc = 0;\t/* no repeat */\n\t}\n\n\tif (*cp != '\\n' && *cp != '\\0') {\n\t\targc = 0;\n\t\tcpp = cbuf;\n\t\twhile (*cp) {\n\t\t\t/* skip whitespace */\n\t\t\twhile (isspace(*cp))\n\t\t\t\tcp++;\n\t\t\tif ((*cp == '\\0') || (*cp == '\\n') ||\n\t\t\t    (*cp == '#' && !defcmd_in_progress))\n\t\t\t\tbreak;\n\t\t\t/* special case: check for | grep pattern */\n\t\t\tif (*cp == '|') {\n\t\t\t\tcheck_grep++;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (cpp >= cbuf + CMD_BUFLEN) {\n\t\t\t\tkdb_printf(\"kdb_parse: command buffer \"\n\t\t\t\t\t   \"overflow, command ignored\\n%s\\n\",\n\t\t\t\t\t   cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\tif (argc >= MAXARGC - 1) {\n\t\t\t\tkdb_printf(\"kdb_parse: too many arguments, \"\n\t\t\t\t\t   \"command ignored\\n%s\\n\", cmdstr);\n\t\t\t\treturn KDB_NOTFOUND;\n\t\t\t}\n\t\t\targv[argc++] = cpp;\n\t\t\tescaped = 0;\n\t\t\tquoted = '\\0';\n\t\t\t/* Copy to next unquoted and unescaped\n\t\t\t * whitespace or '=' */\n\t\t\twhile (*cp && *cp != '\\n' &&\n\t\t\t       (escaped || quoted || !isspace(*cp))) {\n\t\t\t\tif (cpp >= cbuf + CMD_BUFLEN)\n\t\t\t\t\tbreak;\n\t\t\t\tif (escaped) {\n\t\t\t\t\tescaped = 0;\n\t\t\t\t\t*cpp++ = *cp++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == '\\\\') {\n\t\t\t\t\tescaped = 1;\n\t\t\t\t\t++cp;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (*cp == quoted)\n\t\t\t\t\tquoted = '\\0';\n\t\t\t\telse if (*cp == '\\'' || *cp == '\"')\n\t\t\t\t\tquoted = *cp;\n\t\t\t\t*cpp = *cp++;\n\t\t\t\tif (*cpp == '=' && !quoted)\n\t\t\t\t\tbreak;\n\t\t\t\t++cpp;\n\t\t\t}\n\t\t\t*cpp++ = '\\0';\t/* Squash a ws or '=' character */\n\t\t}\n\t}\n\tif (!argc)\n\t\treturn 0;\n\tif (check_grep)\n\t\tparse_grep(cp);\n\tif (defcmd_in_progress) {\n\t\tint result = kdb_defcmd2(cmdstr, argv[0]);\n\t\tif (!defcmd_in_progress) {\n\t\t\targc = 0;\t/* avoid repeat on endefcmd */\n\t\t\t*(argv[0]) = '\\0';\n\t\t}\n\t\treturn result;\n\t}\n\tif (argv[0][0] == '-' && argv[0][1] &&\n\t    (argv[0][1] < '0' || argv[0][1] > '9')) {\n\t\tignore_errors = 1;\n\t\t++argv[0];\n\t}\n\n\tfor_each_kdbcmd(tp, i) {\n\t\tif (tp->cmd_name) {\n\t\t\t/*\n\t\t\t * If this command is allowed to be abbreviated,\n\t\t\t * check to see if this is it.\n\t\t\t */\n\n\t\t\tif (tp->cmd_minlen\n\t\t\t && (strlen(argv[0]) <= tp->cmd_minlen)) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    tp->cmd_minlen) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (strcmp(argv[0], tp->cmd_name) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t}\n\n\t/*\n\t * If we don't find a command by this name, see if the first\n\t * few characters of this match any of the known commands.\n\t * e.g., md1c20 should match md.\n\t */\n\tif (i == kdb_max_commands) {\n\t\tfor_each_kdbcmd(tp, i) {\n\t\t\tif (tp->cmd_name) {\n\t\t\t\tif (strncmp(argv[0],\n\t\t\t\t\t    tp->cmd_name,\n\t\t\t\t\t    strlen(tp->cmd_name)) == 0) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tif (i < kdb_max_commands) {\n\t\tint result;\n\n\t\tif (!kdb_check_flags(tp->cmd_flags, kdb_cmd_enabled, argc <= 1))\n\t\t\treturn KDB_NOPERM;\n\n\t\tKDB_STATE_SET(CMD);\n\t\tresult = (*tp->cmd_func)(argc-1, (const char **)argv);\n\t\tif (result && ignore_errors && result > KDB_CMD_GO)\n\t\t\tresult = 0;\n\t\tKDB_STATE_CLEAR(CMD);\n\n\t\tif (tp->cmd_flags & KDB_REPEAT_WITH_ARGS)\n\t\t\treturn result;\n\n\t\targc = tp->cmd_flags & KDB_REPEAT_NO_ARGS ? 1 : 0;\n\t\tif (argv[argc])\n\t\t\t*(argv[argc]) = '\\0';\n\t\treturn result;\n\t}\n\n\t/*\n\t * If the input with which we were presented does not\n\t * map to an existing command, attempt to parse it as an\n\t * address argument and display the result.   Useful for\n\t * obtaining the address of a variable, or the nearest symbol\n\t * to an address contained in a register.\n\t */\n\t{\n\t\tunsigned long value;\n\t\tchar *name = NULL;\n\t\tlong offset;\n\t\tint nextarg = 0;\n\n\t\tif (kdbgetaddrarg(0, (const char **)argv, &nextarg,\n\t\t\t\t  &value, &offset, &name)) {\n\t\t\treturn KDB_NOTFOUND;\n\t\t}\n\n\t\tkdb_printf(\"%s = \", argv[0]);\n\t\tkdb_symbol_print(value, NULL, KDB_SP_DEFAULT);\n\t\tkdb_printf(\"\\n\");\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"[%s]kdb> %s\\n\"",
            "s->name",
            "s->command[i]"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "s->name",
            "argv[0]"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_exec_defcmd(int argc, const char **argv)\n{\n\tint i, ret;\n\tstruct defcmd_set *s;\n\tif (argc != 0)\n\t\treturn KDB_ARGCOUNT;\n\tfor (s = defcmd_set, i = 0; i < defcmd_set_count; ++i, ++s) {\n\t\tif (strcmp(s->name, argv[0]) == 0)\n\t\t\tbreak;\n\t}\n\tif (i == defcmd_set_count) {\n\t\tkdb_printf(\"kdb_exec_defcmd: could not find commands for %s\\n\",\n\t\t\t   argv[0]);\n\t\treturn KDB_NOTIMP;\n\t}\n\tfor (i = 0; i < s->count; ++i) {\n\t\t/* Recursive use of kdb_parse, do not use argv after\n\t\t * this point */\n\t\targv = NULL;\n\t\tkdb_printf(\"[%s]kdb> %s\\n\", s->name, s->command[i]);\n\t\tret = kdb_parse(s->command[i]);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_defcmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "707-772",
    "snippet": "static int kdb_defcmd(int argc, const char **argv)\n{\n\tstruct defcmd_set *save_defcmd_set = defcmd_set, *s;\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"kdb: nested defcmd detected, assuming missing \"\n\t\t\t   \"endefcmd\\n\");\n\t\tkdb_defcmd2(\"endefcmd\", \"endefcmd\");\n\t}\n\tif (argc == 0) {\n\t\tint i;\n\t\tfor (s = defcmd_set; s < defcmd_set + defcmd_set_count; ++s) {\n\t\t\tkdb_printf(\"defcmd %s \\\"%s\\\" \\\"%s\\\"\\n\", s->name,\n\t\t\t\t   s->usage, s->help);\n\t\t\tfor (i = 0; i < s->count; ++i)\n\t\t\t\tkdb_printf(\"%s\", s->command[i]);\n\t\t\tkdb_printf(\"endefcmd\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (argc != 3)\n\t\treturn KDB_ARGCOUNT;\n\tif (in_dbg_master()) {\n\t\tkdb_printf(\"Command only available during kdb_init()\\n\");\n\t\treturn KDB_NOTIMP;\n\t}\n\tdefcmd_set = kmalloc_array(defcmd_set_count + 1, sizeof(*defcmd_set),\n\t\t\t\t   GFP_KDB);\n\tif (!defcmd_set)\n\t\tgoto fail_defcmd;\n\tmemcpy(defcmd_set, save_defcmd_set,\n\t       defcmd_set_count * sizeof(*defcmd_set));\n\ts = defcmd_set + defcmd_set_count;\n\tmemset(s, 0, sizeof(*s));\n\ts->usable = 1;\n\ts->name = kdb_strdup(argv[1], GFP_KDB);\n\tif (!s->name)\n\t\tgoto fail_name;\n\ts->usage = kdb_strdup(argv[2], GFP_KDB);\n\tif (!s->usage)\n\t\tgoto fail_usage;\n\ts->help = kdb_strdup(argv[3], GFP_KDB);\n\tif (!s->help)\n\t\tgoto fail_help;\n\tif (s->usage[0] == '\"') {\n\t\tstrcpy(s->usage, argv[2]+1);\n\t\ts->usage[strlen(s->usage)-1] = '\\0';\n\t}\n\tif (s->help[0] == '\"') {\n\t\tstrcpy(s->help, argv[3]+1);\n\t\ts->help[strlen(s->help)-1] = '\\0';\n\t}\n\t++defcmd_set_count;\n\tdefcmd_in_progress = 1;\n\tkfree(save_defcmd_set);\n\treturn 0;\nfail_help:\n\tkfree(s->usage);\nfail_usage:\n\tkfree(s->name);\nfail_name:\n\tkfree(defcmd_set);\nfail_defcmd:\n\tkdb_printf(\"Could not allocate new defcmd_set entry for %s\\n\", argv[1]);\n\tdefcmd_set = save_defcmd_set;\n\treturn KDB_NOTIMP;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Could not allocate new defcmd_set entry for %s\\n\"",
            "argv[1]"
          ],
          "line": 769
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "defcmd_set"
          ],
          "line": 767
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "s->help"
          ],
          "line": 756
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s->help",
            "argv[3]+1"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcpy",
          "args": [
            "s->usage",
            "argv[2]+1"
          ],
          "line": 751
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_strdup",
          "args": [
            "argv[3]",
            "GFP_KDB"
          ],
          "line": 747
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "307-314",
          "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "s",
            "0",
            "sizeof(*s)"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "defcmd_set",
            "save_defcmd_set",
            "defcmd_set_count * sizeof(*defcmd_set)"
          ],
          "line": 736
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc_array",
          "args": [
            "defcmd_set_count + 1",
            "sizeof(*defcmd_set)",
            "GFP_KDB"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_dbg_master",
          "args": [],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_defcmd2",
          "args": [
            "\"endefcmd\"",
            "\"endefcmd\""
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_defcmd2",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "674-705",
          "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd(int argc, const char **argv)\n{\n\tstruct defcmd_set *save_defcmd_set = defcmd_set, *s;\n\tif (defcmd_in_progress) {\n\t\tkdb_printf(\"kdb: nested defcmd detected, assuming missing \"\n\t\t\t   \"endefcmd\\n\");\n\t\tkdb_defcmd2(\"endefcmd\", \"endefcmd\");\n\t}\n\tif (argc == 0) {\n\t\tint i;\n\t\tfor (s = defcmd_set; s < defcmd_set + defcmd_set_count; ++s) {\n\t\t\tkdb_printf(\"defcmd %s \\\"%s\\\" \\\"%s\\\"\\n\", s->name,\n\t\t\t\t   s->usage, s->help);\n\t\t\tfor (i = 0; i < s->count; ++i)\n\t\t\t\tkdb_printf(\"%s\", s->command[i]);\n\t\t\tkdb_printf(\"endefcmd\\n\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (argc != 3)\n\t\treturn KDB_ARGCOUNT;\n\tif (in_dbg_master()) {\n\t\tkdb_printf(\"Command only available during kdb_init()\\n\");\n\t\treturn KDB_NOTIMP;\n\t}\n\tdefcmd_set = kmalloc_array(defcmd_set_count + 1, sizeof(*defcmd_set),\n\t\t\t\t   GFP_KDB);\n\tif (!defcmd_set)\n\t\tgoto fail_defcmd;\n\tmemcpy(defcmd_set, save_defcmd_set,\n\t       defcmd_set_count * sizeof(*defcmd_set));\n\ts = defcmd_set + defcmd_set_count;\n\tmemset(s, 0, sizeof(*s));\n\ts->usable = 1;\n\ts->name = kdb_strdup(argv[1], GFP_KDB);\n\tif (!s->name)\n\t\tgoto fail_name;\n\ts->usage = kdb_strdup(argv[2], GFP_KDB);\n\tif (!s->usage)\n\t\tgoto fail_usage;\n\ts->help = kdb_strdup(argv[3], GFP_KDB);\n\tif (!s->help)\n\t\tgoto fail_help;\n\tif (s->usage[0] == '\"') {\n\t\tstrcpy(s->usage, argv[2]+1);\n\t\ts->usage[strlen(s->usage)-1] = '\\0';\n\t}\n\tif (s->help[0] == '\"') {\n\t\tstrcpy(s->help, argv[3]+1);\n\t\ts->help[strlen(s->help)-1] = '\\0';\n\t}\n\t++defcmd_set_count;\n\tdefcmd_in_progress = 1;\n\tkfree(save_defcmd_set);\n\treturn 0;\nfail_help:\n\tkfree(s->usage);\nfail_usage:\n\tkfree(s->name);\nfail_name:\n\tkfree(defcmd_set);\nfail_defcmd:\n\tkdb_printf(\"Could not allocate new defcmd_set entry for %s\\n\", argv[1]);\n\tdefcmd_set = save_defcmd_set;\n\treturn KDB_NOTIMP;\n}"
  },
  {
    "function_name": "kdb_defcmd2",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "674-705",
    "snippet": "static int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "save_command"
          ],
          "line": 703
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kfree",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "803-860",
          "snippet": "void debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid debug_kfree(void *p)\n{\n\tstruct debug_alloc_header *h;\n\tunsigned int h_offset;\n\tif (!p)\n\t\treturn;\n\tif ((char *)p < debug_alloc_pool ||\n\t    (char *)p >= debug_alloc_pool + sizeof(debug_alloc_pool_aligned)) {\n\t\tkfree(p);\n\t\treturn;\n\t}\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn;\t\t/* memory leak, cannot be helped */\n\t}\n\th = (struct debug_alloc_header *)((char *)p - dah_overhead);\n\tmemset(p, POISON_FREE, h->size - 1);\n\t*((char *)p + h->size - 1) = POISON_END;\n\th->caller = NULL;\n\tdah_used -= h->size;\n\th_offset = (char *)h - debug_alloc_pool;\n\tif (h_offset < dah_first) {\n\t\th->next = dah_first;\n\t\tdah_first = h_offset;\n\t} else {\n\t\tstruct debug_alloc_header *prev;\n\t\tunsigned int prev_offset;\n\t\tprev = (struct debug_alloc_header *)(debug_alloc_pool +\n\t\t\t\t\t\t     dah_first);\n\t\twhile (1) {\n\t\t\tif (!prev->next || prev->next > h_offset)\n\t\t\t\tbreak;\n\t\t\tprev = (struct debug_alloc_header *)\n\t\t\t\t(debug_alloc_pool + prev->next);\n\t\t}\n\t\tprev_offset = (char *)prev - debug_alloc_pool;\n\t\tif (prev_offset + dah_overhead + prev->size == h_offset) {\n\t\t\tprev->size += dah_overhead + h->size;\n\t\t\tmemset(h, POISON_FREE, dah_overhead - 1);\n\t\t\t*((char *)h + dah_overhead - 1) = POISON_END;\n\t\t\th = prev;\n\t\t\th_offset = prev_offset;\n\t\t} else {\n\t\t\th->next = prev->next;\n\t\t\tprev->next = h_offset;\n\t\t}\n\t}\n\tif (h_offset + dah_overhead + h->size == h->next) {\n\t\tstruct debug_alloc_header *next;\n\t\tnext = (struct debug_alloc_header *)\n\t\t\t(debug_alloc_pool + h->next);\n\t\th->size += dah_overhead + next->size;\n\t\th->next = next->next;\n\t\tmemset(next, POISON_FREE, dah_overhead - 1);\n\t\t*((char *)next + dah_overhead - 1) = POISON_END;\n\t}\n\tspin_unlock(&dap_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_strdup",
          "args": [
            "cmdstr",
            "GFP_KDB"
          ],
          "line": 702
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_strdup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "307-314",
          "snippet": "char *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nchar *kdb_strdup(const char *str, gfp_t type)\n{\n\tint n = strlen(str)+1;\n\tchar *s = kmalloc(n, type);\n\tif (!s)\n\t\treturn NULL;\n\treturn strcpy(s, str);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "s->command",
            "save_command",
            "s->count * sizeof(*(s->command))"
          ],
          "line": 701
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Could not allocate new kdb_defcmd table for %s\\n\"",
            "cmdstr"
          ],
          "line": 696
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kcalloc",
          "args": [
            "s->count + 1",
            "sizeof(*(s->command))",
            "GFP_KDB"
          ],
          "line": 694
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_register_flags",
          "args": [
            "s->name",
            "kdb_exec_defcmd",
            "s->usage",
            "s->help",
            "0",
            "KDB_ENABLE_ALWAYS_SAFE"
          ],
          "line": 687
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_register_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2674-2734",
          "snippet": "int kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define kdb_command_extend 50\t/* arbitrary */",
            "#define KDB_BASE_CMD_MAX 50"
          ],
          "globals_used": [
            "static kdbtab_t *kdb_commands;",
            "static int kdb_max_commands = KDB_BASE_CMD_MAX;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define kdb_command_extend 50\t/* arbitrary */\n#define KDB_BASE_CMD_MAX 50\n\nstatic kdbtab_t *kdb_commands;\nstatic int kdb_max_commands = KDB_BASE_CMD_MAX;\n\nint kdb_register_flags(char *cmd,\n\t\t       kdb_func_t func,\n\t\t       char *usage,\n\t\t       char *help,\n\t\t       short minlen,\n\t\t       kdb_cmdflags_t flags)\n{\n\tint i;\n\tkdbtab_t *kp;\n\n\t/*\n\t *  Brute force method to determine duplicates\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name && (strcmp(kp->cmd_name, cmd) == 0)) {\n\t\t\tkdb_printf(\"Duplicate kdb command registered: \"\n\t\t\t\t\"%s, func %p help %s\\n\", cmd, func, help);\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\t/*\n\t * Insert command into first available location in table\n\t */\n\tfor_each_kdbcmd(kp, i) {\n\t\tif (kp->cmd_name == NULL)\n\t\t\tbreak;\n\t}\n\n\tif (i >= kdb_max_commands) {\n\t\tkdbtab_t *new = kmalloc_array(kdb_max_commands -\n\t\t\t\t\t\tKDB_BASE_CMD_MAX +\n\t\t\t\t\t\tkdb_command_extend,\n\t\t\t\t\t      sizeof(*new),\n\t\t\t\t\t      GFP_KDB);\n\t\tif (!new) {\n\t\t\tkdb_printf(\"Could not allocate new kdb_command \"\n\t\t\t\t   \"table\\n\");\n\t\t\treturn 1;\n\t\t}\n\t\tif (kdb_commands) {\n\t\t\tmemcpy(new, kdb_commands,\n\t\t\t  (kdb_max_commands - KDB_BASE_CMD_MAX) * sizeof(*new));\n\t\t\tkfree(kdb_commands);\n\t\t}\n\t\tmemset(new + kdb_max_commands - KDB_BASE_CMD_MAX, 0,\n\t\t       kdb_command_extend * sizeof(*new));\n\t\tkdb_commands = new;\n\t\tkp = kdb_commands + kdb_max_commands - KDB_BASE_CMD_MAX;\n\t\tkdb_max_commands += kdb_command_extend;\n\t}\n\n\tkp->cmd_name   = cmd;\n\tkp->cmd_func   = func;\n\tkp->cmd_usage  = usage;\n\tkp->cmd_help   = help;\n\tkp->cmd_minlen = minlen;\n\tkp->cmd_flags  = flags;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv0",
            "\"endefcmd\""
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_defcmd2(const char *cmdstr, const char *argv0)\n{\n\tstruct defcmd_set *s = defcmd_set + defcmd_set_count - 1;\n\tchar **save_command = s->command;\n\tif (strcmp(argv0, \"endefcmd\") == 0) {\n\t\tdefcmd_in_progress = 0;\n\t\tif (!s->count)\n\t\t\ts->usable = 0;\n\t\tif (s->usable)\n\t\t\t/* macros are always safe because when executed each\n\t\t\t * internal command re-enters kdb_parse() and is\n\t\t\t * safety checked individually.\n\t\t\t */\n\t\t\tkdb_register_flags(s->name, kdb_exec_defcmd, s->usage,\n\t\t\t\t\t   s->help, 0,\n\t\t\t\t\t   KDB_ENABLE_ALWAYS_SAFE);\n\t\treturn 0;\n\t}\n\tif (!s->usable)\n\t\treturn KDB_NOTIMP;\n\ts->command = kcalloc(s->count + 1, sizeof(*(s->command)), GFP_KDB);\n\tif (!s->command) {\n\t\tkdb_printf(\"Could not allocate new kdb_defcmd table for %s\\n\",\n\t\t\t   cmdstr);\n\t\ts->usable = 0;\n\t\treturn KDB_NOTIMP;\n\t}\n\tmemcpy(s->command, save_command, s->count * sizeof(*(s->command)));\n\ts->command[s->count++] = kdb_strdup(cmdstr, GFP_KDB);\n\tkfree(save_command);\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_cmderror",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "628-645",
    "snippet": "static void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};",
      "static const int __nkdb_err = ARRAY_SIZE(kdbmsgs);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Unknown diag %d\\n\"",
            "-diag"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic kdbmsg_t kdbmsgs[] = {\n\tKDBMSG(NOTFOUND, \"Command Not Found\"),\n\tKDBMSG(ARGCOUNT, \"Improper argument count, see usage.\"),\n\tKDBMSG(BADWIDTH, \"Illegal value for BYTESPERWORD use 1, 2, 4 or 8, \"\n\t       \"8 is only allowed on 64 bit systems\"),\n\tKDBMSG(BADRADIX, \"Illegal value for RADIX use 8, 10 or 16\"),\n\tKDBMSG(NOTENV, \"Cannot find environment variable\"),\n\tKDBMSG(NOENVVALUE, \"Environment variable should have value\"),\n\tKDBMSG(NOTIMP, \"Command not implemented\"),\n\tKDBMSG(ENVFULL, \"Environment full\"),\n\tKDBMSG(ENVBUFFULL, \"Environment buffer full\"),\n\tKDBMSG(TOOMANYBPT, \"Too many breakpoints defined\"),\n#ifdef CONFIG_CPU_XSCALE\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than ibcr registers defined\"),\n#else\n\tKDBMSG(TOOMANYDBREGS, \"More breakpoints than db registers defined\"),\n#endif\n\tKDBMSG(DUPBPT, \"Duplicate breakpoint address\"),\n\tKDBMSG(BPTNOTFOUND, \"Breakpoint not found\"),\n\tKDBMSG(BADMODE, \"Invalid IDMODE\"),\n\tKDBMSG(BADINT, \"Illegal numeric value\"),\n\tKDBMSG(INVADDRFMT, \"Invalid symbolic address format\"),\n\tKDBMSG(BADREG, \"Invalid register name\"),\n\tKDBMSG(BADCPUNUM, \"Invalid cpu number\"),\n\tKDBMSG(BADLENGTH, \"Invalid length field\"),\n\tKDBMSG(NOBP, \"No Breakpoint exists\"),\n\tKDBMSG(BADADDR, \"Invalid address\"),\n\tKDBMSG(NOPERM, \"Permission denied\"),\n};\nstatic const int __nkdb_err = ARRAY_SIZE(kdbmsgs);\n\nstatic void kdb_cmderror(int diag)\n{\n\tint i;\n\n\tif (diag >= 0) {\n\t\tkdb_printf(\"no error detected (diagnostic is %d)\\n\", diag);\n\t\treturn;\n\t}\n\n\tfor (i = 0; i < __nkdb_err; i++) {\n\t\tif (kdbmsgs[i].km_diag == diag) {\n\t\t\tkdb_printf(\"diag: %d: %s\\n\", diag, kdbmsgs[i].km_msg);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tkdb_printf(\"Unknown diag %d\\n\", -diag);\n}"
  },
  {
    "function_name": "kdbgetaddrarg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "494-626",
    "snippet": "int kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetularg",
          "args": [
            "cp",
            "&off"
          ],
          "line": 612
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetularg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "337-357",
          "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbnearsym",
          "args": [
            "addr",
            "&symtab"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "kdbnearsym",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "82-159",
          "snippet": "int kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define knt1_size 128\t\t/* must be >= kallsyms table size */"
          ],
          "globals_used": [
            "static char *kdb_name_table[100];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\nstatic char *kdb_name_table[100];\n\nint kdbnearsym(unsigned long addr, kdb_symtab_t *symtab)\n{\n\tint ret = 0;\n\tunsigned long symbolsize = 0;\n\tunsigned long offset = 0;\n#define knt1_size 128\t\t/* must be >= kallsyms table size */\n\tchar *knt1 = NULL;\n\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx, symtab=%p\\n\", addr, symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\n\tif (addr < 4096)\n\t\tgoto out;\n\tknt1 = debug_kmalloc(knt1_size, GFP_ATOMIC);\n\tif (!knt1) {\n\t\tkdb_printf(\"kdbnearsym: addr=0x%lx cannot kmalloc knt1\\n\",\n\t\t\t   addr);\n\t\tgoto out;\n\t}\n\tsymtab->sym_name = kallsyms_lookup(addr, &symbolsize , &offset,\n\t\t\t\t(char **)(&symtab->mod_name), knt1);\n\tif (offset > 8*1024*1024) {\n\t\tsymtab->sym_name = NULL;\n\t\taddr = offset = symbolsize = 0;\n\t}\n\tsymtab->sym_start = addr - offset;\n\tsymtab->sym_end = symtab->sym_start + symbolsize;\n\tret = symtab->sym_name != NULL && *(symtab->sym_name) != '\\0';\n\n\tif (ret) {\n\t\tint i;\n\t\t/* Another 2.6 kallsyms \"feature\".  Sometimes the sym_name is\n\t\t * set but the buffer passed into kallsyms_lookup is not used,\n\t\t * so it contains garbage.  The caller has to work out which\n\t\t * buffer needs to be saved.\n\t\t *\n\t\t * What was Rusty smoking when he wrote that code?\n\t\t */\n\t\tif (symtab->sym_name != knt1) {\n\t\t\tstrncpy(knt1, symtab->sym_name, knt1_size);\n\t\t\tknt1[knt1_size-1] = '\\0';\n\t\t}\n\t\tfor (i = 0; i < ARRAY_SIZE(kdb_name_table); ++i) {\n\t\t\tif (kdb_name_table[i] &&\n\t\t\t    strcmp(kdb_name_table[i], knt1) == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (i >= ARRAY_SIZE(kdb_name_table)) {\n\t\t\tdebug_kfree(kdb_name_table[0]);\n\t\t\tmemmove(kdb_name_table, kdb_name_table+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-1));\n\t\t} else {\n\t\t\tdebug_kfree(knt1);\n\t\t\tknt1 = kdb_name_table[i];\n\t\t\tmemmove(kdb_name_table+i, kdb_name_table+i+1,\n\t\t\t       sizeof(kdb_name_table[0]) *\n\t\t\t       (ARRAY_SIZE(kdb_name_table)-i-1));\n\t\t}\n\t\ti = ARRAY_SIZE(kdb_name_table) - 1;\n\t\tkdb_name_table[i] = knt1;\n\t\tsymtab->sym_name = kdb_name_table[i];\n\t\tknt1 = NULL;\n\t}\n\n\tif (symtab->mod_name == NULL)\n\t\tsymtab->mod_name = \"kernel\";\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbnearsym: returns %d symtab->sym_start=0x%lx, \"\n\t\t   \"symtab->mod_name=%p, symtab->sym_name=%p (%s)\\n\", ret,\n\t\t   symtab->sym_start, symtab->mod_name, symtab->sym_name,\n\t\t   symtab->sym_name);\n\nout:\n\tdebug_kfree(knt1);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetsymval",
          "args": [
            "symname",
            "&symtab"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetsymval",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "40-57",
          "snippet": "int kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: symname=%s, symtab=%p\\n\", symname,\n\t\t\t   symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tif (KDB_DEBUG(AR))\n\t\t\tkdb_printf(\"kdbgetsymval: returns 1, \"\n\t\t\t\t   \"symtab->sym_start=0x%lx\\n\",\n\t\t\t\t   symtab->sym_start);\n\t\treturn 1;\n\t}\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: returns 0\\n\");\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\nint kdbgetsymval(const char *symname, kdb_symtab_t *symtab)\n{\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: symname=%s, symtab=%p\\n\", symname,\n\t\t\t   symtab);\n\tmemset(symtab, 0, sizeof(*symtab));\n\tsymtab->sym_start = kallsyms_lookup_name(symname);\n\tif (symtab->sym_start) {\n\t\tif (KDB_DEBUG(AR))\n\t\t\tkdb_printf(\"kdbgetsymval: returns 1, \"\n\t\t\t\t   \"symtab->sym_start=0x%lx\\n\",\n\t\t\t\t   symtab->sym_start);\n\t\treturn 1;\n\t}\n\tif (KDB_DEBUG(AR))\n\t\tkdb_printf(\"kdbgetsymval: returns 0\\n\");\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_check_regs",
          "args": [],
          "line": 547
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_regs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "459-467",
          "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct pt_regs *kdb_current_regs;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetulenv",
          "args": [
            "&symname[1]",
            "&addr"
          ],
          "line": 543
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetulenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "291-304",
          "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strpbrk",
          "args": [
            "symname",
            "\"+-\""
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdb_check_flags",
          "args": [
            "KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL",
            "kdb_cmd_enabled",
            "false"
          ],
          "line": 513
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_check_flags",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "204-218",
          "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_cmd_enabled = CONFIG_KDB_DEFAULT_ENABLE;\n\nint kdbgetaddrarg(int argc, const char **argv, int *nextarg,\n\t\t  unsigned long *value,  long *offset,\n\t\t  char **name)\n{\n\tunsigned long addr;\n\tunsigned long off = 0;\n\tint positive;\n\tint diag;\n\tint found = 0;\n\tchar *symname;\n\tchar symbol = '\\0';\n\tchar *cp;\n\tkdb_symtab_t symtab;\n\n\t/*\n\t * If the enable flags prohibit both arbitrary memory access\n\t * and flow control then there are no reasonable grounds to\n\t * provide symbol lookup.\n\t */\n\tif (!kdb_check_flags(KDB_ENABLE_MEM_READ | KDB_ENABLE_FLOW_CTRL,\n\t\t\t     kdb_cmd_enabled, false))\n\t\treturn KDB_NOPERM;\n\n\t/*\n\t * Process arguments which follow the following syntax:\n\t *\n\t *  symbol | numeric-address [+/- numeric-offset]\n\t *  %register\n\t *  $environment-variable\n\t */\n\n\tif (*nextarg > argc)\n\t\treturn KDB_ARGCOUNT;\n\n\tsymname = (char *)argv[*nextarg];\n\n\t/*\n\t * If there is no whitespace between the symbol\n\t * or address and the '+' or '-' symbols, we\n\t * remember the character and replace it with a\n\t * null so the symbol/value can be properly parsed\n\t */\n\tcp = strpbrk(symname, \"+-\");\n\tif (cp != NULL) {\n\t\tsymbol = *cp;\n\t\t*cp++ = '\\0';\n\t}\n\n\tif (symname[0] == '$') {\n\t\tdiag = kdbgetulenv(&symname[1], &addr);\n\t\tif (diag)\n\t\t\treturn diag;\n\t} else if (symname[0] == '%') {\n\t\tdiag = kdb_check_regs();\n\t\tif (diag)\n\t\t\treturn diag;\n\t\t/* Implement register values with % at a later time as it is\n\t\t * arch optional.\n\t\t */\n\t\treturn KDB_NOTIMP;\n\t} else {\n\t\tfound = kdbgetsymval(symname, &symtab);\n\t\tif (found) {\n\t\t\taddr = symtab.sym_start;\n\t\t} else {\n\t\t\tdiag = kdbgetularg(argv[*nextarg], &addr);\n\t\t\tif (diag)\n\t\t\t\treturn diag;\n\t\t}\n\t}\n\n\tif (!found)\n\t\tfound = kdbnearsym(addr, &symtab);\n\n\t(*nextarg)++;\n\n\tif (name)\n\t\t*name = symname;\n\tif (value)\n\t\t*value = addr;\n\tif (offset && name && *name)\n\t\t*offset = addr - symtab.sym_start;\n\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0'))\n\t\treturn 0;\n\n\t/*\n\t * check for +/- and offset\n\t */\n\n\tif (symbol == '\\0') {\n\t\tif ((argv[*nextarg][0] != '+')\n\t\t && (argv[*nextarg][0] != '-')) {\n\t\t\t/*\n\t\t\t * Not our argument.  Return.\n\t\t\t */\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tpositive = (argv[*nextarg][0] == '+');\n\t\t\t(*nextarg)++;\n\t\t}\n\t} else\n\t\tpositive = (symbol == '+');\n\n\t/*\n\t * Now there must be an offset!\n\t */\n\tif ((*nextarg > argc)\n\t && (symbol == '\\0')) {\n\t\treturn KDB_INVADDRFMT;\n\t}\n\n\tif (!symbol) {\n\t\tcp = (char *)argv[*nextarg];\n\t\t(*nextarg)++;\n\t}\n\n\tdiag = kdbgetularg(cp, &off);\n\tif (diag)\n\t\treturn diag;\n\n\tif (!positive)\n\t\toff = -off;\n\n\tif (offset)\n\t\t*offset += off;\n\n\tif (value)\n\t\t*value += off;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_check_regs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "459-467",
    "snippet": "static int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct pt_regs *kdb_current_regs;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\""
          ],
          "line": 462
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct pt_regs *kdb_current_regs;\n\nstatic int kdb_check_regs(void)\n{\n\tif (!kdb_current_regs) {\n\t\tkdb_printf(\"No current kdb registers.\"\n\t\t\t   \"  You may need to select another task\\n\");\n\t\treturn KDB_BADREG;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "kdb_set",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "382-457",
    "snippet": "int kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(KDB_DEBUG_FLAG_MASK << KDB_DEBUG_FLAG_SHIFT))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int kdb_flags;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "__env[i]",
            "argv[1]",
            "varlen"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sprintf",
          "args": [
            "ep",
            "\"%s=%s\"",
            "argv[1]",
            "argv[2]"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kdballocenv",
          "args": [
            "varlen + vallen + 2"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "kdballocenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "267-279",
          "snippet": "static char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [
            "#define\tKDB_ENVBUFSIZE\t512"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define\tKDB_ENVBUFSIZE\t512\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "argv[2]"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"kdb: illegal debug flags '%s'\\n\"",
            "argv[2]"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "argv[2]",
            "&cp",
            "0"
          ],
          "line": 409
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "argv[1]",
            "\"KDBDEBUG\""
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdb_flags;\n\nint kdb_set(int argc, const char **argv)\n{\n\tint i;\n\tchar *ep;\n\tsize_t varlen, vallen;\n\n\t/*\n\t * we can be invoked two ways:\n\t *   set var=value    argv[1]=\"var\", argv[2]=\"value\"\n\t *   set var = value  argv[1]=\"var\", argv[2]=\"=\", argv[3]=\"value\"\n\t * - if the latter, shift 'em down.\n\t */\n\tif (argc == 3) {\n\t\targv[2] = argv[3];\n\t\targc--;\n\t}\n\n\tif (argc != 2)\n\t\treturn KDB_ARGCOUNT;\n\n\t/*\n\t * Check for internal variables\n\t */\n\tif (strcmp(argv[1], \"KDBDEBUG\") == 0) {\n\t\tunsigned int debugflags;\n\t\tchar *cp;\n\n\t\tdebugflags = simple_strtoul(argv[2], &cp, 0);\n\t\tif (cp == argv[2] || debugflags & ~KDB_DEBUG_FLAG_MASK) {\n\t\t\tkdb_printf(\"kdb: illegal debug flags '%s'\\n\",\n\t\t\t\t    argv[2]);\n\t\t\treturn 0;\n\t\t}\n\t\tkdb_flags = (kdb_flags &\n\t\t\t     ~(KDB_DEBUG_FLAG_MASK << KDB_DEBUG_FLAG_SHIFT))\n\t\t\t| (debugflags << KDB_DEBUG_FLAG_SHIFT);\n\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Tokenizer squashed the '=' sign.  argv[1] is variable\n\t * name, argv[2] = value.\n\t */\n\tvarlen = strlen(argv[1]);\n\tvallen = strlen(argv[2]);\n\tep = kdballocenv(varlen + vallen + 2);\n\tif (ep == (char *)0)\n\t\treturn KDB_ENVBUFFULL;\n\n\tsprintf(ep, \"%s=%s\", argv[1], argv[2]);\n\n\tep[varlen+vallen+1] = '\\0';\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tif (__env[i]\n\t\t && ((strncmp(__env[i], argv[1], varlen) == 0)\n\t\t   && ((__env[i][varlen] == '\\0')\n\t\t    || (__env[i][varlen] == '=')))) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/*\n\t * Wasn't existing variable.  Fit into slot.\n\t */\n\tfor (i = 0; i < __nenv-1; i++) {\n\t\tif (__env[i] == (char *)0) {\n\t\t\t__env[i] = ep;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\treturn KDB_ENVFULL;\n}"
  },
  {
    "function_name": "kdbgetu64arg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "359-376",
    "snippet": "int kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "arg",
            "&endp",
            "16"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoull",
          "args": [
            "arg",
            "&endp",
            "0"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetu64arg(const char *arg, u64 *value)\n{\n\tchar *endp;\n\tu64 val;\n\n\tval = simple_strtoull(arg, &endp, 0);\n\n\tif (endp == arg) {\n\n\t\tval = simple_strtoull(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdbgetularg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "337-357",
    "snippet": "int kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&endp",
            "16"
          ],
          "line": 349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "arg",
            "&endp",
            "0"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetularg(const char *arg, unsigned long *value)\n{\n\tchar *endp;\n\tunsigned long val;\n\n\tval = simple_strtoul(arg, &endp, 0);\n\n\tif (endp == arg) {\n\t\t/*\n\t\t * Also try base 16, for us folks too lazy to type the\n\t\t * leading 0x...\n\t\t */\n\t\tval = simple_strtoul(arg, &endp, 16);\n\t\tif (endp == arg)\n\t\t\treturn KDB_BADINT;\n\t}\n\n\t*value = val;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdbgetintenv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "316-325",
    "snippet": "int kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdbgetulenv",
          "args": [
            "match",
            "&val"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetulenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "291-304",
          "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nint kdbgetintenv(const char *match, int *value)\n{\n\tunsigned long val;\n\tint diag;\n\n\tdiag = kdbgetulenv(match, &val);\n\tif (!diag)\n\t\t*value = (int) val;\n\treturn diag;\n}"
  },
  {
    "function_name": "kdbgetulenv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "291-304",
    "snippet": "static int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "simple_strtoul",
          "args": [
            "ep",
            "NULL",
            "0"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "ep"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kdbgetenv",
          "args": [
            "match"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "kdbgetenv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "229-249",
          "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdbgetulenv(const char *match, unsigned long *value)\n{\n\tchar *ep;\n\n\tep = kdbgetenv(match);\n\tif (!ep)\n\t\treturn KDB_NOTENV;\n\tif (strlen(ep) == 0)\n\t\treturn KDB_NOENVVALUE;\n\n\t*value = simple_strtoul(ep, NULL, 0);\n\n\treturn 0;\n}"
  },
  {
    "function_name": "kdballocenv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "267-279",
    "snippet": "static char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [
      "#define\tKDB_ENVBUFSIZE\t512"
    ],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\n#define\tKDB_ENVBUFSIZE\t512\n\nstatic char *kdballocenv(size_t bytes)\n{\n#define\tKDB_ENVBUFSIZE\t512\n\tstatic char envbuffer[KDB_ENVBUFSIZE];\n\tstatic int envbufsize;\n\tchar *ep = NULL;\n\n\tif ((KDB_ENVBUFSIZE - envbufsize) >= bytes) {\n\t\tep = &envbuffer[envbufsize];\n\t\tenvbufsize += bytes;\n\t}\n\treturn ep;\n}"
  },
  {
    "function_name": "kdbgetenv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "229-249",
    "snippet": "char *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "e",
            "'='"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "match",
            "e",
            "matchlen"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "match"
          ],
          "line": 232
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nchar *kdbgetenv(const char *match)\n{\n\tchar **ep = __env;\n\tint matchlen = strlen(match);\n\tint i;\n\n\tfor (i = 0; i < __nenv; i++) {\n\t\tchar *e = *ep++;\n\n\t\tif (!e)\n\t\t\tcontinue;\n\n\t\tif ((strncmp(match, e, matchlen) == 0)\n\t\t && ((e[matchlen] == '\\0')\n\t\t   || (e[matchlen] == '='))) {\n\t\t\tchar *cp = strchr(e, '=');\n\t\t\treturn cp ? ++cp : \"\";\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "kdb_check_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "204-218",
    "snippet": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}"
  },
  {
    "function_name": "kdb_curr_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
    "lines": "190-198",
    "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
    "includes": [
      "#include \"kdb_private.h\"",
      "#include <linux/slab.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/proc_fs.h>",
      "#include <linux/kdebug.h>",
      "#include <linux/cpu.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/time.h>",
      "#include <linux/nmi.h>",
      "#include <linux/delay.h>",
      "#include <linux/interrupt.h>",
      "#include <linux/notifier.h>",
      "#include <linux/kdb.h>",
      "#include <linux/kgdb.h>",
      "#include <linux/kallsyms.h>",
      "#include <linux/init.h>",
      "#include <linux/mm.h>",
      "#include <linux/moduleparam.h>",
      "#include <linux/module.h>",
      "#include <linux/atomic.h>",
      "#include <linux/vmalloc.h>",
      "#include <linux/utsname.h>",
      "#include <linux/smp.h>",
      "#include <linux/sysrq.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/stat.h>",
      "#include <linux/sched/loadavg.h>",
      "#include <linux/sched.h>",
      "#include <linux/reboot.h>",
      "#include <linux/kmsg_dump.h>",
      "#include <linux/kernel.h>",
      "#include <linux/string.h>",
      "#include <linux/types.h>",
      "#include <linux/ctype.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "KDB_TSK",
          "args": [
            "cpu"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_thread_info",
          "args": [
            "p"
          ],
          "line": 194
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "curr_task",
          "args": [
            "cpu"
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_curr_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "190-198",
          "snippet": "struct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}",
          "note": "cyclic_reference_detected"
        }
      }
    ],
    "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstruct task_struct *kdb_curr_task(int cpu)\n{\n\tstruct task_struct *p = curr_task(cpu);\n#ifdef\t_TIF_MCA_INIT\n\tif ((task_thread_info(p)->flags & _TIF_MCA_INIT) && KDB_TSK(cpu))\n\t\tp = krp->p;\n#endif\n\treturn p;\n}"
  }
]