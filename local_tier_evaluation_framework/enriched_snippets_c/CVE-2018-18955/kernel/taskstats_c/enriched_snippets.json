[
  {
    "function_name": "taskstats_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "684-695",
    "snippet": "static int __init taskstats_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&family);\n\tif (rc)\n\t\treturn rc;\n\n\tfamily_registered = 1;\n\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int family_registered;",
      "static struct genl_family family;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"registered taskstats version %d\\n\"",
            "TASKSTATS_GENL_VERSION"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genl_register_family",
          "args": [
            "&family"
          ],
          "line": 688
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int family_registered;\nstatic struct genl_family family;\n\nstatic int __init taskstats_init(void)\n{\n\tint rc;\n\n\trc = genl_register_family(&family);\n\tif (rc)\n\t\treturn rc;\n\n\tfamily_registered = 1;\n\tpr_info(\"registered taskstats version %d\\n\", TASKSTATS_GENL_VERSION);\n\treturn 0;\n}"
  },
  {
    "function_name": "taskstats_init_early",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "673-682",
    "snippet": "void __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *taskstats_cache;",
      "static DEFINE_PER_CPU(struct listener_list, listener_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "init_rwsem",
          "args": [
            "&(per_cpu(listener_array, i).sem)"
          ],
          "line": 680
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "listener_array",
            "i"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&(per_cpu(listener_array, i).list)"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "taskstats",
            "SLAB_PANIC"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstruct kmem_cache *taskstats_cache;\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nvoid __init taskstats_init_early(void)\n{\n\tunsigned int i;\n\n\ttaskstats_cache = KMEM_CACHE(taskstats, SLAB_PANIC);\n\tfor_each_possible_cpu(i) {\n\t\tINIT_LIST_HEAD(&(per_cpu(listener_array, i).list));\n\t\tinit_rwsem(&(per_cpu(listener_array, i).sem));\n\t}\n}"
  },
  {
    "function_name": "taskstats_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "589-647",
    "snippet": "void taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static int family_registered;",
      "static DEFINE_PER_CPU(struct listener_list, listener_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "rep_skb"
          ],
          "line": 646
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_cpu_listeners",
          "args": [
            "rep_skb",
            "listeners"
          ],
          "line": 643
        },
        "resolved": true,
        "details": {
          "function_name": "send_cpu_listeners",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "123-167",
          "snippet": "static void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\tgenlmsg_end(skb, reply);\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\tgenlmsg_end(skb, reply);\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stats",
            "tsk->signal->stats",
            "sizeof(*stats)"
          ],
          "line": 640
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_reply",
          "args": [
            "rep_skb",
            "TASKSTATS_TYPE_TGID",
            "task_tgid_nr_ns(tsk, &init_pid_ns)"
          ],
          "line": 635
        },
        "resolved": true,
        "details": {
          "function_name": "mk_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "369-397",
          "snippet": "static struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "tsk",
            "&init_pid_ns"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_stats",
          "args": [
            "&init_user_ns",
            "&init_pid_ns",
            "tsk",
            "stats"
          ],
          "line": 627
        },
        "resolved": true,
        "details": {
          "function_name": "fill_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "169-191",
          "snippet": "static void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "&init_pid_ns"
          ],
          "line": 623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_reply",
          "args": [
            "NULL",
            "TASKSTATS_CMD_NEW",
            "&rep_skb",
            "size"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "79-105",
          "snippet": "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static struct genl_family family;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic struct genl_family family;\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&listeners->list"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "raw_cpu_ptr",
          "args": [
            "&listener_array"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fill_tgid_exit",
          "args": [
            "tsk"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "fill_tgid_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "268-286",
          "snippet": "static void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_tgid_alloc",
          "args": [
            "tsk"
          ],
          "line": 606
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_tgid_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "564-586",
          "snippet": "static struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "struct kmem_cache *taskstats_cache;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstruct kmem_cache *taskstats_cache;\n\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_packet_size",
          "args": [],
          "line": 604
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_packet_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "481-490",
          "snippet": "static size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int family_registered;\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nvoid taskstats_exit(struct task_struct *tsk, int group_dead)\n{\n\tint rc;\n\tstruct listener_list *listeners;\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tint is_thread_group;\n\n\tif (!family_registered)\n\t\treturn;\n\n\t/*\n\t * Size includes space for nested attributes\n\t */\n\tsize = taskstats_packet_size();\n\n\tis_thread_group = !!taskstats_tgid_alloc(tsk);\n\tif (is_thread_group) {\n\t\t/* PID + STATS + TGID + STATS */\n\t\tsize = 2 * size;\n\t\t/* fill the tsk->signal->stats structure */\n\t\tfill_tgid_exit(tsk);\n\t}\n\n\tlisteners = raw_cpu_ptr(&listener_array);\n\tif (list_empty(&listeners->list))\n\t\treturn;\n\n\trc = prepare_reply(NULL, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID,\n\t\t\t task_pid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tfill_stats(&init_user_ns, &init_pid_ns, tsk, stats);\n\n\t/*\n\t * Doesn't matter if tsk is the leader or the last group member leaving\n\t */\n\tif (!is_thread_group || !group_dead)\n\t\tgoto send;\n\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID,\n\t\t\t task_tgid_nr_ns(tsk, &init_pid_ns));\n\tif (!stats)\n\t\tgoto err;\n\n\tmemcpy(stats, tsk->signal->stats, sizeof(*stats));\n\nsend:\n\tsend_cpu_listeners(rep_skb, listeners);\n\treturn;\nerr:\n\tnlmsg_free(rep_skb);\n}"
  },
  {
    "function_name": "taskstats_tgid_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "564-586",
    "snippet": "static struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "struct kmem_cache *taskstats_cache;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "taskstats_cache",
            "stats"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 580
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 575
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_zalloc",
          "args": [
            "taskstats_cache",
            "GFP_KERNEL"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstruct kmem_cache *taskstats_cache;\n\nstatic struct taskstats *taskstats_tgid_alloc(struct task_struct *tsk)\n{\n\tstruct signal_struct *sig = tsk->signal;\n\tstruct taskstats *stats;\n\n\tif (sig->stats || thread_group_empty(tsk))\n\t\tgoto ret;\n\n\t/* No problem if kmem_cache_zalloc() fails */\n\tstats = kmem_cache_zalloc(taskstats_cache, GFP_KERNEL);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tif (!sig->stats) {\n\t\tsig->stats = stats;\n\t\tstats = NULL;\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (stats)\n\t\tkmem_cache_free(taskstats_cache, stats);\nret:\n\treturn sig->stats;\n}"
  },
  {
    "function_name": "taskstats_user_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "550-562",
    "snippet": "static int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\n\t\treturn cmd_attr_register_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\n\t\treturn cmd_attr_deregister_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\n\t\treturn cmd_attr_pid(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\n\t\treturn cmd_attr_tgid(info);\n\telse\n\t\treturn -EINVAL;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_attr_tgid",
          "args": [
            "info"
          ],
          "line": 559
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_attr_tgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "521-548",
          "snippet": "static int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_attr_pid",
          "args": [
            "info"
          ],
          "line": 557
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_attr_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "492-519",
          "snippet": "static int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_attr_deregister_cpumask",
          "args": [
            "info"
          ],
          "line": 555
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_attr_deregister_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "465-479",
          "snippet": "static int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmd_attr_register_cpumask",
          "args": [
            "info"
          ],
          "line": 553
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_attr_register_cpumask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "449-463",
          "snippet": "static int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int taskstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tif (info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK])\n\t\treturn cmd_attr_register_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK])\n\t\treturn cmd_attr_deregister_cpumask(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_PID])\n\t\treturn cmd_attr_pid(info);\n\telse if (info->attrs[TASKSTATS_CMD_ATTR_TGID])\n\t\treturn cmd_attr_tgid(info);\n\telse\n\t\treturn -EINVAL;\n}"
  },
  {
    "function_name": "cmd_attr_tgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "521-548",
    "snippet": "static int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "rep_skb"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_reply",
          "args": [
            "rep_skb",
            "info"
          ],
          "line": 544
        },
        "resolved": true,
        "details": {
          "function_name": "send_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "110-118",
          "snippet": "static int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_stats_for_tgid",
          "args": [
            "tgid",
            "stats"
          ],
          "line": 541
        },
        "resolved": true,
        "details": {
          "function_name": "fill_stats_for_tgid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "205-266",
          "snippet": "static int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\tu64 delta, utime, stime;\n\tu64 start_time;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tstart_time = ktime_get_ns();\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\t/* calculate task elapsed time in nsec */\n\t\tdelta = start_time - tsk->start_time;\n\t\t/* Convert to micro seconds */\n\t\tdo_div(delta, NSEC_PER_USEC);\n\t\tstats->ac_etime += delta;\n\n\t\ttask_cputime(tsk, &utime, &stime);\n\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);\n\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\tu64 delta, utime, stime;\n\tu64 start_time;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tstart_time = ktime_get_ns();\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\t/* calculate task elapsed time in nsec */\n\t\tdelta = start_time - tsk->start_time;\n\t\t/* Convert to micro seconds */\n\t\tdo_div(delta, NSEC_PER_USEC);\n\t\tstats->ac_etime += delta;\n\n\t\ttask_cputime(tsk, &utime, &stime);\n\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);\n\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_reply",
          "args": [
            "rep_skb",
            "TASKSTATS_TYPE_TGID",
            "tgid"
          ],
          "line": 537
        },
        "resolved": true,
        "details": {
          "function_name": "mk_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "369-397",
          "snippet": "static struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_get_u32",
          "args": [
            "info->attrs[TASKSTATS_CMD_ATTR_TGID]"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_reply",
          "args": [
            "info",
            "TASKSTATS_CMD_NEW",
            "&rep_skb",
            "size"
          ],
          "line": 531
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "79-105",
          "snippet": "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static struct genl_family family;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic struct genl_family family;\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_packet_size",
          "args": [],
          "line": 529
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_packet_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "481-490",
          "snippet": "static size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_tgid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 tgid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\ttgid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_TGID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_TGID, tgid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_tgid(tgid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}"
  },
  {
    "function_name": "cmd_attr_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "492-519",
    "snippet": "static int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "rep_skb"
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_reply",
          "args": [
            "rep_skb",
            "info"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "send_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "110-118",
          "snippet": "static int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_stats_for_pid",
          "args": [
            "pid",
            "stats"
          ],
          "line": 512
        },
        "resolved": true,
        "details": {
          "function_name": "fill_stats_for_pid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "193-203",
          "snippet": "static int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\ttsk = find_get_task_by_vpid(pid);\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\ttsk = find_get_task_by_vpid(pid);\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mk_reply",
          "args": [
            "rep_skb",
            "TASKSTATS_TYPE_PID",
            "pid"
          ],
          "line": 508
        },
        "resolved": true,
        "details": {
          "function_name": "mk_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "369-397",
          "snippet": "static struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_get_u32",
          "args": [
            "info->attrs[TASKSTATS_CMD_ATTR_PID]"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_reply",
          "args": [
            "info",
            "TASKSTATS_CMD_NEW",
            "&rep_skb",
            "size"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "79-105",
          "snippet": "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static struct genl_family family;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic struct genl_family family;\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "taskstats_packet_size",
          "args": [],
          "line": 500
        },
        "resolved": true,
        "details": {
          "function_name": "taskstats_packet_size",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "481-490",
          "snippet": "static size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_pid(struct genl_info *info)\n{\n\tstruct taskstats *stats;\n\tstruct sk_buff *rep_skb;\n\tsize_t size;\n\tu32 pid;\n\tint rc;\n\n\tsize = taskstats_packet_size();\n\n\trc = prepare_reply(info, TASKSTATS_CMD_NEW, &rep_skb, size);\n\tif (rc < 0)\n\t\treturn rc;\n\n\trc = -EINVAL;\n\tpid = nla_get_u32(info->attrs[TASKSTATS_CMD_ATTR_PID]);\n\tstats = mk_reply(rep_skb, TASKSTATS_TYPE_PID, pid);\n\tif (!stats)\n\t\tgoto err;\n\n\trc = fill_stats_for_pid(pid, stats);\n\tif (rc < 0)\n\t\tgoto err;\n\treturn send_reply(rep_skb, info);\nerr:\n\tnlmsg_free(rep_skb);\n\treturn rc;\n}"
  },
  {
    "function_name": "taskstats_packet_size",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "481-490",
    "snippet": "static size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nla_total_size",
          "args": [
            "0"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_total_size_64bit",
          "args": [
            "sizeof(struct taskstats)"
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_total_size",
          "args": [
            "sizeof(u32)"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic size_t taskstats_packet_size(void)\n{\n\tsize_t size;\n\n\tsize = nla_total_size(sizeof(u32)) +\n\t\tnla_total_size_64bit(sizeof(struct taskstats)) +\n\t\tnla_total_size(0);\n\n\treturn size;\n}"
  },
  {
    "function_name": "cmd_attr_deregister_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "465-479",
    "snippet": "static int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_del_listener",
          "args": [
            "info->snd_portid",
            "mask",
            "DEREGISTER"
          ],
          "line": 475
        },
        "resolved": true,
        "details": {
          "function_name": "add_del_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "288-345",
          "snippet": "static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct listener_list, listener_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse",
          "args": [
            "info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK]",
            "mask"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "347-367",
          "snippet": "static int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_deregister_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_DEREGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, DEREGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}"
  },
  {
    "function_name": "cmd_attr_register_cpumask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "449-463",
    "snippet": "static int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_cpumask_var",
          "args": [
            "mask"
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_del_listener",
          "args": [
            "info->snd_portid",
            "mask",
            "REGISTER"
          ],
          "line": 459
        },
        "resolved": true,
        "details": {
          "function_name": "add_del_listener",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "288-345",
          "snippet": "static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct listener_list, listener_array);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "parse",
          "args": [
            "info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK]",
            "mask"
          ],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "parse",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "347-367",
          "snippet": "static int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "alloc_cpumask_var",
          "args": [
            "&mask",
            "GFP_KERNEL"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cmd_attr_register_cpumask(struct genl_info *info)\n{\n\tcpumask_var_t mask;\n\tint rc;\n\n\tif (!alloc_cpumask_var(&mask, GFP_KERNEL))\n\t\treturn -ENOMEM;\n\trc = parse(info->attrs[TASKSTATS_CMD_ATTR_REGISTER_CPUMASK], mask);\n\tif (rc < 0)\n\t\tgoto out;\n\trc = add_del_listener(info->snd_portid, mask, REGISTER);\nout:\n\tfree_cpumask_var(mask);\n\treturn rc;\n}"
  },
  {
    "function_name": "cgroupstats_user_cmd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "399-447",
    "snippet": "static int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct fd f;\n\n\tna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\n\tif (!na)\n\t\treturn -EINVAL;\n\n\tfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct cgroupstats));\n\n\trc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\n\t\t\t\tsize);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\n\t\t\t\tsizeof(struct cgroupstats));\n\tif (na == NULL) {\n\t\tnlmsg_free(rep_skb);\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, f.file->f_path.dentry);\n\tif (rc < 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfdput(f);\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fdput",
          "args": [
            "f"
          ],
          "line": 445
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_reply",
          "args": [
            "rep_skb",
            "info"
          ],
          "line": 442
        },
        "resolved": true,
        "details": {
          "function_name": "send_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "110-118",
          "snippet": "static int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "rep_skb"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroupstats_build",
          "args": [
            "stats",
            "f.file->f_path.dentry"
          ],
          "line": 436
        },
        "resolved": true,
        "details": {
          "function_name": "cgroupstats_build",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/cgroup/cgroup-v1.c",
          "lines": "717-770",
          "snippet": "int cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct cgroup *cgrp;\n\tstruct css_task_iter it;\n\tstruct task_struct *tsk;\n\n\t/* it should be kernfs_node belonging to cgroupfs and is a directory */\n\tif (dentry->d_sb->s_type != &cgroup_fs_type || !kn ||\n\t    kernfs_type(kn) != KERNFS_DIR)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * We aren't being called from kernfs and there's no guarantee on\n\t * @kn->priv's validity.  For this and css_tryget_online_from_dir(),\n\t * @kn->priv is RCU safe.  Let's do the RCU dancing.\n\t */\n\trcu_read_lock();\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (!cgrp || cgroup_is_dead(cgrp)) {\n\t\trcu_read_unlock();\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((tsk = css_task_iter_next(&it))) {\n\t\tswitch (tsk->state) {\n\t\tcase TASK_RUNNING:\n\t\t\tstats->nr_running++;\n\t\t\tbreak;\n\t\tcase TASK_INTERRUPTIBLE:\n\t\t\tstats->nr_sleeping++;\n\t\t\tbreak;\n\t\tcase TASK_UNINTERRUPTIBLE:\n\t\t\tstats->nr_uninterruptible++;\n\t\t\tbreak;\n\t\tcase TASK_STOPPED:\n\t\t\tstats->nr_stopped++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (delayacct_is_task_waiting_on_io(tsk))\n\t\t\t\tstats->nr_io_wait++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcss_task_iter_end(&it);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn 0;\n}",
          "includes": [
            "#include <trace/events/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/magic.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/mm.h>",
            "#include <linux/delay.h>",
            "#include <linux/sort.h>",
            "#include <linux/kmod.h>",
            "#include <linux/ctype.h>",
            "#include \"cgroup-internal.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/pid_namespace.h>\n#include <linux/delayacct.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/magic.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/mm.h>\n#include <linux/delay.h>\n#include <linux/sort.h>\n#include <linux/kmod.h>\n#include <linux/ctype.h>\n#include \"cgroup-internal.h\"\n\nint cgroupstats_build(struct cgroupstats *stats, struct dentry *dentry)\n{\n\tstruct kernfs_node *kn = kernfs_node_from_dentry(dentry);\n\tstruct cgroup *cgrp;\n\tstruct css_task_iter it;\n\tstruct task_struct *tsk;\n\n\t/* it should be kernfs_node belonging to cgroupfs and is a directory */\n\tif (dentry->d_sb->s_type != &cgroup_fs_type || !kn ||\n\t    kernfs_type(kn) != KERNFS_DIR)\n\t\treturn -EINVAL;\n\n\tmutex_lock(&cgroup_mutex);\n\n\t/*\n\t * We aren't being called from kernfs and there's no guarantee on\n\t * @kn->priv's validity.  For this and css_tryget_online_from_dir(),\n\t * @kn->priv is RCU safe.  Let's do the RCU dancing.\n\t */\n\trcu_read_lock();\n\tcgrp = rcu_dereference(*(void __rcu __force **)&kn->priv);\n\tif (!cgrp || cgroup_is_dead(cgrp)) {\n\t\trcu_read_unlock();\n\t\tmutex_unlock(&cgroup_mutex);\n\t\treturn -ENOENT;\n\t}\n\trcu_read_unlock();\n\n\tcss_task_iter_start(&cgrp->self, 0, &it);\n\twhile ((tsk = css_task_iter_next(&it))) {\n\t\tswitch (tsk->state) {\n\t\tcase TASK_RUNNING:\n\t\t\tstats->nr_running++;\n\t\t\tbreak;\n\t\tcase TASK_INTERRUPTIBLE:\n\t\t\tstats->nr_sleeping++;\n\t\t\tbreak;\n\t\tcase TASK_UNINTERRUPTIBLE:\n\t\t\tstats->nr_uninterruptible++;\n\t\t\tbreak;\n\t\tcase TASK_STOPPED:\n\t\t\tstats->nr_stopped++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tif (delayacct_is_task_waiting_on_io(tsk))\n\t\t\t\tstats->nr_io_wait++;\n\t\t\tbreak;\n\t\t}\n\t}\n\tcss_task_iter_end(&it);\n\n\tmutex_unlock(&cgroup_mutex);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(*stats)"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_data",
          "args": [
            "na"
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "rep_skb"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_reserve",
          "args": [
            "rep_skb",
            "CGROUPSTATS_TYPE_CGROUP_STATS",
            "sizeof(struct cgroupstats)"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "prepare_reply",
          "args": [
            "info",
            "CGROUPSTATS_CMD_NEW",
            "&rep_skb",
            "size"
          ],
          "line": 420
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_reply",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "79-105",
          "snippet": "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
            "static struct genl_family family;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic struct genl_family family;\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_total_size",
          "args": [
            "sizeof(struct cgroupstats)"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fdget",
          "args": [
            "fd"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_get_u32",
          "args": [
            "info->attrs[CGROUPSTATS_CMD_ATTR_FD]"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int cgroupstats_user_cmd(struct sk_buff *skb, struct genl_info *info)\n{\n\tint rc = 0;\n\tstruct sk_buff *rep_skb;\n\tstruct cgroupstats *stats;\n\tstruct nlattr *na;\n\tsize_t size;\n\tu32 fd;\n\tstruct fd f;\n\n\tna = info->attrs[CGROUPSTATS_CMD_ATTR_FD];\n\tif (!na)\n\t\treturn -EINVAL;\n\n\tfd = nla_get_u32(info->attrs[CGROUPSTATS_CMD_ATTR_FD]);\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn 0;\n\n\tsize = nla_total_size(sizeof(struct cgroupstats));\n\n\trc = prepare_reply(info, CGROUPSTATS_CMD_NEW, &rep_skb,\n\t\t\t\tsize);\n\tif (rc < 0)\n\t\tgoto err;\n\n\tna = nla_reserve(rep_skb, CGROUPSTATS_TYPE_CGROUP_STATS,\n\t\t\t\tsizeof(struct cgroupstats));\n\tif (na == NULL) {\n\t\tnlmsg_free(rep_skb);\n\t\trc = -EMSGSIZE;\n\t\tgoto err;\n\t}\n\n\tstats = nla_data(na);\n\tmemset(stats, 0, sizeof(*stats));\n\n\trc = cgroupstats_build(stats, f.file->f_path.dentry);\n\tif (rc < 0) {\n\t\tnlmsg_free(rep_skb);\n\t\tgoto err;\n\t}\n\n\trc = send_reply(rep_skb, info);\n\nerr:\n\tfdput(f);\n\treturn rc;\n}"
  },
  {
    "function_name": "mk_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "369-397",
    "snippet": "static struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "nla_data",
          "args": [
            "ret"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_end",
          "args": [
            "skb",
            "na"
          ],
          "line": 392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_cancel",
          "args": [
            "skb",
            "na"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_reserve_64bit",
          "args": [
            "skb",
            "TASKSTATS_TYPE_STATS",
            "sizeof(struct taskstats)",
            "TASKSTATS_TYPE_NULL"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_cancel",
          "args": [
            "skb",
            "na"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_put",
          "args": [
            "skb",
            "type",
            "sizeof(pid)",
            "&pid"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_nest_start",
          "args": [
            "skb",
            "aggr"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic struct taskstats *mk_reply(struct sk_buff *skb, int type, u32 pid)\n{\n\tstruct nlattr *na, *ret;\n\tint aggr;\n\n\taggr = (type == TASKSTATS_TYPE_PID)\n\t\t\t? TASKSTATS_TYPE_AGGR_PID\n\t\t\t: TASKSTATS_TYPE_AGGR_TGID;\n\n\tna = nla_nest_start(skb, aggr);\n\tif (!na)\n\t\tgoto err;\n\n\tif (nla_put(skb, type, sizeof(pid), &pid) < 0) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tret = nla_reserve_64bit(skb, TASKSTATS_TYPE_STATS,\n\t\t\t\tsizeof(struct taskstats), TASKSTATS_TYPE_NULL);\n\tif (!ret) {\n\t\tnla_nest_cancel(skb, na);\n\t\tgoto err;\n\t}\n\tnla_nest_end(skb, na);\n\n\treturn nla_data(ret);\nerr:\n\treturn NULL;\n}"
  },
  {
    "function_name": "parse",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "347-367",
    "snippet": "static int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [
      "#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "data"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cpulist_parse",
          "args": [
            "data",
            "mask"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nla_strlcpy",
          "args": [
            "data",
            "na",
            "len"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "len",
            "GFP_KERNEL"
          ],
          "line": 360
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nla_len",
          "args": [
            "na"
          ],
          "line": 355
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\n#define TASKSTATS_CPUMASK_MAXLEN\t(100+6*NR_CPUS)\n\nstatic int parse(struct nlattr *na, struct cpumask *mask)\n{\n\tchar *data;\n\tint len;\n\tint ret;\n\n\tif (na == NULL)\n\t\treturn 1;\n\tlen = nla_len(na);\n\tif (len > TASKSTATS_CPUMASK_MAXLEN)\n\t\treturn -E2BIG;\n\tif (len < 1)\n\t\treturn -EINVAL;\n\tdata = kmalloc(len, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tnla_strlcpy(data, na, len);\n\tret = cpulist_parse(data, mask);\n\tkfree(data);\n\treturn ret;\n}"
  },
  {
    "function_name": "add_del_listener",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "288-345",
    "snippet": "static int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(struct listener_list, listener_array);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&listeners->sem"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 338
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->list"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "s",
            "tmp",
            "&listeners->list",
            "list"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&listeners->sem"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "listener_array",
            "cpu"
          ],
          "line": 333
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add",
          "args": [
            "&s->list",
            "&listeners->list"
          ],
          "line": 321
        },
        "resolved": true,
        "details": {
          "function_name": "list_add_event",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1662-1690",
          "snippet": "static void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void update_context_time(struct perf_event_context *ctx);",
            "static u64 perf_event_time(struct perf_event *event);",
            "static __must_check struct",
            "static void perf_log_itrace_start(struct perf_event *event);",
            "static void perf_event_free_filter(struct perf_event *event);",
            "static void perf_event_free_bpf_prog(struct perf_event *event);",
            "static int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);",
            "static void perf_pmu_output_stop(struct perf_event *event);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic u64 perf_event_time(struct perf_event *event);\nstatic __must_check struct;\nstatic void perf_log_itrace_start(struct perf_event *event);\nstatic void perf_event_free_filter(struct perf_event *event);\nstatic void perf_event_free_bpf_prog(struct perf_event *event);\nstatic int perf_copy_attr(struct perf_event_attr __user *uattr,\n\t\t\t  struct perf_event_attr *attr);\nstatic void perf_pmu_output_stop(struct perf_event *event);\n\nstatic void\nlist_add_event(struct perf_event *event, struct perf_event_context *ctx)\n{\n\tlockdep_assert_held(&ctx->lock);\n\n\tWARN_ON_ONCE(event->attach_state & PERF_ATTACH_CONTEXT);\n\tevent->attach_state |= PERF_ATTACH_CONTEXT;\n\n\tevent->tstamp = perf_event_time(event);\n\n\t/*\n\t * If we're a stand alone event or group leader, we go to the context\n\t * list, group events are kept attached to the group so that\n\t * perf_group_detach can, at all times, locate all siblings.\n\t */\n\tif (event->group_leader == event) {\n\t\tevent->group_caps = event->event_caps;\n\t\tadd_event_to_groups(event, ctx);\n\t}\n\n\tlist_update_cgroup_event(event, ctx, true);\n\n\tlist_add_rcu(&event->event_entry, &ctx->event_list);\n\tctx->nr_events++;\n\tif (event->attr.inherit_stat)\n\t\tctx->nr_stat++;\n\n\tctx->generation++;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s2",
            "&listeners->list",
            "list"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc_node",
          "args": [
            "sizeof(struct listener)",
            "GFP_KERNEL",
            "cpu_to_node(cpu)"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_to_node",
          "args": [
            "cpu"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_cpu",
          "args": [
            "cpu",
            "mask"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpumask_subset",
          "args": [
            "mask",
            "cpu_possible_mask"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(struct listener_list, listener_array);\n\nstatic int add_del_listener(pid_t pid, const struct cpumask *mask, int isadd)\n{\n\tstruct listener_list *listeners;\n\tstruct listener *s, *tmp, *s2;\n\tunsigned int cpu;\n\tint ret = 0;\n\n\tif (!cpumask_subset(mask, cpu_possible_mask))\n\t\treturn -EINVAL;\n\n\tif (current_user_ns() != &init_user_ns)\n\t\treturn -EINVAL;\n\n\tif (task_active_pid_ns(current) != &init_pid_ns)\n\t\treturn -EINVAL;\n\n\tif (isadd == REGISTER) {\n\t\tfor_each_cpu(cpu, mask) {\n\t\t\ts = kmalloc_node(sizeof(struct listener),\n\t\t\t\t\tGFP_KERNEL, cpu_to_node(cpu));\n\t\t\tif (!s) {\n\t\t\t\tret = -ENOMEM;\n\t\t\t\tgoto cleanup;\n\t\t\t}\n\t\t\ts->pid = pid;\n\t\t\ts->valid = 1;\n\n\t\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\t\tdown_write(&listeners->sem);\n\t\t\tlist_for_each_entry(s2, &listeners->list, list) {\n\t\t\t\tif (s2->pid == pid && s2->valid)\n\t\t\t\t\tgoto exists;\n\t\t\t}\n\t\t\tlist_add(&s->list, &listeners->list);\n\t\t\ts = NULL;\nexists:\n\t\t\tup_write(&listeners->sem);\n\t\t\tkfree(s); /* nop if NULL */\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/* Deregister or cleanup */\ncleanup:\n\tfor_each_cpu(cpu, mask) {\n\t\tlisteners = &per_cpu(listener_array, cpu);\n\t\tdown_write(&listeners->sem);\n\t\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\t\tif (s->pid == pid) {\n\t\t\t\tlist_del(&s->list);\n\t\t\t\tkfree(s);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tup_write(&listeners->sem);\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "fill_tgid_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "268-286",
    "snippet": "static void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 284
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_add_tsk",
          "args": [
            "tsk->signal->stats",
            "tsk"
          ],
          "line": 282
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_add_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "94-147",
          "snippet": "int __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nint __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void fill_tgid_exit(struct task_struct *tsk)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (!tsk->signal->stats)\n\t\tgoto ret;\n\n\t/*\n\t * Each accounting subsystem calls its functions here to\n\t * accumalate its per-task stats for tsk, into the per-tgid structure\n\t *\n\t *\tper-task-foo(tsk->signal->stats, tsk);\n\t */\n\tdelayacct_add_tsk(tsk->signal->stats, tsk);\nret:\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn;\n}"
  },
  {
    "function_name": "fill_stats_for_tgid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "205-266",
    "snippet": "static int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\tu64 delta, utime, stime;\n\tu64 start_time;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tstart_time = ktime_get_ns();\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\t/* calculate task elapsed time in nsec */\n\t\tdelta = start_time - tsk->start_time;\n\t\t/* Convert to micro seconds */\n\t\tdo_div(delta, NSEC_PER_USEC);\n\t\tstats->ac_etime += delta;\n\n\t\ttask_cputime(tsk, &utime, &stime);\n\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);\n\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "stime",
            "NSEC_PER_USEC"
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "div_u64",
          "args": [
            "utime",
            "NSEC_PER_USEC"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 247
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_div",
          "args": [
            "delta",
            "NSEC_PER_USEC"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "delayacct_add_tsk",
          "args": [
            "stats",
            "tsk"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_add_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "94-147",
          "snippet": "int __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nint __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(*stats)"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "stats",
            "first->signal->stats",
            "sizeof(*stats)"
          ],
          "line": 224
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "first",
            "&flags"
          ],
          "line": 220
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "tgid"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 217
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int fill_stats_for_tgid(pid_t tgid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk, *first;\n\tunsigned long flags;\n\tint rc = -ESRCH;\n\tu64 delta, utime, stime;\n\tu64 start_time;\n\n\t/*\n\t * Add additional stats from live tasks except zombie thread group\n\t * leaders who are already counted with the dead tasks\n\t */\n\trcu_read_lock();\n\tfirst = find_task_by_vpid(tgid);\n\n\tif (!first || !lock_task_sighand(first, &flags))\n\t\tgoto out;\n\n\tif (first->signal->stats)\n\t\tmemcpy(stats, first->signal->stats, sizeof(*stats));\n\telse\n\t\tmemset(stats, 0, sizeof(*stats));\n\n\ttsk = first;\n\tstart_time = ktime_get_ns();\n\tdo {\n\t\tif (tsk->exit_state)\n\t\t\tcontinue;\n\t\t/*\n\t\t * Accounting subsystem can call its functions here to\n\t\t * fill in relevant parts of struct taskstsats as follows\n\t\t *\n\t\t *\tper-task-foo(stats, tsk);\n\t\t */\n\t\tdelayacct_add_tsk(stats, tsk);\n\n\t\t/* calculate task elapsed time in nsec */\n\t\tdelta = start_time - tsk->start_time;\n\t\t/* Convert to micro seconds */\n\t\tdo_div(delta, NSEC_PER_USEC);\n\t\tstats->ac_etime += delta;\n\n\t\ttask_cputime(tsk, &utime, &stime);\n\t\tstats->ac_utime += div_u64(utime, NSEC_PER_USEC);\n\t\tstats->ac_stime += div_u64(stime, NSEC_PER_USEC);\n\n\t\tstats->nvcsw += tsk->nvcsw;\n\t\tstats->nivcsw += tsk->nivcsw;\n\t} while_each_thread(first, tsk);\n\n\tunlock_task_sighand(first, &flags);\n\trc = 0;\nout:\n\trcu_read_unlock();\n\n\tstats->version = TASKSTATS_VERSION;\n\t/*\n\t * Accounting subsystems can also add calls here to modify\n\t * fields of taskstats.\n\t */\n\treturn rc;\n}"
  },
  {
    "function_name": "fill_stats_for_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "193-203",
    "snippet": "static int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\ttsk = find_get_task_by_vpid(pid);\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_task_struct",
          "args": [
            "tsk"
          ],
          "line": 201
        },
        "resolved": true,
        "details": {
          "function_name": "__put_task_struct",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/fork.c",
          "lines": "716-731",
          "snippet": "void __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}",
          "includes": [
            "#include <linux/init_task.h>",
            "#include <trace/events/task.h>",
            "#include <trace/events/sched.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/cacheflush.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/pgalloc.h>",
            "#include <asm/pgtable.h>",
            "#include <linux/stackleak.h>",
            "#include <linux/thread_info.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/kcov.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/compiler.h>",
            "#include <linux/aio.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/khugepaged.h>",
            "#include <linux/oom.h>",
            "#include <linux/user-return-notifier.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/magic.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/tty.h>",
            "#include <linux/random.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/userfaultfd_k.h>",
            "#include <linux/acct.h>",
            "#include <linux/ksm.h>",
            "#include <linux/rmap.h>",
            "#include <linux/profile.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/memcontrol.h>",
            "#include <linux/audit.h>",
            "#include <linux/mount.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/kthread.h>",
            "#include <linux/compat.h>",
            "#include <linux/futex.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/swap.h>",
            "#include <linux/seccomp.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/security.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/vmacache.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>",
            "#include <linux/hmm.h>",
            "#include <linux/mmu_notifier.h>",
            "#include <linux/mman.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/sem.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/module.h>",
            "#include <linux/unistd.h>",
            "#include <linux/init.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/numa_balancing.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __latent_entropy struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/init_task.h>\n#include <trace/events/task.h>\n#include <trace/events/sched.h>\n#include <asm/tlbflush.h>\n#include <asm/cacheflush.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <asm/pgalloc.h>\n#include <asm/pgtable.h>\n#include <linux/stackleak.h>\n#include <linux/thread_info.h>\n#include <linux/livepatch.h>\n#include <linux/kcov.h>\n#include <linux/sysctl.h>\n#include <linux/compiler.h>\n#include <linux/aio.h>\n#include <linux/uprobes.h>\n#include <linux/signalfd.h>\n#include <linux/khugepaged.h>\n#include <linux/oom.h>\n#include <linux/user-return-notifier.h>\n#include <linux/posix-timers.h>\n#include <linux/perf_event.h>\n#include <linux/sched/mm.h>\n#include <linux/magic.h>\n#include <linux/fs_struct.h>\n#include <linux/blkdev.h>\n#include <linux/tty.h>\n#include <linux/random.h>\n#include <linux/taskstats_kern.h>\n#include <linux/delayacct.h>\n#include <linux/freezer.h>\n#include <linux/cn_proc.h>\n#include <linux/tsacct_kern.h>\n#include <linux/userfaultfd_k.h>\n#include <linux/acct.h>\n#include <linux/ksm.h>\n#include <linux/rmap.h>\n#include <linux/profile.h>\n#include <linux/proc_fs.h>\n#include <linux/ftrace.h>\n#include <linux/memcontrol.h>\n#include <linux/audit.h>\n#include <linux/mount.h>\n#include <linux/ptrace.h>\n#include <linux/rcupdate.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/kthread.h>\n#include <linux/compat.h>\n#include <linux/futex.h>\n#include <linux/jiffies.h>\n#include <linux/syscalls.h>\n#include <linux/swap.h>\n#include <linux/seccomp.h>\n#include <linux/hugetlb.h>\n#include <linux/security.h>\n#include <linux/cgroup.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/nsproxy.h>\n#include <linux/vmacache.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n#include <linux/hmm.h>\n#include <linux/mmu_notifier.h>\n#include <linux/mman.h>\n#include <linux/binfmts.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/sem.h>\n#include <linux/mempolicy.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/vmalloc.h>\n#include <linux/module.h>\n#include <linux/unistd.h>\n#include <linux/init.h>\n#include <linux/rtmutex.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/numa_balancing.h>\n#include <linux/sched/user.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n\nstatic __latent_entropy struct;\n\nvoid __put_task_struct(struct task_struct *tsk)\n{\n\tWARN_ON(!tsk->exit_state);\n\tWARN_ON(atomic_read(&tsk->usage));\n\tWARN_ON(tsk == current);\n\n\tcgroup_free(tsk);\n\ttask_numa_free(tsk);\n\tsecurity_task_free(tsk);\n\texit_creds(tsk);\n\tdelayacct_tsk_free(tsk);\n\tput_signal_struct(tsk->signal);\n\n\tif (!profile_handoff_task(tsk))\n\t\tfree_task(tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "fill_stats",
          "args": [
            "current_user_ns()",
            "task_active_pid_ns(current)",
            "tsk",
            "stats"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "fill_stats",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
          "lines": "169-191",
          "snippet": "static void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}",
          "includes": [
            "#include <linux/sched/cputime.h>",
            "#include <linux/atomic.h>",
            "#include <net/genetlink.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/file.h>",
            "#include <linux/fs.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/cgroupstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/percpu.h>",
            "#include <linux/cpumask.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "current"
          ],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 200
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_get_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "find_get_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "353-364",
          "snippet": "struct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_get_task_by_vpid(pid_t nr)\n{\n\tstruct task_struct *task;\n\n\trcu_read_lock();\n\ttask = find_task_by_vpid(nr);\n\tif (task)\n\t\tget_task_struct(task);\n\trcu_read_unlock();\n\n\treturn task;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int fill_stats_for_pid(pid_t pid, struct taskstats *stats)\n{\n\tstruct task_struct *tsk;\n\n\ttsk = find_get_task_by_vpid(pid);\n\tif (!tsk)\n\t\treturn -ESRCH;\n\tfill_stats(current_user_ns(), task_active_pid_ns(current), tsk, stats);\n\tput_task_struct(tsk);\n\treturn 0;\n}"
  },
  {
    "function_name": "fill_stats",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "169-191",
    "snippet": "static void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "xacct_add_tsk",
          "args": [
            "stats",
            "tsk"
          ],
          "line": 190
        },
        "resolved": true,
        "details": {
          "function_name": "xacct_add_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tsacct.c",
          "lines": "94-123",
          "snippet": "void xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstruct mm_struct *mm;\n\n\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */\n\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;\n\tdo_div(stats->coremem, 1000 * KB);\n\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;\n\tdo_div(stats->virtmem, 1000 * KB);\n\tmm = get_task_mm(p);\n\tif (mm) {\n\t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;\n\t\tmmput(mm);\n\t}\n\tstats->read_char\t= p->ioac.rchar & KB_MASK;\n\tstats->write_char\t= p->ioac.wchar & KB_MASK;\n\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;\n\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;\n\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;\n\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;\n#else\n\tstats->read_bytes\t= 0;\n\tstats->write_bytes\t= 0;\n\tstats->cancelled_write_bytes = 0;\n#endif\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [
            "#define KB_MASK (~(KB-1))",
            "#define KB 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\n#define KB_MASK (~(KB-1))\n#define KB 1024\n\nvoid xacct_add_tsk(struct taskstats *stats, struct task_struct *p)\n{\n\tstruct mm_struct *mm;\n\n\t/* convert pages-nsec/1024 to Mbyte-usec, see __acct_update_integrals */\n\tstats->coremem = p->acct_rss_mem1 * PAGE_SIZE;\n\tdo_div(stats->coremem, 1000 * KB);\n\tstats->virtmem = p->acct_vm_mem1 * PAGE_SIZE;\n\tdo_div(stats->virtmem, 1000 * KB);\n\tmm = get_task_mm(p);\n\tif (mm) {\n\t\t/* adjust to KB unit */\n\t\tstats->hiwater_rss   = get_mm_hiwater_rss(mm) * PAGE_SIZE / KB;\n\t\tstats->hiwater_vm    = get_mm_hiwater_vm(mm)  * PAGE_SIZE / KB;\n\t\tmmput(mm);\n\t}\n\tstats->read_char\t= p->ioac.rchar & KB_MASK;\n\tstats->write_char\t= p->ioac.wchar & KB_MASK;\n\tstats->read_syscalls\t= p->ioac.syscr & KB_MASK;\n\tstats->write_syscalls\t= p->ioac.syscw & KB_MASK;\n#ifdef CONFIG_TASK_IO_ACCOUNTING\n\tstats->read_bytes\t= p->ioac.read_bytes & KB_MASK;\n\tstats->write_bytes\t= p->ioac.write_bytes & KB_MASK;\n\tstats->cancelled_write_bytes = p->ioac.cancelled_write_bytes & KB_MASK;\n#else\n\tstats->read_bytes\t= 0;\n\tstats->write_bytes\t= 0;\n\tstats->cancelled_write_bytes = 0;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "bacct_add_tsk",
          "args": [
            "user_ns",
            "pid_ns",
            "stats",
            "tsk"
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "bacct_add_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tsacct.c",
          "lines": "31-83",
          "snippet": "void bacct_add_tsk(struct user_namespace *user_ns,\n\t\t   struct pid_namespace *pid_ns,\n\t\t   struct taskstats *stats, struct task_struct *tsk)\n{\n\tconst struct cred *tcred;\n\tu64 utime, stime, utimescaled, stimescaled;\n\tu64 delta;\n\n\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);\n\n\t/* calculate task elapsed time in nsec */\n\tdelta = ktime_get_ns() - tsk->start_time;\n\t/* Convert to micro seconds */\n\tdo_div(delta, NSEC_PER_USEC);\n\tstats->ac_etime = delta;\n\t/* Convert to seconds for btime */\n\tdo_div(delta, USEC_PER_SEC);\n\tstats->ac_btime = get_seconds() - delta;\n\tif (thread_group_leader(tsk)) {\n\t\tstats->ac_exitcode = tsk->exit_code;\n\t\tif (tsk->flags & PF_FORKNOEXEC)\n\t\t\tstats->ac_flag |= AFORK;\n\t}\n\tif (tsk->flags & PF_SUPERPRIV)\n\t\tstats->ac_flag |= ASU;\n\tif (tsk->flags & PF_DUMPCORE)\n\t\tstats->ac_flag |= ACORE;\n\tif (tsk->flags & PF_SIGNALED)\n\t\tstats->ac_flag |= AXSIG;\n\tstats->ac_nice\t = task_nice(tsk);\n\tstats->ac_sched\t = tsk->policy;\n\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);\n\trcu_read_lock();\n\ttcred = __task_cred(tsk);\n\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);\n\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);\n\tstats->ac_ppid\t = pid_alive(tsk) ?\n\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);\n\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);\n\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);\n\n\tstats->ac_minflt = tsk->min_flt;\n\tstats->ac_majflt = tsk->maj_flt;\n\n\tstrncpy(stats->ac_comm, tsk->comm, sizeof(stats->ac_comm));\n}",
          "includes": [
            "#include <linux/mm.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/acct.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/mm.h>\n#include <linux/jiffies.h>\n#include <linux/acct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/signal.h>\n#include <linux/kernel.h>\n\nvoid bacct_add_tsk(struct user_namespace *user_ns,\n\t\t   struct pid_namespace *pid_ns,\n\t\t   struct taskstats *stats, struct task_struct *tsk)\n{\n\tconst struct cred *tcred;\n\tu64 utime, stime, utimescaled, stimescaled;\n\tu64 delta;\n\n\tBUILD_BUG_ON(TS_COMM_LEN < TASK_COMM_LEN);\n\n\t/* calculate task elapsed time in nsec */\n\tdelta = ktime_get_ns() - tsk->start_time;\n\t/* Convert to micro seconds */\n\tdo_div(delta, NSEC_PER_USEC);\n\tstats->ac_etime = delta;\n\t/* Convert to seconds for btime */\n\tdo_div(delta, USEC_PER_SEC);\n\tstats->ac_btime = get_seconds() - delta;\n\tif (thread_group_leader(tsk)) {\n\t\tstats->ac_exitcode = tsk->exit_code;\n\t\tif (tsk->flags & PF_FORKNOEXEC)\n\t\t\tstats->ac_flag |= AFORK;\n\t}\n\tif (tsk->flags & PF_SUPERPRIV)\n\t\tstats->ac_flag |= ASU;\n\tif (tsk->flags & PF_DUMPCORE)\n\t\tstats->ac_flag |= ACORE;\n\tif (tsk->flags & PF_SIGNALED)\n\t\tstats->ac_flag |= AXSIG;\n\tstats->ac_nice\t = task_nice(tsk);\n\tstats->ac_sched\t = tsk->policy;\n\tstats->ac_pid\t = task_pid_nr_ns(tsk, pid_ns);\n\trcu_read_lock();\n\ttcred = __task_cred(tsk);\n\tstats->ac_uid\t = from_kuid_munged(user_ns, tcred->uid);\n\tstats->ac_gid\t = from_kgid_munged(user_ns, tcred->gid);\n\tstats->ac_ppid\t = pid_alive(tsk) ?\n\t\ttask_tgid_nr_ns(rcu_dereference(tsk->real_parent), pid_ns) : 0;\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tstats->ac_utime = div_u64(utime, NSEC_PER_USEC);\n\tstats->ac_stime = div_u64(stime, NSEC_PER_USEC);\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\tstats->ac_utimescaled = div_u64(utimescaled, NSEC_PER_USEC);\n\tstats->ac_stimescaled = div_u64(stimescaled, NSEC_PER_USEC);\n\n\tstats->ac_minflt = tsk->min_flt;\n\tstats->ac_majflt = tsk->maj_flt;\n\n\tstrncpy(stats->ac_comm, tsk->comm, sizeof(stats->ac_comm));\n}"
        }
      },
      {
        "call_info": {
          "callee": "delayacct_add_tsk",
          "args": [
            "stats",
            "tsk"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "__delayacct_add_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/delayacct.c",
          "lines": "94-147",
          "snippet": "int __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <linux/module.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/time.h>",
            "#include <linux/taskstats.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/module.h>\n#include <linux/delayacct.h>\n#include <linux/sysctl.h>\n#include <linux/time.h>\n#include <linux/taskstats.h>\n#include <linux/slab.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n\nint __delayacct_add_tsk(struct taskstats *d, struct task_struct *tsk)\n{\n\tu64 utime, stime, stimescaled, utimescaled;\n\tunsigned long long t2, t3;\n\tunsigned long flags, t1;\n\ts64 tmp;\n\n\ttask_cputime(tsk, &utime, &stime);\n\ttmp = (s64)d->cpu_run_real_total;\n\ttmp += utime + stime;\n\td->cpu_run_real_total = (tmp < (s64)d->cpu_run_real_total) ? 0 : tmp;\n\n\ttask_cputime_scaled(tsk, &utimescaled, &stimescaled);\n\ttmp = (s64)d->cpu_scaled_run_real_total;\n\ttmp += utimescaled + stimescaled;\n\td->cpu_scaled_run_real_total =\n\t\t(tmp < (s64)d->cpu_scaled_run_real_total) ? 0 : tmp;\n\n\t/*\n\t * No locking available for sched_info (and too expensive to add one)\n\t * Mitigate by taking snapshot of values\n\t */\n\tt1 = tsk->sched_info.pcount;\n\tt2 = tsk->sched_info.run_delay;\n\tt3 = tsk->se.sum_exec_runtime;\n\n\td->cpu_count += t1;\n\n\ttmp = (s64)d->cpu_delay_total + t2;\n\td->cpu_delay_total = (tmp < (s64)d->cpu_delay_total) ? 0 : tmp;\n\n\ttmp = (s64)d->cpu_run_virtual_total + t3;\n\td->cpu_run_virtual_total =\n\t\t(tmp < (s64)d->cpu_run_virtual_total) ?\t0 : tmp;\n\n\t/* zero XXX_total, non-zero XXX_count implies XXX stat overflowed */\n\n\traw_spin_lock_irqsave(&tsk->delays->lock, flags);\n\ttmp = d->blkio_delay_total + tsk->delays->blkio_delay;\n\td->blkio_delay_total = (tmp < d->blkio_delay_total) ? 0 : tmp;\n\ttmp = d->swapin_delay_total + tsk->delays->swapin_delay;\n\td->swapin_delay_total = (tmp < d->swapin_delay_total) ? 0 : tmp;\n\ttmp = d->freepages_delay_total + tsk->delays->freepages_delay;\n\td->freepages_delay_total = (tmp < d->freepages_delay_total) ? 0 : tmp;\n\ttmp = d->thrashing_delay_total + tsk->delays->thrashing_delay;\n\td->thrashing_delay_total = (tmp < d->thrashing_delay_total) ? 0 : tmp;\n\td->blkio_count += tsk->delays->blkio_count;\n\td->swapin_count += tsk->delays->swapin_count;\n\td->freepages_count += tsk->delays->freepages_count;\n\td->thrashing_count += tsk->delays->thrashing_count;\n\traw_spin_unlock_irqrestore(&tsk->delays->lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "stats",
            "0",
            "sizeof(*stats)"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void fill_stats(struct user_namespace *user_ns,\n\t\t       struct pid_namespace *pid_ns,\n\t\t       struct task_struct *tsk, struct taskstats *stats)\n{\n\tmemset(stats, 0, sizeof(*stats));\n\t/*\n\t * Each accounting subsystem adds calls to its functions to\n\t * fill in relevant parts of struct taskstsats as follows\n\t *\n\t *\tper-task-foo(stats, tsk);\n\t */\n\n\tdelayacct_add_tsk(stats, tsk);\n\n\t/* fill in basic acct fields */\n\tstats->version = TASKSTATS_VERSION;\n\tstats->nvcsw = tsk->nvcsw;\n\tstats->nivcsw = tsk->nivcsw;\n\tbacct_add_tsk(user_ns, pid_ns, stats, tsk);\n\n\t/* fill in extended acct fields */\n\txacct_add_tsk(stats, tsk);\n}"
  },
  {
    "function_name": "send_cpu_listeners",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "123-167",
    "snippet": "static void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\tgenlmsg_end(skb, reply);\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&listeners->sem"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "s"
          ],
          "line": 163
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&s->list"
          ],
          "line": 162
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "s",
            "tmp",
            "&listeners->list",
            "list"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&listeners->sem"
          ],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "skb_cur"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&listeners->sem"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genlmsg_unicast",
          "args": [
            "&init_net",
            "skb_cur",
            "s->pid"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "skb_clone",
          "args": [
            "skb_cur",
            "GFP_KERNEL"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_is_last",
          "args": [
            "&s->list",
            "&listeners->list"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "s",
            "&listeners->list",
            "list"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&listeners->sem"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "genlmsg_end",
          "args": [
            "skb",
            "reply"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_data",
          "args": [
            "genlhdr"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlmsg_hdr(skb)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic void send_cpu_listeners(struct sk_buff *skb,\n\t\t\t\t\tstruct listener_list *listeners)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tstruct listener *s, *tmp;\n\tstruct sk_buff *skb_next, *skb_cur = skb;\n\tvoid *reply = genlmsg_data(genlhdr);\n\tint rc, delcount = 0;\n\n\tgenlmsg_end(skb, reply);\n\n\trc = 0;\n\tdown_read(&listeners->sem);\n\tlist_for_each_entry(s, &listeners->list, list) {\n\t\tskb_next = NULL;\n\t\tif (!list_is_last(&s->list, &listeners->list)) {\n\t\t\tskb_next = skb_clone(skb_cur, GFP_KERNEL);\n\t\t\tif (!skb_next)\n\t\t\t\tbreak;\n\t\t}\n\t\trc = genlmsg_unicast(&init_net, skb_cur, s->pid);\n\t\tif (rc == -ECONNREFUSED) {\n\t\t\ts->valid = 0;\n\t\t\tdelcount++;\n\t\t}\n\t\tskb_cur = skb_next;\n\t}\n\tup_read(&listeners->sem);\n\n\tif (skb_cur)\n\t\tnlmsg_free(skb_cur);\n\n\tif (!delcount)\n\t\treturn;\n\n\t/* Delete invalidated entries */\n\tdown_write(&listeners->sem);\n\tlist_for_each_entry_safe(s, tmp, &listeners->list, list) {\n\t\tif (!s->valid) {\n\t\t\tlist_del(&s->list);\n\t\t\tkfree(s);\n\t\t}\n\t}\n\tup_write(&listeners->sem);\n}"
  },
  {
    "function_name": "send_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "110-118",
    "snippet": "static int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "genlmsg_reply",
          "args": [
            "skb",
            "info"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_end",
          "args": [
            "skb",
            "reply"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_data",
          "args": [
            "genlhdr"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_data",
          "args": [
            "nlmsg_hdr(skb)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nlmsg_hdr",
          "args": [
            "skb"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic int send_reply(struct sk_buff *skb, struct genl_info *info)\n{\n\tstruct genlmsghdr *genlhdr = nlmsg_data(nlmsg_hdr(skb));\n\tvoid *reply = genlmsg_data(genlhdr);\n\n\tgenlmsg_end(skb, reply);\n\n\treturn genlmsg_reply(skb, info);\n}"
  },
  {
    "function_name": "prepare_reply",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/taskstats.c",
    "lines": "79-105",
    "snippet": "static int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched/cputime.h>",
      "#include <linux/atomic.h>",
      "#include <net/genetlink.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/file.h>",
      "#include <linux/fs.h>",
      "#include <linux/cgroup.h>",
      "#include <linux/cgroupstats.h>",
      "#include <linux/slab.h>",
      "#include <linux/percpu.h>",
      "#include <linux/cpumask.h>",
      "#include <linux/delayacct.h>",
      "#include <linux/tsacct_kern.h>",
      "#include <linux/taskstats_kern.h>",
      "#include <linux/kernel.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_PER_CPU(__u32, taskstats_seqnum);",
      "static struct genl_family family;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "nlmsg_free",
          "args": [
            "skb"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_put_reply",
          "args": [
            "skb",
            "info",
            "&family",
            "0",
            "cmd"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_put",
          "args": [
            "skb",
            "0",
            "seq",
            "&family",
            "0",
            "cmd"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_inc_return",
          "args": [
            "taskstats_seqnum"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "genlmsg_new",
          "args": [
            "size",
            "GFP_KERNEL"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched/cputime.h>\n#include <linux/atomic.h>\n#include <net/genetlink.h>\n#include <linux/pid_namespace.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/cgroup.h>\n#include <linux/cgroupstats.h>\n#include <linux/slab.h>\n#include <linux/percpu.h>\n#include <linux/cpumask.h>\n#include <linux/delayacct.h>\n#include <linux/tsacct_kern.h>\n#include <linux/taskstats_kern.h>\n#include <linux/kernel.h>\n\nstatic DEFINE_PER_CPU(__u32, taskstats_seqnum);\nstatic struct genl_family family;\n\nstatic int prepare_reply(struct genl_info *info, u8 cmd, struct sk_buff **skbp,\n\t\t\t\tsize_t size)\n{\n\tstruct sk_buff *skb;\n\tvoid *reply;\n\n\t/*\n\t * If new attributes are added, please revisit this allocation\n\t */\n\tskb = genlmsg_new(size, GFP_KERNEL);\n\tif (!skb)\n\t\treturn -ENOMEM;\n\n\tif (!info) {\n\t\tint seq = this_cpu_inc_return(taskstats_seqnum) - 1;\n\n\t\treply = genlmsg_put(skb, 0, seq, &family, 0, cmd);\n\t} else\n\t\treply = genlmsg_put_reply(skb, info, &family, 0, cmd);\n\tif (reply == NULL) {\n\t\tnlmsg_free(skb);\n\t\treturn -EINVAL;\n\t}\n\n\t*skbp = skb;\n\treturn 0;\n}"
  }
]