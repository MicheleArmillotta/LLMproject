[
  {
    "function_name": "perf_ftrace_event_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "489-514",
    "snippet": "int perf_ftrace_event_register(struct trace_event_call *call,\n\t\t\t       enum trace_reg type, void *data)\n{\n\tstruct perf_event *event = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\tcase TRACE_REG_UNREGISTER:\n\t\tbreak;\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn perf_ftrace_function_register(data);\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn perf_ftrace_function_unregister(data);\n\tcase TRACE_REG_PERF_ADD:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)smp_processor_id();\n\t\treturn 1;\n\tcase TRACE_REG_PERF_DEL:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)nr_cpu_ids;\n\t\treturn 1;\n\t}\n\n\treturn -EINVAL;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 506
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_ftrace_function_unregister",
          "args": [
            "data"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "perf_ftrace_function_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "481-487",
          "snippet": "static int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_ftrace_function_register",
          "args": [
            "data"
          ],
          "line": 502
        },
        "resolved": true,
        "details": {
          "function_name": "perf_ftrace_function_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "470-479",
          "snippet": "static int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->flags   = FTRACE_OPS_FL_RCU;\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->flags   = FTRACE_OPS_FL_RCU;\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_ftrace_event_register(struct trace_event_call *call,\n\t\t\t       enum trace_reg type, void *data)\n{\n\tstruct perf_event *event = data;\n\n\tswitch (type) {\n\tcase TRACE_REG_REGISTER:\n\tcase TRACE_REG_UNREGISTER:\n\t\tbreak;\n\tcase TRACE_REG_PERF_REGISTER:\n\tcase TRACE_REG_PERF_UNREGISTER:\n\t\treturn 0;\n\tcase TRACE_REG_PERF_OPEN:\n\t\treturn perf_ftrace_function_register(data);\n\tcase TRACE_REG_PERF_CLOSE:\n\t\treturn perf_ftrace_function_unregister(data);\n\tcase TRACE_REG_PERF_ADD:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)smp_processor_id();\n\t\treturn 1;\n\tcase TRACE_REG_PERF_DEL:\n\t\tevent->ftrace_ops.private = (void *)(unsigned long)nr_cpu_ids;\n\t\treturn 1;\n\t}\n\n\treturn -EINVAL;\n}"
  },
  {
    "function_name": "perf_ftrace_function_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "481-487",
    "snippet": "static int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ftrace_free_filter",
          "args": [
            "ops"
          ],
          "line": 485
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_free_filter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "1292-1297",
          "snippet": "void ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nvoid ftrace_free_filter(struct ftrace_ops *ops)\n{\n\tftrace_ops_init(ops);\n\tfree_ftrace_hash(ops->func_hash->filter_hash);\n\tfree_ftrace_hash(ops->func_hash->notrace_hash);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unregister_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 484
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_unregister(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\tint ret = unregister_ftrace_function(ops);\n\tftrace_free_filter(ops);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_ftrace_function_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "470-479",
    "snippet": "static int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->flags   = FTRACE_OPS_FL_RCU;\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_ftrace_function",
          "args": [
            "ops"
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_ftrace_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/ftrace.c",
          "lines": "6697-6706",
          "snippet": "int unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_stat.h\"",
            "#include \"trace_output.h\"",
            "#include <asm/setup.h>",
            "#include <asm/sections.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/hash.h>",
            "#include <linux/list.h>",
            "#include <linux/sort.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kthread.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/suspend.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/stop_machine.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);",
            "static DEFINE_MUTEX(ftrace_lock);",
            "static void ftrace_update_trampoline(struct ftrace_ops *ops);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_stat.h\"\n#include \"trace_output.h\"\n#include <asm/setup.h>\n#include <asm/sections.h>\n#include <trace/events/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/hash.h>\n#include <linux/list.h>\n#include <linux/sort.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/sysctl.h>\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/bsearch.h>\n#include <linux/uaccess.h>\n#include <linux/kthread.h>\n#include <linux/hardirq.h>\n#include <linux/tracefs.h>\n#include <linux/suspend.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/sched/task.h>\n#include <linux/clocksource.h>\n#include <linux/stop_machine.h>\n\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\nstatic DEFINE_MUTEX(ftrace_lock);\nstatic void ftrace_update_trampoline(struct ftrace_ops *ops);\n\nint unregister_ftrace_function(struct ftrace_ops *ops)\n{\n\tint ret;\n\n\tmutex_lock(&ftrace_lock);\n\tret = ftrace_shutdown(ops, 0);\n\tmutex_unlock(&ftrace_lock);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_ftrace_function_register(struct perf_event *event)\n{\n\tstruct ftrace_ops *ops = &event->ftrace_ops;\n\n\tops->flags   = FTRACE_OPS_FL_RCU;\n\tops->func    = perf_ftrace_function_call;\n\tops->private = (void *)(unsigned long)nr_cpu_ids;\n\n\treturn register_ftrace_function(ops);\n}"
  },
  {
    "function_name": "perf_ftrace_function_call",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "427-468",
    "snippet": "static void\nperf_ftrace_function_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *ops, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_entry *entry;\n\tstruct perf_event *event;\n\tstruct hlist_head head;\n\tstruct pt_regs regs;\n\tint rctx;\n\n\tif ((unsigned long)ops->private != smp_processor_id())\n\t\treturn;\n\n\tevent = container_of(ops, struct perf_event, ftrace_ops);\n\n\t/*\n\t * @event->hlist entry is NULL (per INIT_HLIST_NODE), and all\n\t * the perf code does is hlist_for_each_entry_rcu(), so we can\n\t * get away with simply setting the @head.first pointer in order\n\t * to create a singular list.\n\t */\n\thead.first = &event->hlist_entry;\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\n\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);\n\n\tmemset(&regs, 0, sizeof(regs));\n\tperf_fetch_caller_regs(&regs);\n\n\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->ip = ip;\n\tentry->parent_ip = parent_ip;\n\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,\n\t\t\t      1, &regs, &head, NULL);\n\n#undef ENTRY_SIZE\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_buf_submit",
          "args": [
            "entry",
            "ENTRY_SIZE",
            "rctx",
            "TRACE_FN",
            "1",
            "&regs",
            "&head",
            "NULL"
          ],
          "line": 464
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_trace_buf_alloc",
          "args": [
            "ENTRY_SIZE",
            "NULL",
            "&rctx"
          ],
          "line": 458
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_buf_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "388-410",
          "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_fetch_caller_regs",
          "args": [
            "&regs"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&regs",
            "0",
            "sizeof(regs)"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "ENTRY_SIZE > PERF_MAX_TRACE_SIZE"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "ops",
            "structperf_event",
            "ftrace_ops"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\nstatic void\nperf_ftrace_function_call(unsigned long ip, unsigned long parent_ip,\n\t\t\t  struct ftrace_ops *ops, struct pt_regs *pt_regs)\n{\n\tstruct ftrace_entry *entry;\n\tstruct perf_event *event;\n\tstruct hlist_head head;\n\tstruct pt_regs regs;\n\tint rctx;\n\n\tif ((unsigned long)ops->private != smp_processor_id())\n\t\treturn;\n\n\tevent = container_of(ops, struct perf_event, ftrace_ops);\n\n\t/*\n\t * @event->hlist entry is NULL (per INIT_HLIST_NODE), and all\n\t * the perf code does is hlist_for_each_entry_rcu(), so we can\n\t * get away with simply setting the @head.first pointer in order\n\t * to create a singular list.\n\t */\n\thead.first = &event->hlist_entry;\n\n#define ENTRY_SIZE (ALIGN(sizeof(struct ftrace_entry) + sizeof(u32), \\\n\t\t    sizeof(u64)) - sizeof(u32))\n\n\tBUILD_BUG_ON(ENTRY_SIZE > PERF_MAX_TRACE_SIZE);\n\n\tmemset(&regs, 0, sizeof(regs));\n\tperf_fetch_caller_regs(&regs);\n\n\tentry = perf_trace_buf_alloc(ENTRY_SIZE, NULL, &rctx);\n\tif (!entry)\n\t\treturn;\n\n\tentry->ip = ip;\n\tentry->parent_ip = parent_ip;\n\tperf_trace_buf_submit(entry, ENTRY_SIZE, rctx, TRACE_FN,\n\t\t\t      1, &regs, &head, NULL);\n\n#undef ENTRY_SIZE\n}"
  },
  {
    "function_name": "perf_trace_buf_update",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "414-423",
    "snippet": "void perf_trace_buf_update(void *record, u16 type)\n{\n\tstruct trace_entry *entry = record;\n\tint pc = preempt_count();\n\tunsigned long flags;\n\n\tlocal_save_flags(flags);\n\ttracing_generic_entry_update(entry, flags, pc);\n\tentry->type = type;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracing_generic_entry_update",
          "args": [
            "entry",
            "flags",
            "pc"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "tracing_generic_entry_update",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace.c",
          "lines": "2130-2149",
          "snippet": "void\ntracing_generic_entry_update(struct trace_entry *entry, unsigned long flags,\n\t\t\t     int pc)\n{\n\tstruct task_struct *tsk = current;\n\n\tentry->preempt_count\t\t= pc & 0xff;\n\tentry->pid\t\t\t= (tsk) ? tsk->pid : 0;\n\tentry->flags =\n#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT\n\t\t(irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |\n#else\n\t\tTRACE_FLAG_IRQS_NOSUPPORT |\n#endif\n\t\t((pc & NMI_MASK    ) ? TRACE_FLAG_NMI     : 0) |\n\t\t((pc & HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |\n\t\t((pc & SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |\n\t\t(tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |\n\t\t(test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);\n}",
          "includes": [
            "#include \"trace_selftest.c\"",
            "#include \"trace_output.h\"",
            "#include \"trace.h\"",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/trace.h>",
            "#include <linux/fs.h>",
            "#include <linux/nmi.h>",
            "#include <linux/poll.h>",
            "#include <linux/init.h>",
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/mount.h>",
            "#include <linux/string.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/splice.h>",
            "#include <linux/percpu.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/linkage.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/pagemap.h>",
            "#include <linux/tracefs.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/notifier.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/writeback.h>",
            "#include <linux/stacktrace.h>",
            "#include <generated/utsrelease.h>",
            "#include <linux/ring_buffer.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_selftest.c\"\n#include \"trace_output.h\"\n#include \"trace.h\"\n#include <linux/sched/rt.h>\n#include <linux/sched/clock.h>\n#include <linux/trace.h>\n#include <linux/fs.h>\n#include <linux/nmi.h>\n#include <linux/poll.h>\n#include <linux/init.h>\n#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/rwsem.h>\n#include <linux/mount.h>\n#include <linux/string.h>\n#include <linux/kdebug.h>\n#include <linux/splice.h>\n#include <linux/percpu.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/vmalloc.h>\n#include <linux/uaccess.h>\n#include <linux/linkage.h>\n#include <linux/hardirq.h>\n#include <linux/pagemap.h>\n#include <linux/tracefs.h>\n#include <linux/debugfs.h>\n#include <linux/irqflags.h>\n#include <linux/notifier.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/writeback.h>\n#include <linux/stacktrace.h>\n#include <generated/utsrelease.h>\n#include <linux/ring_buffer.h>\n\nstatic __always_inline struct;\n\nvoid\ntracing_generic_entry_update(struct trace_entry *entry, unsigned long flags,\n\t\t\t     int pc)\n{\n\tstruct task_struct *tsk = current;\n\n\tentry->preempt_count\t\t= pc & 0xff;\n\tentry->pid\t\t\t= (tsk) ? tsk->pid : 0;\n\tentry->flags =\n#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT\n\t\t(irqs_disabled_flags(flags) ? TRACE_FLAG_IRQS_OFF : 0) |\n#else\n\t\tTRACE_FLAG_IRQS_NOSUPPORT |\n#endif\n\t\t((pc & NMI_MASK    ) ? TRACE_FLAG_NMI     : 0) |\n\t\t((pc & HARDIRQ_MASK) ? TRACE_FLAG_HARDIRQ : 0) |\n\t\t((pc & SOFTIRQ_OFFSET) ? TRACE_FLAG_SOFTIRQ : 0) |\n\t\t(tif_need_resched() ? TRACE_FLAG_NEED_RESCHED : 0) |\n\t\t(test_preempt_need_resched() ? TRACE_FLAG_PREEMPT_RESCHED : 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_save_flags",
          "args": [
            "flags"
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_count",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_buf_update(void *record, u16 type)\n{\n\tstruct trace_entry *entry = record;\n\tint pc = preempt_count();\n\tunsigned long flags;\n\n\tlocal_save_flags(flags);\n\ttracing_generic_entry_update(entry, flags, pc);\n\tentry->type = type;\n}"
  },
  {
    "function_name": "perf_trace_buf_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "388-410",
    "snippet": "void *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&raw_data[size - sizeof(u64)]",
            "0",
            "sizeof(u64)"
          ],
          "line": 408
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "perf_trace_buf[rctx]"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&__perf_regs[rctx]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_swevent_get_recursion_context",
          "args": [],
          "line": 399
        },
        "resolved": true,
        "details": {
          "function_name": "perf_swevent_get_recursion_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "7993-7998",
          "snippet": "int perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __must_check struct",
            "static DEFINE_PER_CPU(struct swevent_htable, swevent_htable);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic __must_check struct;\nstatic DEFINE_PER_CPU(struct swevent_htable, swevent_htable);\n\nint perf_swevent_get_recursion_context(void)\n{\n\tstruct swevent_htable *swhash = this_cpu_ptr(&swevent_htable);\n\n\treturn get_recursion_context(swhash->recursion);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ONCE",
          "args": [
            "size > PERF_MAX_TRACE_SIZE",
            "\"perf buffer not large enough\""
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "PERF_MAX_TRACE_SIZE % sizeof(unsigned long)"
          ],
          "line": 393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\n\nvoid *perf_trace_buf_alloc(int size, struct pt_regs **regs, int *rctxp)\n{\n\tchar *raw_data;\n\tint rctx;\n\n\tBUILD_BUG_ON(PERF_MAX_TRACE_SIZE % sizeof(unsigned long));\n\n\tif (WARN_ONCE(size > PERF_MAX_TRACE_SIZE,\n\t\t      \"perf buffer not large enough\"))\n\t\treturn NULL;\n\n\t*rctxp = rctx = perf_swevent_get_recursion_context();\n\tif (rctx < 0)\n\t\treturn NULL;\n\n\tif (regs)\n\t\t*regs = this_cpu_ptr(&__perf_regs[rctx]);\n\traw_data = this_cpu_ptr(perf_trace_buf[rctx]);\n\n\t/* zero the dead bytes from align to not leak stack to user */\n\tmemset(&raw_data[size - sizeof(u64)], 0, sizeof(u64));\n\treturn raw_data;\n}"
  },
  {
    "function_name": "perf_trace_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "375-386",
    "snippet": "void perf_trace_del(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\t/*\n\t * If TRACE_REG_PERF_DEL returns false; no custom action was performed\n\t * and we need to take the default action of dequeueing our event from\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_DEL, p_event))\n\t\thlist_del_rcu(&p_event->hlist_entry);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_del_rcu",
          "args": [
            "&p_event->hlist_entry"
          ],
          "line": 385
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_DEL",
            "p_event"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_del(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\t/*\n\t * If TRACE_REG_PERF_DEL returns false; no custom action was performed\n\t * and we need to take the default action of dequeueing our event from\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_DEL, p_event))\n\t\thlist_del_rcu(&p_event->hlist_entry);\n}"
  },
  {
    "function_name": "perf_trace_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "348-373",
    "snippet": "int perf_trace_add(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\tif (!(flags & PERF_EF_START))\n\t\tp_event->hw.state = PERF_HES_STOPPED;\n\n\t/*\n\t * If TRACE_REG_PERF_ADD returns false; no custom action was performed\n\t * and we need to take the default action of enqueueing our event on\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_ADD, p_event)) {\n\t\tstruct hlist_head __percpu *pcpu_list;\n\t\tstruct hlist_head *list;\n\n\t\tpcpu_list = tp_event->perf_events;\n\t\tif (WARN_ON_ONCE(!pcpu_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = this_cpu_ptr(pcpu_list);\n\t\thlist_add_head_rcu(&p_event->hlist_entry, list);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "hlist_add_head_rcu",
          "args": [
            "&p_event->hlist_entry",
            "list"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "pcpu_list"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!pcpu_list"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_ADD",
            "p_event"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_trace_add(struct perf_event *p_event, int flags)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\n\tif (!(flags & PERF_EF_START))\n\t\tp_event->hw.state = PERF_HES_STOPPED;\n\n\t/*\n\t * If TRACE_REG_PERF_ADD returns false; no custom action was performed\n\t * and we need to take the default action of enqueueing our event on\n\t * the right per-cpu hlist.\n\t */\n\tif (!tp_event->class->reg(tp_event, TRACE_REG_PERF_ADD, p_event)) {\n\t\tstruct hlist_head __percpu *pcpu_list;\n\t\tstruct hlist_head *list;\n\n\t\tpcpu_list = tp_event->perf_events;\n\t\tif (WARN_ON_ONCE(!pcpu_list))\n\t\t\treturn -EINVAL;\n\n\t\tlist = this_cpu_ptr(pcpu_list);\n\t\thlist_add_head_rcu(&p_event->hlist_entry, list);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_uprobe_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "338-345",
    "snippet": "void perf_uprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\tdestroy_local_trace_uprobe(p_event->tp_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_local_trace_uprobe",
          "args": [
            "p_event->tp_event"
          ],
          "line": 344
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1418-1428",
          "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 342
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "149-176",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 341
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "184-188",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 340
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_uprobe_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n\tdestroy_local_trace_uprobe(p_event->tp_event);\n}"
  },
  {
    "function_name": "perf_uprobe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "293-336",
    "snippet": "int perf_uprobe_init(struct perf_event *p_event,\n\t\t     unsigned long ref_ctr_offset, bool is_retprobe)\n{\n\tint ret;\n\tchar *path = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (!p_event->attr.uprobe_path)\n\t\treturn -EINVAL;\n\tpath = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = strncpy_from_user(\n\t\tpath, u64_to_user_ptr(p_event->attr.uprobe_path), PATH_MAX);\n\tif (ret == PATH_MAX)\n\t\treturn -E2BIG;\n\tif (ret < 0)\n\t\tgoto out;\n\tif (path[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttp_event = create_local_trace_uprobe(path, p_event->attr.probe_offset,\n\t\t\t\t\t     ref_ctr_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * local trace_uprobe need to hold event_mutex to call\n\t * uprobe_buffer_enable() and uprobe_buffer_disable().\n\t * event_mutex is not required for local trace_kprobes.\n\t */\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_uprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(path);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "path"
          ],
          "line": 334
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 332
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_local_trace_uprobe",
          "args": [
            "tp_event"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1418-1428",
          "snippet": "void destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nvoid destroy_local_trace_uprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_uprobe *tu;\n\n\ttu = container_of(event_call, struct trace_uprobe, tp.call);\n\n\tkfree(tu->tp.call.print_fmt);\n\ttu->tp.call.print_fmt = NULL;\n\n\tfree_trace_uprobe(tu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "190-210",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp_event"
          ],
          "line": 319
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp_event"
          ],
          "line": 318
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_local_trace_uprobe",
          "args": [
            "path",
            "p_event->attr.probe_offset",
            "ref_ctr_offset",
            "is_retprobe"
          ],
          "line": 316
        },
        "resolved": true,
        "details": {
          "function_name": "create_local_trace_uprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "1369-1416",
          "snippet": "struct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tinit_trace_event_call(tu, &tu->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn &tu->tp.call;\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define UPROBE_EVENT_SYSTEM\t\"uprobes\""
          ],
          "globals_used": [
            "static int register_uprobe_event(struct trace_uprobe *tu);",
            "static int unregister_uprobe_event(struct trace_uprobe *tu);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define UPROBE_EVENT_SYSTEM\t\"uprobes\"\n\nstatic int register_uprobe_event(struct trace_uprobe *tu);\nstatic int unregister_uprobe_event(struct trace_uprobe *tu);\n\nstruct trace_event_call *\ncreate_local_trace_uprobe(char *name, unsigned long offs,\n\t\t\t  unsigned long ref_ctr_offset, bool is_return)\n{\n\tstruct trace_uprobe *tu;\n\tstruct path path;\n\tint ret;\n\n\tret = kern_path(name, LOOKUP_FOLLOW, &path);\n\tif (ret)\n\t\treturn ERR_PTR(ret);\n\n\tif (!d_is_reg(path.dentry)) {\n\t\tpath_put(&path);\n\t\treturn ERR_PTR(-EINVAL);\n\t}\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name \"DUMMY_EVENT\" here.\n\t */\n\ttu = alloc_trace_uprobe(UPROBE_EVENT_SYSTEM, \"DUMMY_EVENT\", 0,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tu)) {\n\t\tpr_info(\"Failed to allocate trace_uprobe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tu));\n\t\tpath_put(&path);\n\t\treturn ERR_CAST(tu);\n\t}\n\n\ttu->offset = offs;\n\ttu->path = path;\n\ttu->ref_ctr_offset = ref_ctr_offset;\n\ttu->filename = kstrdup(name, GFP_KERNEL);\n\tinit_trace_event_call(tu, &tu->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tu->tp, is_ret_probe(tu)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\treturn &tu->tp.call;\nerror:\n\tfree_trace_uprobe(tu);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "path",
            "u64_to_user_ptr(p_event->attr.uprobe_path)",
            "PATH_MAX"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "p_event->attr.uprobe_path"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "PATH_MAX",
            "GFP_KERNEL"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_uprobe_init(struct perf_event *p_event,\n\t\t     unsigned long ref_ctr_offset, bool is_retprobe)\n{\n\tint ret;\n\tchar *path = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (!p_event->attr.uprobe_path)\n\t\treturn -EINVAL;\n\tpath = kzalloc(PATH_MAX, GFP_KERNEL);\n\tif (!path)\n\t\treturn -ENOMEM;\n\tret = strncpy_from_user(\n\t\tpath, u64_to_user_ptr(p_event->attr.uprobe_path), PATH_MAX);\n\tif (ret == PATH_MAX)\n\t\treturn -E2BIG;\n\tif (ret < 0)\n\t\tgoto out;\n\tif (path[0] == '\\0') {\n\t\tret = -EINVAL;\n\t\tgoto out;\n\t}\n\n\ttp_event = create_local_trace_uprobe(path, p_event->attr.probe_offset,\n\t\t\t\t\t     ref_ctr_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\t/*\n\t * local trace_uprobe need to hold event_mutex to call\n\t * uprobe_buffer_enable() and uprobe_buffer_disable().\n\t * event_mutex is not required for local trace_kprobes.\n\t */\n\tmutex_lock(&event_mutex);\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_uprobe(tp_event);\n\tmutex_unlock(&event_mutex);\nout:\n\tkfree(path);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_kprobe_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "283-289",
    "snippet": "void perf_kprobe_destroy(struct perf_event *p_event)\n{\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\n\tdestroy_local_trace_kprobe(p_event->tp_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "destroy_local_trace_kprobe",
          "args": [
            "p_event->tp_event"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1446-1461",
          "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "149-176",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "184-188",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_kprobe_destroy(struct perf_event *p_event)\n{\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\n\tdestroy_local_trace_kprobe(p_event->tp_event);\n}"
  },
  {
    "function_name": "perf_kprobe_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "243-281",
    "snippet": "int perf_kprobe_init(struct perf_event *p_event, bool is_retprobe)\n{\n\tint ret;\n\tchar *func = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (p_event->attr.kprobe_func) {\n\t\tfunc = kzalloc(KSYM_NAME_LEN, GFP_KERNEL);\n\t\tif (!func)\n\t\t\treturn -ENOMEM;\n\t\tret = strncpy_from_user(\n\t\t\tfunc, u64_to_user_ptr(p_event->attr.kprobe_func),\n\t\t\tKSYM_NAME_LEN);\n\t\tif (ret == KSYM_NAME_LEN)\n\t\t\tret = -E2BIG;\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (func[0] == '\\0') {\n\t\t\tkfree(func);\n\t\t\tfunc = NULL;\n\t\t}\n\t}\n\n\ttp_event = create_local_trace_kprobe(\n\t\tfunc, (void *)(unsigned long)(p_event->attr.kprobe_addr),\n\t\tp_event->attr.probe_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_kprobe(tp_event);\nout:\n\tkfree(func);\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "func"
          ],
          "line": 279
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "destroy_local_trace_kprobe",
          "args": [
            "tp_event"
          ],
          "line": 277
        },
        "resolved": true,
        "details": {
          "function_name": "destroy_local_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1446-1461",
          "snippet": "void destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\n\nvoid destroy_local_trace_kprobe(struct trace_event_call *event_call)\n{\n\tstruct trace_kprobe *tk;\n\n\ttk = container_of(event_call, struct trace_kprobe, tp.call);\n\n\tif (trace_probe_is_enabled(&tk->tp)) {\n\t\tWARN_ON(1);\n\t\treturn;\n\t}\n\n\t__unregister_trace_kprobe(tk);\n\n\tkfree(tk->tp.call.print_fmt);\n\tfree_trace_kprobe(tk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 275
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "190-210",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "tp_event"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "tp_event"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "create_local_trace_kprobe",
          "args": [
            "func",
            "(void *)(unsigned long)(p_event->attr.kprobe_addr)",
            "p_event->attr.probe_offset",
            "is_retprobe"
          ],
          "line": 267
        },
        "resolved": true,
        "details": {
          "function_name": "create_local_trace_kprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_kprobe.c",
          "lines": "1402-1444",
          "snippet": "struct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk, &tk->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0) {\n\t\tkfree(tk->tp.call.print_fmt);\n\t\tgoto error;\n\t}\n\n\treturn &tk->tp.call;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include \"trace_kprobe_selftest.h\"",
            "#include <linux/error-injection.h>",
            "#include <linux/rculist.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [
            "#define KPROBE_EVENT_SYSTEM \"kprobes\""
          ],
          "globals_used": [
            "static int register_kprobe_event(struct trace_kprobe *tk);",
            "static int unregister_kprobe_event(struct trace_kprobe *tk);",
            "static LIST_HEAD(probe_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include \"trace_kprobe_selftest.h\"\n#include <linux/error-injection.h>\n#include <linux/rculist.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\n#define KPROBE_EVENT_SYSTEM \"kprobes\"\n\nstatic int register_kprobe_event(struct trace_kprobe *tk);\nstatic int unregister_kprobe_event(struct trace_kprobe *tk);\nstatic LIST_HEAD(probe_list);\n\nstruct trace_event_call *\ncreate_local_trace_kprobe(char *func, void *addr, unsigned long offs,\n\t\t\t  bool is_return)\n{\n\tstruct trace_kprobe *tk;\n\tint ret;\n\tchar *event;\n\n\t/*\n\t * local trace_kprobes are not added to probe_list, so they are never\n\t * searched in find_trace_kprobe(). Therefore, there is no concern of\n\t * duplicated name here.\n\t */\n\tevent = func ? func : \"DUMMY_EVENT\";\n\n\ttk = alloc_trace_kprobe(KPROBE_EVENT_SYSTEM, event, (void *)addr, func,\n\t\t\t\toffs, 0 /* maxactive */, 0 /* nargs */,\n\t\t\t\tis_return);\n\n\tif (IS_ERR(tk)) {\n\t\tpr_info(\"Failed to allocate trace_probe.(%d)\\n\",\n\t\t\t(int)PTR_ERR(tk));\n\t\treturn ERR_CAST(tk);\n\t}\n\n\tinit_trace_event_call(tk, &tk->tp.call);\n\n\tif (traceprobe_set_print_fmt(&tk->tp, trace_kprobe_is_return(tk)) < 0) {\n\t\tret = -ENOMEM;\n\t\tgoto error;\n\t}\n\n\tret = __register_trace_kprobe(tk);\n\tif (ret < 0) {\n\t\tkfree(tk->tp.call.print_fmt);\n\t\tgoto error;\n\t}\n\n\treturn &tk->tp.call;\nerror:\n\tfree_trace_kprobe(tk);\n\treturn ERR_PTR(ret);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "func",
            "u64_to_user_ptr(p_event->attr.kprobe_func)",
            "KSYM_NAME_LEN"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "u64_to_user_ptr",
          "args": [
            "p_event->attr.kprobe_func"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "KSYM_NAME_LEN",
            "GFP_KERNEL"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_kprobe_init(struct perf_event *p_event, bool is_retprobe)\n{\n\tint ret;\n\tchar *func = NULL;\n\tstruct trace_event_call *tp_event;\n\n\tif (p_event->attr.kprobe_func) {\n\t\tfunc = kzalloc(KSYM_NAME_LEN, GFP_KERNEL);\n\t\tif (!func)\n\t\t\treturn -ENOMEM;\n\t\tret = strncpy_from_user(\n\t\t\tfunc, u64_to_user_ptr(p_event->attr.kprobe_func),\n\t\t\tKSYM_NAME_LEN);\n\t\tif (ret == KSYM_NAME_LEN)\n\t\t\tret = -E2BIG;\n\t\tif (ret < 0)\n\t\t\tgoto out;\n\n\t\tif (func[0] == '\\0') {\n\t\t\tkfree(func);\n\t\t\tfunc = NULL;\n\t\t}\n\t}\n\n\ttp_event = create_local_trace_kprobe(\n\t\tfunc, (void *)(unsigned long)(p_event->attr.kprobe_addr),\n\t\tp_event->attr.probe_offset, is_retprobe);\n\tif (IS_ERR(tp_event)) {\n\t\tret = PTR_ERR(tp_event);\n\t\tgoto out;\n\t}\n\n\tret = perf_trace_event_init(tp_event, p_event);\n\tif (ret)\n\t\tdestroy_local_trace_kprobe(tp_event);\nout:\n\tkfree(func);\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "234-240",
    "snippet": "void perf_trace_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "149-176",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_close",
          "args": [
            "p_event"
          ],
          "line": 237
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_close",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "184-188",
          "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 236
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nvoid perf_trace_destroy(struct perf_event *p_event)\n{\n\tmutex_lock(&event_mutex);\n\tperf_trace_event_close(p_event);\n\tperf_trace_event_unreg(p_event);\n\tmutex_unlock(&event_mutex);\n}"
  },
  {
    "function_name": "perf_trace_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "212-232",
    "snippet": "int perf_trace_init(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event;\n\tu64 event_id = p_event->attr.config;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (tp_event->event.type == event_id &&\n\t\t    tp_event->class && tp_event->class->reg &&\n\t\t    try_module_get(tp_event->mod)) {\n\t\t\tret = perf_trace_event_init(tp_event, p_event);\n\t\t\tif (ret)\n\t\t\t\tmodule_put(tp_event->mod);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&event_mutex"
          ],
          "line": 229
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "tp_event->mod"
          ],
          "line": 225
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_init",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "190-210",
          "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "try_module_get",
          "args": [
            "tp_event->mod"
          ],
          "line": 222
        },
        "resolved": true,
        "details": {
          "function_name": "try_module_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1113-1129",
          "snippet": "bool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nbool try_module_get(struct module *module)\n{\n\tbool ret = true;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\t/* Note: here, we can fail to get a reference */\n\t\tif (likely(module_is_live(module) &&\n\t\t\t   atomic_inc_not_zero(&module->refcnt) != 0))\n\t\t\ttrace_module_get(module, _RET_IP_);\n\t\telse\n\t\t\tret = false;\n\n\t\tpreempt_enable();\n\t}\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_event",
            "&ftrace_events",
            "list"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&event_mutex"
          ],
          "line": 218
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nint perf_trace_init(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event;\n\tu64 event_id = p_event->attr.config;\n\tint ret = -EINVAL;\n\n\tmutex_lock(&event_mutex);\n\tlist_for_each_entry(tp_event, &ftrace_events, list) {\n\t\tif (tp_event->event.type == event_id &&\n\t\t    tp_event->class && tp_event->class->reg &&\n\t\t    try_module_get(tp_event->mod)) {\n\t\t\tret = perf_trace_event_init(tp_event, p_event);\n\t\t\tif (ret)\n\t\t\t\tmodule_put(tp_event->mod);\n\t\t\tbreak;\n\t\t}\n\t}\n\tmutex_unlock(&event_mutex);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_event_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "190-210",
    "snippet": "static int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "perf_trace_event_unreg",
          "args": [
            "p_event"
          ],
          "line": 205
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_unreg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "149-176",
          "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_open",
          "args": [
            "p_event"
          ],
          "line": 203
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_open",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "178-182",
          "snippet": "static int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_reg",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 199
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_reg",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "91-147",
          "snippet": "static int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
            "static int\ttotal_ref_count;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_trace_event_perm",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "perf_trace_event_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
          "lines": "26-89",
          "snippet": "static int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (tp_event->perf_perm) {\n\t\tint ret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"trace_probe.h\"",
            "#include \"trace.h\"",
            "#include <linux/kprobes.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (tp_event->perf_perm) {\n\t\tint ret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_init(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tint ret;\n\n\tret = perf_trace_event_perm(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_reg(tp_event, p_event);\n\tif (ret)\n\t\treturn ret;\n\n\tret = perf_trace_event_open(p_event);\n\tif (ret) {\n\t\tperf_trace_event_unreg(p_event);\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "perf_trace_event_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "184-188",
    "snippet": "static void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_CLOSE",
            "p_event"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic void perf_trace_event_close(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_CLOSE, p_event);\n}"
  },
  {
    "function_name": "perf_trace_event_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "178-182",
    "snippet": "static int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_OPEN",
            "p_event"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_open(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\treturn tp_event->class->reg(tp_event, TRACE_REG_PERF_OPEN, p_event);\n}"
  },
  {
    "function_name": "perf_trace_event_unreg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "149-176",
    "snippet": "static void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
      "static int\ttotal_ref_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "module_put",
          "args": [
            "tp_event->mod"
          ],
          "line": 175
        },
        "resolved": true,
        "details": {
          "function_name": "module_put",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "1132-1143",
          "snippet": "void module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nvoid module_put(struct module *module)\n{\n\tint ret;\n\n\tif (module) {\n\t\tpreempt_disable();\n\t\tret = atomic_dec_if_positive(&module->refcnt);\n\t\tWARN_ON(ret < 0);\t/* Failed to put refcount */\n\t\ttrace_module_put(module, _RET_IP_);\n\t\tpreempt_enable();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "perf_trace_buf[i]"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_synchronize_unregister",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_UNREGISTER",
            "NULL"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic void perf_trace_event_unreg(struct perf_event *p_event)\n{\n\tstruct trace_event_call *tp_event = p_event->tp_event;\n\tint i;\n\n\tif (--tp_event->perf_refcount > 0)\n\t\tgoto out;\n\n\ttp_event->class->reg(tp_event, TRACE_REG_PERF_UNREGISTER, NULL);\n\n\t/*\n\t * Ensure our callback won't be called anymore. The buffers\n\t * will be freed after that.\n\t */\n\ttracepoint_synchronize_unregister();\n\n\tfree_percpu(tp_event->perf_events);\n\ttp_event->perf_events = NULL;\n\n\tif (!--total_ref_count) {\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\nout:\n\tmodule_put(tp_event->mod);\n}"
  },
  {
    "function_name": "perf_trace_event_reg",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "91-147",
    "snippet": "static int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];",
      "static int\ttotal_ref_count;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free_percpu",
          "args": [
            "tp_event->perf_events"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_free_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "27-35",
          "snippet": "static void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic void bpf_array_free_percpu(struct bpf_array *array)\n{\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tfree_percpu(array->pptrs[i]);\n\t\tcond_resched();\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_event->class->reg",
          "args": [
            "tp_event",
            "TRACE_REG_PERF_REGISTER",
            "NULL"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "alloc_percpu",
          "args": [
            "perf_trace_t"
          ],
          "line": 116
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_array_alloc_percpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/arraymap.c",
          "lines": "37-54",
          "snippet": "static int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"map_in_map.h\"",
            "#include <uapi/linux/btf.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/filter.h>",
            "#include <linux/mm.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/btf.h>",
            "#include <linux/bpf.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"map_in_map.h\"\n#include <uapi/linux/btf.h>\n#include <linux/perf_event.h>\n#include <linux/filter.h>\n#include <linux/mm.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/btf.h>\n#include <linux/bpf.h>\n\nstatic int bpf_array_alloc_percpu(struct bpf_array *array)\n{\n\tvoid __percpu *ptr;\n\tint i;\n\n\tfor (i = 0; i < array->map.max_entries; i++) {\n\t\tptr = __alloc_percpu_gfp(array->elem_size, 8,\n\t\t\t\t\t GFP_USER | __GFP_NOWARN);\n\t\tif (!ptr) {\n\t\t\tbpf_array_free_percpu(array);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tarray->pptrs[i] = ptr;\n\t\tcond_resched();\n\t}\n\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic char __percpu *perf_trace_buf[PERF_NR_CONTEXTS];\nstatic int\ttotal_ref_count;\n\nstatic int perf_trace_event_reg(struct trace_event_call *tp_event,\n\t\t\t\tstruct perf_event *p_event)\n{\n\tstruct hlist_head __percpu *list;\n\tint ret = -ENOMEM;\n\tint cpu;\n\n\tp_event->tp_event = tp_event;\n\tif (tp_event->perf_refcount++ > 0)\n\t\treturn 0;\n\n\tlist = alloc_percpu(struct hlist_head);\n\tif (!list)\n\t\tgoto fail;\n\n\tfor_each_possible_cpu(cpu)\n\t\tINIT_HLIST_HEAD(per_cpu_ptr(list, cpu));\n\n\ttp_event->perf_events = list;\n\n\tif (!total_ref_count) {\n\t\tchar __percpu *buf;\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tbuf = (char __percpu *)alloc_percpu(perf_trace_t);\n\t\t\tif (!buf)\n\t\t\t\tgoto fail;\n\n\t\t\tperf_trace_buf[i] = buf;\n\t\t}\n\t}\n\n\tret = tp_event->class->reg(tp_event, TRACE_REG_PERF_REGISTER, NULL);\n\tif (ret)\n\t\tgoto fail;\n\n\ttotal_ref_count++;\n\treturn 0;\n\nfail:\n\tif (!total_ref_count) {\n\t\tint i;\n\n\t\tfor (i = 0; i < PERF_NR_CONTEXTS; i++) {\n\t\t\tfree_percpu(perf_trace_buf[i]);\n\t\t\tperf_trace_buf[i] = NULL;\n\t\t}\n\t}\n\n\tif (!--tp_event->perf_refcount) {\n\t\tfree_percpu(tp_event->perf_events);\n\t\ttp_event->perf_events = NULL;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "perf_trace_event_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_event_perf.c",
    "lines": "26-89",
    "snippet": "static int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (tp_event->perf_perm) {\n\t\tint ret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"trace_probe.h\"",
      "#include \"trace.h\"",
      "#include <linux/kprobes.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_SYS_ADMIN"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "perf_paranoid_tracepoint_raw",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_sampling_event",
          "args": [
            "p_event"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "perf_paranoid_tracepoint_raw",
          "args": [],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ftrace_event_is_function",
          "args": [
            "tp_event"
          ],
          "line": 48
        },
        "resolved": true,
        "details": {
          "function_name": "ftrace_event_is_function",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_export.c",
          "lines": "198-201",
          "snippet": "bool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}",
          "includes": [
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_entries.h\"",
            "#include \"trace_output.h\"",
            "#include <linux/init.h>",
            "#include <linux/module.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/stringify.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_entries.h\"\n#include \"trace_output.h\"\n#include <linux/init.h>\n#include <linux/module.h>\n#include <linux/ftrace.h>\n#include <linux/uaccess.h>\n#include <linux/seq_file.h>\n#include <linux/kallsyms.h>\n#include <linux/stringify.h>\n\nbool ftrace_event_is_function(struct trace_event_call *call)\n{\n\treturn call == &event_function;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tp_event->perf_perm",
          "args": [
            "tp_event",
            "p_event"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"trace_probe.h\"\n#include \"trace.h\"\n#include <linux/kprobes.h>\n#include <linux/module.h>\n\nstatic int perf_trace_event_perm(struct trace_event_call *tp_event,\n\t\t\t\t struct perf_event *p_event)\n{\n\tif (tp_event->perf_perm) {\n\t\tint ret = tp_event->perf_perm(tp_event, p_event);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\t/*\n\t * We checked and allowed to create parent,\n\t * allow children without checking.\n\t */\n\tif (p_event->parent)\n\t\treturn 0;\n\n\t/*\n\t * It's ok to check current process (owner) permissions in here,\n\t * because code below is called only via perf_event_open syscall.\n\t */\n\n\t/* The ftrace function trace is allowed only for root. */\n\tif (ftrace_event_is_function(tp_event)) {\n\t\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\t\treturn -EPERM;\n\n\t\tif (!is_sampling_event(p_event))\n\t\t\treturn 0;\n\n\t\t/*\n\t\t * We don't allow user space callchains for  function trace\n\t\t * event, due to issues with page faults while tracing page\n\t\t * fault handler and its overall trickiness nature.\n\t\t */\n\t\tif (!p_event->attr.exclude_callchain_user)\n\t\t\treturn -EINVAL;\n\n\t\t/*\n\t\t * Same reason to disable user stack dump as for user space\n\t\t * callchains above.\n\t\t */\n\t\tif (p_event->attr.sample_type & PERF_SAMPLE_STACK_USER)\n\t\t\treturn -EINVAL;\n\t}\n\n\t/* No tracing, just counting, so no obvious leak */\n\tif (!(p_event->attr.sample_type & PERF_SAMPLE_RAW))\n\t\treturn 0;\n\n\t/* Some events are ok to be traced by non-root users... */\n\tif (p_event->attach_state == PERF_ATTACH_TASK) {\n\t\tif (tp_event->flags & TRACE_EVENT_FL_CAP_ANY)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * ...otherwise raw tracepoint data can be a severe data leak,\n\t * only allow root to have these.\n\t */\n\tif (perf_paranoid_tracepoint_raw() && !capable(CAP_SYS_ADMIN))\n\t\treturn -EPERM;\n\n\treturn 0;\n}"
  }
]