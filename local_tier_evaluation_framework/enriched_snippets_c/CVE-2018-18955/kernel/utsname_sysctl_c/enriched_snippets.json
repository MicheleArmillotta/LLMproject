[
  {
    "function_name": "utsname_sysctl_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname_sysctl.c",
    "lines": "142-146",
    "snippet": "static int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "register_sysctl_table",
          "args": [
            "uts_root_table"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ctl_table uts_root_table[] = {\n\t{\n\t\t.procname\t= \"kernel\",\n\t\t.mode\t\t= 0555,\n\t\t.child\t\t= uts_kern_table,\n\t},\n\t{}\n};\n\nstatic int __init utsname_sysctl_init(void)\n{\n\tregister_sysctl_table(uts_root_table);\n\treturn 0;\n}"
  },
  {
    "function_name": "uts_proc_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname_sysctl.c",
    "lines": "134-139",
    "snippet": "void uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"ostype\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"osrelease\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"version\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"hostname\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"domainname\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_poll_notify",
          "args": [
            "table->poll"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic struct ctl_table uts_kern_table[] = {\n\t{\n\t\t.procname\t= \"ostype\",\n\t\t.data\t\t= init_uts_ns.name.sysname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.sysname),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"osrelease\",\n\t\t.data\t\t= init_uts_ns.name.release,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.release),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"version\",\n\t\t.data\t\t= init_uts_ns.name.version,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.version),\n\t\t.mode\t\t= 0444,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t},\n\t{\n\t\t.procname\t= \"hostname\",\n\t\t.data\t\t= init_uts_ns.name.nodename,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.nodename),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &hostname_poll,\n\t},\n\t{\n\t\t.procname\t= \"domainname\",\n\t\t.data\t\t= init_uts_ns.name.domainname,\n\t\t.maxlen\t\t= sizeof(init_uts_ns.name.domainname),\n\t\t.mode\t\t= 0644,\n\t\t.proc_handler\t= proc_do_uts_string,\n\t\t.poll\t\t= &domainname_poll,\n\t},\n\t{}\n};\n\nvoid uts_proc_notify(enum uts_proc proc)\n{\n\tstruct ctl_table *table = &uts_kern_table[proc];\n\n\tproc_sys_poll_notify(table->poll);\n}"
  },
  {
    "function_name": "proc_do_uts_string",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname_sysctl.c",
    "lines": "36-71",
    "snippet": "static int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tchar tmp_data[__NEW_UTS_LEN + 1];\n\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = tmp_data;\n\n\t/*\n\t * Buffer the value in tmp_data so that proc_dostring() can be called\n\t * without holding any locks.\n\t * We also need to read the original value in the write==1 case to\n\t * support partial writes.\n\t */\n\tdown_read(&uts_sem);\n\tmemcpy(tmp_data, get_uts(table), sizeof(tmp_data));\n\tup_read(&uts_sem);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\t/*\n\t\t * Write back the new value.\n\t\t * Note that, since we dropped uts_sem, the result can\n\t\t * theoretically be incorrect if there are two parallel writes\n\t\t * at non-zero offsets to the same sysctl.\n\t\t */\n\t\tdown_write(&uts_sem);\n\t\tmemcpy(get_uts(table), tmp_data, sizeof(tmp_data));\n\t\tup_write(&uts_sem);\n\t\tproc_sys_poll_notify(table->poll);\n\t}\n\n\treturn r;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [
      "#define proc_do_uts_string NULL"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "proc_sys_poll_notify",
          "args": [
            "table->poll"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "up_write",
          "args": [
            "&uts_sem"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_up_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "166-191",
          "snippet": "void percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_up_write(struct percpu_rw_semaphore *sem)\n{\n\t/*\n\t * Signal the writer is done, no fast path yet.\n\t *\n\t * One reason that we cannot just immediately flip to readers_fast is\n\t * that new readers might fail to see the results of this writer's\n\t * critical section.\n\t *\n\t * Therefore we force it through the slow path which guarantees an\n\t * acquire and thereby guarantees the critical section's consistency.\n\t */\n\tsmp_store_release(&sem->readers_block, 0);\n\n\t/*\n\t * Release the write lock, this will allow readers back in the game.\n\t */\n\tup_write(&sem->rw_sem);\n\n\t/*\n\t * Once this completes (at least one RCU-sched grace period hence) the\n\t * reader fast path will be available again. Safe to use outside the\n\t * exclusive write lock because its counting.\n\t */\n\trcu_sync_exit(&sem->rss);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "get_uts(table)",
            "tmp_data",
            "sizeof(tmp_data)"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_uts",
          "args": [
            "table"
          ],
          "line": 65
        },
        "resolved": true,
        "details": {
          "function_name": "get_uts",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname_sysctl.c",
          "lines": "21-30",
          "snippet": "static void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}",
          "includes": [
            "#include <linux/rwsem.h>",
            "#include <linux/wait.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/utsname.h>",
            "#include <linux/uts.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_write",
          "args": [
            "&uts_sem"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "percpu_down_write",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/percpu-rwsem.c",
          "lines": "140-163",
          "snippet": "void percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}",
          "includes": [
            "#include <linux/errno.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/percpu.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/atomic.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/errno.h>\n#include <linux/sched.h>\n#include <linux/rcupdate.h>\n#include <linux/percpu-rwsem.h>\n#include <linux/lockdep.h>\n#include <linux/percpu.h>\n#include <linux/rwsem.h>\n#include <linux/atomic.h>\n\nvoid percpu_down_write(struct percpu_rw_semaphore *sem)\n{\n\t/* Notify readers to take the slow path. */\n\trcu_sync_enter(&sem->rss);\n\n\tdown_write(&sem->rw_sem);\n\n\t/*\n\t * Notify new readers to block; up until now, and thus throughout the\n\t * longish rcu_sync_enter() above, new readers could still come in.\n\t */\n\tWRITE_ONCE(sem->readers_block, 1);\n\n\tsmp_mb(); /* D matches A */\n\n\t/*\n\t * If they don't see our writer of readers_block, then we are\n\t * guaranteed to see their sem->read_count increment, and therefore\n\t * will wait for them.\n\t */\n\n\t/* Wait for all now active readers to complete. */\n\trcuwait_wait_event(&sem->writer, readers_active_check(sem));\n}"
        }
      },
      {
        "call_info": {
          "callee": "proc_dostring",
          "args": [
            "&uts_table",
            "write",
            "buffer",
            "lenp",
            "ppos"
          ],
          "line": 55
        },
        "resolved": true,
        "details": {
          "function_name": "proc_dostring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sysctl.c",
          "lines": "3182-3186",
          "snippet": "int proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}",
          "includes": [
            "#include <linux/inotify.h>",
            "#include <linux/nmi.h>",
            "#include <linux/stackleak.h>",
            "#include <scsi/sg.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/rtmutex.h>",
            "#include <linux/acct.h>",
            "#include <asm/setup.h>",
            "#include <asm/io.h>",
            "#include <asm/stacktrace.h>",
            "#include <asm/nmi.h>",
            "#include <asm/processor.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/mount.h>",
            "#include <linux/bpf.h>",
            "#include <linux/kexec.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/capability.h>",
            "#include <linux/kmod.h>",
            "#include <linux/oom.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/reboot.h>",
            "#include <linux/acpi.h>",
            "#include <linux/nfs_fs.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/dnotify.h>",
            "#include <linux/dcache.h>",
            "#include <linux/limits.h>",
            "#include <linux/times.h>",
            "#include <linux/key.h>",
            "#include <linux/initrd.h>",
            "#include <linux/hugetlb.h>",
            "#include <linux/compaction.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/writeback.h>",
            "#include <linux/highuid.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/net.h>",
            "#include <linux/kobject.h>",
            "#include <linux/kernel.h>",
            "#include <linux/init.h>",
            "#include <linux/fs.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/ctype.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/printk.h>",
            "#include <linux/signal.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/slab.h>",
            "#include <linux/swap.h>",
            "#include <linux/mm.h>",
            "#include <linux/aio.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/inotify.h>\n#include <linux/nmi.h>\n#include <linux/stackleak.h>\n#include <scsi/sg.h>\n#include <linux/lockdep.h>\n#include <linux/rtmutex.h>\n#include <linux/acct.h>\n#include <asm/setup.h>\n#include <asm/io.h>\n#include <asm/stacktrace.h>\n#include <asm/nmi.h>\n#include <asm/processor.h>\n#include <linux/uaccess.h>\n#include <linux/mount.h>\n#include <linux/bpf.h>\n#include <linux/kexec.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/sysctl.h>\n#include <linux/binfmts.h>\n#include <linux/capability.h>\n#include <linux/kmod.h>\n#include <linux/oom.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/kprobes.h>\n#include <linux/perf_event.h>\n#include <linux/ftrace.h>\n#include <linux/reboot.h>\n#include <linux/acpi.h>\n#include <linux/nfs_fs.h>\n#include <linux/vmstat.h>\n#include <linux/syscalls.h>\n#include <linux/dnotify.h>\n#include <linux/dcache.h>\n#include <linux/limits.h>\n#include <linux/times.h>\n#include <linux/key.h>\n#include <linux/initrd.h>\n#include <linux/hugetlb.h>\n#include <linux/compaction.h>\n#include <linux/ratelimit.h>\n#include <linux/writeback.h>\n#include <linux/highuid.h>\n#include <linux/sysrq.h>\n#include <linux/net.h>\n#include <linux/kobject.h>\n#include <linux/kernel.h>\n#include <linux/init.h>\n#include <linux/fs.h>\n#include <linux/kmemleak.h>\n#include <linux/ctype.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/printk.h>\n#include <linux/signal.h>\n#include <linux/bitmap.h>\n#include <linux/sysctl.h>\n#include <linux/slab.h>\n#include <linux/swap.h>\n#include <linux/mm.h>\n#include <linux/aio.h>\n#include <linux/module.h>\n\nint proc_dostring(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\treturn -ENOSYS;\n}"
        }
      },
      {
        "call_info": {
          "callee": "up_read",
          "args": [
            "&uts_sem"
          ],
          "line": 54
        },
        "resolved": true,
        "details": {
          "function_name": "wakeup_readers",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/relay.c",
          "lines": "336-342",
          "snippet": "static void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}",
          "includes": [
            "#include <linux/splice.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/relay.h>",
            "#include <linux/string.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/stddef.h>",
            "#include <linux/errno.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/splice.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/vmalloc.h>\n#include <linux/relay.h>\n#include <linux/string.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/stddef.h>\n#include <linux/errno.h>\n\nstatic void wakeup_readers(struct irq_work *work)\n{\n\tstruct rchan_buf *buf;\n\n\tbuf = container_of(work, struct rchan_buf, wakeup_work);\n\twake_up_interruptible(&buf->read_wait);\n}"
        }
      },
      {
        "call_info": {
          "callee": "down_read",
          "args": [
            "&uts_sem"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "down_read_non_owner",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rwsem.c",
          "lines": "180-186",
          "snippet": "void down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}",
          "includes": [
            "#include \"rwsem.h\"",
            "#include <linux/atomic.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/export.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rwsem.h\"\n#include <linux/atomic.h>\n#include <linux/rwsem.h>\n#include <linux/export.h>\n#include <linux/sched/debug.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nvoid down_read_non_owner(struct rw_semaphore *sem)\n{\n\tmight_sleep();\n\n\t__down_read(sem);\n\t__rwsem_set_reader_owned(sem, NULL);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\n#define proc_do_uts_string NULL\n\nstatic int proc_do_uts_string(struct ctl_table *table, int write,\n\t\t  void __user *buffer, size_t *lenp, loff_t *ppos)\n{\n\tstruct ctl_table uts_table;\n\tint r;\n\tchar tmp_data[__NEW_UTS_LEN + 1];\n\n\tmemcpy(&uts_table, table, sizeof(uts_table));\n\tuts_table.data = tmp_data;\n\n\t/*\n\t * Buffer the value in tmp_data so that proc_dostring() can be called\n\t * without holding any locks.\n\t * We also need to read the original value in the write==1 case to\n\t * support partial writes.\n\t */\n\tdown_read(&uts_sem);\n\tmemcpy(tmp_data, get_uts(table), sizeof(tmp_data));\n\tup_read(&uts_sem);\n\tr = proc_dostring(&uts_table, write, buffer, lenp, ppos);\n\n\tif (write) {\n\t\t/*\n\t\t * Write back the new value.\n\t\t * Note that, since we dropped uts_sem, the result can\n\t\t * theoretically be incorrect if there are two parallel writes\n\t\t * at non-zero offsets to the same sysctl.\n\t\t */\n\t\tdown_write(&uts_sem);\n\t\tmemcpy(get_uts(table), tmp_data, sizeof(tmp_data));\n\t\tup_write(&uts_sem);\n\t\tproc_sys_poll_notify(table->poll);\n\t}\n\n\treturn r;\n}"
  },
  {
    "function_name": "get_uts",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/utsname_sysctl.c",
    "lines": "21-30",
    "snippet": "static void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}",
    "includes": [
      "#include <linux/rwsem.h>",
      "#include <linux/wait.h>",
      "#include <linux/sysctl.h>",
      "#include <linux/utsname.h>",
      "#include <linux/uts.h>",
      "#include <linux/export.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/rwsem.h>\n#include <linux/wait.h>\n#include <linux/sysctl.h>\n#include <linux/utsname.h>\n#include <linux/uts.h>\n#include <linux/export.h>\n\nstatic void *get_uts(struct ctl_table *table)\n{\n\tchar *which = table->data;\n\tstruct uts_namespace *uts_ns;\n\n\tuts_ns = current->nsproxy->uts_ns;\n\twhich = (which - (char *)&init_uts_ns) + (char *)uts_ns;\n\n\treturn which;\n}"
  }
]