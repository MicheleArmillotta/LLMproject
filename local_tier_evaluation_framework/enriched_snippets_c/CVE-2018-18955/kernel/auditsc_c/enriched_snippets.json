[
  {
    "function_name": "audit_killed_trees",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2523-2529",
    "snippet": "struct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!ctx || !ctx->in_syscall"
          ],
          "line": 2526
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2525
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct list_head *audit_killed_trees(void)\n{\n\tstruct audit_context *ctx = audit_context();\n\tif (likely(!ctx || !ctx->in_syscall))\n\t\treturn NULL;\n\treturn &ctx->killed_trees;\n}"
  },
  {
    "function_name": "audit_seccomp_actions_logged",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2503-2521",
    "snippet": "void audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" res=%d\"",
            "res"
          ],
          "line": 2519
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2513
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_CONFIG_CHANGE"
          ],
          "line": 2511
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp_actions_logged(const char *names, const char *old_names,\n\t\t\t\t  int res)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL,\n\t\t\t     AUDIT_CONFIG_CHANGE);\n\tif (unlikely(!ab))\n\t\treturn;\n\n\taudit_log_format(ab, \"op=seccomp-logging\");\n\taudit_log_format(ab, \" actions=%s\", names);\n\taudit_log_format(ab, \" old-actions=%s\", old_names);\n\taudit_log_format(ab, \" res=%d\", res);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_seccomp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2489-2501",
    "snippet": "void audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2500
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\"",
            "signr",
            "syscall_get_arch()",
            "syscall",
            "in_compat_syscall()",
            "KSTK_EIP(current)",
            "code"
          ],
          "line": 2497
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "KSTK_EIP",
          "args": [
            "current"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_compat_syscall",
          "args": [],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [],
          "line": 2498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task",
          "args": [
            "ab"
          ],
          "line": 2496
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2430-2450",
          "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_SECCOMP"
          ],
          "line": 2493
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2493
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_seccomp(unsigned long syscall, long signr, int code)\n{\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_SECCOMP);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld arch=%x syscall=%ld compat=%d ip=0x%lx code=0x%x\",\n\t\t\t signr, syscall_get_arch(), syscall,\n\t\t\t in_compat_syscall(), KSTK_EIP(current), code);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_core_dumps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2459-2475",
    "snippet": "void audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" sig=%ld res=1\"",
            "signr"
          ],
          "line": 2473
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task",
          "args": [
            "ab"
          ],
          "line": 2472
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2430-2450",
          "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 2470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_ANOM_ABEND"
          ],
          "line": 2469
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2469
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_core_dumps(long signr)\n{\n\tstruct audit_buffer *ab;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tif (signr == SIGQUIT)\t/* don't care for those */\n\t\treturn;\n\n\tab = audit_log_start(audit_context(), GFP_KERNEL, AUDIT_ANOM_ABEND);\n\tif (unlikely(!ab))\n\t\treturn;\n\taudit_log_task(ab);\n\taudit_log_format(ab, \" sig=%ld res=1\", signr);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2430-2450",
    "snippet": "static void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_d_path_exe",
          "args": [
            "ab",
            "current->mm"
          ],
          "line": 2449
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path_exe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2231-2248",
          "snippet": "void audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path_exe(struct audit_buffer *ab,\n\t\t\t  struct mm_struct *mm)\n{\n\tstruct file *exe_file;\n\n\tif (!mm)\n\t\tgoto out_null;\n\n\texe_file = get_mm_exe_file(mm);\n\tif (!exe_file)\n\t\tgoto out_null;\n\n\taudit_log_d_path(ab, \" exe=\", &exe_file->f_path);\n\tfput(exe_file);\n\treturn;\nout_null:\n\taudit_log_format(ab, \" exe=(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "get_task_comm(comm, current)"
          ],
          "line": 2448
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_task_comm",
          "args": [
            "comm",
            "current"
          ],
          "line": 2448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" pid=%d comm=\"",
            "task_tgid_nr(current)"
          ],
          "line": 2447
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2446
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "gid"
          ],
          "line": 2444
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 2443
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid_gid",
          "args": [
            "&uid",
            "&gid"
          ],
          "line": 2439
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2437
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_task(struct audit_buffer *ab)\n{\n\tkuid_t auid, uid;\n\tkgid_t gid;\n\tunsigned int sessionid;\n\tchar comm[sizeof(current->comm)];\n\n\tauid = audit_get_loginuid(current);\n\tsessionid = audit_get_sessionid(current);\n\tcurrent_uid_gid(&uid, &gid);\n\n\taudit_log_format(ab, \"auid=%u uid=%u gid=%u ses=%u\",\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid),\n\t\t\t from_kgid(&init_user_ns, gid),\n\t\t\t sessionid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" pid=%d comm=\", task_tgid_nr(current));\n\taudit_log_untrustedstring(ab, get_task_comm(comm, current));\n\taudit_log_d_path_exe(ab, current->mm);\n}"
  },
  {
    "function_name": "__audit_fanotify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2424-2428",
    "snippet": "void __audit_fanotify(unsigned int response)\n{\n\taudit_log(audit_context(), GFP_KERNEL,\n\t\tAUDIT_FANOTIFY,\t\"resp=%u\", response);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log",
          "args": [
            "audit_context()",
            "GFP_KERNEL",
            "AUDIT_FANOTIFY",
            "\"resp=%u\"",
            "response"
          ],
          "line": 2426
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_set_loginuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2020-2047",
          "snippet": "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2426
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_fanotify(unsigned int response)\n{\n\taudit_log(audit_context(), GFP_KERNEL,\n\t\tAUDIT_FANOTIFY,\t\"resp=%u\", response);\n}"
  },
  {
    "function_name": "__audit_log_kern_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2414-2422",
    "snippet": "void __audit_log_kern_module(char *name)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->module.name = kstrdup(name, GFP_KERNEL);\n\tif (!context->module.name)\n\t\taudit_log_lost(\"out of memory in __audit_log_kern_module\");\n\tcontext->type = AUDIT_KERN_MODULE;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in __audit_log_kern_module\""
          ],
          "line": 2420
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "name",
            "GFP_KERNEL"
          ],
          "line": 2418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2416
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_log_kern_module(char *name)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->module.name = kstrdup(name, GFP_KERNEL);\n\tif (!context->module.name)\n\t\taudit_log_lost(\"out of memory in __audit_log_kern_module\");\n\tcontext->type = AUDIT_KERN_MODULE;\n}"
  },
  {
    "function_name": "__audit_mmap_fd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2406-2412",
    "snippet": "void __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2408
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mmap_fd(int fd, int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->mmap.fd = fd;\n\tcontext->mmap.flags = flags;\n\tcontext->type = AUDIT_MMAP;\n}"
  },
  {
    "function_name": "__audit_log_capset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2395-2404",
    "snippet": "void __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->capset.pid = task_tgid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->capset.cap.ambient     = new->cap_ambient;\n\tcontext->type = AUDIT_CAPSET;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2397
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_log_capset(const struct cred *new, const struct cred *old)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->capset.pid = task_tgid_nr(current);\n\tcontext->capset.cap.effective   = new->cap_effective;\n\tcontext->capset.cap.inheritable = new->cap_effective;\n\tcontext->capset.cap.permitted   = new->cap_permitted;\n\tcontext->capset.cap.ambient     = new->cap_ambient;\n\tcontext->type = AUDIT_CAPSET;\n}"
  },
  {
    "function_name": "__audit_log_bprm_fcaps",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2353-2385",
    "snippet": "int __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = audit_context();\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\tax->old_pcap.ambient     = old->cap_ambient;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\tax->new_pcap.ambient     = new->cap_ambient;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_vfs_caps_from_disk",
          "args": [
            "bprm->file->f_path.dentry",
            "&vcaps"
          ],
          "line": 2368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(*ax)",
            "GFP_KERNEL"
          ],
          "line": 2360
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_log_bprm_fcaps(struct linux_binprm *bprm,\n\t\t\t   const struct cred *new, const struct cred *old)\n{\n\tstruct audit_aux_data_bprm_fcaps *ax;\n\tstruct audit_context *context = audit_context();\n\tstruct cpu_vfs_cap_data vcaps;\n\n\tax = kmalloc(sizeof(*ax), GFP_KERNEL);\n\tif (!ax)\n\t\treturn -ENOMEM;\n\n\tax->d.type = AUDIT_BPRM_FCAPS;\n\tax->d.next = context->aux;\n\tcontext->aux = (void *)ax;\n\n\tget_vfs_caps_from_disk(bprm->file->f_path.dentry, &vcaps);\n\n\tax->fcap.permitted = vcaps.permitted;\n\tax->fcap.inheritable = vcaps.inheritable;\n\tax->fcap.fE = !!(vcaps.magic_etc & VFS_CAP_FLAGS_EFFECTIVE);\n\tax->fcap_ver = (vcaps.magic_etc & VFS_CAP_REVISION_MASK) >> VFS_CAP_REVISION_SHIFT;\n\n\tax->old_pcap.permitted   = old->cap_permitted;\n\tax->old_pcap.inheritable = old->cap_inheritable;\n\tax->old_pcap.effective   = old->cap_effective;\n\tax->old_pcap.ambient     = old->cap_ambient;\n\n\tax->new_pcap.permitted   = new->cap_permitted;\n\tax->new_pcap.inheritable = new->cap_inheritable;\n\tax->new_pcap.effective   = new->cap_effective;\n\tax->new_pcap.ambient     = new->cap_ambient;\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_signal_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2286-2340",
    "snippet": "int audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t uid = current_uid(), auid, t_uid = task_uid(t);\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_task_getsecid(current, &audit_sig_sid);\n\t}\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDIT_AUX_PIDS\t16"
    ],
    "globals_used": [
      "int audit_signals;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "axp->target_comm[axp->pid_count]",
            "t->comm",
            "TASK_COMM_LEN"
          ],
          "line": 2336
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "t",
            "&axp->target_sid[axp->pid_count]"
          ],
          "line": 2335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "axp->pid_count >= AUDIT_AUX_PIDS"
          ],
          "line": 2329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*axp)",
            "GFP_ATOMIC"
          ],
          "line": 2321
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "t",
            "&ctx->target_sid"
          ],
          "line": 2314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_dummy_context",
          "args": [],
          "line": 2304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "current",
            "&audit_sig_sid"
          ],
          "line": 2301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "auid"
          ],
          "line": 2297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "t"
          ],
          "line": 2292
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "226-237",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "t"
          ],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 2290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDIT_AUX_PIDS\t16\n\nint audit_signals;\n\nint audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t uid = current_uid(), auid, t_uid = task_uid(t);\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_task_getsecid(current, &audit_sig_sid);\n\t}\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_ptrace",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2266-2276",
    "snippet": "void __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->target_comm",
            "t->comm",
            "TASK_COMM_LEN"
          ],
          "line": 2275
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "t",
            "&context->target_sid"
          ],
          "line": 2274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "t"
          ],
          "line": 2273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "t"
          ],
          "line": 2272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "t"
          ],
          "line": 2271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "t"
          ],
          "line": 2270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2268
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ptrace(struct task_struct *t)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->target_pid = task_tgid_nr(t);\n\tcontext->target_auid = audit_get_loginuid(t);\n\tcontext->target_uid = task_uid(t);\n\tcontext->target_sessionid = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &context->target_sid);\n\tmemcpy(context->target_comm, t->comm, TASK_COMM_LEN);\n}"
  },
  {
    "function_name": "__audit_sockaddr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2250-2264",
    "snippet": "int __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->sockaddr",
            "a",
            "len"
          ],
          "line": 2262
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct sockaddr_storage)",
            "GFP_KERNEL"
          ],
          "line": 2255
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2252
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_sockaddr(int len, void *a)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (!context->sockaddr) {\n\t\tvoid *p = kmalloc(sizeof(struct sockaddr_storage), GFP_KERNEL);\n\t\tif (!p)\n\t\t\treturn -ENOMEM;\n\t\tcontext->sockaddr = p;\n\t}\n\n\tcontext->sockaddr_len = len;\n\tmemcpy(context->sockaddr, a, len);\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_fd_pair",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2236-2241",
    "snippet": "void __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2238
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_fd_pair(int fd1, int fd2)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->fds[0] = fd1;\n\tcontext->fds[1] = fd2;\n}"
  },
  {
    "function_name": "__audit_socketcall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2218-2228",
    "snippet": "int __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "context->socketcall.args",
            "args",
            "nargs * sizeof(unsigned long)"
          ],
          "line": 2226
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2220
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint __audit_socketcall(int nargs, unsigned long *args)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (nargs <= 0 || nargs > AUDITSC_ARGS || !args)\n\t\treturn -EINVAL;\n\tcontext->type = AUDIT_SOCKETCALL;\n\tcontext->socketcall.nargs = nargs;\n\tmemcpy(context->socketcall.args, args, nargs * sizeof(unsigned long));\n\treturn 0;\n}"
  },
  {
    "function_name": "__audit_bprm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2203-2209",
    "snippet": "void __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_bprm(struct linux_binprm *bprm)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->type = AUDIT_EXECVE;\n\tcontext->execve.argc = bprm->argc;\n}"
  },
  {
    "function_name": "__audit_ipc_set_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2192-2201",
    "snippet": "void __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2194
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ipc_set_perm(unsigned long qbytes, uid_t uid, gid_t gid, umode_t mode)\n{\n\tstruct audit_context *context = audit_context();\n\n\tcontext->ipc.qbytes = qbytes;\n\tcontext->ipc.perm_uid = uid;\n\tcontext->ipc.perm_gid = gid;\n\tcontext->ipc.perm_mode = mode;\n\tcontext->ipc.has_perm = 1;\n}"
  },
  {
    "function_name": "__audit_ipc_obj",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2172-2181",
    "snippet": "void __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_ipc_getsecid",
          "args": [
            "ipcp",
            "&context->ipc.osid"
          ],
          "line": 2179
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2174
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_ipc_obj(struct kern_ipc_perm *ipcp)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->ipc.uid = ipcp->uid;\n\tcontext->ipc.gid = ipcp->gid;\n\tcontext->ipc.mode = ipcp->mode;\n\tcontext->ipc.has_perm = 0;\n\tsecurity_ipc_getsecid(ipcp, &context->ipc.osid);\n\tcontext->type = AUDIT_IPC;\n}"
  },
  {
    "function_name": "__audit_mq_getsetattr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2159-2165",
    "snippet": "void __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2161
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_getsetattr(mqd_t mqdes, struct mq_attr *mqstat)\n{\n\tstruct audit_context *context = audit_context();\n\tcontext->mq_getsetattr.mqdes = mqdes;\n\tcontext->mq_getsetattr.mqstat = *mqstat;\n\tcontext->type = AUDIT_MQ_GETSETATTR;\n}"
  },
  {
    "function_name": "__audit_mq_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2140-2151",
    "snippet": "void __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_notify(mqd_t mqdes, const struct sigevent *notification)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (notification)\n\t\tcontext->mq_notify.sigev_signo = notification->sigev_signo;\n\telse\n\t\tcontext->mq_notify.sigev_signo = 0;\n\n\tcontext->mq_notify.mqdes = mqdes;\n\tcontext->type = AUDIT_MQ_NOTIFY;\n}"
  },
  {
    "function_name": "__audit_mq_sendrecv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2115-2131",
    "snippet": "void __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec64 *abs_timeout)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct timespec64 *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(*p));\n\telse\n\t\tmemset(p, 0, sizeof(*p));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "p",
            "0",
            "sizeof(*p)"
          ],
          "line": 2124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "p",
            "abs_timeout",
            "sizeof(*p)"
          ],
          "line": 2122
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2118
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_sendrecv(mqd_t mqdes, size_t msg_len, unsigned int msg_prio,\n\t\t\tconst struct timespec64 *abs_timeout)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct timespec64 *p = &context->mq_sendrecv.abs_timeout;\n\n\tif (abs_timeout)\n\t\tmemcpy(p, abs_timeout, sizeof(*p));\n\telse\n\t\tmemset(p, 0, sizeof(*p));\n\n\tcontext->mq_sendrecv.mqdes = mqdes;\n\tcontext->mq_sendrecv.msg_len = msg_len;\n\tcontext->mq_sendrecv.msg_prio = msg_prio;\n\n\tcontext->type = AUDIT_MQ_SENDRECV;\n}"
  },
  {
    "function_name": "__audit_mq_open",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2092-2105",
    "snippet": "void __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&context->mq_open.attr",
            "0",
            "sizeof(struct mq_attr)"
          ],
          "line": 2099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "&context->mq_open.attr",
            "attr",
            "sizeof(struct mq_attr)"
          ],
          "line": 2097
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 2094
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_mq_open(int oflag, umode_t mode, struct mq_attr *attr)\n{\n\tstruct audit_context *context = audit_context();\n\n\tif (attr)\n\t\tmemcpy(&context->mq_open.attr, attr, sizeof(struct mq_attr));\n\telse\n\t\tmemset(&context->mq_open.attr, 0, sizeof(struct mq_attr));\n\n\tcontext->mq_open.oflag = oflag;\n\tcontext->mq_open.mode = mode;\n\n\tcontext->type = AUDIT_MQ_OPEN;\n}"
  },
  {
    "function_name": "audit_set_loginuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2057-2083",
    "snippet": "int audit_set_loginuid(kuid_t loginuid)\n{\n\tstruct task_struct *task = current;\n\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid)) {\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))\n\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t}\n\n\ttask->sessionid = sessionid;\n\ttask->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static atomic_t session_id = ATOMIC_INIT(0);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_set_loginuid",
          "args": [
            "oldloginuid",
            "loginuid",
            "oldsessionid",
            "sessionid",
            "rc"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_set_loginuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2020-2047",
          "snippet": "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&session_id"
          ],
          "line": 2075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sessionid == AUDIT_SID_UNSET"
          ],
          "line": 2074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_inc_return",
          "args": [
            "&session_id"
          ],
          "line": 2073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "loginuid"
          ],
          "line": 2072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_loginuid_perm",
          "args": [
            "loginuid"
          ],
          "line": 2067
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_loginuid_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2003-2018",
          "snippet": "static int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "current"
          ],
          "line": 2065
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "current"
          ],
          "line": 2064
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic atomic_t session_id = ATOMIC_INIT(0);\n\nint audit_set_loginuid(kuid_t loginuid)\n{\n\tstruct task_struct *task = current;\n\tunsigned int oldsessionid, sessionid = AUDIT_SID_UNSET;\n\tkuid_t oldloginuid;\n\tint rc;\n\n\toldloginuid = audit_get_loginuid(current);\n\toldsessionid = audit_get_sessionid(current);\n\n\trc = audit_set_loginuid_perm(loginuid);\n\tif (rc)\n\t\tgoto out;\n\n\t/* are we setting or clearing? */\n\tif (uid_valid(loginuid)) {\n\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t\tif (unlikely(sessionid == AUDIT_SID_UNSET))\n\t\t\tsessionid = (unsigned int)atomic_inc_return(&session_id);\n\t}\n\n\ttask->sessionid = sessionid;\n\ttask->loginuid = loginuid;\nout:\n\taudit_log_set_loginuid(oldloginuid, loginuid, oldsessionid, sessionid, rc);\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_log_set_loginuid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2020-2047",
    "snippet": "static void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 2046
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_tty",
          "args": [
            "tty"
          ],
          "line": 2045
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2262-2265",
          "snippet": "void audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_put_tty(struct tty_struct *tty)\n{\n\ttty_kref_put(tty);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\"",
            "oldloginuid",
            "loginuid",
            "tty ? tty_name(tty) : \"(none)\"",
            "oldsessionid",
            "sessionid",
            "!rc"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tty_name",
          "args": [
            "tty"
          ],
          "line": 2043
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_task_context",
          "args": [
            "ab"
          ],
          "line": 2041
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2203-2228",
          "snippet": "int audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nint audit_log_task_context(struct audit_buffer *ab)\n{\n\tchar *ctx = NULL;\n\tunsigned len;\n\tint error;\n\tu32 sid;\n\n\tsecurity_task_getsecid(current, &sid);\n\tif (!sid)\n\t\treturn 0;\n\n\terror = security_secid_to_secctx(sid, &ctx, &len);\n\tif (error) {\n\t\tif (error != -EINVAL)\n\t\t\tgoto error_path;\n\t\treturn 0;\n\t}\n\n\taudit_log_format(ab, \" subj=%s\", ctx);\n\tsecurity_release_secctx(ctx, len);\n\treturn 0;\n\nerror_path:\n\taudit_panic(\"error in audit_log_task_context\");\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "current"
          ],
          "line": 2040
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_tty",
          "args": [
            "current"
          ],
          "line": 2038
        },
        "resolved": true,
        "details": {
          "function_name": "audit_get_tty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2250-2260",
          "snippet": "struct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstruct tty_struct *audit_get_tty(struct task_struct *tsk)\n{\n\tstruct tty_struct *tty = NULL;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\tif (tsk->signal)\n\t\ttty = tty_kref_get(tsk->signal->tty);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n\treturn tty;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "kloginuid"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "current"
          ],
          "line": 2035
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "NULL",
            "GFP_KERNEL",
            "AUDIT_LOGIN"
          ],
          "line": 2031
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_log_set_loginuid(kuid_t koldloginuid, kuid_t kloginuid,\n\t\t\t\t   unsigned int oldsessionid, unsigned int sessionid,\n\t\t\t\t   int rc)\n{\n\tstruct audit_buffer *ab;\n\tuid_t uid, oldloginuid, loginuid;\n\tstruct tty_struct *tty;\n\n\tif (!audit_enabled)\n\t\treturn;\n\n\tab = audit_log_start(NULL, GFP_KERNEL, AUDIT_LOGIN);\n\tif (!ab)\n\t\treturn;\n\n\tuid = from_kuid(&init_user_ns, task_uid(current));\n\toldloginuid = from_kuid(&init_user_ns, koldloginuid);\n\tloginuid = from_kuid(&init_user_ns, kloginuid),\n\ttty = audit_get_tty(current);\n\n\taudit_log_format(ab, \"pid=%d uid=%u\", task_tgid_nr(current), uid);\n\taudit_log_task_context(ab);\n\taudit_log_format(ab, \" old-auid=%u auid=%u tty=%s old-ses=%u ses=%u res=%d\",\n\t\t\t oldloginuid, loginuid, tty ? tty_name(tty) : \"(none)\",\n\t\t\t oldsessionid, sessionid, !rc);\n\taudit_put_tty(tty);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_set_loginuid_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "2003-2018",
    "snippet": "static int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_valid",
          "args": [
            "loginuid"
          ],
          "line": 2015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_audit_feature_set",
          "args": [
            "AUDIT_FEATURE_ONLY_UNSET_LOGINUID"
          ],
          "line": 2015
        },
        "resolved": true,
        "details": {
          "function_name": "is_audit_feature_set",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1075-1078",
          "snippet": "int is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct audit_features af = {.vers = AUDIT_FEATURE_VERSION,\n\t\t\t\t   .mask = -1,\n\t\t\t\t   .features = 0,\n\t\t\t\t   .lock = 0,};\n\nint is_audit_feature_set(int i)\n{\n\treturn af.features & AUDIT_FEATURE_TO_MASK(i);\n}"
        }
      },
      {
        "call_info": {
          "callee": "capable",
          "args": [
            "CAP_AUDIT_CONTROL"
          ],
          "line": 2012
        },
        "resolved": true,
        "details": {
          "function_name": "capable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "429-432",
          "snippet": "bool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool capable(int cap)\n{\n\treturn ns_capable(&init_user_ns, cap);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "current"
          ],
          "line": 2006
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_set_loginuid_perm(kuid_t loginuid)\n{\n\t/* if we are unset, we don't need privs */\n\tif (!audit_loginuid_set(current))\n\t\treturn 0;\n\t/* if AUDIT_FEATURE_LOGINUID_IMMUTABLE means never ever allow a change*/\n\tif (is_audit_feature_set(AUDIT_FEATURE_LOGINUID_IMMUTABLE))\n\t\treturn -EPERM;\n\t/* it is set, you need permission */\n\tif (!capable(CAP_AUDIT_CONTROL))\n\t\treturn -EPERM;\n\t/* reject if this is not an unset and we don't allow that */\n\tif (is_audit_feature_set(AUDIT_FEATURE_ONLY_UNSET_LOGINUID) && uid_valid(loginuid))\n\t\treturn -EPERM;\n\treturn 0;\n}"
  },
  {
    "function_name": "auditsc_get_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1983-1998",
    "snippet": "int auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_serial",
          "args": [],
          "line": 1989
        },
        "resolved": true,
        "details": {
          "function_name": "audit_serial",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1713-1718",
          "snippet": "unsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nunsigned int audit_serial(void)\n{\n\tstatic atomic_t serial = ATOMIC_INIT(0);\n\n\treturn atomic_add_return(1, &serial);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint auditsc_get_stamp(struct audit_context *ctx,\n\t\t       struct timespec64 *t, unsigned int *serial)\n{\n\tif (!ctx->in_syscall)\n\t\treturn 0;\n\tif (!ctx->serial)\n\t\tctx->serial = audit_serial();\n\tt->tv_sec  = ctx->ctime.tv_sec;\n\tt->tv_nsec = ctx->ctime.tv_nsec;\n\t*serial    = ctx->serial;\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "__audit_inode_child",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1871-1972",
    "snippet": "void __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\t\tif (f->type == AUDIT_FSTYPE) {\n\t\t\t\t\tif (audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t    f->op, f->val)) {\n\t\t\t\t\t\tif (e->rule.action == AUDIT_NEVER) {\n\t\t\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_inode",
          "args": [
            "found_child",
            "dentry",
            "inode"
          ],
          "line": 1969
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2099-2110",
          "snippet": "void audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "type"
          ],
          "line": 1954
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1691-1712",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_compare_dname_path",
          "args": [
            "dname",
            "n->name->name",
            "found_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL"
          ],
          "line": 1934
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_dname_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1293-1310",
          "snippet": "int audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_compare_dname_path(const char *dname, const char *path, int parentlen)\n{\n\tint dlen, pathlen;\n\tconst char *p;\n\n\tdlen = strlen(dname);\n\tpathlen = strlen(path);\n\tif (pathlen < dlen)\n\t\treturn 1;\n\n\tparentlen = parentlen == AUDIT_NAME_FULL ? parent_len(path) : parentlen;\n\tif (pathlen - parentlen != dlen)\n\t\treturn 1;\n\n\tp = path + parentlen;\n\n\treturn strncmp(p, dname, dlen);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "dname",
            "n->name->name"
          ],
          "line": 1933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1927
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1910
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_one",
          "args": [
            "inode"
          ],
          "line": 1907
        },
        "resolved": true,
        "details": {
          "function_name": "handle_one",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1603-1631",
          "snippet": "static inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1904
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "parent->i_sb->s_magic",
            "f->op",
            "f->val"
          ],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1184-1207",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 1888
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 1887
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1886
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1875
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\t\tif (f->type == AUDIT_FSTYPE) {\n\t\t\t\t\tif (audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t    f->op, f->val)) {\n\t\t\t\t\t\tif (e->rule.action == AUDIT_NEVER) {\n\t\t\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}"
  },
  {
    "function_name": "__audit_file",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1852-1855",
    "snippet": "void __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__audit_inode",
          "args": [
            "NULL",
            "file->f_path.dentry",
            "0"
          ],
          "line": 1854
        },
        "resolved": true,
        "details": {
          "function_name": "__audit_inode_child",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1871-1972",
          "snippet": "void __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\t\tif (f->type == AUDIT_FSTYPE) {\n\t\t\t\t\tif (audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t    f->op, f->val)) {\n\t\t\t\t\t\tif (e->rule.action == AUDIT_NEVER) {\n\t\t\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode_child(struct inode *parent,\n\t\t\t const struct dentry *dentry,\n\t\t\t const unsigned char type)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tconst char *dname = dentry->d_name.name;\n\tstruct audit_names *n, *found_parent = NULL, *found_child = NULL;\n\tstruct audit_entry *e;\n\tstruct list_head *list = &audit_filter_list[AUDIT_FILTER_FS];\n\tint i;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tfor (i = 0; i < e->rule.field_count; i++) {\n\t\t\t\tstruct audit_field *f = &e->rule.fields[i];\n\n\t\t\t\tif (f->type == AUDIT_FSTYPE) {\n\t\t\t\t\tif (audit_comparator(parent->i_sb->s_magic,\n\t\t\t\t\t    f->op, f->val)) {\n\t\t\t\t\t\tif (e->rule.action == AUDIT_NEVER) {\n\t\t\t\t\t\t\trcu_read_unlock();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\tif (inode)\n\t\thandle_one(inode);\n\n\t/* look for a parent entry first */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name ||\n\t\t    (n->type != AUDIT_TYPE_PARENT &&\n\t\t     n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (n->ino == parent->i_ino && n->dev == parent->i_sb->s_dev &&\n\t\t    !audit_compare_dname_path(dname,\n\t\t\t\t\t      n->name->name, n->name_len)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = AUDIT_TYPE_PARENT;\n\t\t\tfound_parent = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t/* is there a matching child entry? */\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\t/* can only match entries that have a name */\n\t\tif (!n->name ||\n\t\t    (n->type != type && n->type != AUDIT_TYPE_UNKNOWN))\n\t\t\tcontinue;\n\n\t\tif (!strcmp(dname, n->name->name) ||\n\t\t    !audit_compare_dname_path(dname, n->name->name,\n\t\t\t\t\t\tfound_parent ?\n\t\t\t\t\t\tfound_parent->name_len :\n\t\t\t\t\t\tAUDIT_NAME_FULL)) {\n\t\t\tif (n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tn->type = type;\n\t\t\tfound_child = n;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (!found_parent) {\n\t\t/* create a new, \"anonymous\" parent record */\n\t\tn = audit_alloc_name(context, AUDIT_TYPE_PARENT);\n\t\tif (!n)\n\t\t\treturn;\n\t\taudit_copy_inode(n, NULL, parent);\n\t}\n\n\tif (!found_child) {\n\t\tfound_child = audit_alloc_name(context, type);\n\t\tif (!found_child)\n\t\t\treturn;\n\n\t\t/* Re-use the name belonging to the slot for a matching parent\n\t\t * directory. All names for this context are relinquished in\n\t\t * audit_free_names() */\n\t\tif (found_parent) {\n\t\t\tfound_child->name = found_parent->name;\n\t\t\tfound_child->name_len = AUDIT_NAME_FULL;\n\t\t\tfound_child->name->refcnt++;\n\t\t}\n\t}\n\n\tif (inode)\n\t\taudit_copy_inode(found_child, dentry, inode);\n\telse\n\t\tfound_child->ino = AUDIT_INO_UNSET;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_file(const struct file *file)\n{\n\t__audit_inode(NULL, file->f_path.dentry, 0);\n}"
  },
  {
    "function_name": "__audit_inode",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1773-1850",
    "snippet": "void __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_copy_inode",
          "args": [
            "n",
            "dentry",
            "inode"
          ],
          "line": 1849
        },
        "resolved": true,
        "details": {
          "function_name": "audit_copy_inode",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2099-2110",
          "snippet": "void audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_copy_inode(struct audit_names *name, const struct dentry *dentry,\n\t\t      struct inode *inode)\n{\n\tname->ino   = inode->i_ino;\n\tname->dev   = inode->i_sb->s_dev;\n\tname->mode  = inode->i_mode;\n\tname->uid   = inode->i_uid;\n\tname->gid   = inode->i_gid;\n\tname->rdev  = inode->i_rdev;\n\tsecurity_inode_getsecid(inode, &name->osid);\n\taudit_copy_fcaps(name, dentry);\n}"
        }
      },
      {
        "call_info": {
          "callee": "handle_path",
          "args": [
            "dentry"
          ],
          "line": 1848
        },
        "resolved": true,
        "details": {
          "function_name": "handle_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1633-1689",
          "snippet": "static void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "parent_len",
          "args": [
            "n->name->name"
          ],
          "line": 1840
        },
        "resolved": true,
        "details": {
          "function_name": "parent_len",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1259-1283",
          "snippet": "int parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint parent_len(const char *path)\n{\n\tint plen;\n\tconst char *p;\n\n\tplen = strlen(path);\n\n\tif (plen == 0)\n\t\treturn plen;\n\n\t/* disregard trailing slashes */\n\tp = path + plen - 1;\n\twhile ((*p == '/') && (p > path))\n\t\tp--;\n\n\t/* walk backward until we find the next slash or hit beginning */\n\twhile ((*p != '/') && (p > path))\n\t\tp--;\n\n\t/* did we find a slash? Then increment to include it in path */\n\tif (*p == '/')\n\t\tp++;\n\n\treturn p - path;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "AUDIT_TYPE_UNKNOWN"
          ],
          "line": 1830
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1691-1712",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "n->name->name",
            "name->name"
          ],
          "line": 1811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_reverse",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "dentry"
          ],
          "line": 1777
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_inode(struct filename *name, const struct dentry *dentry,\n\t\t   unsigned int flags)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct inode *inode = d_backing_inode(dentry);\n\tstruct audit_names *n;\n\tbool parent = flags & AUDIT_INODE_PARENT;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tif (!name)\n\t\tgoto out_alloc;\n\n\t/*\n\t * If we have a pointer to an audit_names entry already, then we can\n\t * just use it directly if the type is correct.\n\t */\n\tn = name->aname;\n\tif (n) {\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\n\tlist_for_each_entry_reverse(n, &context->names_list, list) {\n\t\tif (n->ino) {\n\t\t\t/* valid inode number, use that for the comparison */\n\t\t\tif (n->ino != inode->i_ino ||\n\t\t\t    n->dev != inode->i_sb->s_dev)\n\t\t\t\tcontinue;\n\t\t} else if (n->name) {\n\t\t\t/* inode number has not been set, check the name */\n\t\t\tif (strcmp(n->name->name, name->name))\n\t\t\t\tcontinue;\n\t\t} else\n\t\t\t/* no inode and no name (?!) ... this is odd ... */\n\t\t\tcontinue;\n\n\t\t/* match the correct record type */\n\t\tif (parent) {\n\t\t\tif (n->type == AUDIT_TYPE_PARENT ||\n\t\t\t    n->type == AUDIT_TYPE_UNKNOWN)\n\t\t\t\tgoto out;\n\t\t} else {\n\t\t\tif (n->type != AUDIT_TYPE_PARENT)\n\t\t\t\tgoto out;\n\t\t}\n\t}\n\nout_alloc:\n\t/* unable to find an entry with both a matching name and type */\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\tif (name) {\n\t\tn->name = name;\n\t\tname->refcnt++;\n\t}\n\nout:\n\tif (parent) {\n\t\tn->name_len = n->name ? parent_len(n->name->name) : AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_PARENT;\n\t\tif (flags & AUDIT_INODE_HIDDEN)\n\t\t\tn->hidden = true;\n\t} else {\n\t\tn->name_len = AUDIT_NAME_FULL;\n\t\tn->type = AUDIT_TYPE_NORMAL;\n\t}\n\thandle_path(dentry);\n\taudit_copy_inode(n, dentry, inode);\n}"
  },
  {
    "function_name": "__audit_getname",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1746-1765",
    "snippet": "void __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_fs_pwd",
          "args": [
            "current->fs",
            "&context->pwd"
          ],
          "line": 1764
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_alloc_name",
          "args": [
            "context",
            "AUDIT_TYPE_UNKNOWN"
          ],
          "line": 1754
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1691-1712",
          "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_getname(struct filename *name)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tif (!context->in_syscall)\n\t\treturn;\n\n\tn = audit_alloc_name(context, AUDIT_TYPE_UNKNOWN);\n\tif (!n)\n\t\treturn;\n\n\tn->name = name;\n\tn->name_len = AUDIT_NAME_FULL;\n\tname->aname = n;\n\tname->refcnt++;\n\n\tif (!context->pwd.dentry)\n\t\tget_fs_pwd(current->fs, &context->pwd);\n}"
  },
  {
    "function_name": "__audit_reusename",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1722-1737",
    "snippet": "struct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstruct filename *\n__audit_reusename(const __user char *uptr)\n{\n\tstruct audit_context *context = audit_context();\n\tstruct audit_names *n;\n\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (!n->name)\n\t\t\tcontinue;\n\t\tif (n->name->uptr == uptr) {\n\t\t\tn->name->refcnt++;\n\t\t\treturn n->name;\n\t\t}\n\t}\n\treturn NULL;\n}"
  },
  {
    "function_name": "audit_alloc_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1691-1712",
    "snippet": "static struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&aname->list",
            "&context->names_list"
          ],
          "line": 1708
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*aname)",
            "GFP_NOFS"
          ],
          "line": 1700
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "aname",
            "0",
            "sizeof(*aname)"
          ],
          "line": 1698
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic struct audit_names *audit_alloc_name(struct audit_context *context,\n\t\t\t\t\t\tunsigned char type)\n{\n\tstruct audit_names *aname;\n\n\tif (context->name_count < AUDIT_NAMES) {\n\t\taname = &context->preallocated_names[context->name_count];\n\t\tmemset(aname, 0, sizeof(*aname));\n\t} else {\n\t\taname = kzalloc(sizeof(*aname), GFP_NOFS);\n\t\tif (!aname)\n\t\t\treturn NULL;\n\t\taname->should_free = true;\n\t}\n\n\taname->ino = AUDIT_INO_UNSET;\n\taname->type = type;\n\tlist_add_tail(&aname->list, &context->names_list);\n\n\tcontext->name_count++;\n\treturn aname;\n}"
  },
  {
    "function_name": "handle_path",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1633-1689",
    "snippet": "static void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1687
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_auditable",
          "args": [
            "context"
          ],
          "line": 1684
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_auditable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "204-210",
          "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "p",
            "count"
          ],
          "line": 1683
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "250-278",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory, audit has lost a tree reference\\n\""
          ],
          "line": 1682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_tree_refs",
          "args": [
            "context"
          ],
          "line": 1676
        },
        "resolved": true,
        "details": {
          "function_name": "grow_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "233-247",
          "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "drop"
          ],
          "line": 1675
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "122-126",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "read_seqretry(&rename_lock, seq) || drop"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqretry",
          "args": [
            "&rename_lock",
            "seq"
          ],
          "line": 1668
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!put_tree_ref(context, chunk)"
          ],
          "line": 1657
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "put_tree_ref",
          "args": [
            "context",
            "chunk"
          ],
          "line": 1657
        },
        "resolved": true,
        "details": {
          "function_name": "put_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "212-231",
          "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_lookup",
          "args": [
            "inode"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "209-222",
          "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "inode->i_fsnotify_marks"
          ],
          "line": 1653
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "d_backing_inode",
          "args": [
            "d"
          ],
          "line": 1652
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_seqbegin",
          "args": [
            "&rename_lock"
          ],
          "line": 1650
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1649
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1643
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void handle_path(const struct dentry *dentry)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tconst struct dentry *d, *parent;\n\tstruct audit_chunk *drop;\n\tunsigned long seq;\n\tint count;\n\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\nretry:\n\tdrop = NULL;\n\td = dentry;\n\trcu_read_lock();\n\tseq = read_seqbegin(&rename_lock);\n\tfor(;;) {\n\t\tstruct inode *inode = d_backing_inode(d);\n\t\tif (inode && unlikely(inode->i_fsnotify_marks)) {\n\t\t\tstruct audit_chunk *chunk;\n\t\t\tchunk = audit_tree_lookup(inode);\n\t\t\tif (chunk) {\n\t\t\t\tif (unlikely(!put_tree_ref(context, chunk))) {\n\t\t\t\t\tdrop = chunk;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tparent = d->d_parent;\n\t\tif (parent == d)\n\t\t\tbreak;\n\t\td = parent;\n\t}\n\tif (unlikely(read_seqretry(&rename_lock, seq) || drop)) {  /* in this order */\n\t\trcu_read_unlock();\n\t\tif (!drop) {\n\t\t\t/* just a race with rename */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\taudit_put_chunk(drop);\n\t\tif (grow_tree_refs(context)) {\n\t\t\t/* OK, got more space */\n\t\t\tunroll_tree_refs(context, p, count);\n\t\t\tgoto retry;\n\t\t}\n\t\t/* too bad */\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\tunroll_tree_refs(context, p, count);\n\t\taudit_set_auditable(context);\n\t\treturn;\n\t}\n\trcu_read_unlock();\n#endif\n}"
  },
  {
    "function_name": "handle_one",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1603-1631",
    "snippet": "static inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "put_tree_ref",
          "args": [
            "context",
            "chunk"
          ],
          "line": 1629
        },
        "resolved": true,
        "details": {
          "function_name": "put_tree_ref",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "212-231",
          "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "p",
            "count"
          ],
          "line": 1626
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "250-278",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "chunk"
          ],
          "line": 1625
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "122-126",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_set_auditable",
          "args": [
            "context"
          ],
          "line": 1624
        },
        "resolved": true,
        "details": {
          "function_name": "audit_set_auditable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "204-210",
          "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"out of memory, audit has lost a tree reference\\n\""
          ],
          "line": 1623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!grow_tree_refs(context)"
          ],
          "line": 1622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "grow_tree_refs",
          "args": [
            "context"
          ],
          "line": 1622
        },
        "resolved": true,
        "details": {
          "function_name": "grow_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "233-247",
          "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "put_tree_ref(context, chunk)"
          ],
          "line": 1620
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_tree_lookup",
          "args": [
            "inode"
          ],
          "line": 1616
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_lookup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "209-222",
          "snippet": "struct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstruct audit_chunk *audit_tree_lookup(const struct inode *inode)\n{\n\tunsigned long key = inode_to_key(inode);\n\tstruct list_head *list = chunk_hash(key);\n\tstruct audit_chunk *p;\n\n\tlist_for_each_entry_rcu(p, list, hash) {\n\t\tif (chunk_to_key(p) == key) {\n\t\t\tatomic_long_inc(&p->refs);\n\t\t\treturn p;\n\t\t}\n\t}\n\treturn NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1615
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!inode->i_fsnotify_marks"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void handle_one(const struct inode *inode)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_context *context;\n\tstruct audit_tree_refs *p;\n\tstruct audit_chunk *chunk;\n\tint count;\n\tif (likely(!inode->i_fsnotify_marks))\n\t\treturn;\n\tcontext = audit_context();\n\tp = context->trees;\n\tcount = context->tree_count;\n\trcu_read_lock();\n\tchunk = audit_tree_lookup(inode);\n\trcu_read_unlock();\n\tif (!chunk)\n\t\treturn;\n\tif (likely(put_tree_ref(context, chunk)))\n\t\treturn;\n\tif (unlikely(!grow_tree_refs(context))) {\n\t\tpr_warn(\"out of memory, audit has lost a tree reference\\n\");\n\t\taudit_set_auditable(context);\n\t\taudit_put_chunk(chunk);\n\t\tunroll_tree_refs(context, p, count);\n\t\treturn;\n\t}\n\tput_tree_ref(context, chunk);\n#endif\n}"
  },
  {
    "function_name": "__audit_syscall_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1564-1601",
    "snippet": "void __audit_syscall_exit(int success, long return_code)\n{\n\tstruct audit_context *context;\n\n\tif (success)\n\t\tsuccess = AUDITSC_SUCCESS;\n\telse\n\t\tsuccess = AUDITSC_FAILURE;\n\n\tcontext = audit_take_context(current, success, return_code);\n\tif (!context)\n\t\treturn;\n\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, current);\n\n\tcontext->in_syscall = 0;\n\tcontext->prio = context->state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\taudit_free_aux(context);\n\tcontext->aux = NULL;\n\tcontext->aux_pids = NULL;\n\tcontext->target_pid = 0;\n\tcontext->target_sid = 0;\n\tcontext->sockaddr_len = 0;\n\tcontext->type = 0;\n\tcontext->fds[0] = -1;\n\tif (context->state != AUDIT_RECORD_CONTEXT) {\n\t\tkfree(context->filterkey);\n\t\tcontext->filterkey = NULL;\n\t}\n\taudit_set_context(current, context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_FAILURE 2",
      "#define AUDITSC_SUCCESS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_set_context",
          "args": [
            "current",
            "context"
          ],
          "line": 1600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context->filterkey"
          ],
          "line": 1597
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_aux",
          "args": [
            "context"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "901-913",
          "snippet": "static inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "NULL",
            "0"
          ],
          "line": 1587
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "250-278",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_names",
          "args": [
            "context"
          ],
          "line": 1586
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "884-899",
          "snippet": "static inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_kill_trees",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1584
        },
        "resolved": true,
        "details": {
          "function_name": "audit_kill_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "928-949",
          "snippet": "void audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1583
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_exit",
          "args": [
            "context",
            "current"
          ],
          "line": 1578
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1346-1473",
          "snippet": "static void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_take_context",
          "args": [
            "current",
            "success",
            "return_code"
          ],
          "line": 1573
        },
        "resolved": true,
        "details": {
          "function_name": "audit_take_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "840-875",
          "snippet": "static inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nvoid __audit_syscall_exit(int success, long return_code)\n{\n\tstruct audit_context *context;\n\n\tif (success)\n\t\tsuccess = AUDITSC_SUCCESS;\n\telse\n\t\tsuccess = AUDITSC_FAILURE;\n\n\tcontext = audit_take_context(current, success, return_code);\n\tif (!context)\n\t\treturn;\n\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, current);\n\n\tcontext->in_syscall = 0;\n\tcontext->prio = context->state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\taudit_free_aux(context);\n\tcontext->aux = NULL;\n\tcontext->aux_pids = NULL;\n\tcontext->target_pid = 0;\n\tcontext->target_sid = 0;\n\tcontext->sockaddr_len = 0;\n\tcontext->type = 0;\n\tcontext->fds[0] = -1;\n\tif (context->state != AUDIT_RECORD_CONTEXT) {\n\t\tkfree(context->filterkey);\n\t\tcontext->filterkey = NULL;\n\t}\n\taudit_set_context(current, context);\n}"
  },
  {
    "function_name": "__audit_syscall_entry",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1518-1551",
    "snippet": "void __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tBUG_ON(context->in_syscall || context->name_count);\n\n\tstate = context->state;\n\tif (state == AUDIT_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_BUILD_CONTEXT) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch();\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->serial     = 0;\n\tcontext->in_syscall = 1;\n\tcontext->current_state  = state;\n\tcontext->ppid       = 0;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int audit_n_rules;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ktime_get_coarse_real_ts64",
          "args": [
            "&context->ctime"
          ],
          "line": 1550
        },
        "resolved": true,
        "details": {
          "function_name": "ktime_get_coarse_real_ts64",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/timekeeping.c",
          "lines": "2161-2171",
          "snippet": "void ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}",
          "includes": [
            "#include \"timekeeping_internal.h\"",
            "#include \"ntp_internal.h\"",
            "#include \"tick-internal.h\"",
            "#include <linux/compiler.h>",
            "#include <linux/pvclock_gtod.h>",
            "#include <linux/stop_machine.h>",
            "#include <linux/tick.h>",
            "#include <linux/time.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/clocksource.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/nmi.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/percpu.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/module.h>",
            "#include <linux/timekeeper_internal.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping_internal.h\"\n#include \"ntp_internal.h\"\n#include \"tick-internal.h\"\n#include <linux/compiler.h>\n#include <linux/pvclock_gtod.h>\n#include <linux/stop_machine.h>\n#include <linux/tick.h>\n#include <linux/time.h>\n#include <linux/jiffies.h>\n#include <linux/clocksource.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/nmi.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/percpu.h>\n#include <linux/interrupt.h>\n#include <linux/module.h>\n#include <linux/timekeeper_internal.h>\n\nvoid ktime_get_coarse_real_ts64(struct timespec64 *ts)\n{\n\tstruct timekeeper *tk = &tk_core.timekeeper;\n\tunsigned long seq;\n\n\tdo {\n\t\tseq = read_seqcount_begin(&tk_core.seq);\n\n\t\t*ts = tk_xtime(tk);\n\t} while (read_seqcount_retry(&tk_core.seq, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "syscall_get_arch",
          "args": [],
          "line": 1540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "current"
          ],
          "line": 1536
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "226-237",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "context->in_syscall || context->name_count"
          ],
          "line": 1527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_context",
          "args": [],
          "line": 1521
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_n_rules;\n\nvoid __audit_syscall_entry(int major, unsigned long a1, unsigned long a2,\n\t\t\t   unsigned long a3, unsigned long a4)\n{\n\tstruct audit_context *context = audit_context();\n\tenum audit_state     state;\n\n\tif (!audit_enabled || !context)\n\t\treturn;\n\n\tBUG_ON(context->in_syscall || context->name_count);\n\n\tstate = context->state;\n\tif (state == AUDIT_DISABLED)\n\t\treturn;\n\n\tcontext->dummy = !audit_n_rules;\n\tif (!context->dummy && state == AUDIT_BUILD_CONTEXT) {\n\t\tcontext->prio = 0;\n\t\tif (auditd_test_task(current))\n\t\t\treturn;\n\t}\n\n\tcontext->arch\t    = syscall_get_arch();\n\tcontext->major      = major;\n\tcontext->argv[0]    = a1;\n\tcontext->argv[1]    = a2;\n\tcontext->argv[2]    = a3;\n\tcontext->argv[3]    = a4;\n\tcontext->serial     = 0;\n\tcontext->in_syscall = 1;\n\tcontext->current_state  = state;\n\tcontext->ppid       = 0;\n\tktime_get_coarse_real_ts64(&context->ctime);\n}"
  },
  {
    "function_name": "__audit_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1481-1500",
    "snippet": "void __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\n\tcontext = audit_take_context(tsk, 0, 0);\n\tif (!context)\n\t\treturn;\n\n\t/* Check for system calls that do not go through the exit\n\t * function (e.g., exit_group), then free context block.\n\t * We use GFP_ATOMIC here because we might be doing this\n\t * in the context of the idle thread */\n\t/* that can happen only if we are called from do_exit() */\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_context(context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_free_context",
          "args": [
            "context"
          ],
          "line": 1499
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "965-975",
          "snippet": "static inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_kill_trees",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1497
        },
        "resolved": true,
        "details": {
          "function_name": "audit_kill_trees",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "928-949",
          "snippet": "void audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_kill_trees(struct list_head *list)\n{\n\taudit_ctl_lock();\n\tmutex_lock(&audit_filter_mutex);\n\n\twhile (!list_empty(list)) {\n\t\tstruct audit_tree *victim;\n\n\t\tvictim = list_entry(list->next, struct audit_tree, list);\n\t\tkill_rules(victim);\n\t\tlist_del_init(&victim->list);\n\n\t\tmutex_unlock(&audit_filter_mutex);\n\n\t\tprune_one(victim);\n\n\t\tmutex_lock(&audit_filter_mutex);\n\t}\n\n\tmutex_unlock(&audit_filter_mutex);\n\taudit_ctl_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&context->killed_trees"
          ],
          "line": 1496
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_exit",
          "args": [
            "context",
            "tsk"
          ],
          "line": 1495
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1346-1473",
          "snippet": "static void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_take_context",
          "args": [
            "tsk",
            "0",
            "0"
          ],
          "line": 1485
        },
        "resolved": true,
        "details": {
          "function_name": "audit_take_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "840-875",
          "snippet": "static inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid __audit_free(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\n\tcontext = audit_take_context(tsk, 0, 0);\n\tif (!context)\n\t\treturn;\n\n\t/* Check for system calls that do not go through the exit\n\t * function (e.g., exit_group), then free context block.\n\t * We use GFP_ATOMIC here because we might be doing this\n\t * in the context of the idle thread */\n\t/* that can happen only if we are called from do_exit() */\n\tif (context->in_syscall && context->current_state == AUDIT_RECORD_CONTEXT)\n\t\taudit_log_exit(context, tsk);\n\tif (!list_empty(&context->killed_trees))\n\t\taudit_kill_trees(&context->killed_trees);\n\n\taudit_free_context(context);\n}"
  },
  {
    "function_name": "audit_log_exit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1346-1473",
    "snippet": "static void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_SUCCESS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"error converting sid to string\""
          ],
          "line": 1472
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1470
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_EOE"
          ],
          "line": 1468
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_proctitle",
          "args": [
            "tsk",
            "context"
          ],
          "line": 1465
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_proctitle",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1305-1344",
          "snippet": "static void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_PROCTITLE_AUDIT_LEN 128"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\nstatic void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_name",
          "args": [
            "context",
            "n",
            "NULL",
            "i++",
            "&call_panic"
          ],
          "line": 1462
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2120-2201",
          "snippet": "void audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd */\n\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu\"\n\t\t\t\t \" dev=%02x:%02x mode=%#ho\"\n\t\t\t\t \" ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\taudit_log_format(ab, \" nametype=\");\n\tswitch(n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \"NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \"PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \"DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \"CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_name(struct audit_context *context, struct audit_names *n,\n\t\t    const struct path *path, int record_num, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PATH);\n\tif (!ab)\n\t\treturn;\n\n\taudit_log_format(ab, \"item=%d\", record_num);\n\n\tif (path)\n\t\taudit_log_d_path(ab, \" name=\", path);\n\telse if (n->name) {\n\t\tswitch (n->name_len) {\n\t\tcase AUDIT_NAME_FULL:\n\t\t\t/* log the full path */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_untrustedstring(ab, n->name->name);\n\t\t\tbreak;\n\t\tcase 0:\n\t\t\t/* name was specified as a relative path and the\n\t\t\t * directory component is the cwd */\n\t\t\taudit_log_d_path(ab, \" name=\", &context->pwd);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* log the name's directory component */\n\t\t\taudit_log_format(ab, \" name=\");\n\t\t\taudit_log_n_untrustedstring(ab, n->name->name,\n\t\t\t\t\t\t    n->name_len);\n\t\t}\n\t} else\n\t\taudit_log_format(ab, \" name=(null)\");\n\n\tif (n->ino != AUDIT_INO_UNSET)\n\t\taudit_log_format(ab, \" inode=%lu\"\n\t\t\t\t \" dev=%02x:%02x mode=%#ho\"\n\t\t\t\t \" ouid=%u ogid=%u rdev=%02x:%02x\",\n\t\t\t\t n->ino,\n\t\t\t\t MAJOR(n->dev),\n\t\t\t\t MINOR(n->dev),\n\t\t\t\t n->mode,\n\t\t\t\t from_kuid(&init_user_ns, n->uid),\n\t\t\t\t from_kgid(&init_user_ns, n->gid),\n\t\t\t\t MAJOR(n->rdev),\n\t\t\t\t MINOR(n->rdev));\n\tif (n->osid != 0) {\n\t\tchar *ctx = NULL;\n\t\tu32 len;\n\t\tif (security_secid_to_secctx(\n\t\t\tn->osid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" osid=%u\", n->osid);\n\t\t\tif (call_panic)\n\t\t\t\t*call_panic = 2;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\n\t/* log the audit_names record type */\n\taudit_log_format(ab, \" nametype=\");\n\tswitch(n->type) {\n\tcase AUDIT_TYPE_NORMAL:\n\t\taudit_log_format(ab, \"NORMAL\");\n\t\tbreak;\n\tcase AUDIT_TYPE_PARENT:\n\t\taudit_log_format(ab, \"PARENT\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_DELETE:\n\t\taudit_log_format(ab, \"DELETE\");\n\t\tbreak;\n\tcase AUDIT_TYPE_CHILD_CREATE:\n\t\taudit_log_format(ab, \"CREATE\");\n\t\tbreak;\n\tdefault:\n\t\taudit_log_format(ab, \"UNKNOWN\");\n\t\tbreak;\n\t}\n\n\taudit_log_fcaps(ab, n);\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&context->names_list",
            "list"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_d_path",
          "args": [
            "ab",
            "\"cwd=\"",
            "&context->pwd"
          ],
          "line": 1453
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_d_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2017-2038",
          "snippet": "void audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_d_path(struct audit_buffer *ab, const char *prefix,\n\t\t      const struct path *path)\n{\n\tchar *p, *pathname;\n\n\tif (prefix)\n\t\taudit_log_format(ab, \"%s\", prefix);\n\n\t/* We will allow 11 spaces for ' (deleted)' to be appended */\n\tpathname = kmalloc(PATH_MAX+11, ab->gfp_mask);\n\tif (!pathname) {\n\t\taudit_log_string(ab, \"<no_memory>\");\n\t\treturn;\n\t}\n\tp = d_path(path, pathname, PATH_MAX+11);\n\tif (IS_ERR(p)) { /* Should never happen since we send PATH_MAX */\n\t\t/* FIXME: can we save some information here? */\n\t\taudit_log_string(ab, \"<too_long>\");\n\t} else\n\t\taudit_log_untrustedstring(ab, p);\n\tkfree(pathname);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_pid_context",
          "args": [
            "context",
            "context->target_pid",
            "context->target_auid",
            "context->target_uid",
            "context->target_sessionid",
            "context->target_sid",
            "context->target_comm"
          ],
          "line": 1444
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_pid_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "977-1007",
          "snippet": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "ab",
            "(void *)context->sockaddr",
            "context->sockaddr_len"
          ],
          "line": 1424
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1904-1931",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"saddr=\""
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "show_special",
          "args": [
            "context",
            "&call_panic"
          ],
          "line": 1409
        },
        "resolved": true,
        "details": {
          "function_name": "show_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1183-1291",
          "snippet": "static void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t\tkfree(context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t\tkfree(context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"pa\"",
            "&axs->new_pcap.ambient"
          ],
          "line": 1401
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2057-2066",
          "snippet": "void audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_key",
          "args": [
            "ab",
            "context->filterkey"
          ],
          "line": 1377
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_key",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2048-2055",
          "snippet": "void audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_key(struct audit_buffer *ab, char *key)\n{\n\taudit_log_format(ab, \" key=\");\n\tif (key)\n\t\taudit_log_untrustedstring(ab, key);\n\telse\n\t\taudit_log_format(ab, \"(null)\");\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_task_info",
          "args": [
            "ab",
            "tsk"
          ],
          "line": 1376
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_task_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2267-2301",
          "snippet": "void audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_task_info(struct audit_buffer *ab, struct task_struct *tsk)\n{\n\tconst struct cred *cred;\n\tchar comm[sizeof(tsk->comm)];\n\tstruct tty_struct *tty;\n\n\tif (!ab)\n\t\treturn;\n\n\t/* tsk == current */\n\tcred = current_cred();\n\ttty = audit_get_tty(tsk);\n\taudit_log_format(ab,\n\t\t\t \" ppid=%d pid=%d auid=%u uid=%u gid=%u\"\n\t\t\t \" euid=%u suid=%u fsuid=%u\"\n\t\t\t \" egid=%u sgid=%u fsgid=%u tty=%s ses=%u\",\n\t\t\t task_ppid_nr(tsk),\n\t\t\t task_tgid_nr(tsk),\n\t\t\t from_kuid(&init_user_ns, audit_get_loginuid(tsk)),\n\t\t\t from_kuid(&init_user_ns, cred->uid),\n\t\t\t from_kgid(&init_user_ns, cred->gid),\n\t\t\t from_kuid(&init_user_ns, cred->euid),\n\t\t\t from_kuid(&init_user_ns, cred->suid),\n\t\t\t from_kuid(&init_user_ns, cred->fsuid),\n\t\t\t from_kgid(&init_user_ns, cred->egid),\n\t\t\t from_kgid(&init_user_ns, cred->sgid),\n\t\t\t from_kgid(&init_user_ns, cred->fsgid),\n\t\t\t tty ? tty_name(tty) : \"(none)\",\n\t\t\t audit_get_sessionid(tsk));\n\taudit_put_tty(tty);\n\taudit_log_format(ab, \" comm=\");\n\taudit_log_untrustedstring(ab, get_task_comm(comm, tsk));\n\taudit_log_d_path_exe(ab, tsk->mm);\n\taudit_log_task_context(ab);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_SUCCESS 1\n\nstatic void audit_log_exit(struct audit_context *context, struct task_struct *tsk)\n{\n\tint i, call_panic = 0;\n\tstruct audit_buffer *ab;\n\tstruct audit_aux_data *aux;\n\tstruct audit_names *n;\n\n\t/* tsk == current */\n\tcontext->personality = tsk->personality;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SYSCALL);\n\tif (!ab)\n\t\treturn;\t\t/* audit_panic has been called */\n\taudit_log_format(ab, \"arch=%x syscall=%d\",\n\t\t\t context->arch, context->major);\n\tif (context->personality != PER_LINUX)\n\t\taudit_log_format(ab, \" per=%lx\", context->personality);\n\tif (context->return_valid)\n\t\taudit_log_format(ab, \" success=%s exit=%ld\",\n\t\t\t\t (context->return_valid==AUDITSC_SUCCESS)?\"yes\":\"no\",\n\t\t\t\t context->return_code);\n\n\taudit_log_format(ab,\n\t\t\t \" a0=%lx a1=%lx a2=%lx a3=%lx items=%d\",\n\t\t\t context->argv[0],\n\t\t\t context->argv[1],\n\t\t\t context->argv[2],\n\t\t\t context->argv[3],\n\t\t\t context->name_count);\n\n\taudit_log_task_info(ab, tsk);\n\taudit_log_key(ab, context->filterkey);\n\taudit_log_end(ab);\n\n\tfor (aux = context->aux; aux; aux = aux->next) {\n\n\t\tab = audit_log_start(context, GFP_KERNEL, aux->type);\n\t\tif (!ab)\n\t\t\tcontinue; /* audit_panic has been called */\n\n\t\tswitch (aux->type) {\n\n\t\tcase AUDIT_BPRM_FCAPS: {\n\t\t\tstruct audit_aux_data_bprm_fcaps *axs = (void *)aux;\n\t\t\taudit_log_format(ab, \"fver=%x\", axs->fcap_ver);\n\t\t\taudit_log_cap(ab, \"fp\", &axs->fcap.permitted);\n\t\t\taudit_log_cap(ab, \"fi\", &axs->fcap.inheritable);\n\t\t\taudit_log_format(ab, \" fe=%d\", axs->fcap.fE);\n\t\t\taudit_log_cap(ab, \"old_pp\", &axs->old_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"old_pi\", &axs->old_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"old_pe\", &axs->old_pcap.effective);\n\t\t\taudit_log_cap(ab, \"old_pa\", &axs->old_pcap.ambient);\n\t\t\taudit_log_cap(ab, \"pp\", &axs->new_pcap.permitted);\n\t\t\taudit_log_cap(ab, \"pi\", &axs->new_pcap.inheritable);\n\t\t\taudit_log_cap(ab, \"pe\", &axs->new_pcap.effective);\n\t\t\taudit_log_cap(ab, \"pa\", &axs->new_pcap.ambient);\n\t\t\tbreak; }\n\n\t\t}\n\t\taudit_log_end(ab);\n\t}\n\n\tif (context->type)\n\t\tshow_special(context, &call_panic);\n\n\tif (context->fds[0] >= 0) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_FD_PAIR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"fd0=%d fd1=%d\",\n\t\t\t\t\tcontext->fds[0], context->fds[1]);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tif (context->sockaddr_len) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_SOCKADDR);\n\t\tif (ab) {\n\t\t\taudit_log_format(ab, \"saddr=\");\n\t\t\taudit_log_n_hex(ab, (void *)context->sockaddr,\n\t\t\t\t\tcontext->sockaddr_len);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\tfor (aux = context->aux_pids; aux; aux = aux->next) {\n\t\tstruct audit_aux_data_pids *axs = (void *)aux;\n\n\t\tfor (i = 0; i < axs->pid_count; i++)\n\t\t\tif (audit_log_pid_context(context, axs->target_pid[i],\n\t\t\t\t\t\t  axs->target_auid[i],\n\t\t\t\t\t\t  axs->target_uid[i],\n\t\t\t\t\t\t  axs->target_sessionid[i],\n\t\t\t\t\t\t  axs->target_sid[i],\n\t\t\t\t\t\t  axs->target_comm[i]))\n\t\t\t\tcall_panic = 1;\n\t}\n\n\tif (context->target_pid &&\n\t    audit_log_pid_context(context, context->target_pid,\n\t\t\t\t  context->target_auid, context->target_uid,\n\t\t\t\t  context->target_sessionid,\n\t\t\t\t  context->target_sid, context->target_comm))\n\t\t\tcall_panic = 1;\n\n\tif (context->pwd.dentry && context->pwd.mnt) {\n\t\tab = audit_log_start(context, GFP_KERNEL, AUDIT_CWD);\n\t\tif (ab) {\n\t\t\taudit_log_d_path(ab, \"cwd=\", &context->pwd);\n\t\t\taudit_log_end(ab);\n\t\t}\n\t}\n\n\ti = 0;\n\tlist_for_each_entry(n, &context->names_list, list) {\n\t\tif (n->hidden)\n\t\t\tcontinue;\n\t\taudit_log_name(context, n, NULL, i++, &call_panic);\n\t}\n\n\taudit_log_proctitle(tsk, context);\n\n\t/* Send end of event record to help user space know we are finished */\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_EOE);\n\tif (ab)\n\t\taudit_log_end(ab);\n\tif (call_panic)\n\t\taudit_panic(\"error converting sid to string\");\n}"
  },
  {
    "function_name": "audit_log_proctitle",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1305-1344",
    "snippet": "static void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_PROCTITLE_AUDIT_LEN 128"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1343
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_untrustedstring",
          "args": [
            "ab",
            "msg",
            "len"
          ],
          "line": 1342
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1994-2001",
          "snippet": "void audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_untrustedstring(struct audit_buffer *ab, const char *string,\n\t\t\t\t size_t len)\n{\n\tif (audit_string_contains_control(string, len))\n\t\taudit_log_n_hex(ab, string, len);\n\telse\n\t\taudit_log_n_string(ab, string, len);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf"
          ],
          "line": 1333
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_proctitle_rtrim",
          "args": [
            "buf",
            "res"
          ],
          "line": 1331
        },
        "resolved": true,
        "details": {
          "function_name": "audit_proctitle_rtrim",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1293-1303",
          "snippet": "static inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_cmdline",
          "args": [
            "tsk",
            "buf",
            "MAX_PROCTITLE_AUDIT_LEN"
          ],
          "line": 1326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_PROCTITLE_AUDIT_LEN",
            "GFP_KERNEL"
          ],
          "line": 1322
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"proctitle=\""
          ],
          "line": 1318
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_PROCTITLE"
          ],
          "line": 1314
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "msg"
          ],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "fetch_store_strlen",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_uprobe.c",
          "lines": "137-146",
          "snippet": "static nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}",
          "includes": [
            "#include \"trace_probe_tmpl.h\"",
            "#include \"trace_probe.h\"",
            "#include <linux/rculist.h>",
            "#include <linux/string.h>",
            "#include <linux/namei.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"trace_probe_tmpl.h\"\n#include \"trace_probe.h\"\n#include <linux/rculist.h>\n#include <linux/string.h>\n#include <linux/namei.h>\n#include <linux/uprobes.h>\n#include <linux/uaccess.h>\n#include <linux/module.h>\n\nstatic nokprobe_inline int\nfetch_store_strlen(unsigned long addr)\n{\n\tint len;\n\tvoid __user *vaddr = (void __force __user *) addr;\n\n\tlen = strnlen_user(vaddr, MAX_STRING_SIZE);\n\n\treturn (len > MAX_STRING_SIZE) ? 0 : len;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_PROCTITLE_AUDIT_LEN 128\n\nstatic void audit_log_proctitle(struct task_struct *tsk,\n\t\t\t struct audit_context *context)\n{\n\tint res;\n\tchar *buf;\n\tchar *msg = \"(null)\";\n\tint len = strlen(msg);\n\tstruct audit_buffer *ab;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_PROCTITLE);\n\tif (!ab)\n\t\treturn;\t/* audit_panic or being filtered */\n\n\taudit_log_format(ab, \"proctitle=\");\n\n\t/* Not  cached */\n\tif (!context->proctitle.value) {\n\t\tbuf = kmalloc(MAX_PROCTITLE_AUDIT_LEN, GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tgoto out;\n\t\t/* Historically called this from procfs naming */\n\t\tres = get_cmdline(tsk, buf, MAX_PROCTITLE_AUDIT_LEN);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tres = audit_proctitle_rtrim(buf, res);\n\t\tif (res == 0) {\n\t\t\tkfree(buf);\n\t\t\tgoto out;\n\t\t}\n\t\tcontext->proctitle.value = buf;\n\t\tcontext->proctitle.len = res;\n\t}\n\tmsg = context->proctitle.value;\n\tlen = context->proctitle.len;\nout:\n\taudit_log_n_untrustedstring(ab, msg, len);\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_proctitle_rtrim",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1293-1303",
    "snippet": "static inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "proctitle[len-1]"
          ],
          "line": 1301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isprint",
          "args": [
            "*end"
          ],
          "line": 1296
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline int audit_proctitle_rtrim(char *proctitle, int len)\n{\n\tchar *end = proctitle + len - 1;\n\twhile (end > proctitle && !isprint(*end))\n\t\tend--;\n\n\t/* catch the case where proctitle is only 1 non-print character */\n\tlen = end - proctitle + 1;\n\tlen -= isprint(proctitle[len-1]) == 0;\n\treturn len;\n}"
  },
  {
    "function_name": "show_special",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1183-1291",
    "snippet": "static void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t\tkfree(context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1290
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\"(null)\""
          ],
          "line": 1286
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context->module.name"
          ],
          "line": 1284
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "context->module.name"
          ],
          "line": 1283
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_execve_info",
          "args": [
            "context",
            "&ab"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_execve_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "1009-1181",
          "snippet": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf > 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define MAX_EXECVE_AUDIT_LEN 7500"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_EXECVE_AUDIT_LEN 7500\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf > 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_cap",
          "args": [
            "ab",
            "\"cap_pa\"",
            "&context->capset.cap.ambient"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_cap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2057-2066",
          "snippet": "void audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_cap(struct audit_buffer *ab, char *prefix, kernel_cap_t *cap)\n{\n\tint i;\n\n\taudit_log_format(ab, \" %s=\", prefix);\n\tCAP_FOR_EACH_U32(i) {\n\t\taudit_log_format(ab, \"%08x\",\n\t\t\t\t cap->cap[CAP_LAST_U32 - i]);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ab"
          ],
          "line": 1222
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_IPC_SET_PERM"
          ],
          "line": 1220
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 1215
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "osid",
            "&ctx",
            "&len"
          ],
          "line": 1210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kgid",
          "args": [
            "&init_user_ns",
            "context->ipc.gid"
          ],
          "line": 1205
        },
        "resolved": true,
        "details": {
          "function_name": "from_kgid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "503-511",
          "snippet": "gid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\ngid_t from_kgid_munged(struct user_namespace *targ, kgid_t kgid)\n{\n\tgid_t gid;\n\tgid = from_kgid(targ, kgid);\n\n\tif (gid == (gid_t) -1)\n\t\tgid = overflowgid;\n\treturn gid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "context->ipc.uid"
          ],
          "line": 1204
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void show_special(struct audit_context *context, int *call_panic)\n{\n\tstruct audit_buffer *ab;\n\tint i;\n\n\tab = audit_log_start(context, GFP_KERNEL, context->type);\n\tif (!ab)\n\t\treturn;\n\n\tswitch (context->type) {\n\tcase AUDIT_SOCKETCALL: {\n\t\tint nargs = context->socketcall.nargs;\n\t\taudit_log_format(ab, \"nargs=%d\", nargs);\n\t\tfor (i = 0; i < nargs; i++)\n\t\t\taudit_log_format(ab, \" a%d=%lx\", i,\n\t\t\t\tcontext->socketcall.args[i]);\n\t\tbreak; }\n\tcase AUDIT_IPC: {\n\t\tu32 osid = context->ipc.osid;\n\n\t\taudit_log_format(ab, \"ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\t from_kuid(&init_user_ns, context->ipc.uid),\n\t\t\t\t from_kgid(&init_user_ns, context->ipc.gid),\n\t\t\t\t context->ipc.mode);\n\t\tif (osid) {\n\t\t\tchar *ctx = NULL;\n\t\t\tu32 len;\n\t\t\tif (security_secid_to_secctx(osid, &ctx, &len)) {\n\t\t\t\taudit_log_format(ab, \" osid=%u\", osid);\n\t\t\t\t*call_panic = 1;\n\t\t\t} else {\n\t\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\t\tsecurity_release_secctx(ctx, len);\n\t\t\t}\n\t\t}\n\t\tif (context->ipc.has_perm) {\n\t\t\taudit_log_end(ab);\n\t\t\tab = audit_log_start(context, GFP_KERNEL,\n\t\t\t\t\t     AUDIT_IPC_SET_PERM);\n\t\t\tif (unlikely(!ab))\n\t\t\t\treturn;\n\t\t\taudit_log_format(ab,\n\t\t\t\t\"qbytes=%lx ouid=%u ogid=%u mode=%#ho\",\n\t\t\t\tcontext->ipc.qbytes,\n\t\t\t\tcontext->ipc.perm_uid,\n\t\t\t\tcontext->ipc.perm_gid,\n\t\t\t\tcontext->ipc.perm_mode);\n\t\t}\n\t\tbreak; }\n\tcase AUDIT_MQ_OPEN:\n\t\taudit_log_format(ab,\n\t\t\t\"oflag=0x%x mode=%#ho mq_flags=0x%lx mq_maxmsg=%ld \"\n\t\t\t\"mq_msgsize=%ld mq_curmsgs=%ld\",\n\t\t\tcontext->mq_open.oflag, context->mq_open.mode,\n\t\t\tcontext->mq_open.attr.mq_flags,\n\t\t\tcontext->mq_open.attr.mq_maxmsg,\n\t\t\tcontext->mq_open.attr.mq_msgsize,\n\t\t\tcontext->mq_open.attr.mq_curmsgs);\n\t\tbreak;\n\tcase AUDIT_MQ_SENDRECV:\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d msg_len=%zd msg_prio=%u \"\n\t\t\t\"abs_timeout_sec=%lld abs_timeout_nsec=%ld\",\n\t\t\tcontext->mq_sendrecv.mqdes,\n\t\t\tcontext->mq_sendrecv.msg_len,\n\t\t\tcontext->mq_sendrecv.msg_prio,\n\t\t\t(long long) context->mq_sendrecv.abs_timeout.tv_sec,\n\t\t\tcontext->mq_sendrecv.abs_timeout.tv_nsec);\n\t\tbreak;\n\tcase AUDIT_MQ_NOTIFY:\n\t\taudit_log_format(ab, \"mqdes=%d sigev_signo=%d\",\n\t\t\t\tcontext->mq_notify.mqdes,\n\t\t\t\tcontext->mq_notify.sigev_signo);\n\t\tbreak;\n\tcase AUDIT_MQ_GETSETATTR: {\n\t\tstruct mq_attr *attr = &context->mq_getsetattr.mqstat;\n\t\taudit_log_format(ab,\n\t\t\t\"mqdes=%d mq_flags=0x%lx mq_maxmsg=%ld mq_msgsize=%ld \"\n\t\t\t\"mq_curmsgs=%ld \",\n\t\t\tcontext->mq_getsetattr.mqdes,\n\t\t\tattr->mq_flags, attr->mq_maxmsg,\n\t\t\tattr->mq_msgsize, attr->mq_curmsgs);\n\t\tbreak; }\n\tcase AUDIT_CAPSET:\n\t\taudit_log_format(ab, \"pid=%d\", context->capset.pid);\n\t\taudit_log_cap(ab, \"cap_pi\", &context->capset.cap.inheritable);\n\t\taudit_log_cap(ab, \"cap_pp\", &context->capset.cap.permitted);\n\t\taudit_log_cap(ab, \"cap_pe\", &context->capset.cap.effective);\n\t\taudit_log_cap(ab, \"cap_pa\", &context->capset.cap.ambient);\n\t\tbreak;\n\tcase AUDIT_MMAP:\n\t\taudit_log_format(ab, \"fd=%d flags=0x%x\", context->mmap.fd,\n\t\t\t\t context->mmap.flags);\n\t\tbreak;\n\tcase AUDIT_EXECVE:\n\t\taudit_log_execve_info(context, &ab);\n\t\tbreak;\n\tcase AUDIT_KERN_MODULE:\n\t\taudit_log_format(ab, \"name=\");\n\t\tif (context->module.name) {\n\t\t\taudit_log_untrustedstring(ab, context->module.name);\n\t\t\tkfree(context->module.name);\n\t\t} else\n\t\t\taudit_log_format(ab, \"(null)\");\n\n\t\tbreak;\n\t}\n\taudit_log_end(ab);\n}"
  },
  {
    "function_name": "audit_log_execve_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "1009-1181",
    "snippet": "static void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf > 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define MAX_EXECVE_AUDIT_LEN 7500"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "buf_head"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_string",
          "args": [
            "*ab",
            "buf",
            "len_tmp"
          ],
          "line": 1157
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_string",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1937-1963",
          "snippet": "void audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_n_string(struct audit_buffer *ab, const char *string,\n\t\t\tsize_t slen)\n{\n\tint avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = slen + 3;\t/* enclosing quotes + null terminator */\n\tif (new_len > avail) {\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\tptr = skb_tail_pointer(skb);\n\t*ptr++ = '\"';\n\tmemcpy(ptr, string, slen);\n\tptr += slen;\n\t*ptr++ = '\"';\n\t*ptr = 0;\n\tskb_put(skb, slen + 2);\t/* don't include null terminator */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_n_hex",
          "args": [
            "*ab",
            "buf",
            "len_tmp"
          ],
          "line": 1151
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_n_hex",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1904-1931",
          "snippet": "void audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_BUFSIZ 1024"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_BUFSIZ 1024\n\nvoid audit_log_n_hex(struct audit_buffer *ab, const unsigned char *buf,\n\t\tsize_t len)\n{\n\tint i, avail, new_len;\n\tunsigned char *ptr;\n\tstruct sk_buff *skb;\n\n\tif (!ab)\n\t\treturn;\n\n\tBUG_ON(!ab->skb);\n\tskb = ab->skb;\n\tavail = skb_tailroom(skb);\n\tnew_len = len<<1;\n\tif (new_len >= avail) {\n\t\t/* Round the buffer request up to the next multiple */\n\t\tnew_len = AUDIT_BUFSIZ*(((new_len-avail)/AUDIT_BUFSIZ) + 1);\n\t\tavail = audit_expand(ab, new_len);\n\t\tif (!avail)\n\t\t\treturn;\n\t}\n\n\tptr = skb_tail_pointer(skb);\n\tfor (i = 0; i < len; i++)\n\t\tptr = hex_byte_pack_upper(ptr, buf[i]);\n\t*ptr = 0;\n\tskb_put(skb, len << 1); /* new string is twice the old string */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "*ab",
            "\"%s\"",
            "abuf"
          ],
          "line": 1145
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "len_tmp >= sizeof(abuf)"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d=\"",
            "arg"
          ],
          "line": 1138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d[%d]=\"",
            "arg",
            "iter++"
          ],
          "line": 1134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "&abuf[len_tmp]",
            "sizeof(abuf) - len_tmp",
            "\" a%d_len=%lu\"",
            "arg",
            "len_full"
          ],
          "line": 1129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_EXECVE"
          ],
          "line": 1118
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "*ab"
          ],
          "line": 1117
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_string_contains_control",
          "args": [
            "buf",
            "len_tmp"
          ],
          "line": 1094
        },
        "resolved": true,
        "details": {
          "function_name": "audit_string_contains_control",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1970-1978",
          "snippet": "bool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nbool audit_string_contains_control(const char *string, size_t len)\n{\n\tconst unsigned char *p;\n\tfor (p = string; p < (const unsigned char *)string + len; p++) {\n\t\tif (*p == '\"' || *p < 0x21 || *p > 0x7e)\n\t\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_sig",
          "args": [
            "SIGKILL",
            "current",
            "0"
          ],
          "line": 1079
        },
        "resolved": true,
        "details": {
          "function_name": "send_sigqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1712-1758",
          "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "strncpy_from_user",
          "args": [
            "&buf_head[len_buf]",
            "p",
            "len_max - len_buf"
          ],
          "line": 1075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memmove",
          "args": [
            "buf_head",
            "buf",
            "len_buf"
          ],
          "line": 1070
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strnlen_user",
          "args": [
            "p",
            "MAX_ARG_STRLEN"
          ],
          "line": 1064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_panic",
          "args": [
            "\"out of memory for argv string\""
          ],
          "line": 1041
        },
        "resolved": true,
        "details": {
          "function_name": "audit_panic",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "310-323",
          "snippet": "void audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\n\nvoid audit_panic(const char *message)\n{\n\tswitch (audit_failure) {\n\tcase AUDIT_FAIL_SILENT:\n\t\tbreak;\n\tcase AUDIT_FAIL_PRINTK:\n\t\tif (printk_ratelimit())\n\t\t\tpr_err(\"%s\\n\", message);\n\t\tbreak;\n\tcase AUDIT_FAIL_PANIC:\n\t\tpanic(\"audit: %s\\n\", message);\n\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "MAX_EXECVE_AUDIT_LEN + 1",
            "GFP_KERNEL"
          ],
          "line": 1039
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "MAX_EXECVE_AUDIT_LEN > 7500"
          ],
          "line": 1035
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define MAX_EXECVE_AUDIT_LEN 7500\n\nstatic void audit_log_execve_info(struct audit_context *context,\n\t\t\t\t  struct audit_buffer **ab)\n{\n\tlong len_max;\n\tlong len_rem;\n\tlong len_full;\n\tlong len_buf;\n\tlong len_abuf = 0;\n\tlong len_tmp;\n\tbool require_data;\n\tbool encode;\n\tunsigned int iter;\n\tunsigned int arg;\n\tchar *buf_head;\n\tchar *buf;\n\tconst char __user *p = (const char __user *)current->mm->arg_start;\n\n\t/* NOTE: this buffer needs to be large enough to hold all the non-arg\n\t *       data we put in the audit record for this argument (see the\n\t *       code below) ... at this point in time 96 is plenty */\n\tchar abuf[96];\n\n\t/* NOTE: we set MAX_EXECVE_AUDIT_LEN to a rather arbitrary limit, the\n\t *       current value of 7500 is not as important as the fact that it\n\t *       is less than 8k, a setting of 7500 gives us plenty of wiggle\n\t *       room if we go over a little bit in the logging below */\n\tWARN_ON_ONCE(MAX_EXECVE_AUDIT_LEN > 7500);\n\tlen_max = MAX_EXECVE_AUDIT_LEN;\n\n\t/* scratch buffer to hold the userspace args */\n\tbuf_head = kmalloc(MAX_EXECVE_AUDIT_LEN + 1, GFP_KERNEL);\n\tif (!buf_head) {\n\t\taudit_panic(\"out of memory for argv string\");\n\t\treturn;\n\t}\n\tbuf = buf_head;\n\n\taudit_log_format(*ab, \"argc=%d\", context->execve.argc);\n\n\tlen_rem = len_max;\n\tlen_buf = 0;\n\tlen_full = 0;\n\trequire_data = true;\n\tencode = false;\n\titer = 0;\n\targ = 0;\n\tdo {\n\t\t/* NOTE: we don't ever want to trust this value for anything\n\t\t *       serious, but the audit record format insists we\n\t\t *       provide an argument length for really long arguments,\n\t\t *       e.g. > MAX_EXECVE_AUDIT_LEN, so we have no choice but\n\t\t *       to use strncpy_from_user() to obtain this value for\n\t\t *       recording in the log, although we don't use it\n\t\t *       anywhere here to avoid a double-fetch problem */\n\t\tif (len_full == 0)\n\t\t\tlen_full = strnlen_user(p, MAX_ARG_STRLEN) - 1;\n\n\t\t/* read more data from userspace */\n\t\tif (require_data) {\n\t\t\t/* can we make more room in the buffer? */\n\t\t\tif (buf != buf_head) {\n\t\t\t\tmemmove(buf_head, buf, len_buf);\n\t\t\t\tbuf = buf_head;\n\t\t\t}\n\n\t\t\t/* fetch as much as we can of the argument */\n\t\t\tlen_tmp = strncpy_from_user(&buf_head[len_buf], p,\n\t\t\t\t\t\t    len_max - len_buf);\n\t\t\tif (len_tmp == -EFAULT) {\n\t\t\t\t/* unable to copy from userspace */\n\t\t\t\tsend_sig(SIGKILL, current, 0);\n\t\t\t\tgoto out;\n\t\t\t} else if (len_tmp == (len_max - len_buf)) {\n\t\t\t\t/* buffer is not large enough */\n\t\t\t\trequire_data = true;\n\t\t\t\t/* NOTE: if we are going to span multiple\n\t\t\t\t *       buffers force the encoding so we stand\n\t\t\t\t *       a chance at a sane len_full value and\n\t\t\t\t *       consistent record encoding */\n\t\t\t\tencode = true;\n\t\t\t\tlen_full = len_full * 2;\n\t\t\t\tp += len_tmp;\n\t\t\t} else {\n\t\t\t\trequire_data = false;\n\t\t\t\tif (!encode)\n\t\t\t\t\tencode = audit_string_contains_control(\n\t\t\t\t\t\t\t\tbuf, len_tmp);\n\t\t\t\t/* try to use a trusted value for len_full */\n\t\t\t\tif (len_full < len_max)\n\t\t\t\t\tlen_full = (encode ?\n\t\t\t\t\t\t    len_tmp * 2 : len_tmp);\n\t\t\t\tp += len_tmp + 1;\n\t\t\t}\n\t\t\tlen_buf += len_tmp;\n\t\t\tbuf_head[len_buf] = '\\0';\n\n\t\t\t/* length of the buffer in the audit record? */\n\t\t\tlen_abuf = (encode ? len_buf * 2 : len_buf + 2);\n\t\t}\n\n\t\t/* write as much as we can to the audit log */\n\t\tif (len_buf > 0) {\n\t\t\t/* NOTE: some magic numbers here - basically if we\n\t\t\t *       can't fit a reasonable amount of data into the\n\t\t\t *       existing audit buffer, flush it and start with\n\t\t\t *       a new buffer */\n\t\t\tif ((sizeof(abuf) + 8) > len_rem) {\n\t\t\t\tlen_rem = len_max;\n\t\t\t\taudit_log_end(*ab);\n\t\t\t\t*ab = audit_log_start(context,\n\t\t\t\t\t\t      GFP_KERNEL, AUDIT_EXECVE);\n\t\t\t\tif (!*ab)\n\t\t\t\t\tgoto out;\n\t\t\t}\n\n\t\t\t/* create the non-arg portion of the arg record */\n\t\t\tlen_tmp = 0;\n\t\t\tif (require_data || (iter > 0) ||\n\t\t\t    ((len_abuf + sizeof(abuf)) > len_rem)) {\n\t\t\t\tif (iter == 0) {\n\t\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t\tsizeof(abuf) - len_tmp,\n\t\t\t\t\t\t\t\" a%d_len=%lu\",\n\t\t\t\t\t\t\targ, len_full);\n\t\t\t\t}\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d[%d]=\", arg, iter++);\n\t\t\t} else\n\t\t\t\tlen_tmp += snprintf(&abuf[len_tmp],\n\t\t\t\t\t\t    sizeof(abuf) - len_tmp,\n\t\t\t\t\t\t    \" a%d=\", arg);\n\t\t\tWARN_ON(len_tmp >= sizeof(abuf));\n\t\t\tabuf[sizeof(abuf) - 1] = '\\0';\n\n\t\t\t/* log the arg in the audit record */\n\t\t\taudit_log_format(*ab, \"%s\", abuf);\n\t\t\tlen_rem -= len_tmp;\n\t\t\tlen_tmp = len_buf;\n\t\t\tif (encode) {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem / 2; /* encoding */\n\t\t\t\taudit_log_n_hex(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp * 2;\n\t\t\t\tlen_abuf -= len_tmp * 2;\n\t\t\t} else {\n\t\t\t\tif (len_abuf > len_rem)\n\t\t\t\t\tlen_tmp = len_rem - 2; /* quotes */\n\t\t\t\taudit_log_n_string(*ab, buf, len_tmp);\n\t\t\t\tlen_rem -= len_tmp + 2;\n\t\t\t\t/* don't subtract the \"2\" because we still need\n\t\t\t\t * to add quotes to the remaining string */\n\t\t\t\tlen_abuf -= len_tmp;\n\t\t\t}\n\t\t\tlen_buf -= len_tmp;\n\t\t\tbuf += len_tmp;\n\t\t}\n\n\t\t/* ready to move to the next argument? */\n\t\tif ((len_buf == 0) && !require_data) {\n\t\t\targ++;\n\t\t\titer = 0;\n\t\t\tlen_full = 0;\n\t\t\trequire_data = true;\n\t\t\tencode = false;\n\t\t}\n\t} while (arg < context->execve.argc);\n\n\t/* NOTE: the caller handles the final audit_log_end() call */\n\nout:\n\tkfree(buf_head);\n}"
  },
  {
    "function_name": "audit_log_pid_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "977-1007",
    "snippet": "static int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_log_end",
          "args": [
            "ab"
          ],
          "line": 1004
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_end",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2334-2358",
          "snippet": "void audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\n\nvoid audit_log_end(struct audit_buffer *ab)\n{\n\tstruct sk_buff *skb;\n\tstruct nlmsghdr *nlh;\n\n\tif (!ab)\n\t\treturn;\n\n\tif (audit_rate_check()) {\n\t\tskb = ab->skb;\n\t\tab->skb = NULL;\n\n\t\t/* setup the netlink header, see the comments in\n\t\t * kauditd_send_multicast_skb() for length quirks */\n\t\tnlh = nlmsg_hdr(skb);\n\t\tnlh->nlmsg_len = skb->len - NLMSG_HDRLEN;\n\n\t\t/* queue the netlink packet and poke the kauditd thread */\n\t\tskb_queue_tail(&audit_queue, skb);\n\t\twake_up_interruptible(&kauditd_wait);\n\t} else\n\t\taudit_log_lost(\"rate limit exceeded\");\n\n\taudit_buffer_free(ab);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_untrustedstring",
          "args": [
            "ab",
            "comm"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_untrustedstring",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "2011-2014",
          "snippet": "void audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_untrustedstring(struct audit_buffer *ab, const char *string)\n{\n\taudit_log_n_untrustedstring(ab, string, strlen(string));\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_format",
          "args": [
            "ab",
            "\" ocomm=\""
          ],
          "line": 1002
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_format",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1882-1891",
          "snippet": "void audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nvoid audit_log_format(struct audit_buffer *ab, const char *fmt, ...)\n{\n\tva_list args;\n\n\tif (!ab)\n\t\treturn;\n\tva_start(args, fmt);\n\taudit_log_vformat(ab, fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_release_secctx",
          "args": [
            "ctx",
            "len"
          ],
          "line": 999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_secid_to_secctx",
          "args": [
            "sid",
            "&ctx",
            "&len"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid",
          "args": [
            "&init_user_ns",
            "uid"
          ],
          "line": 992
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_log_start",
          "args": [
            "context",
            "GFP_KERNEL",
            "AUDIT_OBJ_PID"
          ],
          "line": 986
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_start",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "1744-1804",
          "snippet": "struct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [
            "#define AUDIT_INITIALIZED\t1"
          ],
          "globals_used": [
            "static int\taudit_initialized;",
            "static u32\taudit_backlog_limit = 64;",
            "static u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;",
            "static struct sk_buff_head audit_queue;",
            "static DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);",
            "static DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);",
            "static struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\n#define AUDIT_INITIALIZED\t1\n\nstatic int\taudit_initialized;\nstatic u32\taudit_backlog_limit = 64;\nstatic u32\taudit_backlog_wait_time = AUDIT_BACKLOG_WAIT_TIME;\nstatic struct sk_buff_head audit_queue;\nstatic DECLARE_WAIT_QUEUE_HEAD(kauditd_wait);\nstatic DECLARE_WAIT_QUEUE_HEAD(audit_backlog_wait);\nstatic struct audit_ctl_mutex {\n\tstruct mutex lock;\n\tvoid *owner;\n} audit_cmd_mutex;\n\nstruct audit_buffer *audit_log_start(struct audit_context *ctx, gfp_t gfp_mask,\n\t\t\t\t     int type)\n{\n\tstruct audit_buffer *ab;\n\tstruct timespec64 t;\n\tunsigned int uninitialized_var(serial);\n\n\tif (audit_initialized != AUDIT_INITIALIZED)\n\t\treturn NULL;\n\n\tif (unlikely(!audit_filter(type, AUDIT_FILTER_EXCLUDE)))\n\t\treturn NULL;\n\n\t/* NOTE: don't ever fail/sleep on these two conditions:\n\t * 1. auditd generated record - since we need auditd to drain the\n\t *    queue; also, when we are checking for auditd, compare PIDs using\n\t *    task_tgid_vnr() since auditd_pid is set in audit_receive_msg()\n\t *    using a PID anchored in the caller's namespace\n\t * 2. generator holding the audit_cmd_mutex - we don't want to block\n\t *    while holding the mutex */\n\tif (!(auditd_test_task(current) || audit_ctl_owner_current())) {\n\t\tlong stime = audit_backlog_wait_time;\n\n\t\twhile (audit_backlog_limit &&\n\t\t       (skb_queue_len(&audit_queue) > audit_backlog_limit)) {\n\t\t\t/* wake kauditd to try and flush the queue */\n\t\t\twake_up_interruptible(&kauditd_wait);\n\n\t\t\t/* sleep if we are allowed and we haven't exhausted our\n\t\t\t * backlog wait limit */\n\t\t\tif (gfpflags_allow_blocking(gfp_mask) && (stime > 0)) {\n\t\t\t\tDECLARE_WAITQUEUE(wait, current);\n\n\t\t\t\tadd_wait_queue_exclusive(&audit_backlog_wait,\n\t\t\t\t\t\t\t &wait);\n\t\t\t\tset_current_state(TASK_UNINTERRUPTIBLE);\n\t\t\t\tstime = schedule_timeout(stime);\n\t\t\t\tremove_wait_queue(&audit_backlog_wait, &wait);\n\t\t\t} else {\n\t\t\t\tif (audit_rate_check() && printk_ratelimit())\n\t\t\t\t\tpr_warn(\"audit_backlog=%d > audit_backlog_limit=%d\\n\",\n\t\t\t\t\t\tskb_queue_len(&audit_queue),\n\t\t\t\t\t\taudit_backlog_limit);\n\t\t\t\taudit_log_lost(\"backlog limit exceeded\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\tab = audit_buffer_alloc(ctx, gfp_mask, type);\n\tif (!ab) {\n\t\taudit_log_lost(\"out of memory in audit_log_start\");\n\t\treturn NULL;\n\t}\n\n\taudit_get_stamp(ab->ctx, &t, &serial);\n\taudit_log_format(ab, \"audit(%llu.%03lu:%u): \",\n\t\t\t (unsigned long long)t.tv_sec, t.tv_nsec/1000000, serial);\n\n\treturn ab;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_log_pid_context(struct audit_context *context, pid_t pid,\n\t\t\t\t kuid_t auid, kuid_t uid, unsigned int sessionid,\n\t\t\t\t u32 sid, char *comm)\n{\n\tstruct audit_buffer *ab;\n\tchar *ctx = NULL;\n\tu32 len;\n\tint rc = 0;\n\n\tab = audit_log_start(context, GFP_KERNEL, AUDIT_OBJ_PID);\n\tif (!ab)\n\t\treturn rc;\n\n\taudit_log_format(ab, \"opid=%d oauid=%d ouid=%d oses=%d\", pid,\n\t\t\t from_kuid(&init_user_ns, auid),\n\t\t\t from_kuid(&init_user_ns, uid), sessionid);\n\tif (sid) {\n\t\tif (security_secid_to_secctx(sid, &ctx, &len)) {\n\t\t\taudit_log_format(ab, \" obj=(none)\");\n\t\t\trc = 1;\n\t\t} else {\n\t\t\taudit_log_format(ab, \" obj=%s\", ctx);\n\t\t\tsecurity_release_secctx(ctx, len);\n\t\t}\n\t}\n\taudit_log_format(ab, \" ocomm=\");\n\taudit_log_untrustedstring(ab, comm);\n\taudit_log_end(ab);\n\n\treturn rc;\n}"
  },
  {
    "function_name": "audit_free_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "965-975",
    "snippet": "static inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context"
          ],
          "line": 974
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_proctitle_free",
          "args": [
            "context"
          ],
          "line": 973
        },
        "resolved": true,
        "details": {
          "function_name": "audit_proctitle_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "877-882",
          "snippet": "static inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_aux",
          "args": [
            "context"
          ],
          "line": 970
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_aux",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "901-913",
          "snippet": "static inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "free_tree_refs",
          "args": [
            "context"
          ],
          "line": 969
        },
        "resolved": true,
        "details": {
          "function_name": "free_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "280-287",
          "snippet": "static void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unroll_tree_refs",
          "args": [
            "context",
            "NULL",
            "0"
          ],
          "line": 968
        },
        "resolved": true,
        "details": {
          "function_name": "unroll_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "250-278",
          "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_free_names",
          "args": [
            "context"
          ],
          "line": 967
        },
        "resolved": true,
        "details": {
          "function_name": "audit_free_names",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "884-899",
          "snippet": "static inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_context(struct audit_context *context)\n{\n\taudit_free_names(context);\n\tunroll_tree_refs(context, NULL, 0);\n\tfree_tree_refs(context);\n\taudit_free_aux(context);\n\tkfree(context->filterkey);\n\tkfree(context->sockaddr);\n\taudit_proctitle_free(context);\n\tkfree(context);\n}"
  },
  {
    "function_name": "audit_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "938-963",
    "snippet": "int audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED) {\n\t\tclear_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\taudit_set_context(tsk, context);\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_SYSCALL_AUDIT"
          ],
          "line": 961
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_set_context",
          "args": [
            "tsk",
            "context"
          ],
          "line": 960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_log_lost",
          "args": [
            "\"out of memory in audit_alloc\""
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "audit_log_lost",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "362-392",
          "snippet": "void audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static u32\taudit_failure = AUDIT_FAIL_PRINTK;",
            "static u32\taudit_rate_limit;",
            "static u32\taudit_backlog_limit = 64;",
            "static atomic_t\taudit_lost = ATOMIC_INIT(0);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic u32\taudit_failure = AUDIT_FAIL_PRINTK;\nstatic u32\taudit_rate_limit;\nstatic u32\taudit_backlog_limit = 64;\nstatic atomic_t\taudit_lost = ATOMIC_INIT(0);\n\nvoid audit_log_lost(const char *message)\n{\n\tstatic unsigned long\tlast_msg = 0;\n\tstatic DEFINE_SPINLOCK(lock);\n\tunsigned long\t\tflags;\n\tunsigned long\t\tnow;\n\tint\t\t\tprint;\n\n\tatomic_inc(&audit_lost);\n\n\tprint = (audit_failure == AUDIT_FAIL_PANIC || !audit_rate_limit);\n\n\tif (!print) {\n\t\tspin_lock_irqsave(&lock, flags);\n\t\tnow = jiffies;\n\t\tif (now - last_msg > HZ) {\n\t\t\tprint = 1;\n\t\t\tlast_msg = now;\n\t\t}\n\t\tspin_unlock_irqrestore(&lock, flags);\n\t}\n\n\tif (print) {\n\t\tif (printk_ratelimit())\n\t\t\tpr_warn(\"audit_lost=%u audit_rate_limit=%u audit_backlog_limit=%u\\n\",\n\t\t\t\tatomic_read(&audit_lost),\n\t\t\t\taudit_rate_limit,\n\t\t\t\taudit_backlog_limit);\n\t\taudit_panic(message);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "key"
          ],
          "line": 954
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_alloc_context",
          "args": [
            "state"
          ],
          "line": 953
        },
        "resolved": true,
        "details": {
          "function_name": "audit_alloc_context",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "915-927",
          "snippet": "static inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "tsk",
            "TIF_SYSCALL_AUDIT"
          ],
          "line": 949
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter_task",
          "args": [
            "tsk",
            "&key"
          ],
          "line": 947
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "726-743",
          "snippet": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!audit_ever_enabled"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nint audit_alloc(struct task_struct *tsk)\n{\n\tstruct audit_context *context;\n\tenum audit_state     state;\n\tchar *key = NULL;\n\n\tif (likely(!audit_ever_enabled))\n\t\treturn 0; /* Return if not auditing. */\n\n\tstate = audit_filter_task(tsk, &key);\n\tif (state == AUDIT_DISABLED) {\n\t\tclear_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\t\treturn 0;\n\t}\n\n\tif (!(context = audit_alloc_context(state))) {\n\t\tkfree(key);\n\t\taudit_log_lost(\"out of memory in audit_alloc\");\n\t\treturn -ENOMEM;\n\t}\n\tcontext->filterkey = key;\n\n\taudit_set_context(tsk, context);\n\tset_tsk_thread_flag(tsk, TIF_SYSCALL_AUDIT);\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_alloc_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "915-927",
    "snippet": "static inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&context->names_list"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&context->killed_trees"
          ],
          "line": 924
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(*context)",
            "GFP_KERNEL"
          ],
          "line": 919
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline struct audit_context *audit_alloc_context(enum audit_state state)\n{\n\tstruct audit_context *context;\n\n\tcontext = kzalloc(sizeof(*context), GFP_KERNEL);\n\tif (!context)\n\t\treturn NULL;\n\tcontext->state = state;\n\tcontext->prio = state == AUDIT_RECORD_CONTEXT ? ~0ULL : 0;\n\tINIT_LIST_HEAD(&context->killed_trees);\n\tINIT_LIST_HEAD(&context->names_list);\n\treturn context;\n}"
  },
  {
    "function_name": "audit_free_aux",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "901-913",
    "snippet": "static inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "aux"
          ],
          "line": 911
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_aux(struct audit_context *context)\n{\n\tstruct audit_aux_data *aux;\n\n\twhile ((aux = context->aux)) {\n\t\tcontext->aux = aux->next;\n\t\tkfree(aux);\n\t}\n\twhile ((aux = context->aux_pids)) {\n\t\tcontext->aux_pids = aux->next;\n\t\tkfree(aux);\n\t}\n}"
  },
  {
    "function_name": "audit_free_names",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "884-899",
    "snippet": "static inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "path_put",
          "args": [
            "&context->pwd"
          ],
          "line": 896
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "n"
          ],
          "line": 893
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "putname",
          "args": [
            "n->name"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&n->list"
          ],
          "line": 889
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "n",
            "next",
            "&context->names_list",
            "list"
          ],
          "line": 888
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_free_names(struct audit_context *context)\n{\n\tstruct audit_names *n, *next;\n\n\tlist_for_each_entry_safe(n, next, &context->names_list, list) {\n\t\tlist_del(&n->list);\n\t\tif (n->name)\n\t\t\tputname(n->name);\n\t\tif (n->should_free)\n\t\t\tkfree(n);\n\t}\n\tcontext->name_count = 0;\n\tpath_put(&context->pwd);\n\tcontext->pwd.dentry = NULL;\n\tcontext->pwd.mnt = NULL;\n}"
  },
  {
    "function_name": "audit_proctitle_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "877-882",
    "snippet": "static inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "context->proctitle.value"
          ],
          "line": 879
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline void audit_proctitle_free(struct audit_context *context)\n{\n\tkfree(context->proctitle.value);\n\tcontext->proctitle.value = NULL;\n\tcontext->proctitle.len = 0;\n}"
  },
  {
    "function_name": "audit_take_context",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "840-875",
    "snippet": "static inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_set_context",
          "args": [
            "tsk",
            "NULL"
          ],
          "line": 873
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter_inodes",
          "args": [
            "tsk",
            "context"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inodes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "823-837",
          "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_syscall",
          "args": [
            "tsk",
            "context",
            "&audit_filter_list[AUDIT_FILTER_EXIT]"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_syscall",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "766-790",
          "snippet": "static enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "return_code <= -ERESTARTSYS"
          ],
          "line": 861
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic inline struct audit_context *audit_take_context(struct task_struct *tsk,\n\t\t\t\t\t\t      int return_valid,\n\t\t\t\t\t\t      long return_code)\n{\n\tstruct audit_context *context = tsk->audit_context;\n\n\tif (!context)\n\t\treturn NULL;\n\tcontext->return_valid = return_valid;\n\n\t/*\n\t * we need to fix up the return code in the audit logs if the actual\n\t * return codes are later going to be fixed up by the arch specific\n\t * signal handlers\n\t *\n\t * This is actually a test for:\n\t * (rc == ERESTARTSYS ) || (rc == ERESTARTNOINTR) ||\n\t * (rc == ERESTARTNOHAND) || (rc == ERESTART_RESTARTBLOCK)\n\t *\n\t * but is faster than a bunch of ||\n\t */\n\tif (unlikely(return_code <= -ERESTARTSYS) &&\n\t    (return_code >= -ERESTART_RESTARTBLOCK) &&\n\t    (return_code != -ENOIOCTLCMD))\n\t\tcontext->return_code = -EINTR;\n\telse\n\t\tcontext->return_code  = return_code;\n\n\tif (context->in_syscall && !context->dummy) {\n\t\taudit_filter_syscall(tsk, context, &audit_filter_list[AUDIT_FILTER_EXIT]);\n\t\taudit_filter_inodes(tsk, context);\n\t}\n\n\taudit_set_context(tsk, NULL);\n\treturn context;\n}"
  },
  {
    "function_name": "audit_filter_inodes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "823-837",
    "snippet": "void audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 836
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_inode_name",
          "args": [
            "tsk",
            "n",
            "ctx"
          ],
          "line": 833
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_inode_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "796-816",
          "snippet": "static int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 832
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 830
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "tsk"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "226-237",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nvoid audit_filter_inodes(struct task_struct *tsk, struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\n\tif (auditd_test_task(tsk))\n\t\treturn;\n\n\trcu_read_lock();\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif (audit_filter_inode_name(tsk, n, ctx))\n\t\t\tbreak;\n\t}\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "audit_filter_inode_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "796-816",
    "snippet": "static int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "ctx",
            "n",
            "&state",
            "false"
          ],
          "line": 809
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "444-720",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_in_mask",
          "args": [
            "&e->rule",
            "ctx->major"
          ],
          "line": 808
        },
        "resolved": true,
        "details": {
          "function_name": "audit_in_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "745-759",
          "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 804
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_hash_ino",
          "args": [
            "(u32)n->ino"
          ],
          "line": 799
        },
        "resolved": true,
        "details": {
          "function_name": "audit_hash_ino",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.h",
          "lines": "227-230",
          "snippet": "static inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}",
          "includes": [
            "#include <linux/tty.h>",
            "#include <uapi/linux/mqueue.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/audit.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [
            "#define AUDIT_INODE_BUCKETS\t32"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tty.h>\n#include <uapi/linux/mqueue.h>\n#include <linux/skbuff.h>\n#include <linux/audit.h>\n#include <linux/fs.h>\n\n#define AUDIT_INODE_BUCKETS\t32\n\nstatic inline int audit_hash_ino(u32 ino)\n{\n\treturn (ino & (AUDIT_INODE_BUCKETS-1));\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_filter_inode_name(struct task_struct *tsk,\n\t\t\t\t   struct audit_names *n,\n\t\t\t\t   struct audit_context *ctx) {\n\tint h = audit_hash_ino((u32)n->ino);\n\tstruct list_head *list = &audit_inode_hash[h];\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (list_empty(list))\n\t\treturn 0;\n\n\tlist_for_each_entry_rcu(e, list, list) {\n\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t    audit_filter_rules(tsk, &e->rule, ctx, n, &state, false)) {\n\t\t\tctx->current_state = state;\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_filter_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "766-790",
    "snippet": "static enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 788
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "ctx",
            "NULL",
            "&state",
            "false"
          ],
          "line": 780
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "444-720",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_in_mask",
          "args": [
            "&e->rule",
            "ctx->major"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "audit_in_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "745-759",
          "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "list",
            "list"
          ],
          "line": 778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "list"
          ],
          "line": 777
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 776
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "auditd_test_task",
          "args": [
            "tsk"
          ],
          "line": 773
        },
        "resolved": true,
        "details": {
          "function_name": "auditd_test_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "226-237",
          "snippet": "int auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic struct auditd_connection {\n\tstruct pid *pid;\n\tu32 portid;\n\tstruct net *net;\n\tstruct rcu_head rcu;\n} *auditd_conn = NULL;\n\nint auditd_test_task(struct task_struct *task)\n{\n\tint rc;\n\tstruct auditd_connection *ac;\n\n\trcu_read_lock();\n\tac = rcu_dereference(auditd_conn);\n\trc = (ac && ac->pid == task_tgid(task) ? 1 : 0);\n\trcu_read_unlock();\n\n\treturn rc;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_syscall(struct task_struct *tsk,\n\t\t\t\t\t     struct audit_context *ctx,\n\t\t\t\t\t     struct list_head *list)\n{\n\tstruct audit_entry *e;\n\tenum audit_state state;\n\n\tif (auditd_test_task(tsk))\n\t\treturn AUDIT_DISABLED;\n\n\trcu_read_lock();\n\tif (!list_empty(list)) {\n\t\tlist_for_each_entry_rcu(e, list, list) {\n\t\t\tif (audit_in_mask(&e->rule, ctx->major) &&\n\t\t\t    audit_filter_rules(tsk, &e->rule, ctx, NULL,\n\t\t\t\t\t       &state, false)) {\n\t\t\t\trcu_read_unlock();\n\t\t\t\tctx->current_state = state;\n\t\t\t\treturn state;\n\t\t\t}\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}"
  },
  {
    "function_name": "audit_in_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "745-759",
    "snippet": "static int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "AUDIT_BIT",
          "args": [
            "val"
          ],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "AUDIT_WORD",
          "args": [
            "val"
          ],
          "line": 752
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_in_mask(const struct audit_krule *rule, unsigned long val)\n{\n\tint word, bit;\n\n\tif (val > 0xffffffff)\n\t\treturn false;\n\n\tword = AUDIT_WORD(val);\n\tif (word >= AUDIT_BITMASK_SIZE)\n\t\treturn false;\n\n\tbit = AUDIT_BIT(val);\n\n\treturn rule->mask[word] & bit;\n}"
  },
  {
    "function_name": "audit_filter_task",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "726-743",
    "snippet": "static enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 741
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "e->rule.filterkey",
            "GFP_ATOMIC"
          ],
          "line": 736
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_filter_rules",
          "args": [
            "tsk",
            "&e->rule",
            "NULL",
            "NULL",
            "&state",
            "true"
          ],
          "line": 733
        },
        "resolved": true,
        "details": {
          "function_name": "audit_filter_rules",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "444-720",
          "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDITSC_FAILURE 2",
            "#define AUDITSC_SUCCESS 1"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_rcu",
          "args": [
            "e",
            "&audit_filter_list[AUDIT_FILTER_TASK]",
            "list"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 731
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic enum audit_state audit_filter_task(struct task_struct *tsk, char **key)\n{\n\tstruct audit_entry *e;\n\tenum audit_state   state;\n\n\trcu_read_lock();\n\tlist_for_each_entry_rcu(e, &audit_filter_list[AUDIT_FILTER_TASK], list) {\n\t\tif (audit_filter_rules(tsk, &e->rule, NULL, NULL,\n\t\t\t\t       &state, true)) {\n\t\t\tif (state == AUDIT_RECORD_CONTEXT)\n\t\t\t\t*key = kstrdup(e->rule.filterkey, GFP_ATOMIC);\n\t\t\trcu_read_unlock();\n\t\t\treturn state;\n\t\t}\n\t}\n\trcu_read_unlock();\n\treturn AUDIT_BUILD_CONTEXT;\n}"
  },
  {
    "function_name": "audit_filter_rules",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "444-720",
    "snippet": "static int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [
      "#define AUDITSC_FAILURE 2",
      "#define AUDITSC_SUCCESS 1"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "rule->filterkey",
            "GFP_ATOMIC"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "ctx->filterkey"
          ],
          "line": 706
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_field_compare",
          "args": [
            "tsk",
            "cred",
            "f",
            "ctx",
            "name"
          ],
          "line": 695
        },
        "resolved": true,
        "details": {
          "function_name": "audit_field_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "360-434",
          "snippet": "static int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_filetype",
          "args": [
            "ctx",
            "f->val"
          ],
          "line": 692
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_filetype",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "176-191",
          "snippet": "static int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_match_perm",
          "args": [
            "ctx",
            "f->val"
          ],
          "line": 689
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "133-174",
          "snippet": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_comparator",
          "args": [
            "ctx->argv[f->type-AUDIT_ARG0]",
            "f->op",
            "f->val"
          ],
          "line": 682
        },
        "resolved": true,
        "details": {
          "function_name": "audit_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1184-1207",
          "snippet": "int audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_comparator(u32 left, u32 op, u32 right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn (left == right);\n\tcase Audit_not_equal:\n\t\treturn (left != right);\n\tcase Audit_lt:\n\t\treturn (left < right);\n\tcase Audit_le:\n\t\treturn (left <= right);\n\tcase Audit_gt:\n\t\treturn (left > right);\n\tcase Audit_ge:\n\t\treturn (left >= right);\n\tcase Audit_bitmask:\n\t\treturn (left & right);\n\tcase Audit_bittest:\n\t\treturn ((left & right) == right);\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "ctx->ipc.osid",
            "f->type",
            "f->op",
            "f->lsm_rule",
            "ctx"
          ],
          "line": 671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "n->osid",
            "f->type",
            "f->op",
            "f->lsm_rule",
            "ctx"
          ],
          "line": 660
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 659
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "name->osid",
            "f->type",
            "f->op",
            "f->lsm_rule",
            "ctx"
          ],
          "line": 655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_audit_rule_match",
          "args": [
            "sid",
            "f->type",
            "f->op",
            "f->lsm_rule",
            "ctx"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_task_getsecid",
          "args": [
            "tsk",
            "&sid"
          ],
          "line": 636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_loginuid_set",
          "args": [
            "tsk"
          ],
          "line": 622
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "audit_get_loginuid(tsk)",
            "f->op",
            "f->uid"
          ],
          "line": 618
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1209-1230",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 618
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "match_tree_refs",
          "args": [
            "ctx",
            "rule->tree"
          ],
          "line": 615
        },
        "resolved": true,
        "details": {
          "function_name": "match_tree_refs",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "289-310",
          "snippet": "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_watch_compare",
          "args": [
            "rule->watch",
            "name->ino",
            "name->dev"
          ],
          "line": 611
        },
        "resolved": true,
        "details": {
          "function_name": "audit_watch_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "141-146",
          "snippet": "int audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_watch_compare(struct audit_watch *watch, unsigned long ino, dev_t dev)\n{\n\treturn (watch->ino != AUDIT_INO_UNSET) &&\n\t\t(watch->ino == ino) &&\n\t\t(watch->dev == dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "n->gid",
            "f->op",
            "f->gid"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1232-1253",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 601
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 589
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 577
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->rdev"
          ],
          "line": 566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "n->dev"
          ],
          "line": 565
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "name->rdev"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MINOR",
          "args": [
            "name->dev"
          ],
          "line": 560
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->rdev"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "n->dev"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "name->rdev"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MAJOR",
          "args": [
            "name->dev"
          ],
          "line": 545
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_sessionid",
          "args": [
            "tsk"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "groups_search",
          "args": [
            "cred->group_info",
            "f->gid"
          ],
          "line": 510
        },
        "resolved": true,
        "details": {
          "function_name": "groups_search",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/groups.c",
          "lines": "97-116",
          "snippet": "int groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/sort.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/cred.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/vmalloc.h>\n#include <linux/user_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/sort.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/cred.h>\n\nint groups_search(const struct group_info *group_info, kgid_t grp)\n{\n\tunsigned int left, right;\n\n\tif (!group_info)\n\t\treturn 0;\n\n\tleft = 0;\n\tright = group_info->ngroups;\n\twhile (left < right) {\n\t\tunsigned int mid = (left+right)/2;\n\t\tif (gid_gt(grp, group_info->gid[mid]))\n\t\t\tleft = mid + 1;\n\t\telse if (gid_lt(grp, group_info->gid[mid]))\n\t\t\tright = mid;\n\t\telse\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_exe_compare",
          "args": [
            "tsk",
            "rule->exe"
          ],
          "line": 477
        },
        "resolved": true,
        "details": {
          "function_name": "audit_exe_compare",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_watch.c",
          "lines": "556-569",
          "snippet": "int audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/refcount.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/refcount.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n#include <linux/file.h>\n\nint audit_exe_compare(struct task_struct *tsk, struct audit_fsnotify_mark *mark)\n{\n\tstruct file *exe_file;\n\tunsigned long ino;\n\tdev_t dev;\n\n\texe_file = get_task_exe_file(tsk);\n\tif (!exe_file)\n\t\treturn 0;\n\tino = file_inode(exe_file)->i_ino;\n\tdev = file_inode(exe_file)->i_sb->s_dev;\n\tfput(exe_file);\n\treturn audit_mark_compare(mark, ino, dev);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_ppid_nr",
          "args": [
            "tsk"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr",
          "args": [
            "tsk"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference_check",
          "args": [
            "tsk->cred",
            "tsk == current || task_creation"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDITSC_FAILURE 2\n#define AUDITSC_SUCCESS 1\n\nstatic int audit_filter_rules(struct task_struct *tsk,\n\t\t\t      struct audit_krule *rule,\n\t\t\t      struct audit_context *ctx,\n\t\t\t      struct audit_names *name,\n\t\t\t      enum audit_state *state,\n\t\t\t      bool task_creation)\n{\n\tconst struct cred *cred;\n\tint i, need_sid = 1;\n\tu32 sid;\n\tunsigned int sessionid;\n\n\tcred = rcu_dereference_check(tsk->cred, tsk == current || task_creation);\n\n\tfor (i = 0; i < rule->field_count; i++) {\n\t\tstruct audit_field *f = &rule->fields[i];\n\t\tstruct audit_names *n;\n\t\tint result = 0;\n\t\tpid_t pid;\n\n\t\tswitch (f->type) {\n\t\tcase AUDIT_PID:\n\t\t\tpid = task_tgid_nr(tsk);\n\t\t\tresult = audit_comparator(pid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PPID:\n\t\t\tif (ctx) {\n\t\t\t\tif (!ctx->ppid)\n\t\t\t\t\tctx->ppid = task_ppid_nr(tsk);\n\t\t\t\tresult = audit_comparator(ctx->ppid, f->op, f->val);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EXE:\n\t\t\tresult = audit_exe_compare(tsk, rule->exe);\n\t\t\tif (f->op == Audit_not_equal)\n\t\t\t\tresult = !result;\n\t\t\tbreak;\n\t\tcase AUDIT_UID:\n\t\t\tresult = audit_uid_comparator(cred->uid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_EUID:\n\t\t\tresult = audit_uid_comparator(cred->euid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_SUID:\n\t\t\tresult = audit_uid_comparator(cred->suid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSUID:\n\t\t\tresult = audit_uid_comparator(cred->fsuid, f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_GID:\n\t\t\tresult = audit_gid_comparator(cred->gid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_EGID:\n\t\t\tresult = audit_gid_comparator(cred->egid, f->op, f->gid);\n\t\t\tif (f->op == Audit_equal) {\n\t\t\t\tif (!result)\n\t\t\t\t\tresult = groups_search(cred->group_info, f->gid);\n\t\t\t} else if (f->op == Audit_not_equal) {\n\t\t\t\tif (result)\n\t\t\t\t\tresult = !groups_search(cred->group_info, f->gid);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_SGID:\n\t\t\tresult = audit_gid_comparator(cred->sgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_FSGID:\n\t\t\tresult = audit_gid_comparator(cred->fsgid, f->op, f->gid);\n\t\t\tbreak;\n\t\tcase AUDIT_SESSIONID:\n\t\t\tsessionid = audit_get_sessionid(tsk);\n\t\t\tresult = audit_comparator(sessionid, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_PERS:\n\t\t\tresult = audit_comparator(tsk->personality, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_ARCH:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->arch, f->op, f->val);\n\t\t\tbreak;\n\n\t\tcase AUDIT_EXIT:\n\t\t\tif (ctx && ctx->return_valid)\n\t\t\t\tresult = audit_comparator(ctx->return_code, f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUCCESS:\n\t\t\tif (ctx && ctx->return_valid) {\n\t\t\t\tif (f->val)\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_SUCCESS);\n\t\t\t\telse\n\t\t\t\t\tresult = audit_comparator(ctx->return_valid, f->op, AUDITSC_FAILURE);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMAJOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MAJOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MAJOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MAJOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MAJOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_DEVMINOR:\n\t\t\tif (name) {\n\t\t\t\tif (audit_comparator(MINOR(name->dev), f->op, f->val) ||\n\t\t\t\t    audit_comparator(MINOR(name->rdev), f->op, f->val))\n\t\t\t\t\t++result;\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(MINOR(n->dev), f->op, f->val) ||\n\t\t\t\t\t    audit_comparator(MINOR(n->rdev), f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_INODE:\n\t\t\tif (name)\n\t\t\t\tresult = audit_comparator(name->ino, f->op, f->val);\n\t\t\telse if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_comparator(n->ino, f->op, f->val)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_UID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_uid_comparator(name->uid, f->op, f->uid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_uid_comparator(n->uid, f->op, f->uid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_GID:\n\t\t\tif (name) {\n\t\t\t\tresult = audit_gid_comparator(name->gid, f->op, f->gid);\n\t\t\t} else if (ctx) {\n\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\tif (audit_gid_comparator(n->gid, f->op, f->gid)) {\n\t\t\t\t\t\t++result;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_WATCH:\n\t\t\tif (name)\n\t\t\t\tresult = audit_watch_compare(rule->watch, name->ino, name->dev);\n\t\t\tbreak;\n\t\tcase AUDIT_DIR:\n\t\t\tif (ctx)\n\t\t\t\tresult = match_tree_refs(ctx, rule->tree);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID:\n\t\t\tresult = audit_uid_comparator(audit_get_loginuid(tsk),\n\t\t\t\t\t\t      f->op, f->uid);\n\t\t\tbreak;\n\t\tcase AUDIT_LOGINUID_SET:\n\t\t\tresult = audit_comparator(audit_loginuid_set(tsk), f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_SUBJ_USER:\n\t\tcase AUDIT_SUBJ_ROLE:\n\t\tcase AUDIT_SUBJ_TYPE:\n\t\tcase AUDIT_SUBJ_SEN:\n\t\tcase AUDIT_SUBJ_CLR:\n\t\t\t/* NOTE: this may return negative values indicating\n\t\t\t   a temporary error.  We simply treat this as a\n\t\t\t   match for now to avoid losing information that\n\t\t\t   may be wanted.   An error message will also be\n\t\t\t   logged upon error */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\tif (need_sid) {\n\t\t\t\t\tsecurity_task_getsecid(tsk, &sid);\n\t\t\t\t\tneed_sid = 0;\n\t\t\t\t}\n\t\t\t\tresult = security_audit_rule_match(sid, f->type,\n\t\t\t\t                                  f->op,\n\t\t\t\t                                  f->lsm_rule,\n\t\t\t\t                                  ctx);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_OBJ_USER:\n\t\tcase AUDIT_OBJ_ROLE:\n\t\tcase AUDIT_OBJ_TYPE:\n\t\tcase AUDIT_OBJ_LEV_LOW:\n\t\tcase AUDIT_OBJ_LEV_HIGH:\n\t\t\t/* The above note for AUDIT_SUBJ_USER...AUDIT_SUBJ_CLR\n\t\t\t   also applies here */\n\t\t\tif (f->lsm_rule) {\n\t\t\t\t/* Find files that match */\n\t\t\t\tif (name) {\n\t\t\t\t\tresult = security_audit_rule_match(\n\t\t\t\t\t           name->osid, f->type, f->op,\n\t\t\t\t\t           f->lsm_rule, ctx);\n\t\t\t\t} else if (ctx) {\n\t\t\t\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\t\t\t\tif (security_audit_rule_match(n->osid, f->type,\n\t\t\t\t\t\t\t\t\t      f->op, f->lsm_rule,\n\t\t\t\t\t\t\t\t\t      ctx)) {\n\t\t\t\t\t\t\t++result;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/* Find ipc objects that match */\n\t\t\t\tif (!ctx || ctx->type != AUDIT_IPC)\n\t\t\t\t\tbreak;\n\t\t\t\tif (security_audit_rule_match(ctx->ipc.osid,\n\t\t\t\t\t\t\t      f->type, f->op,\n\t\t\t\t\t\t\t      f->lsm_rule, ctx))\n\t\t\t\t\t++result;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase AUDIT_ARG0:\n\t\tcase AUDIT_ARG1:\n\t\tcase AUDIT_ARG2:\n\t\tcase AUDIT_ARG3:\n\t\t\tif (ctx)\n\t\t\t\tresult = audit_comparator(ctx->argv[f->type-AUDIT_ARG0], f->op, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILTERKEY:\n\t\t\t/* ignore this field for filtering */\n\t\t\tresult = 1;\n\t\t\tbreak;\n\t\tcase AUDIT_PERM:\n\t\t\tresult = audit_match_perm(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FILETYPE:\n\t\t\tresult = audit_match_filetype(ctx, f->val);\n\t\t\tbreak;\n\t\tcase AUDIT_FIELD_COMPARE:\n\t\t\tresult = audit_field_compare(tsk, cred, f, ctx, name);\n\t\t\tbreak;\n\t\t}\n\t\tif (!result)\n\t\t\treturn 0;\n\t}\n\n\tif (ctx) {\n\t\tif (rule->prio <= ctx->prio)\n\t\t\treturn 0;\n\t\tif (rule->filterkey) {\n\t\t\tkfree(ctx->filterkey);\n\t\t\tctx->filterkey = kstrdup(rule->filterkey, GFP_ATOMIC);\n\t\t}\n\t\tctx->prio = rule->prio;\n\t}\n\tswitch (rule->action) {\n\tcase AUDIT_NEVER:\n\t\t*state = AUDIT_DISABLED;\n\t\tbreak;\n\tcase AUDIT_ALWAYS:\n\t\t*state = AUDIT_RECORD_CONTEXT;\n\t\tbreak;\n\t}\n\treturn 1;\n}"
  },
  {
    "function_name": "audit_field_compare",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "360-434",
    "snippet": "static int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN",
          "args": [
            "1",
            "\"Missing AUDIT_COMPARE define.  Report as a bug\\n\""
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "cred->sgid",
            "f->op",
            "cred->fsgid"
          ],
          "line": 428
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1232-1253",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "cred->suid",
            "f->op",
            "cred->fsuid"
          ],
          "line": 413
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1209-1230",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 401
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_compare_gid",
          "args": [
            "cred->fsgid",
            "name",
            "f",
            "ctx"
          ],
          "line": 385
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_gid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "336-358",
          "snippet": "static int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_compare_uid",
          "args": [
            "cred->fsuid",
            "name",
            "f",
            "ctx"
          ],
          "line": 383
        },
        "resolved": true,
        "details": {
          "function_name": "audit_compare_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "312-334",
          "snippet": "static int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_get_loginuid",
          "args": [
            "tsk"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_field_compare(struct task_struct *tsk,\n\t\t\t       const struct cred *cred,\n\t\t\t       struct audit_field *f,\n\t\t\t       struct audit_context *ctx,\n\t\t\t       struct audit_names *name)\n{\n\tswitch (f->val) {\n\t/* process to file object comparisons */\n\tcase AUDIT_COMPARE_UID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->uid, name, f, ctx);\n\tcase AUDIT_COMPARE_GID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->gid, name, f, ctx);\n\tcase AUDIT_COMPARE_EUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->euid, name, f, ctx);\n\tcase AUDIT_COMPARE_EGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->egid, name, f, ctx);\n\tcase AUDIT_COMPARE_AUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(audit_get_loginuid(tsk), name, f, ctx);\n\tcase AUDIT_COMPARE_SUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->suid, name, f, ctx);\n\tcase AUDIT_COMPARE_SGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->sgid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSUID_TO_OBJ_UID:\n\t\treturn audit_compare_uid(cred->fsuid, name, f, ctx);\n\tcase AUDIT_COMPARE_FSGID_TO_OBJ_GID:\n\t\treturn audit_compare_gid(cred->fsgid, name, f, ctx);\n\t/* uid comparisons */\n\tcase AUDIT_COMPARE_UID_TO_AUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op,\n\t\t\t\t\t    audit_get_loginuid(tsk));\n\tcase AUDIT_COMPARE_UID_TO_EUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->euid);\n\tcase AUDIT_COMPARE_UID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_UID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->uid, f->op, cred->fsuid);\n\t/* auid comparisons */\n\tcase AUDIT_COMPARE_AUID_TO_EUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->euid);\n\tcase AUDIT_COMPARE_AUID_TO_SUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->suid);\n\tcase AUDIT_COMPARE_AUID_TO_FSUID:\n\t\treturn audit_uid_comparator(audit_get_loginuid(tsk), f->op,\n\t\t\t\t\t    cred->fsuid);\n\t/* euid comparisons */\n\tcase AUDIT_COMPARE_EUID_TO_SUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->suid);\n\tcase AUDIT_COMPARE_EUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->euid, f->op, cred->fsuid);\n\t/* suid comparisons */\n\tcase AUDIT_COMPARE_SUID_TO_FSUID:\n\t\treturn audit_uid_comparator(cred->suid, f->op, cred->fsuid);\n\t/* gid comparisons */\n\tcase AUDIT_COMPARE_GID_TO_EGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->egid);\n\tcase AUDIT_COMPARE_GID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_GID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->gid, f->op, cred->fsgid);\n\t/* egid comparisons */\n\tcase AUDIT_COMPARE_EGID_TO_SGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->sgid);\n\tcase AUDIT_COMPARE_EGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->egid, f->op, cred->fsgid);\n\t/* sgid comparison */\n\tcase AUDIT_COMPARE_SGID_TO_FSGID:\n\t\treturn audit_gid_comparator(cred->sgid, f->op, cred->fsgid);\n\tdefault:\n\t\tWARN(1, \"Missing AUDIT_COMPARE define.  Report as a bug\\n\");\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_compare_gid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "336-358",
    "snippet": "static int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_gid_comparator",
          "args": [
            "gid",
            "f->op",
            "n->gid"
          ],
          "line": 352
        },
        "resolved": true,
        "details": {
          "function_name": "audit_gid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1232-1253",
          "snippet": "int audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_gid_comparator(kgid_t left, u32 op, kgid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn gid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !gid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn gid_lt(left, right);\n\tcase Audit_le:\n\t\treturn gid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn gid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn gid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_gid(kgid_t gid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_gid_comparator(gid, f->op, name->gid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_gid_comparator(gid, f->op, n->gid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_compare_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "312-334",
    "snippet": "static int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_uid_comparator",
          "args": [
            "uid",
            "f->op",
            "n->uid"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "audit_uid_comparator",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "1209-1230",
          "snippet": "int audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nint audit_uid_comparator(kuid_t left, u32 op, kuid_t right)\n{\n\tswitch (op) {\n\tcase Audit_equal:\n\t\treturn uid_eq(left, right);\n\tcase Audit_not_equal:\n\t\treturn !uid_eq(left, right);\n\tcase Audit_lt:\n\t\treturn uid_lt(left, right);\n\tcase Audit_le:\n\t\treturn uid_lte(left, right);\n\tcase Audit_gt:\n\t\treturn uid_gt(left, right);\n\tcase Audit_ge:\n\t\treturn uid_gte(left, right);\n\tcase Audit_bitmask:\n\tcase Audit_bittest:\n\tdefault:\n\t\tBUG();\n\t\treturn 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_compare_uid(kuid_t uid,\n\t\t\t     struct audit_names *name,\n\t\t\t     struct audit_field *f,\n\t\t\t     struct audit_context *ctx)\n{\n\tstruct audit_names *n;\n\tint rc;\n \n\tif (name) {\n\t\trc = audit_uid_comparator(uid, f->op, name->uid);\n\t\tif (rc)\n\t\t\treturn rc;\n\t}\n \n\tif (ctx) {\n\t\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\t\trc = audit_uid_comparator(uid, f->op, n->uid);\n\t\t\tif (rc)\n\t\t\t\treturn rc;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "match_tree_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "289-310",
    "snippet": "static int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_tree_match",
          "args": [
            "p->c[n]",
            "tree"
          ],
          "line": 305
        },
        "resolved": true,
        "details": {
          "function_name": "audit_tree_match",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "224-231",
          "snippet": "bool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nbool audit_tree_match(struct audit_chunk *chunk, struct audit_tree *tree)\n{\n\tint n;\n\tfor (n = 0; n < chunk->count; n++)\n\t\tif (chunk->owners[n].owner == tree)\n\t\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int match_tree_refs(struct audit_context *ctx, struct audit_tree *tree)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *p;\n\tint n;\n\tif (!tree)\n\t\treturn 0;\n\t/* full ones */\n\tfor (p = ctx->first_trees; p != ctx->trees; p = p->next) {\n\t\tfor (n = 0; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n\t/* partial */\n\tif (p) {\n\t\tfor (n = ctx->tree_count; n < 31; n++)\n\t\t\tif (audit_tree_match(p->c[n], tree))\n\t\t\t\treturn 1;\n\t}\n#endif\n\treturn 0;\n}"
  },
  {
    "function_name": "free_tree_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "280-287",
    "snippet": "static void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "p"
          ],
          "line": 285
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void free_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p, *q;\n\tfor (p = ctx->first_trees; p; p = q) {\n\t\tq = p->next;\n\t\tkfree(p);\n\t}\n}"
  },
  {
    "function_name": "unroll_tree_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "250-278",
    "snippet": "static void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "audit_put_chunk",
          "args": [
            "q->c[n]"
          ],
          "line": 272
        },
        "resolved": true,
        "details": {
          "function_name": "audit_put_chunk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "122-126",
          "snippet": "void audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nvoid audit_put_chunk(struct audit_chunk *chunk)\n{\n\tif (atomic_long_dec_and_test(&chunk->refs))\n\t\tfree_chunk(chunk);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void unroll_tree_refs(struct audit_context *ctx,\n\t\t      struct audit_tree_refs *p, int count)\n{\n#ifdef CONFIG_AUDIT_TREE\n\tstruct audit_tree_refs *q;\n\tint n;\n\tif (!p) {\n\t\t/* we started with empty chain */\n\t\tp = ctx->first_trees;\n\t\tcount = 31;\n\t\t/* if the very first allocation has failed, nothing to do */\n\t\tif (!p)\n\t\t\treturn;\n\t}\n\tn = count;\n\tfor (q = p; q != ctx->trees; q = q->next, n = 31) {\n\t\twhile (n--) {\n\t\t\taudit_put_chunk(q->c[n]);\n\t\t\tq->c[n] = NULL;\n\t\t}\n\t}\n\twhile (n-- > ctx->tree_count) {\n\t\taudit_put_chunk(q->c[n]);\n\t\tq->c[n] = NULL;\n\t}\n\tctx->trees = p;\n\tctx->tree_count = count;\n#endif\n}"
  },
  {
    "function_name": "grow_tree_refs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "233-247",
    "snippet": "static int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kzalloc",
          "args": [
            "sizeof(struct audit_tree_refs)",
            "GFP_KERNEL"
          ],
          "line": 236
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int grow_tree_refs(struct audit_context *ctx)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tctx->trees = kzalloc(sizeof(struct audit_tree_refs), GFP_KERNEL);\n\tif (!ctx->trees) {\n\t\tctx->trees = p;\n\t\treturn 0;\n\t}\n\tif (p)\n\t\tp->next = ctx->trees;\n\telse\n\t\tctx->first_trees = ctx->trees;\n\tctx->tree_count = 31;\n\treturn 1;\n}"
  },
  {
    "function_name": "put_tree_ref",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "212-231",
    "snippet": "static int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "left"
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int put_tree_ref(struct audit_context *ctx, struct audit_chunk *chunk)\n{\n\tstruct audit_tree_refs *p = ctx->trees;\n\tint left = ctx->tree_count;\n\tif (likely(left)) {\n\t\tp->c[--left] = chunk;\n\t\tctx->tree_count = left;\n\t\treturn 1;\n\t}\n\tif (!p)\n\t\treturn 0;\n\tp = p->next;\n\tif (p) {\n\t\tp->c[30] = chunk;\n\t\tctx->trees = p;\n\t\tctx->tree_count = 30;\n\t\treturn 1;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_set_auditable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "204-210",
    "snippet": "static void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic void audit_set_auditable(struct audit_context *ctx)\n{\n\tif (!ctx->prio) {\n\t\tctx->prio = 1;\n\t\tctx->current_state = AUDIT_RECORD_CONTEXT;\n\t}\n}"
  },
  {
    "function_name": "audit_match_filetype",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "176-191",
    "snippet": "static int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "n",
            "&ctx->names_list",
            "list"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 181
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_filetype(struct audit_context *ctx, int val)\n{\n\tstruct audit_names *n;\n\tumode_t mode = (umode_t)val;\n\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\n\tlist_for_each_entry(n, &ctx->names_list, list) {\n\t\tif ((n->ino != AUDIT_INO_UNSET) &&\n\t\t    ((n->mode & S_IFMT) == mode))\n\t\t\treturn 1;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "audit_match_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
    "lines": "133-174",
    "snippet": "static int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}",
    "includes": [
      "#include \"audit.h\"",
      "#include <uapi/linux/limits.h>",
      "#include <linux/fsnotify_backend.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/string.h>",
      "#include <linux/ctype.h>",
      "#include <linux/compat.h>",
      "#include <linux/fs_struct.h>",
      "#include <linux/capability.h>",
      "#include <asm/syscall.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/highmem.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/list.h>",
      "#include <linux/security.h>",
      "#include <asm/unistd.h>",
      "#include <linux/compiler.h>",
      "#include <linux/netlink.h>",
      "#include <linux/time.h>",
      "#include <linux/personality.h>",
      "#include <linux/audit.h>",
      "#include <linux/mqueue.h>",
      "#include <linux/socket.h>",
      "#include <linux/mount.h>",
      "#include <linux/slab.h>",
      "#include <linux/export.h>",
      "#include <linux/mm.h>",
      "#include <linux/namei.h>",
      "#include <linux/fs.h>",
      "#include <linux/atomic.h>",
      "#include <asm/types.h>",
      "#include <linux/init.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "ctx->argv[2]"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ACC_MODE",
          "args": [
            "ctx->argv[1]"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_match_class",
          "args": [
            "AUDIT_CLASS_CHATTR_32",
            "n"
          ],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "audit_match_class_bits",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditfilter.c",
          "lines": "209-219",
          "snippet": "static inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/sock.h>",
            "#include <net/net_namespace.h>",
            "#include <linux/security.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/netlink.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/mutex.h>",
            "#include <linux/kthread.h>",
            "#include <linux/audit.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static __u32 *classes[AUDIT_SYSCALL_CLASSES];"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/sock.h>\n#include <net/net_namespace.h>\n#include <linux/security.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/netlink.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/mutex.h>\n#include <linux/kthread.h>\n#include <linux/audit.h>\n#include <linux/kernel.h>\n\nstatic __u32 *classes[AUDIT_SYSCALL_CLASSES];\n\nstatic inline int audit_match_class_bits(int class, u32 *mask)\n{\n\tint i;\n\n\tif (classes[class]) {\n\t\tfor (i = 0; i < AUDIT_BITMASK_SIZE; i++)\n\t\t\tif (mask[i] & classes[class][i])\n\t\t\t\treturn 0;\n\t}\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "audit_classify_syscall",
          "args": [
            "ctx->arch",
            "n"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ctx"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\nstatic int audit_match_perm(struct audit_context *ctx, int mask)\n{\n\tunsigned n;\n\tif (unlikely(!ctx))\n\t\treturn 0;\n\tn = ctx->major;\n\n\tswitch (audit_classify_syscall(ctx->arch, n)) {\n\tcase 0:\t/* native */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 1: /* 32bit on biarch */\n\t\tif ((mask & AUDIT_PERM_WRITE) &&\n\t\t     audit_match_class(AUDIT_CLASS_WRITE_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_READ) &&\n\t\t     audit_match_class(AUDIT_CLASS_READ_32, n))\n\t\t\treturn 1;\n\t\tif ((mask & AUDIT_PERM_ATTR) &&\n\t\t     audit_match_class(AUDIT_CLASS_CHATTR_32, n))\n\t\t\treturn 1;\n\t\treturn 0;\n\tcase 2: /* open */\n\t\treturn mask & ACC_MODE(ctx->argv[1]);\n\tcase 3: /* openat */\n\t\treturn mask & ACC_MODE(ctx->argv[2]);\n\tcase 4: /* socketcall */\n\t\treturn ((mask & AUDIT_PERM_WRITE) && ctx->argv[0] == SYS_BIND);\n\tcase 5: /* execve */\n\t\treturn mask & AUDIT_PERM_EXEC;\n\tdefault:\n\t\treturn 0;\n\t}\n}"
  }
]