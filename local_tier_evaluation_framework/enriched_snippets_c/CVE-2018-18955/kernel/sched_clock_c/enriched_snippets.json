[
  {
    "function_name": "running_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "478-481",
    "snippet": "u64 __weak running_clock(void)\n{\n\treturn local_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_clock",
          "args": [],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nu64 __weak running_clock(void)\n{\n\treturn local_clock();\n}"
  },
  {
    "function_name": "sched_clock_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "460-466",
    "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 465
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
  },
  {
    "function_name": "sched_clock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "452-458",
    "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "generic_sched_clock_init",
          "args": [],
          "line": 456
        },
        "resolved": true,
        "details": {
          "function_name": "generic_sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/sched_clock.c",
          "lines": "240-258",
          "snippet": "void __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n}",
          "includes": [
            "#include <linux/bitops.h>",
            "#include <linux/seqlock.h>",
            "#include <linux/sched_clock.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/syscore_ops.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ktime.h>",
            "#include <linux/jiffies.h>",
            "#include <linux/init.h>",
            "#include <linux/clocksource.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct hrtimer sched_clock_timer;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bitops.h>\n#include <linux/seqlock.h>\n#include <linux/sched_clock.h>\n#include <linux/hrtimer.h>\n#include <linux/syscore_ops.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/moduleparam.h>\n#include <linux/kernel.h>\n#include <linux/ktime.h>\n#include <linux/jiffies.h>\n#include <linux/init.h>\n#include <linux/clocksource.h>\n\nstatic struct hrtimer sched_clock_timer;\n\nvoid __init generic_sched_clock_init(void)\n{\n\t/*\n\t * If no sched_clock() function has been provided at that point,\n\t * make it the final one one.\n\t */\n\tif (cd.actual_read_sched_clock == jiffy_sched_clock_read)\n\t\tsched_clock_register(jiffy_sched_clock_read, BITS_PER_LONG, HZ);\n\n\tupdate_sched_clock();\n\n\t/*\n\t * Start the timer to keep sched_clock() properly updated and\n\t * sets the initial epoch.\n\t */\n\thrtimer_init(&sched_clock_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);\n\tsched_clock_timer.function = sched_clock_poll;\n\thrtimer_start(&sched_clock_timer, cd.wrap_kt, HRTIMER_MODE_REL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "sched_clock_idle_wakeup_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "434-447",
    "snippet": "void sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_restore",
          "args": [
            "flags"
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_tick",
          "args": [],
          "line": 445
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_tick_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "405-420",
          "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_save",
          "args": [
            "flags"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "timekeeping_suspended"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 438
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_wakeup_event(void)\n{\n\tunsigned long flags;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (unlikely(timekeeping_suspended))\n\t\treturn;\n\n\tlocal_irq_save(flags);\n\tsched_clock_tick();\n\tlocal_irq_restore(flags);\n}"
  },
  {
    "function_name": "sched_clock_idle_sleep_event",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "425-428",
    "snippet": "void sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_cpu",
          "args": [
            "smp_processor_id()"
          ],
          "line": 427
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "460-466",
          "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn 0;\n\n\treturn sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_idle_sleep_event(void)\n{\n\tsched_clock_cpu(smp_processor_id());\n}"
  },
  {
    "function_name": "sched_clock_tick_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "405-420",
    "snippet": "void sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_clock_gtod_offset",
          "args": [],
          "line": 418
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_clock_gtod_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "198-204",
          "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 407
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nvoid sched_clock_tick_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\t/*\n\t * Called under watchdog_lock.\n\t *\n\t * The watchdog just found this TSC to (still) be stable, so now is a\n\t * good moment to update our __gtod_offset. Because once we find the\n\t * TSC to be unstable, any computation will be computing crap.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n}"
  },
  {
    "function_name": "sched_clock_tick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "388-403",
    "snippet": "void sched_clock_tick(void)\n{\n\tstruct sched_clock_data *scd;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn;\n\n\tlockdep_assert_irqs_disabled();\n\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tsched_clock_local(scd);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "scd"
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "264-295",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 401
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "112-116",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 400
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "97-100",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lockdep_assert_irqs_disabled",
          "args": [],
          "line": 398
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 392
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid sched_clock_tick(void)\n{\n\tstruct sched_clock_data *scd;\n\n\tif (sched_clock_stable())\n\t\treturn;\n\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn;\n\n\tlockdep_assert_irqs_disabled();\n\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tsched_clock_local(scd);\n}"
  },
  {
    "function_name": "sched_clock_cpu",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "364-385",
    "snippet": "u64 sched_clock_cpu(int cpu)\n{\n\tstruct sched_clock_data *scd;\n\tu64 clock;\n\n\tif (sched_clock_stable())\n\t\treturn sched_clock() + __sched_clock_offset;\n\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn sched_clock();\n\n\tpreempt_disable_notrace();\n\tscd = cpu_sdc(cpu);\n\n\tif (cpu != smp_processor_id())\n\t\tclock = sched_clock_remote(scd);\n\telse\n\t\tclock = sched_clock_local(scd);\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable_notrace",
          "args": [],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "scd"
          ],
          "line": 381
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "264-295",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sched_clock_remote",
          "args": [
            "scd"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_remote",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "297-357",
          "snippet": "static u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_processor_id",
          "args": [],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cpu_sdc",
          "args": [
            "cpu"
          ],
          "line": 376
        },
        "resolved": true,
        "details": {
          "function_name": "cpu_sdc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "102-105",
          "snippet": "static inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable_notrace",
          "args": [],
          "line": 375
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 373
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_branch_unlikely",
          "args": [
            "&sched_clock_running"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nu64 sched_clock_cpu(int cpu)\n{\n\tstruct sched_clock_data *scd;\n\tu64 clock;\n\n\tif (sched_clock_stable())\n\t\treturn sched_clock() + __sched_clock_offset;\n\n\tif (!static_branch_unlikely(&sched_clock_running))\n\t\treturn sched_clock();\n\n\tpreempt_disable_notrace();\n\tscd = cpu_sdc(cpu);\n\n\tif (cpu != smp_processor_id())\n\t\tclock = sched_clock_remote(scd);\n\telse\n\t\tclock = sched_clock_local(scd);\n\tpreempt_enable_notrace();\n\n\treturn clock;\n}"
  },
  {
    "function_name": "sched_clock_remote",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "297-357",
    "snippet": "static u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "ptr",
            "old_val",
            "val"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "(s64)(remote_clock - this_clock) < 0"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "",
          "args": [
            "remote_clock - this_clock"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_local",
          "args": [
            "my_scd"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_local",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "264-295",
          "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
        }
      },
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&scd->clock",
            "0",
            "0"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 299
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "97-100",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_remote(struct sched_clock_data *scd)\n{\n\tstruct sched_clock_data *my_scd = this_scd();\n\tu64 this_clock, remote_clock;\n\tu64 *ptr, old_val, val;\n\n#if BITS_PER_LONG != 64\nagain:\n\t/*\n\t * Careful here: The local and the remote clock values need to\n\t * be read out atomic as we need to compare the values and\n\t * then update either the local or the remote side. So the\n\t * cmpxchg64 below only protects one readout.\n\t *\n\t * We must reread via sched_clock_local() in the retry case on\n\t * 32-bit kernels as an NMI could use sched_clock_local() via the\n\t * tracer and hit between the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tthis_clock = sched_clock_local(my_scd);\n\t/*\n\t * We must enforce atomic readout on 32-bit, otherwise the\n\t * update on the remote CPU can hit inbetween the readout of\n\t * the low 32-bit and the high 32-bit portion.\n\t */\n\tremote_clock = cmpxchg64(&scd->clock, 0, 0);\n#else\n\t/*\n\t * On 64-bit kernels the read of [my]scd->clock is atomic versus the\n\t * update, so we can avoid the above 32-bit dance.\n\t */\n\tsched_clock_local(my_scd);\nagain:\n\tthis_clock = my_scd->clock;\n\tremote_clock = scd->clock;\n#endif\n\n\t/*\n\t * Use the opportunity that we have both locks\n\t * taken to couple the two clocks: we take the\n\t * larger time as the latest time for both\n\t * runqueues. (this creates monotonic movement)\n\t */\n\tif (likely((s64)(remote_clock - this_clock) < 0)) {\n\t\tptr = &scd->clock;\n\t\told_val = remote_clock;\n\t\tval = this_clock;\n\t} else {\n\t\t/*\n\t\t * Should be rare, but possible:\n\t\t */\n\t\tptr = &my_scd->clock;\n\t\told_val = this_clock;\n\t\tval = remote_clock;\n\t}\n\n\tif (cmpxchg64(ptr, old_val, val) != old_val)\n\t\tgoto again;\n\n\treturn val;\n}"
  },
  {
    "function_name": "sched_clock_local",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "264-295",
    "snippet": "static u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmpxchg64",
          "args": [
            "&scd->clock",
            "old_clock",
            "clock"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wrap_min",
          "args": [
            "clock",
            "max_clock"
          ],
          "line": 289
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_min",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "248-251",
          "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "wrap_max",
          "args": [
            "clock",
            "min_clock"
          ],
          "line": 288
        },
        "resolved": true,
        "details": {
          "function_name": "wrap_max",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "253-256",
          "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "delta < 0"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 270
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic u64 sched_clock_local(struct sched_clock_data *scd)\n{\n\tu64 now, clock, old_clock, min_clock, max_clock, gtod;\n\ts64 delta;\n\nagain:\n\tnow = sched_clock();\n\tdelta = now - scd->tick_raw;\n\tif (unlikely(delta < 0))\n\t\tdelta = 0;\n\n\told_clock = scd->clock;\n\n\t/*\n\t * scd->clock = clamp(scd->tick_gtod + delta,\n\t *\t\t      max(scd->tick_gtod, scd->clock),\n\t *\t\t      scd->tick_gtod + TICK_NSEC);\n\t */\n\n\tgtod = scd->tick_gtod + __gtod_offset;\n\tclock = gtod + delta;\n\tmin_clock = wrap_max(gtod, old_clock);\n\tmax_clock = wrap_max(old_clock, gtod + TICK_NSEC);\n\n\tclock = wrap_max(clock, min_clock);\n\tclock = wrap_min(clock, max_clock);\n\n\tif (cmpxchg64(&scd->clock, old_clock, clock) != old_clock)\n\t\tgoto again;\n\n\treturn clock;\n}"
  },
  {
    "function_name": "wrap_max",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "253-256",
    "snippet": "static inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "x - y"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_max(u64 x, u64 y)\n{\n\treturn (s64)(x - y) > 0 ? x : y;\n}"
  },
  {
    "function_name": "wrap_min",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "248-251",
    "snippet": "static inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "",
          "args": [
            "x - y"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline u64 wrap_min(u64 x, u64 y)\n{\n\treturn (s64)(x - y) < 0 ? x : y;\n}"
  },
  {
    "function_name": "sched_clock_init_late",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "225-241",
    "snippet": "static int __init sched_clock_init_late(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\t/*\n\t * Ensure that it is impossible to not do a static_key update.\n\t *\n\t * Either {set,clear}_sched_clock_stable() must see sched_clock_running\n\t * and do the update, or we must see their __sched_clock_stable_early\n\t * and do the update, or both.\n\t */\n\tsmp_mb(); /* matches {set,clear}_sched_clock_stable() */\n\n\tif (__sched_clock_stable_early)\n\t\t__set_sched_clock_stable();\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_sched_clock_stable",
          "args": [],
          "line": 238
        },
        "resolved": true,
        "details": {
          "function_name": "__set_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "118-140",
          "snippet": "static void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 235
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nstatic int __init sched_clock_init_late(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\t/*\n\t * Ensure that it is impossible to not do a static_key update.\n\t *\n\t * Either {set,clear}_sched_clock_stable() must see sched_clock_running\n\t * and do the update, or we must see their __sched_clock_stable_early\n\t * and do the update, or both.\n\t */\n\tsmp_mb(); /* matches {set,clear}_sched_clock_stable() */\n\n\tif (__sched_clock_stable_early)\n\t\t__set_sched_clock_stable();\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sched_clock_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "206-220",
    "snippet": "void __init sched_clock_init(void)\n{\n\t/*\n\t * Set __gtod_offset such that once we mark sched_clock_running,\n\t * sched_clock_tick() continues where sched_clock() left off.\n\t *\n\t * Even if TSC is buggered, we're still UP at this point so it\n\t * can't really be out of sync.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n\n\tstatic_branch_inc(&sched_clock_running);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_inc",
          "args": [
            "&sched_clock_running"
          ],
          "line": 219
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sched_clock_gtod_offset",
          "args": [],
          "line": 216
        },
        "resolved": true,
        "details": {
          "function_name": "__sched_clock_gtod_offset",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "198-204",
          "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 215
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\t/*\n\t * Set __gtod_offset such that once we mark sched_clock_running,\n\t * sched_clock_tick() continues where sched_clock() left off.\n\t *\n\t * Even if TSC is buggered, we're still UP at this point so it\n\t * can't really be out of sync.\n\t */\n\tlocal_irq_disable();\n\t__sched_clock_gtod_offset();\n\tlocal_irq_enable();\n\n\tstatic_branch_inc(&sched_clock_running);\n}"
  },
  {
    "function_name": "__sched_clock_gtod_offset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "198-204",
    "snippet": "static void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 202
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "112-116",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 200
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "97-100",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_gtod_offset(void)\n{\n\tstruct sched_clock_data *scd = this_scd();\n\n\t__scd_stamp(scd);\n\t__gtod_offset = (scd->tick_raw + __sched_clock_offset) - scd->tick_gtod;\n}"
  },
  {
    "function_name": "clear_sched_clock_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "188-196",
    "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__clear_sched_clock_stable",
          "args": [],
          "line": 195
        },
        "resolved": true,
        "details": {
          "function_name": "__clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "179-186",
          "snippet": "static void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_count",
          "args": [
            "&sched_clock_running.key"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_count",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "91-100",
          "snippet": "int static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nint static_key_count(struct static_key *key)\n{\n\t/*\n\t * -1 means the first static_key_slow_inc() is in progress.\n\t *  static_key_enabled() must return true, so return 1 here.\n\t */\n\tint n = atomic_read(&key->enabled);\n\n\treturn n >= 0 ? n : 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
  },
  {
    "function_name": "__clear_sched_clock_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "179-186",
    "snippet": "static void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "schedule_work",
          "args": [
            "&sched_clock_work"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tick_dep_set",
          "args": [
            "TICK_DEP_BIT_CLOCK_UNSTABLE"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sched_clock_stable",
          "args": [],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "clear_sched_clock_stable",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "188-196",
          "snippet": "void clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid clear_sched_clock_stable(void)\n{\n\t__sched_clock_stable_early = 0;\n\n\tsmp_mb(); /* matches sched_clock_init_late() */\n\n\tif (static_key_count(&sched_clock_running.key) == 2)\n\t\t__clear_sched_clock_stable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __clear_sched_clock_stable(void)\n{\n\tif (!sched_clock_stable())\n\t\treturn;\n\n\ttick_dep_set(TICK_DEP_BIT_CLOCK_UNSTABLE);\n\tschedule_work(&sched_clock_work);\n}"
  },
  {
    "function_name": "__sched_clock_work",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "153-175",
    "snippet": "static void __sched_clock_work(struct work_struct *work)\n{\n\tstruct sched_clock_data *scd;\n\tint cpu;\n\n\t/* take a current timestamp and set 'now' */\n\tpreempt_disable();\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tscd->clock = scd->tick_gtod + __gtod_offset;\n\tpreempt_enable();\n\n\t/* clone to all CPUs */\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(sched_clock_data, cpu) = *scd;\n\n\tprintk(KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\");\n\tprintk(KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_disable(&__sched_clock_stable);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_disable",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 174
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\"",
            "scd->tick_gtod",
            "__gtod_offset",
            "scd->tick_raw",
            "__sched_clock_offset"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\""
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "kauditd_printk_skb",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit.c",
          "lines": "540-547",
          "snippet": "static void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <net/netns/generic.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/security.h>",
            "#include <linux/skbuff.h>",
            "#include <net/netlink.h>",
            "#include <net/sock.h>",
            "#include <linux/audit.h>",
            "#include <linux/slab.h>",
            "#include <linux/pid.h>",
            "#include <linux/gfp.h>",
            "#include <linux/mutex.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/kernel.h>",
            "#include <linux/kthread.h>",
            "#include <linux/err.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/atomic.h>",
            "#include <linux/types.h>",
            "#include <linux/init.h>",
            "#include <linux/file.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <net/netns/generic.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/security.h>\n#include <linux/skbuff.h>\n#include <net/netlink.h>\n#include <net/sock.h>\n#include <linux/audit.h>\n#include <linux/slab.h>\n#include <linux/pid.h>\n#include <linux/gfp.h>\n#include <linux/mutex.h>\n#include <linux/rcupdate.h>\n#include <linux/spinlock.h>\n#include <linux/syscalls.h>\n#include <linux/kernel.h>\n#include <linux/kthread.h>\n#include <linux/err.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/atomic.h>\n#include <linux/types.h>\n#include <linux/init.h>\n#include <linux/file.h>\n\nstatic void kauditd_printk_skb(struct sk_buff *skb)\n{\n\tstruct nlmsghdr *nlh = nlmsg_hdr(skb);\n\tchar *data = nlmsg_data(nlh);\n\n\tif (nlh->nlmsg_type != AUDIT_EOE && printk_ratelimit())\n\t\tpr_notice(\"type=%d %s\\n\", nlh->nlmsg_type, data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__scd_stamp",
          "args": [
            "scd"
          ],
          "line": 161
        },
        "resolved": true,
        "details": {
          "function_name": "__scd_stamp",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "112-116",
          "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 160
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "97-100",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 159
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __sched_clock_work(struct work_struct *work)\n{\n\tstruct sched_clock_data *scd;\n\tint cpu;\n\n\t/* take a current timestamp and set 'now' */\n\tpreempt_disable();\n\tscd = this_scd();\n\t__scd_stamp(scd);\n\tscd->clock = scd->tick_gtod + __gtod_offset;\n\tpreempt_enable();\n\n\t/* clone to all CPUs */\n\tfor_each_possible_cpu(cpu)\n\t\tper_cpu(sched_clock_data, cpu) = *scd;\n\n\tprintk(KERN_WARNING \"TSC found unstable after boot, most likely due to broken BIOS. Use 'tsc=unstable'.\\n\");\n\tprintk(KERN_INFO \"sched_clock: Marking unstable (%lld, %lld)<-(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_disable(&__sched_clock_stable);\n}"
  },
  {
    "function_name": "__set_sched_clock_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "118-140",
    "snippet": "static void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tick_dep_clear",
          "args": [
            "TICK_DEP_BIT_CLOCK_UNSTABLE"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_branch_enable",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\"",
            "scd->tick_gtod",
            "__gtod_offset",
            "scd->tick_raw",
            "__sched_clock_offset"
          ],
          "line": 134
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_scd",
          "args": [],
          "line": 127
        },
        "resolved": true,
        "details": {
          "function_name": "this_scd",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "97-100",
          "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
        }
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __set_sched_clock_stable(void)\n{\n\tstruct sched_clock_data *scd;\n\n\t/*\n\t * Since we're still unstable and the tick is already running, we have\n\t * to disable IRQs in order to get a consistent scd->tick* reading.\n\t */\n\tlocal_irq_disable();\n\tscd = this_scd();\n\t/*\n\t * Attempt to make the (initial) unstable->stable transition continuous.\n\t */\n\t__sched_clock_offset = (scd->tick_gtod + __gtod_offset) - (scd->tick_raw);\n\tlocal_irq_enable();\n\n\tprintk(KERN_INFO \"sched_clock: Marking stable (%lld, %lld)->(%lld, %lld)\\n\",\n\t\t\tscd->tick_gtod, __gtod_offset,\n\t\t\tscd->tick_raw,  __sched_clock_offset);\n\n\tstatic_branch_enable(&__sched_clock_stable);\n\ttick_dep_clear(TICK_DEP_BIT_CLOCK_UNSTABLE);\n}"
  },
  {
    "function_name": "__scd_stamp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "112-116",
    "snippet": "static void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sched_clock",
          "args": [],
          "line": 115
        },
        "resolved": true,
        "details": {
          "function_name": "sched_clock_init",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
          "lines": "452-458",
          "snippet": "void __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}",
          "includes": [
            "#include <linux/sched_clock.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_STATIC_KEY_FALSE(sched_clock_running);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic DEFINE_STATIC_KEY_FALSE(sched_clock_running);\n\nvoid __init sched_clock_init(void)\n{\n\tstatic_branch_inc(&sched_clock_running);\n\tlocal_irq_disable();\n\tgeneric_sched_clock_init();\n\tlocal_irq_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ktime_get_ns",
          "args": [],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic void __scd_stamp(struct sched_clock_data *scd)\n{\n\tscd->tick_gtod = ktime_get_ns();\n\tscd->tick_raw = sched_clock();\n}"
  },
  {
    "function_name": "sched_clock_stable",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "107-110",
    "snippet": "int sched_clock_stable(void)\n{\n\treturn static_branch_likely(&__sched_clock_stable);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "static_branch_likely",
          "args": [
            "&__sched_clock_stable"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nint sched_clock_stable(void)\n{\n\treturn static_branch_likely(&__sched_clock_stable);\n}"
  },
  {
    "function_name": "cpu_sdc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "102-105",
    "snippet": "static inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "per_cpu",
          "args": [
            "sched_clock_data",
            "cpu"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_per_cpu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_main.c",
          "lines": "2575-2640",
          "snippet": "static int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/kdebug.h>",
            "#include <linux/cpu.h>",
            "#include <linux/sysctl.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/time.h>",
            "#include <linux/nmi.h>",
            "#include <linux/delay.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/mm.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/atomic.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/utsname.h>",
            "#include <linux/smp.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/loadavg.h>",
            "#include <linux/sched.h>",
            "#include <linux/reboot.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/kernel.h>",
            "#include <linux/string.h>",
            "#include <linux/types.h>",
            "#include <linux/ctype.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/uaccess.h>\n#include <linux/proc_fs.h>\n#include <linux/kdebug.h>\n#include <linux/cpu.h>\n#include <linux/sysctl.h>\n#include <linux/ptrace.h>\n#include <linux/time.h>\n#include <linux/nmi.h>\n#include <linux/delay.h>\n#include <linux/interrupt.h>\n#include <linux/notifier.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/mm.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/atomic.h>\n#include <linux/vmalloc.h>\n#include <linux/utsname.h>\n#include <linux/smp.h>\n#include <linux/sysrq.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/loadavg.h>\n#include <linux/sched.h>\n#include <linux/reboot.h>\n#include <linux/kmsg_dump.h>\n#include <linux/kernel.h>\n#include <linux/string.h>\n#include <linux/types.h>\n#include <linux/ctype.h>\n\nstatic int kdb_per_cpu(int argc, const char **argv)\n{\n\tchar fmtstr[64];\n\tint cpu, diag, nextarg = 1;\n\tunsigned long addr, symaddr, val, bytesperword = 0, whichcpu = ~0UL;\n\n\tif (argc < 1 || argc > 3)\n\t\treturn KDB_ARGCOUNT;\n\n\tdiag = kdbgetaddrarg(argc, argv, &nextarg, &symaddr, NULL, NULL);\n\tif (diag)\n\t\treturn diag;\n\n\tif (argc >= 2) {\n\t\tdiag = kdbgetularg(argv[2], &bytesperword);\n\t\tif (diag)\n\t\t\treturn diag;\n\t}\n\tif (!bytesperword)\n\t\tbytesperword = KDB_WORD_SIZE;\n\telse if (bytesperword > KDB_WORD_SIZE)\n\t\treturn KDB_BADWIDTH;\n\tsprintf(fmtstr, \"%%0%dlx \", (int)(2*bytesperword));\n\tif (argc >= 3) {\n\t\tdiag = kdbgetularg(argv[3], &whichcpu);\n\t\tif (diag)\n\t\t\treturn diag;\n\t\tif (!cpu_online(whichcpu)) {\n\t\t\tkdb_printf(\"cpu %ld is not online\\n\", whichcpu);\n\t\t\treturn KDB_BADCPUNUM;\n\t\t}\n\t}\n\n\t/* Most architectures use __per_cpu_offset[cpu], some use\n\t * __per_cpu_offset(cpu), smp has no __per_cpu_offset.\n\t */\n#ifdef\t__per_cpu_offset\n#define KDB_PCU(cpu) __per_cpu_offset(cpu)\n#else\n#ifdef\tCONFIG_SMP\n#define KDB_PCU(cpu) __per_cpu_offset[cpu]\n#else\n#define KDB_PCU(cpu) 0\n#endif\n#endif\n\tfor_each_online_cpu(cpu) {\n\t\tif (KDB_FLAG(CMD_INTERRUPT))\n\t\t\treturn 0;\n\n\t\tif (whichcpu != ~0UL && whichcpu != cpu)\n\t\t\tcontinue;\n\t\taddr = symaddr + KDB_PCU(cpu);\n\t\tdiag = kdb_getword(&val, addr, bytesperword);\n\t\tif (diag) {\n\t\t\tkdb_printf(\"%5d \" kdb_bfd_vma_fmt0 \" - unable to \"\n\t\t\t\t   \"read, diag=%d\\n\", cpu, addr, diag);\n\t\t\tcontinue;\n\t\t}\n\t\tkdb_printf(\"%5d \", cpu);\n\t\tkdb_md_line(fmtstr, addr,\n\t\t\tbytesperword == KDB_WORD_SIZE,\n\t\t\t1, bytesperword, 1, 1, 0);\n\t}\n#undef KDB_PCU\n\treturn 0;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *cpu_sdc(int cpu)\n{\n\treturn &per_cpu(sched_clock_data, cpu);\n}"
  },
  {
    "function_name": "this_scd",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "97-100",
    "snippet": "static inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "this_cpu_ptr",
          "args": [
            "&sched_clock_data"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nstatic inline struct sched_clock_data *this_scd(void)\n{\n\treturn this_cpu_ptr(&sched_clock_data);\n}"
  },
  {
    "function_name": "sched_clock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/clock.c",
    "lines": "63-67",
    "snippet": "unsigned long long __weak sched_clock(void)\n{\n\treturn (unsigned long long)(jiffies - INITIAL_JIFFIES)\n\t\t\t\t\t* (NSEC_PER_SEC / HZ);\n}",
    "includes": [
      "#include <linux/sched_clock.h>",
      "#include \"sched.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/sched_clock.h>\n#include \"sched.h\"\n\nunsigned long long __weak sched_clock(void)\n{\n\treturn (unsigned long long)(jiffies - INITIAL_JIFFIES)\n\t\t\t\t\t* (NSEC_PER_SEC / HZ);\n}"
  }
]