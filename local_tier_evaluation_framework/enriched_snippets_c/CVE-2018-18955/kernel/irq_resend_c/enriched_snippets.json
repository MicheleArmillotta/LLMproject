[
  {
    "function_name": "check_irq_resend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/resend.c",
    "lines": "55-100",
    "snippet": "void check_irq_resend(struct irq_desc *desc)\n{\n\t/*\n\t * We do not resend level type interrupts. Level type\n\t * interrupts are resent by hardware when they are still\n\t * active. Clear the pending bit so suspend/resume does not\n\t * get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn;\n\t}\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn;\n\tif (desc->istate & IRQS_PENDING) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\tdesc->istate |= IRQS_REPLAY;\n\n\t\tif (!desc->irq_data.chip->irq_retrigger ||\n\t\t    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {\n#ifdef CONFIG_HARDIRQS_SW_RESEND\n\t\t\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t\t\t/*\n\t\t\t * If the interrupt is running in the thread\n\t\t\t * context of the parent irq we need to be\n\t\t\t * careful, because we cannot trigger it\n\t\t\t * directly.\n\t\t\t */\n\t\t\tif (irq_settings_is_nested_thread(desc)) {\n\t\t\t\t/*\n\t\t\t\t * If the parent_irq is valid, we\n\t\t\t\t * retrigger the parent, otherwise we\n\t\t\t\t * do nothing.\n\t\t\t\t */\n\t\t\t\tif (!desc->parent_irq)\n\t\t\t\t\treturn;\n\t\t\t\tirq = desc->parent_irq;\n\t\t\t}\n\t\t\t/* Set it pending and activate the softirq: */\n\t\t\tset_bit(irq, irqs_resend);\n\t\t\ttasklet_schedule(&resend_tasklet);\n#endif\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tasklet_schedule",
          "args": [
            "&resend_tasklet"
          ],
          "line": 96
        },
        "resolved": true,
        "details": {
          "function_name": "__tasklet_schedule",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/softirq.c",
          "lines": "487-491",
          "snippet": "void __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}",
          "includes": [
            "#include <trace/events/irq.h>",
            "#include <linux/irq.h>",
            "#include <linux/tick.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/smp.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/cpu.h>",
            "#include <linux/percpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/irq.h>\n#include <linux/irq.h>\n#include <linux/tick.h>\n#include <linux/smpboot.h>\n#include <linux/smp.h>\n#include <linux/ftrace.h>\n#include <linux/rcupdate.h>\n#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/cpu.h>\n#include <linux/percpu.h>\n#include <linux/notifier.h>\n#include <linux/mm.h>\n#include <linux/init.h>\n#include <linux/interrupt.h>\n#include <linux/kernel_stat.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);\n\nvoid __tasklet_schedule(struct tasklet_struct *t)\n{\n\t__tasklet_schedule_common(t, &tasklet_vec,\n\t\t\t\t  TASKLET_SOFTIRQ);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_bit",
          "args": [
            "irq",
            "irqs_resend"
          ],
          "line": 95
        },
        "resolved": true,
        "details": {
          "function_name": "mem_bm_set_bit_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "779-790",
          "snippet": "static int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic int mem_bm_set_bit_check(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tif (!error)\n\t\tset_bit(bit, addr);\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_settings_is_nested_thread",
          "args": [
            "desc"
          ],
          "line": 84
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_nested_thread",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/settings.h",
          "lines": "151-154",
          "snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_nested_thread(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_NESTED_THREAD;\n}"
        }
      },
      {
        "call_info": {
          "callee": "irq_desc_get_irq",
          "args": [
            "desc"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->irq_data.chip->irq_retrigger",
          "args": [
            "&desc->irq_data"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_settings_is_level",
          "args": [
            "desc"
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "irq_settings_is_level",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/settings.h",
          "lines": "81-84",
          "snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline bool irq_settings_is_level(struct irq_desc *desc)\n{\n\treturn desc->status_use_accessors & _IRQ_LEVEL;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nvoid check_irq_resend(struct irq_desc *desc)\n{\n\t/*\n\t * We do not resend level type interrupts. Level type\n\t * interrupts are resent by hardware when they are still\n\t * active. Clear the pending bit so suspend/resume does not\n\t * get confused.\n\t */\n\tif (irq_settings_is_level(desc)) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\treturn;\n\t}\n\tif (desc->istate & IRQS_REPLAY)\n\t\treturn;\n\tif (desc->istate & IRQS_PENDING) {\n\t\tdesc->istate &= ~IRQS_PENDING;\n\t\tdesc->istate |= IRQS_REPLAY;\n\n\t\tif (!desc->irq_data.chip->irq_retrigger ||\n\t\t    !desc->irq_data.chip->irq_retrigger(&desc->irq_data)) {\n#ifdef CONFIG_HARDIRQS_SW_RESEND\n\t\t\tunsigned int irq = irq_desc_get_irq(desc);\n\n\t\t\t/*\n\t\t\t * If the interrupt is running in the thread\n\t\t\t * context of the parent irq we need to be\n\t\t\t * careful, because we cannot trigger it\n\t\t\t * directly.\n\t\t\t */\n\t\t\tif (irq_settings_is_nested_thread(desc)) {\n\t\t\t\t/*\n\t\t\t\t * If the parent_irq is valid, we\n\t\t\t\t * retrigger the parent, otherwise we\n\t\t\t\t * do nothing.\n\t\t\t\t */\n\t\t\t\tif (!desc->parent_irq)\n\t\t\t\t\treturn;\n\t\t\t\tirq = desc->parent_irq;\n\t\t\t}\n\t\t\t/* Set it pending and activate the softirq: */\n\t\t\tset_bit(irq, irqs_resend);\n\t\t\ttasklet_schedule(&resend_tasklet);\n#endif\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "resend_irqs",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/resend.c",
    "lines": "30-43",
    "snippet": "static void resend_irqs(unsigned long arg)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\twhile (!bitmap_empty(irqs_resend, nr_irqs)) {\n\t\tirq = find_first_bit(irqs_resend, nr_irqs);\n\t\tclear_bit(irq, irqs_resend);\n\t\tdesc = irq_to_desc(irq);\n\t\tlocal_irq_disable();\n\t\tdesc->handle_irq(desc);\n\t\tlocal_irq_enable();\n\t}\n}",
    "includes": [
      "#include \"internals.h\"",
      "#include <linux/interrupt.h>",
      "#include <linux/random.h>",
      "#include <linux/module.h>",
      "#include <linux/irq.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "local_irq_enable",
          "args": [],
          "line": 41
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "desc->handle_irq",
          "args": [
            "desc"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "local_irq_disable",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irq_to_desc",
          "args": [
            "irq"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "irq_to_desc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/irq/irqdesc.c",
          "lines": "561-564",
          "snippet": "struct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}",
          "includes": [
            "#include \"internals.h\"",
            "#include <linux/sysfs.h>",
            "#include <linux/irqdomain.h>",
            "#include <linux/bitmap.h>",
            "#include <linux/radix-tree.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>",
            "#include <linux/irq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"internals.h\"\n#include <linux/sysfs.h>\n#include <linux/irqdomain.h>\n#include <linux/bitmap.h>\n#include <linux/radix-tree.h>\n#include <linux/kernel_stat.h>\n#include <linux/interrupt.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n#include <linux/irq.h>\n\nstruct irq_desc *irq_to_desc(unsigned int irq)\n{\n\treturn (irq < NR_IRQS) ? irq_desc + irq : NULL;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_bit",
          "args": [
            "irq",
            "irqs_resend"
          ],
          "line": 37
        },
        "resolved": true,
        "details": {
          "function_name": "memory_bm_clear_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/power/snapshot.c",
          "lines": "792-801",
          "snippet": "static void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}",
          "includes": [
            "#include \"power.h\"",
            "#include <asm/io.h>",
            "#include <asm/tlbflush.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/set_memory.h>",
            "#include <linux/ktime.h>",
            "#include <linux/compiler.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/highmem.h>",
            "#include <linux/console.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/nmi.h>",
            "#include <linux/memblock.h>",
            "#include <linux/init.h>",
            "#include <linux/device.h>",
            "#include <linux/pm.h>",
            "#include <linux/kernel.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/bitops.h>",
            "#include <linux/delay.h>",
            "#include <linux/suspend.h>",
            "#include <linux/mm.h>",
            "#include <linux/module.h>",
            "#include <linux/version.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"power.h\"\n#include <asm/io.h>\n#include <asm/tlbflush.h>\n#include <asm/pgtable.h>\n#include <asm/mmu_context.h>\n#include <linux/uaccess.h>\n#include <linux/set_memory.h>\n#include <linux/ktime.h>\n#include <linux/compiler.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/highmem.h>\n#include <linux/console.h>\n#include <linux/syscalls.h>\n#include <linux/nmi.h>\n#include <linux/memblock.h>\n#include <linux/init.h>\n#include <linux/device.h>\n#include <linux/pm.h>\n#include <linux/kernel.h>\n#include <linux/spinlock.h>\n#include <linux/bitops.h>\n#include <linux/delay.h>\n#include <linux/suspend.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/version.h>\n\nstatic void memory_bm_clear_bit(struct memory_bitmap *bm, unsigned long pfn)\n{\n\tvoid *addr;\n\tunsigned int bit;\n\tint error;\n\n\terror = memory_bm_find_bit(bm, pfn, &addr, &bit);\n\tBUG_ON(error);\n\tclear_bit(bit, addr);\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_first_bit",
          "args": [
            "irqs_resend",
            "nr_irqs"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmap_empty",
          "args": [
            "irqs_resend",
            "nr_irqs"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"internals.h\"\n#include <linux/interrupt.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/irq.h>\n\nstatic void resend_irqs(unsigned long arg)\n{\n\tstruct irq_desc *desc;\n\tint irq;\n\n\twhile (!bitmap_empty(irqs_resend, nr_irqs)) {\n\t\tirq = find_first_bit(irqs_resend, nr_irqs);\n\t\tclear_bit(irq, irqs_resend);\n\t\tdesc = irq_to_desc(irq);\n\t\tlocal_irq_disable();\n\t\tdesc->handle_irq(desc);\n\t\tlocal_irq_enable();\n\t}\n}"
  }
]