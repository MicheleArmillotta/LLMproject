[
  {
    "function_name": "__request_module",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kmod.c",
    "lines": "125-177",
    "snippet": "int __request_module(bool wait, const char *fmt, ...)\n{\n\tva_list args;\n\tchar module_name[MODULE_NAME_LEN];\n\tint ret;\n\n\t/*\n\t * We don't allow synchronous module loading from async.  Module\n\t * init may invoke async_synchronize_full() which will end up\n\t * waiting for this task which already is waiting for the module\n\t * loading to complete, leading to a deadlock.\n\t */\n\tWARN_ON_ONCE(wait && current_is_async());\n\n\tif (!modprobe_path[0])\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);\n\tva_end(args);\n\tif (ret >= MODULE_NAME_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tret = security_kernel_module_request(module_name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_dec_if_positive(&kmod_concurrent_max) < 0) {\n\t\tpr_warn_ratelimited(\"request_module: kmod_concurrent_max (%u) close to 0 (max_modprobes: %u), for module %s, throttling...\",\n\t\t\t\t    atomic_read(&kmod_concurrent_max),\n\t\t\t\t    MAX_KMOD_CONCURRENT, module_name);\n\t\tret = wait_event_killable_timeout(kmod_wq,\n\t\t\t\t\t\t  atomic_dec_if_positive(&kmod_concurrent_max) >= 0,\n\t\t\t\t\t\t  MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);\n\t\tif (!ret) {\n\t\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",\n\t\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);\n\t\t\treturn -ETIME;\n\t\t} else if (ret == -ERESTARTSYS) {\n\t\t\tpr_warn_ratelimited(\"request_module: sigkill sent for modprobe %s, giving up\", module_name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttrace_module_request(module_name, wait, _RET_IP_);\n\n\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);\n\n\tatomic_inc(&kmod_concurrent_max);\n\twake_up(&kmod_wq);\n\n\treturn ret;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [
      "#define MAX_KMOD_ALL_BUSY_TIMEOUT 5",
      "#define MAX_KMOD_CONCURRENT 50"
    ],
    "globals_used": [
      "static atomic_t kmod_concurrent_max = ATOMIC_INIT(MAX_KMOD_CONCURRENT);",
      "static DECLARE_WAIT_QUEUE_HEAD(kmod_wq);",
      "char modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up",
          "args": [
            "&kmod_wq"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_worker",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "833-839",
          "snippet": "static void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void wake_up_worker(struct worker_pool *pool)\n{\n\tstruct worker *worker = first_idle_worker(pool);\n\n\tif (likely(worker))\n\t\twake_up_process(worker->task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&kmod_concurrent_max"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "call_modprobe",
          "args": [
            "module_name",
            "wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC"
          ],
          "line": 171
        },
        "resolved": true,
        "details": {
          "function_name": "call_modprobe",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kmod.c",
          "lines": "70-107",
          "snippet": "static int call_modprobe(char *module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t/* check free_modprobe_argv() */\n\targv[4] = NULL;\n\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\treturn -ENOMEM;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "char modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nchar modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";\n\nstatic int call_modprobe(char *module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t/* check free_modprobe_argv() */\n\targv[4] = NULL;\n\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\treturn -ENOMEM;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_request",
          "args": [
            "module_name",
            "wait",
            "_RET_IP_"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"request_module: sigkill sent for modprobe %s, giving up\"",
            "module_name"
          ],
          "line": 164
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\"",
            "module_name",
            "MAX_KMOD_CONCURRENT",
            "MAX_KMOD_ALL_BUSY_TIMEOUT"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wait_event_killable_timeout",
          "args": [
            "kmod_wq",
            "atomic_dec_if_positive(&kmod_concurrent_max) >= 0",
            "MAX_KMOD_ALL_BUSY_TIMEOUT * HZ"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&kmod_concurrent_max"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_warn_ratelimited",
          "args": [
            "\"request_module: kmod_concurrent_max (%u) close to 0 (max_modprobes: %u), for module %s, throttling...\"",
            "atomic_read(&kmod_concurrent_max)",
            "MAX_KMOD_CONCURRENT",
            "module_name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&kmod_concurrent_max"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_dec_if_positive",
          "args": [
            "&kmod_concurrent_max"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "security_kernel_module_request",
          "args": [
            "module_name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_end",
          "args": [
            "args"
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "vsnprintf",
          "args": [
            "module_name",
            "MODULE_NAME_LEN",
            "fmt",
            "args"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "va_start",
          "args": [
            "args",
            "fmt"
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "wait && current_is_async()"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_is_async",
          "args": [],
          "line": 137
        },
        "resolved": true,
        "details": {
          "function_name": "current_is_async",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/async.c",
          "lines": "327-332",
          "snippet": "bool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}",
          "includes": [
            "#include \"workqueue_internal.h\"",
            "#include <linux/workqueue.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/wait.h>",
            "#include <linux/export.h>",
            "#include <linux/ktime.h>",
            "#include <linux/atomic.h>",
            "#include <linux/async.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"workqueue_internal.h\"\n#include <linux/workqueue.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/wait.h>\n#include <linux/export.h>\n#include <linux/ktime.h>\n#include <linux/atomic.h>\n#include <linux/async.h>\n\nbool current_is_async(void)\n{\n\tstruct worker *worker = current_wq_worker();\n\n\treturn worker && worker->current_func == async_run_entry_fn;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\n#define MAX_KMOD_ALL_BUSY_TIMEOUT 5\n#define MAX_KMOD_CONCURRENT 50\n\nstatic atomic_t kmod_concurrent_max = ATOMIC_INIT(MAX_KMOD_CONCURRENT);\nstatic DECLARE_WAIT_QUEUE_HEAD(kmod_wq);\nchar modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";\n\nint __request_module(bool wait, const char *fmt, ...)\n{\n\tva_list args;\n\tchar module_name[MODULE_NAME_LEN];\n\tint ret;\n\n\t/*\n\t * We don't allow synchronous module loading from async.  Module\n\t * init may invoke async_synchronize_full() which will end up\n\t * waiting for this task which already is waiting for the module\n\t * loading to complete, leading to a deadlock.\n\t */\n\tWARN_ON_ONCE(wait && current_is_async());\n\n\tif (!modprobe_path[0])\n\t\treturn 0;\n\n\tva_start(args, fmt);\n\tret = vsnprintf(module_name, MODULE_NAME_LEN, fmt, args);\n\tva_end(args);\n\tif (ret >= MODULE_NAME_LEN)\n\t\treturn -ENAMETOOLONG;\n\n\tret = security_kernel_module_request(module_name);\n\tif (ret)\n\t\treturn ret;\n\n\tif (atomic_dec_if_positive(&kmod_concurrent_max) < 0) {\n\t\tpr_warn_ratelimited(\"request_module: kmod_concurrent_max (%u) close to 0 (max_modprobes: %u), for module %s, throttling...\",\n\t\t\t\t    atomic_read(&kmod_concurrent_max),\n\t\t\t\t    MAX_KMOD_CONCURRENT, module_name);\n\t\tret = wait_event_killable_timeout(kmod_wq,\n\t\t\t\t\t\t  atomic_dec_if_positive(&kmod_concurrent_max) >= 0,\n\t\t\t\t\t\t  MAX_KMOD_ALL_BUSY_TIMEOUT * HZ);\n\t\tif (!ret) {\n\t\t\tpr_warn_ratelimited(\"request_module: modprobe %s cannot be processed, kmod busy with %d threads for more than %d seconds now\",\n\t\t\t\t\t    module_name, MAX_KMOD_CONCURRENT, MAX_KMOD_ALL_BUSY_TIMEOUT);\n\t\t\treturn -ETIME;\n\t\t} else if (ret == -ERESTARTSYS) {\n\t\t\tpr_warn_ratelimited(\"request_module: sigkill sent for modprobe %s, giving up\", module_name);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\ttrace_module_request(module_name, wait, _RET_IP_);\n\n\tret = call_modprobe(module_name, wait ? UMH_WAIT_PROC : UMH_WAIT_EXEC);\n\n\tatomic_inc(&kmod_concurrent_max);\n\twake_up(&kmod_wq);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "call_modprobe",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kmod.c",
    "lines": "70-107",
    "snippet": "static int call_modprobe(char *module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t/* check free_modprobe_argv() */\n\targv[4] = NULL;\n\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\treturn -ENOMEM;\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "char modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "argv"
          ],
          "line": 104
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_exec",
          "args": [
            "info",
            "wait | UMH_KILLABLE"
          ],
          "line": 99
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_exec",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "538-592",
          "snippet": "int call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\n\nint call_usermodehelper_exec(struct subprocess_info *sub_info, int wait)\n{\n\tDECLARE_COMPLETION_ONSTACK(done);\n\tint retval = 0;\n\n\tif (!sub_info->path) {\n\t\tcall_usermodehelper_freeinfo(sub_info);\n\t\treturn -EINVAL;\n\t}\n\thelper_lock();\n\tif (usermodehelper_disabled) {\n\t\tretval = -EBUSY;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If there is no binary for us to call, then just return and get out of\n\t * here.  This allows us to set STATIC_USERMODEHELPER_PATH to \"\" and\n\t * disable all call_usermodehelper() calls.\n\t */\n\tif (strlen(sub_info->path) == 0)\n\t\tgoto out;\n\n\t/*\n\t * Set the completion pointer only if there is a waiter.\n\t * This makes it possible to use umh_complete to free\n\t * the data structure in case of UMH_NO_WAIT.\n\t */\n\tsub_info->complete = (wait == UMH_NO_WAIT) ? NULL : &done;\n\tsub_info->wait = wait;\n\n\tqueue_work(system_unbound_wq, &sub_info->work);\n\tif (wait == UMH_NO_WAIT)\t/* task has freed sub_info */\n\t\tgoto unlock;\n\n\tif (wait & UMH_KILLABLE) {\n\t\tretval = wait_for_completion_killable(&done);\n\t\tif (!retval)\n\t\t\tgoto wait_done;\n\n\t\t/* umh_complete() will see NULL and free sub_info */\n\t\tif (xchg(&sub_info->complete, NULL))\n\t\t\tgoto unlock;\n\t\t/* fallthrough, umh_complete() was already called */\n\t}\n\n\twait_for_completion(&done);\nwait_done:\n\tretval = sub_info->retval;\nout:\n\tcall_usermodehelper_freeinfo(sub_info);\nunlock:\n\thelper_unlock();\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "call_usermodehelper_setup",
          "args": [
            "modprobe_path",
            "argv",
            "envp",
            "GFP_KERNEL",
            "NULL",
            "free_modprobe_argv",
            "NULL"
          ],
          "line": 94
        },
        "resolved": true,
        "details": {
          "function_name": "call_usermodehelper_setup",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "374-400",
          "snippet": "struct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstruct subprocess_info *call_usermodehelper_setup(const char *path, char **argv,\n\t\tchar **envp, gfp_t gfp_mask,\n\t\tint (*init)(struct subprocess_info *info, struct cred *new),\n\t\tvoid (*cleanup)(struct subprocess_info *info),\n\t\tvoid *data)\n{\n\tstruct subprocess_info *sub_info;\n\tsub_info = kzalloc(sizeof(struct subprocess_info), gfp_mask);\n\tif (!sub_info)\n\t\tgoto out;\n\n\tINIT_WORK(&sub_info->work, call_usermodehelper_exec_work);\n\n#ifdef CONFIG_STATIC_USERMODEHELPER\n\tsub_info->path = CONFIG_STATIC_USERMODEHELPER_PATH;\n#else\n\tsub_info->path = path;\n#endif\n\tsub_info->argv = argv;\n\tsub_info->envp = envp;\n\n\tsub_info->cleanup = cleanup;\n\tsub_info->init = init;\n\tsub_info->data = data;\n  out:\n\treturn sub_info;\n}"
        }
      },
      {
        "call_info": {
          "callee": "kstrdup",
          "args": [
            "module_name",
            "GFP_KERNEL"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(char *[5])",
            "GFP_KERNEL"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nchar modprobe_path[KMOD_PATH_LEN] = \"/sbin/modprobe\";\n\nstatic int call_modprobe(char *module_name, int wait)\n{\n\tstruct subprocess_info *info;\n\tstatic char *envp[] = {\n\t\t\"HOME=/\",\n\t\t\"TERM=linux\",\n\t\t\"PATH=/sbin:/usr/sbin:/bin:/usr/bin\",\n\t\tNULL\n\t};\n\n\tchar **argv = kmalloc(sizeof(char *[5]), GFP_KERNEL);\n\tif (!argv)\n\t\tgoto out;\n\n\tmodule_name = kstrdup(module_name, GFP_KERNEL);\n\tif (!module_name)\n\t\tgoto free_argv;\n\n\targv[0] = modprobe_path;\n\targv[1] = \"-q\";\n\targv[2] = \"--\";\n\targv[3] = module_name;\t/* check free_modprobe_argv() */\n\targv[4] = NULL;\n\n\tinfo = call_usermodehelper_setup(modprobe_path, argv, envp, GFP_KERNEL,\n\t\t\t\t\t NULL, free_modprobe_argv, NULL);\n\tif (!info)\n\t\tgoto free_module_name;\n\n\treturn call_usermodehelper_exec(info, wait | UMH_KILLABLE);\n\nfree_module_name:\n\tkfree(module_name);\nfree_argv:\n\tkfree(argv);\nout:\n\treturn -ENOMEM;\n}"
  },
  {
    "function_name": "free_modprobe_argv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/kmod.c",
    "lines": "64-68",
    "snippet": "static void free_modprobe_argv(struct subprocess_info *info)\n{\n\tkfree(info->argv[3]); /* check call_modprobe() */\n\tkfree(info->argv);\n}",
    "includes": [
      "#include <trace/events/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/async.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/rwsem.h>",
      "#include <linux/suspend.h>",
      "#include <linux/notifier.h>",
      "#include <linux/resource.h>",
      "#include <linux/init.h>",
      "#include <linux/kernel.h>",
      "#include <linux/mount.h>",
      "#include <linux/security.h>",
      "#include <linux/workqueue.h>",
      "#include <linux/fdtable.h>",
      "#include <linux/file.h>",
      "#include <linux/cred.h>",
      "#include <linux/completion.h>",
      "#include <linux/slab.h>",
      "#include <linux/kmod.h>",
      "#include <linux/unistd.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "info->argv"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic void free_modprobe_argv(struct subprocess_info *info)\n{\n\tkfree(info->argv[3]); /* check call_modprobe() */\n\tkfree(info->argv);\n}"
  }
]