[
  {
    "function_name": "syscall_unregfunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "592-604",
    "snippet": "void syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 602
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 600
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 599
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 598
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nvoid syscall_unregfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tsys_tracepoint_refcount--;\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tclear_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
  },
  {
    "function_name": "syscall_regfunc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "576-590",
    "snippet": "int syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 585
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SYSCALL_TRACEPOINT"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_process_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint syscall_regfunc(void)\n{\n\tstruct task_struct *p, *t;\n\n\tif (!sys_tracepoint_refcount) {\n\t\tread_lock(&tasklist_lock);\n\t\tfor_each_process_thread(p, t) {\n\t\t\tset_tsk_thread_flag(t, TIF_SYSCALL_TRACEPOINT);\n\t\t}\n\t\tread_unlock(&tasklist_lock);\n\t}\n\tsys_tracepoint_refcount++;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "for_each_kernel_tracepoint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "563-568",
    "snippet": "void for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "extern tracepoint_ptr_t __start___tracepoints_ptrs[];",
      "extern tracepoint_ptr_t __stop___tracepoints_ptrs[];"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "for_each_tracepoint_range",
          "args": [
            "__start___tracepoints_ptrs",
            "__stop___tracepoints_ptrs",
            "fct",
            "priv"
          ],
          "line": 566
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_tracepoint_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "374-385",
          "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nextern tracepoint_ptr_t __start___tracepoints_ptrs[];\nextern tracepoint_ptr_t __stop___tracepoints_ptrs[];\n\nvoid for_each_kernel_tracepoint(void (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\tfor_each_tracepoint_range(__start___tracepoints_ptrs,\n\t\t__stop___tracepoints_ptrs, fct, priv);\n}"
  },
  {
    "function_name": "init_tracepoints",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "545-554",
    "snippet": "static __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register tracepoint module enter notifier\\n\");\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_warn",
          "args": [
            "\"Failed to register tracepoint module enter notifier\\n\""
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "register_module_notifier",
          "args": [
            "&tracepoint_module_nb"
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "unregister_module_notifier",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/module.c",
          "lines": "304-307",
          "snippet": "int unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include \"module-internal.h\"",
            "#include <uapi/linux/module.h>",
            "#include <linux/audit.h>",
            "#include <linux/dynamic_debug.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/pfn.h>",
            "#include <linux/jump_label.h>",
            "#include <linux/kmemleak.h>",
            "#include <linux/percpu.h>",
            "#include <linux/async.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/tracepoint.h>",
            "#include <asm/sections.h>",
            "#include <linux/license.h>",
            "#include <asm/mmu_context.h>",
            "#include <linux/set_memory.h>",
            "#include <asm/cacheflush.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/mutex.h>",
            "#include <linux/string.h>",
            "#include <linux/device.h>",
            "#include <linux/sched.h>",
            "#include <linux/notifier.h>",
            "#include <linux/vermagic.h>",
            "#include <linux/err.h>",
            "#include <linux/errno.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/cpu.h>",
            "#include <linux/capability.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/security.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/elf.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/slab.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/fs.h>",
            "#include <linux/file.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/init.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/extable.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static BLOCKING_NOTIFIER_HEAD(module_notify_list);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include \"module-internal.h\"\n#include <uapi/linux/module.h>\n#include <linux/audit.h>\n#include <linux/dynamic_debug.h>\n#include <linux/bsearch.h>\n#include <linux/pfn.h>\n#include <linux/jump_label.h>\n#include <linux/kmemleak.h>\n#include <linux/percpu.h>\n#include <linux/async.h>\n#include <linux/livepatch.h>\n#include <linux/ftrace.h>\n#include <linux/tracepoint.h>\n#include <asm/sections.h>\n#include <linux/license.h>\n#include <asm/mmu_context.h>\n#include <linux/set_memory.h>\n#include <asm/cacheflush.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/mutex.h>\n#include <linux/string.h>\n#include <linux/device.h>\n#include <linux/sched.h>\n#include <linux/notifier.h>\n#include <linux/vermagic.h>\n#include <linux/err.h>\n#include <linux/errno.h>\n#include <linux/moduleparam.h>\n#include <linux/cpu.h>\n#include <linux/capability.h>\n#include <linux/rcupdate.h>\n#include <linux/fcntl.h>\n#include <linux/syscalls.h>\n#include <linux/seq_file.h>\n#include <linux/security.h>\n#include <linux/proc_fs.h>\n#include <linux/elf.h>\n#include <linux/vmalloc.h>\n#include <linux/slab.h>\n#include <linux/kernel.h>\n#include <linux/sysfs.h>\n#include <linux/fs.h>\n#include <linux/file.h>\n#include <linux/kallsyms.h>\n#include <linux/init.h>\n#include <linux/trace_events.h>\n#include <linux/moduleloader.h>\n#include <linux/extable.h>\n#include <linux/export.h>\n\nstatic BLOCKING_NOTIFIER_HEAD(module_notify_list);\n\nint unregister_module_notifier(struct notifier_block *nb)\n{\n\treturn blocking_notifier_chain_unregister(&module_notify_list, nb);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic __init int init_tracepoints(void)\n{\n\tint ret;\n\n\tret = register_module_notifier(&tracepoint_module_nb);\n\tif (ret)\n\t\tpr_warn(\"Failed to register tracepoint module enter notifier\\n\");\n\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_module_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "519-538",
    "snippet": "static int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_module_going",
          "args": [
            "mod"
          ],
          "line": 532
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_module_going",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "486-517",
          "snippet": "static void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_module_coming",
          "args": [
            "mod"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_module_coming",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "456-484",
          "snippet": "static int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_notify(struct notifier_block *self,\n\t\tunsigned long val, void *data)\n{\n\tstruct module *mod = data;\n\tint ret = 0;\n\n\tswitch (val) {\n\tcase MODULE_STATE_COMING:\n\t\tret = tracepoint_module_coming(mod);\n\t\tbreak;\n\tcase MODULE_STATE_LIVE:\n\t\tbreak;\n\tcase MODULE_STATE_GOING:\n\t\ttracepoint_module_going(mod);\n\t\tbreak;\n\tcase MODULE_STATE_UNFORMED:\n\t\tbreak;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_module_going",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "486-517",
    "snippet": "static void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 516
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_tracepoint_range",
          "args": [
            "mod->tracepoints_ptrs",
            "mod->tracepoints_ptrs + mod->num_tracepoints",
            "tp_module_going_check_quiescent",
            "NULL"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "for_each_tracepoint_range",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "374-385",
          "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kfree",
          "args": [
            "tp_mod"
          ],
          "line": 499
        },
        "resolved": true,
        "details": {
          "function_name": "maybe_kfree_parameter",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/params.c",
          "lines": "73-86",
          "snippet": "static void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}",
          "includes": [
            "#include <linux/ctype.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/device.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/module.h>",
            "#include <linux/errno.h>",
            "#include <linux/string.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static LIST_HEAD(kmalloced_params);",
            "static DEFINE_SPINLOCK(kmalloced_params_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/ctype.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/device.h>\n#include <linux/moduleparam.h>\n#include <linux/module.h>\n#include <linux/errno.h>\n#include <linux/string.h>\n#include <linux/kernel.h>\n\nstatic LIST_HEAD(kmalloced_params);\nstatic DEFINE_SPINLOCK(kmalloced_params_lock);\n\nstatic void maybe_kfree_parameter(void *param)\n{\n\tstruct kmalloced_param *p;\n\n\tspin_lock(&kmalloced_params_lock);\n\tlist_for_each_entry(p, &kmalloced_params, list) {\n\t\tif (p->val == param) {\n\t\t\tlist_del(&p->list);\n\t\t\tkfree(p);\n\t\t\tbreak;\n\t\t}\n\t}\n\tspin_unlock(&kmalloced_params_lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del",
          "args": [
            "&tp_mod->list"
          ],
          "line": 498
        },
        "resolved": true,
        "details": {
          "function_name": "list_del_leaf_cfs_rq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/fair.c",
          "lines": "446-448",
          "snippet": "static inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}",
          "includes": [
            "#include \"sched-pelt.h\"",
            "#include \"pelt.h\"",
            "#include <trace/events/sched.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void check_enqueue_throttle(struct cfs_rq *cfs_rq);",
            "static __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);",
            "static bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"sched-pelt.h\"\n#include \"pelt.h\"\n#include <trace/events/sched.h>\n#include \"sched.h\"\n\nstatic void check_enqueue_throttle(struct cfs_rq *cfs_rq);\nstatic __always_inline void return_cfs_rq_runtime(struct cfs_rq *cfs_rq);\nstatic bool check_cfs_rq_runtime(struct cfs_rq *cfs_rq);\n\nstatic inline void list_del_leaf_cfs_rq(struct cfs_rq *cfs_rq)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&tracepoint_notify_list",
            "MODULE_STATE_GOING",
            "tp_mod"
          ],
          "line": 496
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "325-329",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 494
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 493
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tracepoint_module_going(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\n\tif (!mod->num_tracepoints)\n\t\treturn;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list) {\n\t\tif (tp_mod->mod == mod) {\n\t\t\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\t\t\tMODULE_STATE_GOING, tp_mod);\n\t\t\tlist_del(&tp_mod->list);\n\t\t\tkfree(tp_mod);\n\t\t\t/*\n\t\t\t * Called the going notifier before checking for\n\t\t\t * quiescence.\n\t\t\t */\n\t\t\tfor_each_tracepoint_range(mod->tracepoints_ptrs,\n\t\t\t\tmod->tracepoints_ptrs + mod->num_tracepoints,\n\t\t\t\ttp_module_going_check_quiescent, NULL);\n\t\t\tbreak;\n\t\t}\n\t}\n\t/*\n\t * In the case of modules that were tainted at \"coming\", we'll simply\n\t * walk through the list without finding it. We cannot use the \"tainted\"\n\t * flag on \"going\", in case a module taints the kernel only after being\n\t * loaded.\n\t */\n\tmutex_unlock(&tracepoint_module_list_mutex);\n}"
  },
  {
    "function_name": "tracepoint_module_coming",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "456-484",
    "snippet": "static int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "blocking_notifier_call_chain",
          "args": [
            "&tracepoint_notify_list",
            "MODULE_STATE_COMING",
            "tp_mod"
          ],
          "line": 479
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_call_chain",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "325-329",
          "snippet": "int blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_call_chain(struct blocking_notifier_head *nh,\n\t\tunsigned long val, void *v)\n{\n\treturn __blocking_notifier_call_chain(nh, val, v, -1, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&tp_mod->list",
            "&tracepoint_module_list"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "sizeof(struct tp_module)",
            "GFP_KERNEL"
          ],
          "line": 472
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 471
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_module_has_bad_taint",
          "args": [
            "mod"
          ],
          "line": 469
        },
        "resolved": true,
        "details": {
          "function_name": "trace_module_has_bad_taint",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "388-392",
          "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic int tracepoint_module_coming(struct module *mod)\n{\n\tstruct tp_module *tp_mod;\n\tint ret = 0;\n\n\tif (!mod->num_tracepoints)\n\t\treturn 0;\n\n\t/*\n\t * We skip modules that taint the kernel, especially those with different\n\t * module headers (for forced load), to make sure we don't cause a crash.\n\t * Staging, out-of-tree, and unsigned GPL modules are fine.\n\t */\n\tif (trace_module_has_bad_taint(mod))\n\t\treturn 0;\n\tmutex_lock(&tracepoint_module_list_mutex);\n\ttp_mod = kmalloc(sizeof(struct tp_module), GFP_KERNEL);\n\tif (!tp_mod) {\n\t\tret = -ENOMEM;\n\t\tgoto end;\n\t}\n\ttp_mod->mod = mod;\n\tlist_add_tail(&tp_mod->list, &tracepoint_module_list);\n\tblocking_notifier_call_chain(&tracepoint_notify_list,\n\t\t\tMODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tp_module_going_check_quiescent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "451-454",
    "snippet": "static void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)\n{\n\tWARN_ON_ONCE(tp->funcs);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "tp->funcs"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void tp_module_going_check_quiescent(struct tracepoint *tp, void *priv)\n{\n\tWARN_ON_ONCE(tp->funcs);\n}"
  },
  {
    "function_name": "unregister_tracepoint_module_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "429-444",
    "snippet": "int unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "nb",
            "MODULE_STATE_GOING",
            "tp_mod"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "void"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_chain_unregister",
          "args": [
            "&tracepoint_notify_list",
            "nb"
          ],
          "line": 435
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_unregister",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "266-283",
          "snippet": "int blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_unregister(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_unregister(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_unregister(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 434
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint unregister_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_unregister(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_GOING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n\n}"
  },
  {
    "function_name": "register_tracepoint_module_notifier",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "405-419",
    "snippet": "int register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 417
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "nb",
            "MODULE_STATE_COMING",
            "tp_mod"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "void"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "tp_mod",
            "&tracepoint_module_list",
            "list"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "blocking_notifier_chain_register",
          "args": [
            "&tracepoint_notify_list",
            "nb"
          ],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "blocking_notifier_chain_register",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/notifier.c",
          "lines": "213-230",
          "snippet": "int blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/reboot.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/notifier.h>",
            "#include <linux/export.h>",
            "#include <linux/kprobes.h>",
            "#include <linux/kdebug.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/reboot.h>\n#include <linux/vmalloc.h>\n#include <linux/rcupdate.h>\n#include <linux/notifier.h>\n#include <linux/export.h>\n#include <linux/kprobes.h>\n#include <linux/kdebug.h>\n\nint blocking_notifier_chain_register(struct blocking_notifier_head *nh,\n\t\tstruct notifier_block *n)\n{\n\tint ret;\n\n\t/*\n\t * This code gets used during boot-up, when task switching is\n\t * not yet working and interrupts must remain disabled.  At\n\t * such times we must not call down_write().\n\t */\n\tif (unlikely(system_state == SYSTEM_BOOTING))\n\t\treturn notifier_chain_register(&nh->head, n);\n\n\tdown_write(&nh->rwsem);\n\tret = notifier_chain_register(&nh->head, n);\n\tup_write(&nh->rwsem);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoint_module_list_mutex"
          ],
          "line": 410
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint register_tracepoint_module_notifier(struct notifier_block *nb)\n{\n\tstruct tp_module *tp_mod;\n\tint ret;\n\n\tmutex_lock(&tracepoint_module_list_mutex);\n\tret = blocking_notifier_chain_register(&tracepoint_notify_list, nb);\n\tif (ret)\n\t\tgoto end;\n\tlist_for_each_entry(tp_mod, &tracepoint_module_list, list)\n\t\t(void) nb->notifier_call(nb, MODULE_STATE_COMING, tp_mod);\nend:\n\tmutex_unlock(&tracepoint_module_list_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "trace_module_has_bad_taint",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "388-392",
    "snippet": "bool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nbool trace_module_has_bad_taint(struct module *mod)\n{\n\treturn mod->taints & ~((1 << TAINT_OOT_MODULE) | (1 << TAINT_CRAP) |\n\t\t\t       (1 << TAINT_UNSIGNED_MODULE));\n}"
  },
  {
    "function_name": "for_each_tracepoint_range",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "374-385",
    "snippet": "static void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "fct",
          "args": [
            "tracepoint_ptr_deref(iter)",
            "priv"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracepoint_ptr_deref",
          "args": [
            "iter"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void for_each_tracepoint_range(\n\t\ttracepoint_ptr_t *begin, tracepoint_ptr_t *end,\n\t\tvoid (*fct)(struct tracepoint *tp, void *priv),\n\t\tvoid *priv)\n{\n\ttracepoint_ptr_t *iter;\n\n\tif (!begin)\n\t\treturn;\n\tfor (iter = begin; iter < end; iter++)\n\t\tfct(tracepoint_ptr_deref(iter), priv);\n}"
  },
  {
    "function_name": "tracepoint_probe_unregister",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "360-371",
    "snippet": "int tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 369
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_remove_func",
          "args": [
            "tp",
            "&tp_func"
          ],
          "line": 368
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_remove_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "279-303",
          "snippet": "static int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 365
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_unregister(struct tracepoint *tp, void *probe, void *data)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\tret = tracepoint_remove_func(tp, &tp_func);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_probe_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "346-349",
    "snippet": "int tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracepoint_probe_register_prio",
          "args": [
            "tp",
            "probe",
            "data",
            "TRACEPOINT_DEFAULT_PRIO"
          ],
          "line": 348
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_probe_register_prio",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "318-331",
          "snippet": "int tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nint tracepoint_probe_register(struct tracepoint *tp, void *probe, void *data)\n{\n\treturn tracepoint_probe_register_prio(tp, probe, data, TRACEPOINT_DEFAULT_PRIO);\n}"
  },
  {
    "function_name": "tracepoint_probe_register_prio",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "318-331",
    "snippet": "int tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mutex_unlock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 329
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1602-1606",
          "snippet": "void __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nvoid __sched rt_mutex_unlock(struct rt_mutex *lock)\n{\n\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\trt_mutex_fastunlock(lock, rt_mutex_slowunlock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "tracepoint_add_func",
          "args": [
            "tp",
            "&tp_func",
            "prio"
          ],
          "line": 328
        },
        "resolved": true,
        "details": {
          "function_name": "tracepoint_add_func",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "240-271",
          "snippet": "static int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_MUTEX(tracepoints_mutex);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mutex_lock",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 324
        },
        "resolved": true,
        "details": {
          "function_name": "rt_mutex_lock_interruptible",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/rtmutex.c",
          "lines": "1512-1524",
          "snippet": "int __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}",
          "includes": [
            "#include \"rtmutex_common.h\"",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/wake_q.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/export.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rtmutex_common.h\"\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/wake_q.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/signal.h>\n#include <linux/export.h>\n#include <linux/spinlock.h>\n\nint __sched rt_mutex_lock_interruptible(struct rt_mutex *lock)\n{\n\tint ret;\n\n\tmight_sleep();\n\n\tmutex_acquire(&lock->dep_map, 0, 0, _RET_IP_);\n\tret = rt_mutex_fastlock(lock, TASK_INTERRUPTIBLE, rt_mutex_slowlock);\n\tif (ret)\n\t\tmutex_release(&lock->dep_map, 1, _RET_IP_);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nint tracepoint_probe_register_prio(struct tracepoint *tp, void *probe,\n\t\t\t\t   void *data, int prio)\n{\n\tstruct tracepoint_func tp_func;\n\tint ret;\n\n\tmutex_lock(&tracepoints_mutex);\n\ttp_func.func = probe;\n\ttp_func.data = data;\n\ttp_func.prio = prio;\n\tret = tracepoint_add_func(tp, &tp_func, prio);\n\tmutex_unlock(&tracepoints_mutex);\n\treturn ret;\n}"
  },
  {
    "function_name": "tracepoint_remove_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "279-303",
    "snippet": "static int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_probes",
          "args": [
            "old"
          ],
          "line": 301
        },
        "resolved": true,
        "details": {
          "function_name": "release_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "104-128",
          "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_head *early_probes;",
            "static bool ok_to_free_tracepoints;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_slow_dec",
          "args": [
            "&tp->key"
          ],
          "line": 298
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_slow_dec_deferred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "264-268",
          "snippet": "void static_key_slow_dec_deferred(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(&key->key, key->timeout, &key->work);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_dec_deferred(struct static_key_deferred *key)\n{\n\tSTATIC_KEY_CHECK_USE(key);\n\t__static_key_slow_dec(&key->key, key->timeout, &key->work);\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->unregfunc",
          "args": [],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PTR_ERR(old) != -ENOMEM"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_remove",
          "args": [
            "&tp_funcs",
            "func"
          ],
          "line": 286
        },
        "resolved": true,
        "details": {
          "function_name": "func_remove",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "189-235",
          "snippet": "static void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tp->funcs",
            "lockdep_is_held(&tracepoints_mutex)"
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_remove_func(struct tracepoint *tp,\n\t\tstruct tracepoint_func *func)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_remove(&tp_funcs, func);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\tif (!tp_funcs) {\n\t\t/* Removed last function */\n\t\tif (tp->unregfunc && static_key_enabled(&tp->key))\n\t\t\ttp->unregfunc();\n\n\t\tif (static_key_enabled(&tp->key))\n\t\t\tstatic_key_slow_dec(&tp->key);\n\t}\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\trelease_probes(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "tracepoint_add_func",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "240-271",
    "snippet": "static int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static DEFINE_MUTEX(tracepoints_mutex);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "release_probes",
          "args": [
            "old"
          ],
          "line": 269
        },
        "resolved": true,
        "details": {
          "function_name": "release_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "104-128",
          "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct rcu_head *early_probes;",
            "static bool ok_to_free_tracepoints;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_slow_inc",
          "args": [
            "&tp->key"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "static_key_slow_inc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/jump_label.c",
          "lines": "143-148",
          "snippet": "void static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/cpu.h>",
            "#include <linux/bug.h>",
            "#include <linux/jump_label_ratelimit.h>",
            "#include <linux/static_key.h>",
            "#include <linux/err.h>",
            "#include <linux/sort.h>",
            "#include <linux/slab.h>",
            "#include <linux/list.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/memory.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/cpu.h>\n#include <linux/bug.h>\n#include <linux/jump_label_ratelimit.h>\n#include <linux/static_key.h>\n#include <linux/err.h>\n#include <linux/sort.h>\n#include <linux/slab.h>\n#include <linux/list.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/memory.h>\n\nvoid static_key_slow_inc(struct static_key *key)\n{\n\tcpus_read_lock();\n\tstatic_key_slow_inc_cpuslocked(key);\n\tcpus_read_unlock();\n}"
        }
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 267
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_assign_pointer",
          "args": [
            "tp->funcs",
            "tp_funcs"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "PTR_ERR(old) != -ENOMEM"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PTR_ERR",
          "args": [
            "old"
          ],
          "line": 256
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "IS_ERR",
          "args": [
            "old"
          ],
          "line": 255
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "func_add",
          "args": [
            "&tp_funcs",
            "func",
            "prio"
          ],
          "line": 254
        },
        "resolved": true,
        "details": {
          "function_name": "func_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "141-187",
          "snippet": "static struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint nr_probes = 0;\n\tint pos = -1;\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[nr_probes].prio < prio)\n\t\t\t\tpos = nr_probes;\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tif (pos < 0) {\n\t\t\tpos = nr_probes;\n\t\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\t\t} else {\n\t\t\t/* Copy higher priority probes ahead of the new probe */\n\t\t\tmemcpy(new, old, pos * sizeof(struct tracepoint_func));\n\t\t\t/* Copy the rest after it. */\n\t\t\tmemcpy(new + pos + 1, old + pos,\n\t\t\t       (nr_probes - pos) * sizeof(struct tracepoint_func));\n\t\t}\n\t} else\n\t\tpos = 0;\n\tnew[pos] = *tp_func;\n\tnew[nr_probes + 1].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint nr_probes = 0;\n\tint pos = -1;\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[nr_probes].prio < prio)\n\t\t\t\tpos = nr_probes;\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tif (pos < 0) {\n\t\t\tpos = nr_probes;\n\t\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\t\t} else {\n\t\t\t/* Copy higher priority probes ahead of the new probe */\n\t\t\tmemcpy(new, old, pos * sizeof(struct tracepoint_func));\n\t\t\t/* Copy the rest after it. */\n\t\t\tmemcpy(new + pos + 1, old + pos,\n\t\t\t       (nr_probes - pos) * sizeof(struct tracepoint_func));\n\t\t}\n\t} else\n\t\tpos = 0;\n\tnew[pos] = *tp_func;\n\tnew[nr_probes + 1].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_dereference_protected",
          "args": [
            "tp->funcs",
            "lockdep_is_held(&tracepoints_mutex)"
          ],
          "line": 252
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lockdep_is_held",
          "args": [
            "&tracepoints_mutex"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tp->regfunc",
          "args": [],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "static_key_enabled",
          "args": [
            "&tp->key"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic DEFINE_MUTEX(tracepoints_mutex);\n\nstatic int tracepoint_add_func(struct tracepoint *tp,\n\t\t\t       struct tracepoint_func *func, int prio)\n{\n\tstruct tracepoint_func *old, *tp_funcs;\n\tint ret;\n\n\tif (tp->regfunc && !static_key_enabled(&tp->key)) {\n\t\tret = tp->regfunc();\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\ttp_funcs = rcu_dereference_protected(tp->funcs,\n\t\t\tlockdep_is_held(&tracepoints_mutex));\n\told = func_add(&tp_funcs, func, prio);\n\tif (IS_ERR(old)) {\n\t\tWARN_ON_ONCE(PTR_ERR(old) != -ENOMEM);\n\t\treturn PTR_ERR(old);\n\t}\n\n\t/*\n\t * rcu_assign_pointer has as smp_store_release() which makes sure\n\t * that the new probe callbacks array is consistent before setting\n\t * a pointer to it.  This array is referenced by __DO_TRACE from\n\t * include/linux/tracepoint.h using rcu_dereference_sched().\n\t */\n\trcu_assign_pointer(tp->funcs, tp_funcs);\n\tif (!static_key_enabled(&tp->key))\n\t\tstatic_key_slow_inc(&tp->key);\n\trelease_probes(old);\n\treturn 0;\n}"
  },
  {
    "function_name": "func_remove",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "189-235",
    "snippet": "static void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_print_probes",
          "args": [
            "*funcs"
          ],
          "line": 233
        },
        "resolved": true,
        "details": {
          "function_name": "debug_print_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "130-139",
          "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int tracepoint_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_probes",
          "args": [
            "nr_probes - nr_del + 1"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "69-74",
          "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOENT"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void *func_remove(struct tracepoint_func **funcs,\n\t\tstruct tracepoint_func *tp_func)\n{\n\tint nr_probes = 0, nr_del = 0, i;\n\tstruct tracepoint_func *old, *new;\n\n\told = *funcs;\n\n\tif (!old)\n\t\treturn ERR_PTR(-ENOENT);\n\n\tdebug_print_probes(*funcs);\n\t/* (N -> M), (N > 1, M >= 0) probes */\n\tif (tp_func->func) {\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t     old[nr_probes].data == tp_func->data)\n\t\t\t\tnr_del++;\n\t\t}\n\t}\n\n\t/*\n\t * If probe is NULL, then nr_probes = nr_del = 0, and then the\n\t * entire entry will be removed.\n\t */\n\tif (nr_probes - nr_del == 0) {\n\t\t/* N -> 0, (N > 1) */\n\t\t*funcs = NULL;\n\t\tdebug_print_probes(*funcs);\n\t\treturn old;\n\t} else {\n\t\tint j = 0;\n\t\t/* N -> M, (N > 1, M > 0) */\n\t\t/* + 1 for NULL */\n\t\tnew = allocate_probes(nr_probes - nr_del + 1);\n\t\tif (new == NULL)\n\t\t\treturn ERR_PTR(-ENOMEM);\n\t\tfor (i = 0; old[i].func; i++)\n\t\t\tif (old[i].func != tp_func->func\n\t\t\t\t\t|| old[i].data != tp_func->data)\n\t\t\t\tnew[j++] = old[i];\n\t\tnew[nr_probes - nr_del].func = NULL;\n\t\t*funcs = new;\n\t}\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
  },
  {
    "function_name": "func_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "141-187",
    "snippet": "static struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint nr_probes = 0;\n\tint pos = -1;\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[nr_probes].prio < prio)\n\t\t\t\tpos = nr_probes;\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tif (pos < 0) {\n\t\t\tpos = nr_probes;\n\t\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\t\t} else {\n\t\t\t/* Copy higher priority probes ahead of the new probe */\n\t\t\tmemcpy(new, old, pos * sizeof(struct tracepoint_func));\n\t\t\t/* Copy the rest after it. */\n\t\t\tmemcpy(new + pos + 1, old + pos,\n\t\t\t       (nr_probes - pos) * sizeof(struct tracepoint_func));\n\t\t}\n\t} else\n\t\tpos = 0;\n\tnew[pos] = *tp_func;\n\tnew[nr_probes + 1].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "debug_print_probes",
          "args": [
            "*funcs"
          ],
          "line": 185
        },
        "resolved": true,
        "details": {
          "function_name": "debug_print_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "130-139",
          "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const int tracepoint_debug;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
        }
      },
      {
        "call_info": {
          "callee": "memcpy",
          "args": [
            "new + pos + 1",
            "old + pos",
            "(nr_probes - pos) * sizeof(struct tracepoint_func)"
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "memcpy_skip",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/internal.h",
          "lines": "178-182",
          "snippet": "static inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/hardirq.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/hardirq.h>\n\nstatic inline unsigned long\nmemcpy_skip(void *dst, const void *src, unsigned long n)\n{\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-ENOMEM"
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allocate_probes",
          "args": [
            "nr_probes + 2"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "allocate_probes",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
          "lines": "69-74",
          "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
          "includes": [
            "#include <linux/static_key.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/err.h>",
            "#include <linux/tracepoint.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/list.h>",
            "#include <linux/jhash.h>",
            "#include <linux/types.h>",
            "#include <linux/mutex.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EEXIST"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ERR_PTR",
          "args": [
            "-EINVAL"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "!tp_func->func"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct tracepoint_func *\nfunc_add(struct tracepoint_func **funcs, struct tracepoint_func *tp_func,\n\t int prio)\n{\n\tstruct tracepoint_func *old, *new;\n\tint nr_probes = 0;\n\tint pos = -1;\n\n\tif (WARN_ON(!tp_func->func))\n\t\treturn ERR_PTR(-EINVAL);\n\n\tdebug_print_probes(*funcs);\n\told = *funcs;\n\tif (old) {\n\t\t/* (N -> N+1), (N != 0, 1) probes */\n\t\tfor (nr_probes = 0; old[nr_probes].func; nr_probes++) {\n\t\t\t/* Insert before probes of lower priority */\n\t\t\tif (pos < 0 && old[nr_probes].prio < prio)\n\t\t\t\tpos = nr_probes;\n\t\t\tif (old[nr_probes].func == tp_func->func &&\n\t\t\t    old[nr_probes].data == tp_func->data)\n\t\t\t\treturn ERR_PTR(-EEXIST);\n\t\t}\n\t}\n\t/* + 2 : one for new probe, one for NULL func */\n\tnew = allocate_probes(nr_probes + 2);\n\tif (new == NULL)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (old) {\n\t\tif (pos < 0) {\n\t\t\tpos = nr_probes;\n\t\t\tmemcpy(new, old, nr_probes * sizeof(struct tracepoint_func));\n\t\t} else {\n\t\t\t/* Copy higher priority probes ahead of the new probe */\n\t\t\tmemcpy(new, old, pos * sizeof(struct tracepoint_func));\n\t\t\t/* Copy the rest after it. */\n\t\t\tmemcpy(new + pos + 1, old + pos,\n\t\t\t       (nr_probes - pos) * sizeof(struct tracepoint_func));\n\t\t}\n\t} else\n\t\tpos = 0;\n\tnew[pos] = *tp_func;\n\tnew[nr_probes + 1].func = NULL;\n\t*funcs = new;\n\tdebug_print_probes(*funcs);\n\treturn old;\n}"
  },
  {
    "function_name": "debug_print_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "130-139",
    "snippet": "static void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const int tracepoint_debug;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "printk",
          "args": [
            "KERN_DEBUG \"Probe %d : %p\\n\"",
            "i",
            "funcs[i].func"
          ],
          "line": 138
        },
        "resolved": true,
        "details": {
          "function_name": "__warn_printk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/panic.c",
          "lines": "590-599",
          "snippet": "void __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}",
          "includes": [
            "#include <asm/sections.h>",
            "#include <linux/debugfs.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/bug.h>",
            "#include <linux/console.h>",
            "#include <linux/nmi.h>",
            "#include <linux/init.h>",
            "#include <linux/sysrq.h>",
            "#include <linux/sched.h>",
            "#include <linux/kexec.h>",
            "#include <linux/delay.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/random.h>",
            "#include <linux/module.h>",
            "#include <linux/notifier.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/kmsg_dump.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/debug_locks.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/sections.h>\n#include <linux/debugfs.h>\n#include <linux/ratelimit.h>\n#include <linux/bug.h>\n#include <linux/console.h>\n#include <linux/nmi.h>\n#include <linux/init.h>\n#include <linux/sysrq.h>\n#include <linux/sched.h>\n#include <linux/kexec.h>\n#include <linux/delay.h>\n#include <linux/reboot.h>\n#include <linux/ftrace.h>\n#include <linux/random.h>\n#include <linux/module.h>\n#include <linux/notifier.h>\n#include <linux/kallsyms.h>\n#include <linux/kmsg_dump.h>\n#include <linux/interrupt.h>\n#include <linux/sched/debug.h>\n#include <linux/debug_locks.h>\n\nvoid __warn_printk(const char *fmt, ...)\n{\n\tva_list args;\n\n\tpr_warn(CUT_HERE);\n\n\tva_start(args, fmt);\n\tvprintk(fmt, args);\n\tva_end(args);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic const int tracepoint_debug;\n\nstatic void debug_print_probes(struct tracepoint_func *funcs)\n{\n\tint i;\n\n\tif (!tracepoint_debug || !funcs)\n\t\treturn;\n\n\tfor (i = 0; funcs[i].func; i++)\n\t\tprintk(KERN_DEBUG \"Probe %d : %p\\n\", i, funcs[i].func);\n}"
  },
  {
    "function_name": "release_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "104-128",
    "snippet": "static inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_head *early_probes;",
      "static bool ok_to_free_tracepoints;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "&tp_probes->rcu",
            "rcu_free_old_probes"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!ok_to_free_tracepoints"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "container_of",
          "args": [
            "old",
            "structtp_probes",
            "probes[0]"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic inline void release_probes(struct tracepoint_func *old)\n{\n\tif (old) {\n\t\tstruct tp_probes *tp_probes = container_of(old,\n\t\t\tstruct tp_probes, probes[0]);\n\n\t\t/*\n\t\t * We can't free probes if SRCU is not initialized yet.\n\t\t * Postpone the freeing till after SRCU is initialized.\n\t\t */\n\t\tif (unlikely(!ok_to_free_tracepoints)) {\n\t\t\ttp_probes->rcu.next = early_probes;\n\t\t\tearly_probes = &tp_probes->rcu;\n\t\t\treturn;\n\t\t}\n\n\t\t/*\n\t\t * Tracepoint probes are protected by both sched RCU and SRCU,\n\t\t * by calling the SRCU callback in the sched RCU callback we\n\t\t * cover both cases. So let us chain the SRCU and sched RCU\n\t\t * callbacks to wait for both grace periods.\n\t\t */\n\t\tcall_rcu_sched(&tp_probes->rcu, rcu_free_old_probes);\n\t}\n}"
  },
  {
    "function_name": "release_early_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "86-99",
    "snippet": "static __init int release_early_probes(void)\n{\n\tstruct rcu_head *tmp;\n\n\tok_to_free_tracepoints = true;\n\n\twhile (early_probes) {\n\t\ttmp = early_probes;\n\t\tearly_probes = tmp->next;\n\t\tcall_rcu_sched(tmp, rcu_free_old_probes);\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct rcu_head *early_probes;",
      "static bool ok_to_free_tracepoints;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_rcu_sched",
          "args": [
            "tmp",
            "rcu_free_old_probes"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic struct rcu_head *early_probes;\nstatic bool ok_to_free_tracepoints;\n\nstatic __init int release_early_probes(void)\n{\n\tstruct rcu_head *tmp;\n\n\tok_to_free_tracepoints = true;\n\n\twhile (early_probes) {\n\t\ttmp = early_probes;\n\t\tearly_probes = tmp->next;\n\t\tcall_rcu_sched(tmp, rcu_free_old_probes);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rcu_free_old_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "81-84",
    "snippet": "static void rcu_free_old_probes(struct rcu_head *head)\n{\n\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "call_srcu",
          "args": [
            "&tracepoint_srcu",
            "head",
            "srcu_free_old_probes"
          ],
          "line": 83
        },
        "resolved": true,
        "details": {
          "function_name": "call_srcu",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/srcutree.c",
          "lines": "914-918",
          "snippet": "void call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}",
          "includes": [
            "#include \"rcu_segcblist.h\"",
            "#include \"rcu.h\"",
            "#include <linux/srcu.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/preempt.h>",
            "#include <linux/percpu.h>",
            "#include <linux/mutex.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu_segcblist.h\"\n#include \"rcu.h\"\n#include <linux/srcu.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/preempt.h>\n#include <linux/percpu.h>\n#include <linux/mutex.h>\n#include <linux/export.h>\n\nvoid call_srcu(struct srcu_struct *sp, struct rcu_head *rhp,\n\t       rcu_callback_t func)\n{\n\t__call_srcu(sp, rhp, func, true);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void rcu_free_old_probes(struct rcu_head *head)\n{\n\tcall_srcu(&tracepoint_srcu, head, srcu_free_old_probes);\n}"
  },
  {
    "function_name": "srcu_free_old_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "76-79",
    "snippet": "static void srcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic void srcu_free_old_probes(struct rcu_head *head)\n{\n\tkfree(container_of(head, struct tp_probes, rcu));\n}"
  },
  {
    "function_name": "allocate_probes",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/tracepoint.c",
    "lines": "69-74",
    "snippet": "static inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}",
    "includes": [
      "#include <linux/static_key.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/signal.h>",
      "#include <linux/slab.h>",
      "#include <linux/err.h>",
      "#include <linux/tracepoint.h>",
      "#include <linux/rcupdate.h>",
      "#include <linux/list.h>",
      "#include <linux/jhash.h>",
      "#include <linux/types.h>",
      "#include <linux/mutex.h>",
      "#include <linux/module.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmalloc",
          "args": [
            "count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes)",
            "GFP_KERNEL"
          ],
          "line": 71
        },
        "resolved": true,
        "details": {
          "function_name": "debug_kmalloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_support.c",
          "lines": "745-801",
          "snippet": "void *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/slab.h>",
            "#include <linux/kdb.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/highmem.h>",
            "#include <linux/module.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/stddef.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/types.h>",
            "#include <stdarg.h>"
          ],
          "macros_used": [
            "#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)",
            "#define dah_align 8"
          ],
          "globals_used": [
            "static u64 debug_alloc_pool_aligned[256*1024/dah_align];",
            "static char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;",
            "static u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;",
            "static DEFINE_SPINLOCK(dap_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/slab.h>\n#include <linux/kdb.h>\n#include <linux/uaccess.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/highmem.h>\n#include <linux/module.h>\n#include <linux/ptrace.h>\n#include <linux/vmalloc.h>\n#include <linux/stddef.h>\n#include <linux/kallsyms.h>\n#include <linux/mm.h>\n#include <linux/sched.h>\n#include <linux/types.h>\n#include <stdarg.h>\n\n#define dah_overhead ALIGN(sizeof(struct debug_alloc_header), dah_align)\n#define dah_align 8\n\nstatic u64 debug_alloc_pool_aligned[256*1024/dah_align];\nstatic char *debug_alloc_pool = (char *)debug_alloc_pool_aligned;\nstatic u32 dah_first, dah_first_call = 1, dah_used, dah_used_max;\nstatic DEFINE_SPINLOCK(dap_lock);\n\nvoid *debug_kmalloc(size_t size, gfp_t flags)\n{\n\tunsigned int rem, h_offset;\n\tstruct debug_alloc_header *best, *bestprev, *prev, *h;\n\tvoid *p = NULL;\n\tif (!get_dap_lock()) {\n\t\t__release(dap_lock);\t/* we never actually got it */\n\t\treturn NULL;\n\t}\n\th = (struct debug_alloc_header *)(debug_alloc_pool + dah_first);\n\tif (dah_first_call) {\n\t\th->size = sizeof(debug_alloc_pool_aligned) - dah_overhead;\n\t\tdah_first_call = 0;\n\t}\n\tsize = ALIGN(size, dah_align);\n\tprev = best = bestprev = NULL;\n\twhile (1) {\n\t\tif (h->size >= size && (!best || h->size < best->size)) {\n\t\t\tbest = h;\n\t\t\tbestprev = prev;\n\t\t\tif (h->size == size)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (!h->next)\n\t\t\tbreak;\n\t\tprev = h;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h->next);\n\t}\n\tif (!best)\n\t\tgoto out;\n\trem = best->size - size;\n\t/* The pool must always contain at least one header */\n\tif (best->next == 0 && bestprev == NULL && rem < dah_overhead)\n\t\tgoto out;\n\tif (rem >= dah_overhead) {\n\t\tbest->size = size;\n\t\th_offset = ((char *)best - debug_alloc_pool) +\n\t\t\t   dah_overhead + best->size;\n\t\th = (struct debug_alloc_header *)(debug_alloc_pool + h_offset);\n\t\th->size = rem - dah_overhead;\n\t\th->next = best->next;\n\t} else\n\t\th_offset = best->next;\n\tbest->caller = __builtin_return_address(0);\n\tdah_used += best->size;\n\tdah_used_max = max(dah_used, dah_used_max);\n\tif (bestprev)\n\t\tbestprev->next = h_offset;\n\telse\n\t\tdah_first = h_offset;\n\tp = (char *)best + dah_overhead;\n\tmemset(p, POISON_INUSE, best->size - 1);\n\t*((char *)p + best->size - 1) = POISON_END;\nout:\n\tspin_unlock(&dap_lock);\n\treturn p;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/static_key.h>\n#include <linux/sched/task.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/err.h>\n#include <linux/tracepoint.h>\n#include <linux/rcupdate.h>\n#include <linux/list.h>\n#include <linux/jhash.h>\n#include <linux/types.h>\n#include <linux/mutex.h>\n#include <linux/module.h>\n\nstatic inline void *allocate_probes(int count)\n{\n\tstruct tp_probes *p  = kmalloc(count * sizeof(struct tracepoint_func)\n\t\t\t+ sizeof(struct tp_probes), GFP_KERNEL);\n\treturn p == NULL ? NULL : p->probes;\n}"
  }
]