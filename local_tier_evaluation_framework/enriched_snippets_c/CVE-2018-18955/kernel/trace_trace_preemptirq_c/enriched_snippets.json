[
  {
    "function_name": "trace_preempt_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "83-88",
    "snippet": "void trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_preempt_off",
          "args": [
            "a0",
            "a1"
          ],
          "line": 87
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_preempt_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "667-673",
          "snippet": "void tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) && !irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) && !irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_preempt_disable_rcuidle",
          "args": [
            "a0",
            "a1"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_off(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_disable_rcuidle(a0, a1);\n\ttracer_preempt_off(a0, a1);\n}"
  },
  {
    "function_name": "trace_preempt_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "76-81",
    "snippet": "void trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracer_preempt_on",
          "args": [
            "a0",
            "a1"
          ],
          "line": 80
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_preempt_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "659-665",
          "snippet": "void tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) && !irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tint pc = preempt_count();\n\n\tif (preempt_trace(pc) && !irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_preempt_enable_rcuidle",
          "args": [
            "a0",
            "a1"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_preempt_on(unsigned long a0, unsigned long a1)\n{\n\tif (!in_nmi())\n\t\ttrace_preempt_enable_rcuidle(a0, a1);\n\ttracer_preempt_on(a0, a1);\n}"
  },
  {
    "function_name": "trace_hardirqs_off_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "60-70",
    "snippet": "__visible void trace_hardirqs_off_caller(unsigned long caller_addr)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, caller_addr);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, caller_addr);\n\t}\n\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2818-2842",
          "snippet": "void lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_disable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_off",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 64
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "617-623",
          "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "1"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n__visible void trace_hardirqs_off_caller(unsigned long caller_addr)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, caller_addr);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, caller_addr);\n\t}\n\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "trace_hardirqs_on_caller",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "47-57",
    "snippet": "__visible void trace_hardirqs_on_caller(unsigned long caller_addr)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, caller_addr);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, caller_addr);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 56
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2774-2813",
          "snippet": "void lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "0"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_on",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 52
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "609-615",
          "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_enable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "caller_addr"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\n__visible void trace_hardirqs_on_caller(unsigned long caller_addr)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, caller_addr);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, caller_addr);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "trace_hardirqs_off",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "34-44",
    "snippet": "void trace_hardirqs_off(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_off",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 43
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2818-2842",
          "snippet": "void lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_off(unsigned long ip)\n{\n\tstruct task_struct *curr = current;\n\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\t/*\n\t * So we're supposed to get called after you mask local IRQs, but for\n\t * some reason the hardware doesn't quite think you did a proper job.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\tif (curr->hardirqs_enabled) {\n\t\t/*\n\t\t * We have done an ON -> OFF transition:\n\t\t */\n\t\tcurr->hardirqs_enabled = 0;\n\t\tcurr->hardirq_disable_ip = ip;\n\t\tcurr->hardirq_disable_event = ++curr->irq_events;\n\t\tdebug_atomic_inc(hardirqs_off_events);\n\t} else\n\t\tdebug_atomic_inc(redundant_hardirqs_off);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_disable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 39
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_off",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 38
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_off",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "617-623",
          "snippet": "void tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_off(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstart_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "1"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_off(void)\n{\n\tif (!this_cpu_read(tracing_irq_cpu)) {\n\t\tthis_cpu_write(tracing_irq_cpu, 1);\n\t\ttracer_hardirqs_off(CALLER_ADDR0, CALLER_ADDR1);\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_disable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t}\n\n\tlockdep_hardirqs_off(CALLER_ADDR0);\n}"
  },
  {
    "function_name": "trace_hardirqs_on",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_preemptirq.c",
    "lines": "21-31",
    "snippet": "void trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}",
    "includes": [
      "#include <trace/events/preemptirq.h>",
      "#include \"trace.h\"",
      "#include <linux/ftrace.h>",
      "#include <linux/module.h>",
      "#include <linux/uaccess.h>",
      "#include <linux/kallsyms.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "lockdep_hardirqs_on",
          "args": [
            "CALLER_ADDR0"
          ],
          "line": 30
        },
        "resolved": true,
        "details": {
          "function_name": "lockdep_hardirqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/lockdep.c",
          "lines": "2774-2813",
          "snippet": "void lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}",
          "includes": [
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include \"lockdep_states.h\"",
            "#include <trace/events/lock.h>",
            "#include \"lockdep_internals.h\"",
            "#include <asm/sections.h>",
            "#include <linux/nmi.h>",
            "#include <linux/jhash.h>",
            "#include <linux/random.h>",
            "#include <linux/gfp.h>",
            "#include <linux/bitops.h>",
            "#include <linux/stringify.h>",
            "#include <linux/ftrace.h>",
            "#include <linux/hash.h>",
            "#include <linux/utsname.h>",
            "#include <linux/irqflags.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/stacktrace.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/module.h>",
            "#include <linux/delay.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/sched.h>",
            "#include <linux/mutex.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include \"lockdep_states.h\"\n#include <trace/events/lock.h>\n#include \"lockdep_internals.h\"\n#include <asm/sections.h>\n#include <linux/nmi.h>\n#include <linux/jhash.h>\n#include <linux/random.h>\n#include <linux/gfp.h>\n#include <linux/bitops.h>\n#include <linux/stringify.h>\n#include <linux/ftrace.h>\n#include <linux/hash.h>\n#include <linux/utsname.h>\n#include <linux/irqflags.h>\n#include <linux/debug_locks.h>\n#include <linux/stacktrace.h>\n#include <linux/interrupt.h>\n#include <linux/kallsyms.h>\n#include <linux/spinlock.h>\n#include <linux/seq_file.h>\n#include <linux/proc_fs.h>\n#include <linux/module.h>\n#include <linux/delay.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/task.h>\n#include <linux/sched/clock.h>\n#include <linux/sched.h>\n#include <linux/mutex.h>\n\nvoid lockdep_hardirqs_on(unsigned long ip)\n{\n\tif (unlikely(!debug_locks || current->lockdep_recursion))\n\t\treturn;\n\n\tif (unlikely(current->hardirqs_enabled)) {\n\t\t/*\n\t\t * Neither irq nor preemption are disabled here\n\t\t * so this is racy by nature but losing one hit\n\t\t * in a stat is not a big deal.\n\t\t */\n\t\t__debug_atomic_inc(redundant_hardirqs_on);\n\t\treturn;\n\t}\n\n\t/*\n\t * We're enabling irqs and according to our state above irqs weren't\n\t * already enabled, yet we find the hardware thinks they are in fact\n\t * enabled.. someone messed up their IRQ state tracing.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(!irqs_disabled()))\n\t\treturn;\n\n\t/*\n\t * See the fine text that goes along with this variable definition.\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(unlikely(early_boot_irqs_disabled)))\n\t\treturn;\n\n\t/*\n\t * Can't allow enabling interrupts while in an interrupt handler,\n\t * that's general bad form and such. Recursion, limited stack etc..\n\t */\n\tif (DEBUG_LOCKS_WARN_ON(current->hardirq_context))\n\t\treturn;\n\n\tcurrent->lockdep_recursion = 1;\n\t__trace_hardirqs_on_caller(ip);\n\tcurrent->lockdep_recursion = 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "this_cpu_write",
          "args": [
            "tracing_irq_cpu",
            "0"
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "tracer_hardirqs_on",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 26
        },
        "resolved": true,
        "details": {
          "function_name": "tracer_hardirqs_on",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/trace/trace_irqsoff.c",
          "lines": "609-615",
          "snippet": "void tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}",
          "includes": [
            "#include <trace/events/preemptirq.h>",
            "#include \"trace.h\"",
            "#include <linux/ftrace.h>",
            "#include <linux/module.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/kallsyms.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid tracer_hardirqs_on(unsigned long a0, unsigned long a1)\n{\n\tunsigned int pc = preempt_count();\n\n\tif (!preempt_trace(pc) && irq_trace())\n\t\tstop_critical_timing(a0, a1, pc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "trace_irq_enable_rcuidle",
          "args": [
            "CALLER_ADDR0",
            "CALLER_ADDR1"
          ],
          "line": 25
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_nmi",
          "args": [],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "this_cpu_read",
          "args": [
            "tracing_irq_cpu"
          ],
          "line": 23
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <trace/events/preemptirq.h>\n#include \"trace.h\"\n#include <linux/ftrace.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/kallsyms.h>\n\nvoid trace_hardirqs_on(void)\n{\n\tif (this_cpu_read(tracing_irq_cpu)) {\n\t\tif (!in_nmi())\n\t\t\ttrace_irq_enable_rcuidle(CALLER_ADDR0, CALLER_ADDR1);\n\t\ttracer_hardirqs_on(CALLER_ADDR0, CALLER_ADDR1);\n\t\tthis_cpu_write(tracing_irq_cpu, 0);\n\t}\n\n\tlockdep_hardirqs_on(CALLER_ADDR0);\n}"
  }
]